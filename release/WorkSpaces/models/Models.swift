// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The user is not authorized to access a resource.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum AccessPropertyValue {
    case allow
    case deny
    case sdkUnknown(String)
}

extension AccessPropertyValue : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AccessPropertyValue] {
        return [
            .allow,
            .deny,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .allow: return "ALLOW"
        case .deny: return "DENY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AccessPropertyValue(rawValue: rawValue) ?? AccessPropertyValue.sdkUnknown(rawValue)
    }
}

extension AccountModification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dedicatedTenancyManagementCidrRange = "DedicatedTenancyManagementCidrRange"
        case dedicatedTenancySupport = "DedicatedTenancySupport"
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case modificationState = "ModificationState"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dedicatedTenancyManagementCidrRange = dedicatedTenancyManagementCidrRange {
            try encodeContainer.encode(dedicatedTenancyManagementCidrRange, forKey: .dedicatedTenancyManagementCidrRange)
        }
        if let dedicatedTenancySupport = dedicatedTenancySupport {
            try encodeContainer.encode(dedicatedTenancySupport.rawValue, forKey: .dedicatedTenancySupport)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let modificationState = modificationState {
            try encodeContainer.encode(modificationState.rawValue, forKey: .modificationState)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modificationStateDecoded = try containerValues.decodeIfPresent(DedicatedTenancyModificationStateEnum.self, forKey: .modificationState)
        modificationState = modificationStateDecoded
        let dedicatedTenancySupportDecoded = try containerValues.decodeIfPresent(DedicatedTenancySupportResultEnum.self, forKey: .dedicatedTenancySupport)
        dedicatedTenancySupport = dedicatedTenancySupportDecoded
        let dedicatedTenancyManagementCidrRangeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dedicatedTenancyManagementCidrRange)
        dedicatedTenancyManagementCidrRange = dedicatedTenancyManagementCidrRangeDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AccountModification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountModification(dedicatedTenancyManagementCidrRange: \(String(describing: dedicatedTenancyManagementCidrRange)), dedicatedTenancySupport: \(String(describing: dedicatedTenancySupport)), errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), modificationState: \(String(describing: modificationState)), startTime: \(String(describing: startTime)))"}
}

/// <p>Describes a modification to the configuration of Bring Your Own License (BYOL) for the
///          specified account. </p>
public struct AccountModification: Equatable {
    /// <p>The IP address range, specified as an IPv4 CIDR block, for the management network
    ///          interface used for the account.</p>
    public let dedicatedTenancyManagementCidrRange: String?
    /// <p>The status of BYOL (whether BYOL is being enabled or disabled).</p>
    public let dedicatedTenancySupport: DedicatedTenancySupportResultEnum?
    /// <p>The error code that is returned if the configuration of BYOL cannot be modified.</p>
    public let errorCode: String?
    /// <p>The text of the error message that is returned if the configuration of BYOL cannot be
    ///          modified.</p>
    public let errorMessage: String?
    /// <p>The state of the modification to the configuration of BYOL.</p>
    public let modificationState: DedicatedTenancyModificationStateEnum?
    /// <p>The timestamp when the modification of the BYOL configuration was started.</p>
    public let startTime: Date?

    public init (
        dedicatedTenancyManagementCidrRange: String? = nil,
        dedicatedTenancySupport: DedicatedTenancySupportResultEnum? = nil,
        errorCode: String? = nil,
        errorMessage: String? = nil,
        modificationState: DedicatedTenancyModificationStateEnum? = nil,
        startTime: Date? = nil
    )
    {
        self.dedicatedTenancyManagementCidrRange = dedicatedTenancyManagementCidrRange
        self.dedicatedTenancySupport = dedicatedTenancySupport
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.modificationState = modificationState
        self.startTime = startTime
    }
}

public enum Application {
    case microsoftOffice2016
    case microsoftOffice2019
    case sdkUnknown(String)
}

extension Application : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Application] {
        return [
            .microsoftOffice2016,
            .microsoftOffice2019,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .microsoftOffice2016: return "Microsoft_Office_2016"
        case .microsoftOffice2019: return "Microsoft_Office_2019"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Application(rawValue: rawValue) ?? Application.sdkUnknown(rawValue)
    }
}

public struct AssociateConnectionAliasInputBodyMiddleware: Middleware {
    public let id: String = "AssociateConnectionAliasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateConnectionAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateConnectionAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateConnectionAliasInput>
    public typealias MOutput = OperationOutput<AssociateConnectionAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateConnectionAliasOutputError>
}

extension AssociateConnectionAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateConnectionAliasInput(aliasId: \(String(describing: aliasId)), resourceId: \(String(describing: resourceId)))"}
}

extension AssociateConnectionAliasInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aliasId = "AliasId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasId = aliasId {
            try encodeContainer.encode(aliasId, forKey: .aliasId)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

public struct AssociateConnectionAliasInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateConnectionAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateConnectionAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateConnectionAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateConnectionAliasInput>
    public typealias MOutput = OperationOutput<AssociateConnectionAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateConnectionAliasOutputError>
}

public struct AssociateConnectionAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateConnectionAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateConnectionAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateConnectionAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateConnectionAliasInput>
    public typealias MOutput = OperationOutput<AssociateConnectionAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateConnectionAliasOutputError>
}

public struct AssociateConnectionAliasInput: Equatable {
    /// <p>The identifier of the connection alias.</p>
    public let aliasId: String?
    /// <p>The identifier of the directory to associate the connection alias with.</p>
    public let resourceId: String?

    public init (
        aliasId: String? = nil,
        resourceId: String? = nil
    )
    {
        self.aliasId = aliasId
        self.resourceId = resourceId
    }
}

struct AssociateConnectionAliasInputBody: Equatable {
    public let aliasId: String?
    public let resourceId: String?
}

extension AssociateConnectionAliasInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aliasId = "AliasId"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension AssociateConnectionAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateConnectionAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAssociatedException" : self = .resourceAssociatedException(try ResourceAssociatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateConnectionAliasOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceAssociatedException(ResourceAssociatedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateConnectionAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateConnectionAliasOutputResponse(connectionIdentifier: \(String(describing: connectionIdentifier)))"}
}

extension AssociateConnectionAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateConnectionAliasOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.connectionIdentifier = output.connectionIdentifier
        } else {
            self.connectionIdentifier = nil
        }
    }
}

public struct AssociateConnectionAliasOutputResponse: Equatable {
    /// <p>The identifier of the connection alias association. You use the connection identifier in the DNS TXT record when
    ///          you're configuring your DNS routing policies. </p>
    public let connectionIdentifier: String?

    public init (
        connectionIdentifier: String? = nil
    )
    {
        self.connectionIdentifier = connectionIdentifier
    }
}

struct AssociateConnectionAliasOutputResponseBody: Equatable {
    public let connectionIdentifier: String?
}

extension AssociateConnectionAliasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionIdentifier = "ConnectionIdentifier"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionIdentifier)
        connectionIdentifier = connectionIdentifierDecoded
    }
}

public struct AssociateIpGroupsInputBodyMiddleware: Middleware {
    public let id: String = "AssociateIpGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateIpGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateIpGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateIpGroupsInput>
    public typealias MOutput = OperationOutput<AssociateIpGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateIpGroupsOutputError>
}

extension AssociateIpGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateIpGroupsInput(directoryId: \(String(describing: directoryId)), groupIds: \(String(describing: groupIds)))"}
}

extension AssociateIpGroupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case groupIds = "GroupIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let groupIds = groupIds {
            var groupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupIds)
            for ipgroupidlist0 in groupIds {
                try groupIdsContainer.encode(ipgroupidlist0)
            }
        }
    }
}

public struct AssociateIpGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateIpGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateIpGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateIpGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateIpGroupsInput>
    public typealias MOutput = OperationOutput<AssociateIpGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateIpGroupsOutputError>
}

public struct AssociateIpGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateIpGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateIpGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateIpGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateIpGroupsInput>
    public typealias MOutput = OperationOutput<AssociateIpGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateIpGroupsOutputError>
}

public struct AssociateIpGroupsInput: Equatable {
    /// <p>The identifier of the directory.</p>
    public let directoryId: String?
    /// <p>The identifiers of one or more IP access control groups.</p>
    public let groupIds: [String]?

    public init (
        directoryId: String? = nil,
        groupIds: [String]? = nil
    )
    {
        self.directoryId = directoryId
        self.groupIds = groupIds
    }
}

struct AssociateIpGroupsInputBody: Equatable {
    public let directoryId: String?
    public let groupIds: [String]?
}

extension AssociateIpGroupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case groupIds = "GroupIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let groupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .groupIds)
        var groupIdsDecoded0:[String]? = nil
        if let groupIdsContainer = groupIdsContainer {
            groupIdsDecoded0 = [String]()
            for string0 in groupIdsContainer {
                if let string0 = string0 {
                    groupIdsDecoded0?.append(string0)
                }
            }
        }
        groupIds = groupIdsDecoded0
    }
}

extension AssociateIpGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateIpGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateIpGroupsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateIpGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateIpGroupsOutputResponse()"}
}

extension AssociateIpGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateIpGroupsOutputResponse: Equatable {

    public init() {}
}

struct AssociateIpGroupsOutputResponseBody: Equatable {
}

extension AssociateIpGroupsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum AssociationStatus {
    case associatedWithOwnerAccount
    case associatedWithSharedAccount
    case notAssociated
    case pendingAssociation
    case pendingDisassociation
    case sdkUnknown(String)
}

extension AssociationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AssociationStatus] {
        return [
            .associatedWithOwnerAccount,
            .associatedWithSharedAccount,
            .notAssociated,
            .pendingAssociation,
            .pendingDisassociation,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .associatedWithOwnerAccount: return "ASSOCIATED_WITH_OWNER_ACCOUNT"
        case .associatedWithSharedAccount: return "ASSOCIATED_WITH_SHARED_ACCOUNT"
        case .notAssociated: return "NOT_ASSOCIATED"
        case .pendingAssociation: return "PENDING_ASSOCIATION"
        case .pendingDisassociation: return "PENDING_DISASSOCIATION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AssociationStatus(rawValue: rawValue) ?? AssociationStatus.sdkUnknown(rawValue)
    }
}

public struct AuthorizeIpRulesInputBodyMiddleware: Middleware {
    public let id: String = "AuthorizeIpRulesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AuthorizeIpRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<AuthorizeIpRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AuthorizeIpRulesInput>
    public typealias MOutput = OperationOutput<AuthorizeIpRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AuthorizeIpRulesOutputError>
}

extension AuthorizeIpRulesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthorizeIpRulesInput(groupId: \(String(describing: groupId)), userRules: \(String(describing: userRules)))"}
}

extension AuthorizeIpRulesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupId = "GroupId"
        case userRules = "UserRules"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let userRules = userRules {
            var userRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userRules)
            for iprulelist0 in userRules {
                try userRulesContainer.encode(iprulelist0)
            }
        }
    }
}

public struct AuthorizeIpRulesInputHeadersMiddleware: Middleware {
    public let id: String = "AuthorizeIpRulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AuthorizeIpRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<AuthorizeIpRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AuthorizeIpRulesInput>
    public typealias MOutput = OperationOutput<AuthorizeIpRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AuthorizeIpRulesOutputError>
}

public struct AuthorizeIpRulesInputQueryItemMiddleware: Middleware {
    public let id: String = "AuthorizeIpRulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AuthorizeIpRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<AuthorizeIpRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AuthorizeIpRulesInput>
    public typealias MOutput = OperationOutput<AuthorizeIpRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AuthorizeIpRulesOutputError>
}

public struct AuthorizeIpRulesInput: Equatable {
    /// <p>The identifier of the group.</p>
    public let groupId: String?
    /// <p>The rules to add to the group.</p>
    public let userRules: [IpRuleItem]?

    public init (
        groupId: String? = nil,
        userRules: [IpRuleItem]? = nil
    )
    {
        self.groupId = groupId
        self.userRules = userRules
    }
}

struct AuthorizeIpRulesInputBody: Equatable {
    public let groupId: String?
    public let userRules: [IpRuleItem]?
}

extension AuthorizeIpRulesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupId = "GroupId"
        case userRules = "UserRules"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let userRulesContainer = try containerValues.decodeIfPresent([IpRuleItem?].self, forKey: .userRules)
        var userRulesDecoded0:[IpRuleItem]? = nil
        if let userRulesContainer = userRulesContainer {
            userRulesDecoded0 = [IpRuleItem]()
            for structure0 in userRulesContainer {
                if let structure0 = structure0 {
                    userRulesDecoded0?.append(structure0)
                }
            }
        }
        userRules = userRulesDecoded0
    }
}

extension AuthorizeIpRulesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AuthorizeIpRulesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AuthorizeIpRulesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AuthorizeIpRulesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthorizeIpRulesOutputResponse()"}
}

extension AuthorizeIpRulesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AuthorizeIpRulesOutputResponse: Equatable {

    public init() {}
}

struct AuthorizeIpRulesOutputResponseBody: Equatable {
}

extension AuthorizeIpRulesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ClientProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case reconnectEnabled = "ReconnectEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reconnectEnabled = reconnectEnabled {
            try encodeContainer.encode(reconnectEnabled.rawValue, forKey: .reconnectEnabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reconnectEnabledDecoded = try containerValues.decodeIfPresent(ReconnectEnum.self, forKey: .reconnectEnabled)
        reconnectEnabled = reconnectEnabledDecoded
    }
}

extension ClientProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClientProperties(reconnectEnabled: \(String(describing: reconnectEnabled)))"}
}

/// <p>Describes an Amazon WorkSpaces client.</p>
public struct ClientProperties: Equatable {
    /// <p>Specifies whether users can cache their credentials on the Amazon WorkSpaces client.
    ///          When enabled, users can choose to reconnect to their WorkSpaces without re-entering their
    ///          credentials. </p>
    public let reconnectEnabled: ReconnectEnum?

    public init (
        reconnectEnabled: ReconnectEnum? = nil
    )
    {
        self.reconnectEnabled = reconnectEnabled
    }
}

extension ClientPropertiesResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientProperties = "ClientProperties"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientProperties = clientProperties {
            try encodeContainer.encode(clientProperties, forKey: .clientProperties)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let clientPropertiesDecoded = try containerValues.decodeIfPresent(ClientProperties.self, forKey: .clientProperties)
        clientProperties = clientPropertiesDecoded
    }
}

extension ClientPropertiesResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClientPropertiesResult(clientProperties: \(String(describing: clientProperties)), resourceId: \(String(describing: resourceId)))"}
}

/// <p>Information about the Amazon WorkSpaces client.</p>
public struct ClientPropertiesResult: Equatable {
    /// <p>Information about the Amazon WorkSpaces client.</p>
    public let clientProperties: ClientProperties?
    /// <p>The resource identifier, in the form of a directory ID.</p>
    public let resourceId: String?

    public init (
        clientProperties: ClientProperties? = nil,
        resourceId: String? = nil
    )
    {
        self.clientProperties = clientProperties
        self.resourceId = resourceId
    }
}

public enum Compute {
    case graphics
    case graphicspro
    case performance
    case power
    case powerpro
    case standard
    case value
    case sdkUnknown(String)
}

extension Compute : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Compute] {
        return [
            .graphics,
            .graphicspro,
            .performance,
            .power,
            .powerpro,
            .standard,
            .value,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .graphics: return "GRAPHICS"
        case .graphicspro: return "GRAPHICSPRO"
        case .performance: return "PERFORMANCE"
        case .power: return "POWER"
        case .powerpro: return "POWERPRO"
        case .standard: return "STANDARD"
        case .value: return "VALUE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Compute(rawValue: rawValue) ?? Compute.sdkUnknown(rawValue)
    }
}

extension ComputeType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Compute.self, forKey: .name)
        name = nameDecoded
    }
}

extension ComputeType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComputeType(name: \(String(describing: name)))"}
}

/// <p>Describes the compute type of the bundle.</p>
public struct ComputeType: Equatable {
    /// <p>The compute type.</p>
    public let name: Compute?

    public init (
        name: Compute? = nil
    )
    {
        self.name = name
    }
}

extension ConnectionAlias: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aliasId = "AliasId"
        case associations = "Associations"
        case connectionString = "ConnectionString"
        case ownerAccountId = "OwnerAccountId"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasId = aliasId {
            try encodeContainer.encode(aliasId, forKey: .aliasId)
        }
        if let associations = associations {
            var associationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associations)
            for connectionaliasassociationlist0 in associations {
                try associationsContainer.encode(connectionaliasassociationlist0)
            }
        }
        if let connectionString = connectionString {
            try encodeContainer.encode(connectionString, forKey: .connectionString)
        }
        if let ownerAccountId = ownerAccountId {
            try encodeContainer.encode(ownerAccountId, forKey: .ownerAccountId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionString)
        connectionString = connectionStringDecoded
        let aliasIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ConnectionAliasState.self, forKey: .state)
        state = stateDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let associationsContainer = try containerValues.decodeIfPresent([ConnectionAliasAssociation?].self, forKey: .associations)
        var associationsDecoded0:[ConnectionAliasAssociation]? = nil
        if let associationsContainer = associationsContainer {
            associationsDecoded0 = [ConnectionAliasAssociation]()
            for structure0 in associationsContainer {
                if let structure0 = structure0 {
                    associationsDecoded0?.append(structure0)
                }
            }
        }
        associations = associationsDecoded0
    }
}

extension ConnectionAlias: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectionAlias(aliasId: \(String(describing: aliasId)), associations: \(String(describing: associations)), connectionString: \(String(describing: connectionString)), ownerAccountId: \(String(describing: ownerAccountId)), state: \(String(describing: state)))"}
}

/// <p>Describes a connection alias. Connection aliases are used for cross-Region redirection. For more information,
///          see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/cross-region-redirection.html">
///          Cross-Region Redirection for Amazon WorkSpaces</a>.</p>
public struct ConnectionAlias: Equatable {
    /// <p>The identifier of the connection alias.</p>
    public let aliasId: String?
    /// <p>The association status of the connection alias.</p>
    public let associations: [ConnectionAliasAssociation]?
    /// <p>The connection string specified for the connection alias. The connection string must be in the form of
    ///          a fully qualified domain name (FQDN), such as <code>www.example.com</code>.</p>
    public let connectionString: String?
    /// <p>The identifier of the AWS account that owns the connection alias.</p>
    public let ownerAccountId: String?
    /// <p>The current state of the connection alias.</p>
    public let state: ConnectionAliasState?

    public init (
        aliasId: String? = nil,
        associations: [ConnectionAliasAssociation]? = nil,
        connectionString: String? = nil,
        ownerAccountId: String? = nil,
        state: ConnectionAliasState? = nil
    )
    {
        self.aliasId = aliasId
        self.associations = associations
        self.connectionString = connectionString
        self.ownerAccountId = ownerAccountId
        self.state = state
    }
}

extension ConnectionAliasAssociation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associatedAccountId = "AssociatedAccountId"
        case associationStatus = "AssociationStatus"
        case connectionIdentifier = "ConnectionIdentifier"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedAccountId = associatedAccountId {
            try encodeContainer.encode(associatedAccountId, forKey: .associatedAccountId)
        }
        if let associationStatus = associationStatus {
            try encodeContainer.encode(associationStatus.rawValue, forKey: .associationStatus)
        }
        if let connectionIdentifier = connectionIdentifier {
            try encodeContainer.encode(connectionIdentifier, forKey: .connectionIdentifier)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationStatusDecoded = try containerValues.decodeIfPresent(AssociationStatus.self, forKey: .associationStatus)
        associationStatus = associationStatusDecoded
        let associatedAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associatedAccountId)
        associatedAccountId = associatedAccountIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let connectionIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionIdentifier)
        connectionIdentifier = connectionIdentifierDecoded
    }
}

extension ConnectionAliasAssociation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectionAliasAssociation(associatedAccountId: \(String(describing: associatedAccountId)), associationStatus: \(String(describing: associationStatus)), connectionIdentifier: \(String(describing: connectionIdentifier)), resourceId: \(String(describing: resourceId)))"}
}

/// <p>Describes a connection alias association that is used for cross-Region redirection. For more information, see
///          <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/cross-region-redirection.html">
///          Cross-Region Redirection for Amazon WorkSpaces</a>.</p>
public struct ConnectionAliasAssociation: Equatable {
    /// <p>The identifier of the AWS account that associated the connection alias with a directory.</p>
    public let associatedAccountId: String?
    /// <p>The association status of the connection alias.</p>
    public let associationStatus: AssociationStatus?
    /// <p>The identifier of the connection alias association. You use the connection identifier in the DNS TXT record when
    ///          you're configuring your DNS routing policies.</p>
    public let connectionIdentifier: String?
    /// <p>The identifier of the directory associated with a connection alias.</p>
    public let resourceId: String?

    public init (
        associatedAccountId: String? = nil,
        associationStatus: AssociationStatus? = nil,
        connectionIdentifier: String? = nil,
        resourceId: String? = nil
    )
    {
        self.associatedAccountId = associatedAccountId
        self.associationStatus = associationStatus
        self.connectionIdentifier = connectionIdentifier
        self.resourceId = resourceId
    }
}

extension ConnectionAliasPermission: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowAssociation = "AllowAssociation"
        case sharedAccountId = "SharedAccountId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowAssociation = allowAssociation {
            try encodeContainer.encode(allowAssociation, forKey: .allowAssociation)
        }
        if let sharedAccountId = sharedAccountId {
            try encodeContainer.encode(sharedAccountId, forKey: .sharedAccountId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sharedAccountId)
        sharedAccountId = sharedAccountIdDecoded
        let allowAssociationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowAssociation)
        allowAssociation = allowAssociationDecoded
    }
}

extension ConnectionAliasPermission: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectionAliasPermission(allowAssociation: \(String(describing: allowAssociation)), sharedAccountId: \(String(describing: sharedAccountId)))"}
}

/// <p>Describes the permissions for a connection alias. Connection aliases are used for cross-Region redirection.
///          For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/cross-region-redirection.html">
///          Cross-Region Redirection for Amazon WorkSpaces</a>.</p>
public struct ConnectionAliasPermission: Equatable {
    /// <p>Indicates whether the specified AWS account is allowed to associate the connection alias with a directory.</p>
    public let allowAssociation: Bool?
    /// <p>The identifier of the AWS account that the connection alias is shared with.</p>
    public let sharedAccountId: String?

    public init (
        allowAssociation: Bool? = nil,
        sharedAccountId: String? = nil
    )
    {
        self.allowAssociation = allowAssociation
        self.sharedAccountId = sharedAccountId
    }
}

public enum ConnectionAliasState {
    case created
    case creating
    case deleting
    case sdkUnknown(String)
}

extension ConnectionAliasState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConnectionAliasState] {
        return [
            .created,
            .creating,
            .deleting,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .created: return "CREATED"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConnectionAliasState(rawValue: rawValue) ?? ConnectionAliasState.sdkUnknown(rawValue)
    }
}

public enum ConnectionState {
    case connected
    case disconnected
    case unknown
    case sdkUnknown(String)
}

extension ConnectionState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConnectionState] {
        return [
            .connected,
            .disconnected,
            .unknown,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .connected: return "CONNECTED"
        case .disconnected: return "DISCONNECTED"
        case .unknown: return "UNKNOWN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConnectionState(rawValue: rawValue) ?? ConnectionState.sdkUnknown(rawValue)
    }
}

public struct CopyWorkspaceImageInputBodyMiddleware: Middleware {
    public let id: String = "CopyWorkspaceImageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyWorkspaceImageInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyWorkspaceImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyWorkspaceImageInput>
    public typealias MOutput = OperationOutput<CopyWorkspaceImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyWorkspaceImageOutputError>
}

extension CopyWorkspaceImageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyWorkspaceImageInput(description: \(String(describing: description)), name: \(String(describing: name)), sourceImageId: \(String(describing: sourceImageId)), sourceRegion: \(String(describing: sourceRegion)), tags: \(String(describing: tags)))"}
}

extension CopyWorkspaceImageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
        case sourceImageId = "SourceImageId"
        case sourceRegion = "SourceRegion"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceImageId = sourceImageId {
            try encodeContainer.encode(sourceImageId, forKey: .sourceImageId)
        }
        if let sourceRegion = sourceRegion {
            try encodeContainer.encode(sourceRegion, forKey: .sourceRegion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CopyWorkspaceImageInputHeadersMiddleware: Middleware {
    public let id: String = "CopyWorkspaceImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyWorkspaceImageInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyWorkspaceImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyWorkspaceImageInput>
    public typealias MOutput = OperationOutput<CopyWorkspaceImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyWorkspaceImageOutputError>
}

public struct CopyWorkspaceImageInputQueryItemMiddleware: Middleware {
    public let id: String = "CopyWorkspaceImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyWorkspaceImageInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyWorkspaceImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyWorkspaceImageInput>
    public typealias MOutput = OperationOutput<CopyWorkspaceImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyWorkspaceImageOutputError>
}

public struct CopyWorkspaceImageInput: Equatable {
    /// <p>A description of the image.</p>
    public let description: String?
    /// <p>The name of the image.</p>
    public let name: String?
    /// <p>The identifier of the source image.</p>
    public let sourceImageId: String?
    /// <p>The identifier of the source Region.</p>
    public let sourceRegion: String?
    /// <p>The tags for the image.</p>
    public let tags: [Tag]?

    public init (
        description: String? = nil,
        name: String? = nil,
        sourceImageId: String? = nil,
        sourceRegion: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.description = description
        self.name = name
        self.sourceImageId = sourceImageId
        self.sourceRegion = sourceRegion
        self.tags = tags
    }
}

struct CopyWorkspaceImageInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let sourceImageId: String?
    public let sourceRegion: String?
    public let tags: [Tag]?
}

extension CopyWorkspaceImageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
        case sourceImageId = "SourceImageId"
        case sourceRegion = "SourceRegion"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let sourceImageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceImageId)
        sourceImageId = sourceImageIdDecoded
        let sourceRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceRegion)
        sourceRegion = sourceRegionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CopyWorkspaceImageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CopyWorkspaceImageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyWorkspaceImageOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyWorkspaceImageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyWorkspaceImageOutputResponse(imageId: \(String(describing: imageId)))"}
}

extension CopyWorkspaceImageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CopyWorkspaceImageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.imageId = output.imageId
        } else {
            self.imageId = nil
        }
    }
}

public struct CopyWorkspaceImageOutputResponse: Equatable {
    /// <p>The identifier of the image.</p>
    public let imageId: String?

    public init (
        imageId: String? = nil
    )
    {
        self.imageId = imageId
    }
}

struct CopyWorkspaceImageOutputResponseBody: Equatable {
    public let imageId: String?
}

extension CopyWorkspaceImageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageId = "ImageId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageId)
        imageId = imageIdDecoded
    }
}

public struct CreateConnectionAliasInputBodyMiddleware: Middleware {
    public let id: String = "CreateConnectionAliasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConnectionAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConnectionAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConnectionAliasInput>
    public typealias MOutput = OperationOutput<CreateConnectionAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConnectionAliasOutputError>
}

extension CreateConnectionAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConnectionAliasInput(connectionString: \(String(describing: connectionString)), tags: \(String(describing: tags)))"}
}

extension CreateConnectionAliasInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionString = "ConnectionString"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionString = connectionString {
            try encodeContainer.encode(connectionString, forKey: .connectionString)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateConnectionAliasInputHeadersMiddleware: Middleware {
    public let id: String = "CreateConnectionAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConnectionAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConnectionAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConnectionAliasInput>
    public typealias MOutput = OperationOutput<CreateConnectionAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConnectionAliasOutputError>
}

public struct CreateConnectionAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateConnectionAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConnectionAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConnectionAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConnectionAliasInput>
    public typealias MOutput = OperationOutput<CreateConnectionAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConnectionAliasOutputError>
}

public struct CreateConnectionAliasInput: Equatable {
    /// <p>A connection string in the form of a fully qualified domain name (FQDN), such as <code>www.example.com</code>.</p>
    ///
    ///          <important>
    ///             <p>After you create a connection string, it is always associated to your AWS account. You cannot recreate the same
    ///             connection string with a different account, even if you delete all instances of it from the original account. The
    ///          connection string is globally reserved for your account.</p>
    ///          </important>
    public let connectionString: String?
    /// <p>The tags to associate with the connection alias.</p>
    public let tags: [Tag]?

    public init (
        connectionString: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.connectionString = connectionString
        self.tags = tags
    }
}

struct CreateConnectionAliasInputBody: Equatable {
    public let connectionString: String?
    public let tags: [Tag]?
}

extension CreateConnectionAliasInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionString = "ConnectionString"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionString)
        connectionString = connectionStringDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConnectionAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectionAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConnectionAliasOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectionAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConnectionAliasOutputResponse(aliasId: \(String(describing: aliasId)))"}
}

extension CreateConnectionAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateConnectionAliasOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.aliasId = output.aliasId
        } else {
            self.aliasId = nil
        }
    }
}

public struct CreateConnectionAliasOutputResponse: Equatable {
    /// <p>The identifier of the connection alias.</p>
    public let aliasId: String?

    public init (
        aliasId: String? = nil
    )
    {
        self.aliasId = aliasId
    }
}

struct CreateConnectionAliasOutputResponseBody: Equatable {
    public let aliasId: String?
}

extension CreateConnectionAliasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aliasId = "AliasId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
    }
}

public struct CreateIpGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateIpGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIpGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIpGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIpGroupInput>
    public typealias MOutput = OperationOutput<CreateIpGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIpGroupOutputError>
}

extension CreateIpGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateIpGroupInput(groupDesc: \(String(describing: groupDesc)), groupName: \(String(describing: groupName)), tags: \(String(describing: tags)), userRules: \(String(describing: userRules)))"}
}

extension CreateIpGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupDesc = "GroupDesc"
        case groupName = "GroupName"
        case tags = "Tags"
        case userRules = "UserRules"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupDesc = groupDesc {
            try encodeContainer.encode(groupDesc, forKey: .groupDesc)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let userRules = userRules {
            var userRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userRules)
            for iprulelist0 in userRules {
                try userRulesContainer.encode(iprulelist0)
            }
        }
    }
}

public struct CreateIpGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateIpGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIpGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIpGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIpGroupInput>
    public typealias MOutput = OperationOutput<CreateIpGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIpGroupOutputError>
}

public struct CreateIpGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateIpGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIpGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIpGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIpGroupInput>
    public typealias MOutput = OperationOutput<CreateIpGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIpGroupOutputError>
}

public struct CreateIpGroupInput: Equatable {
    /// <p>The description of the group.</p>
    public let groupDesc: String?
    /// <p>The name of the group.</p>
    public let groupName: String?
    /// <p>The tags. Each WorkSpaces resource can have a maximum of 50 tags.</p>
    public let tags: [Tag]?
    /// <p>The rules to add to the group.</p>
    public let userRules: [IpRuleItem]?

    public init (
        groupDesc: String? = nil,
        groupName: String? = nil,
        tags: [Tag]? = nil,
        userRules: [IpRuleItem]? = nil
    )
    {
        self.groupDesc = groupDesc
        self.groupName = groupName
        self.tags = tags
        self.userRules = userRules
    }
}

struct CreateIpGroupInputBody: Equatable {
    public let groupName: String?
    public let groupDesc: String?
    public let userRules: [IpRuleItem]?
    public let tags: [Tag]?
}

extension CreateIpGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupDesc = "GroupDesc"
        case groupName = "GroupName"
        case tags = "Tags"
        case userRules = "UserRules"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupDescDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupDesc)
        groupDesc = groupDescDecoded
        let userRulesContainer = try containerValues.decodeIfPresent([IpRuleItem?].self, forKey: .userRules)
        var userRulesDecoded0:[IpRuleItem]? = nil
        if let userRulesContainer = userRulesContainer {
            userRulesDecoded0 = [IpRuleItem]()
            for structure0 in userRulesContainer {
                if let structure0 = structure0 {
                    userRulesDecoded0?.append(structure0)
                }
            }
        }
        userRules = userRulesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateIpGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateIpGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceCreationFailedException" : self = .resourceCreationFailedException(try ResourceCreationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateIpGroupOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceCreationFailedException(ResourceCreationFailedException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateIpGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateIpGroupOutputResponse(groupId: \(String(describing: groupId)))"}
}

extension CreateIpGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateIpGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.groupId = output.groupId
        } else {
            self.groupId = nil
        }
    }
}

public struct CreateIpGroupOutputResponse: Equatable {
    /// <p>The identifier of the group.</p>
    public let groupId: String?

    public init (
        groupId: String? = nil
    )
    {
        self.groupId = groupId
    }
}

struct CreateIpGroupOutputResponseBody: Equatable {
    public let groupId: String?
}

extension CreateIpGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupId = "GroupId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

public struct CreateTagsInputBodyMiddleware: Middleware {
    public let id: String = "CreateTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTagsInput>
    public typealias MOutput = OperationOutput<CreateTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTagsOutputError>
}

extension CreateTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTagsInput(resourceId: \(String(describing: resourceId)), tags: \(String(describing: tags)))"}
}

extension CreateTagsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateTagsInputHeadersMiddleware: Middleware {
    public let id: String = "CreateTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTagsInput>
    public typealias MOutput = OperationOutput<CreateTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTagsOutputError>
}

public struct CreateTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTagsInput>
    public typealias MOutput = OperationOutput<CreateTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTagsOutputError>
}

public struct CreateTagsInput: Equatable {
    /// <p>The identifier of the WorkSpaces resource. The supported resource types are WorkSpaces,
    ///          registered directories, images, custom bundles, IP access control groups, and connection aliases.</p>
    public let resourceId: String?
    /// <p>The tags. Each WorkSpaces resource can have a maximum of 50 tags.</p>
    public let tags: [Tag]?

    public init (
        resourceId: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceId = resourceId
        self.tags = tags
    }
}

struct CreateTagsInputBody: Equatable {
    public let resourceId: String?
    public let tags: [Tag]?
}

extension CreateTagsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTagsOutputError: Equatable {
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTagsOutputResponse()"}
}

extension CreateTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateTagsOutputResponse: Equatable {

    public init() {}
}

struct CreateTagsOutputResponseBody: Equatable {
}

extension CreateTagsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateWorkspaceBundleInputBodyMiddleware: Middleware {
    public let id: String = "CreateWorkspaceBundleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorkspaceBundleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorkspaceBundleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorkspaceBundleInput>
    public typealias MOutput = OperationOutput<CreateWorkspaceBundleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorkspaceBundleOutputError>
}

extension CreateWorkspaceBundleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWorkspaceBundleInput(bundleDescription: \(String(describing: bundleDescription)), bundleName: \(String(describing: bundleName)), computeType: \(String(describing: computeType)), imageId: \(String(describing: imageId)), rootStorage: \(String(describing: rootStorage)), tags: \(String(describing: tags)), userStorage: \(String(describing: userStorage)))"}
}

extension CreateWorkspaceBundleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bundleDescription = "BundleDescription"
        case bundleName = "BundleName"
        case computeType = "ComputeType"
        case imageId = "ImageId"
        case rootStorage = "RootStorage"
        case tags = "Tags"
        case userStorage = "UserStorage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleDescription = bundleDescription {
            try encodeContainer.encode(bundleDescription, forKey: .bundleDescription)
        }
        if let bundleName = bundleName {
            try encodeContainer.encode(bundleName, forKey: .bundleName)
        }
        if let computeType = computeType {
            try encodeContainer.encode(computeType, forKey: .computeType)
        }
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let rootStorage = rootStorage {
            try encodeContainer.encode(rootStorage, forKey: .rootStorage)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let userStorage = userStorage {
            try encodeContainer.encode(userStorage, forKey: .userStorage)
        }
    }
}

public struct CreateWorkspaceBundleInputHeadersMiddleware: Middleware {
    public let id: String = "CreateWorkspaceBundleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorkspaceBundleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorkspaceBundleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorkspaceBundleInput>
    public typealias MOutput = OperationOutput<CreateWorkspaceBundleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorkspaceBundleOutputError>
}

public struct CreateWorkspaceBundleInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateWorkspaceBundleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorkspaceBundleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorkspaceBundleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorkspaceBundleInput>
    public typealias MOutput = OperationOutput<CreateWorkspaceBundleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorkspaceBundleOutputError>
}

public struct CreateWorkspaceBundleInput: Equatable {
    /// <p>The description of the bundle.</p>
    public let bundleDescription: String?
    /// <p>The name of the bundle.</p>
    public let bundleName: String?
    /// <p>Describes the compute type of the bundle.</p>
    public let computeType: ComputeType?
    /// <p>The identifier of the image that is used to create the bundle.</p>
    public let imageId: String?
    /// <p>Describes the root volume for a WorkSpace bundle.</p>
    public let rootStorage: RootStorage?
    /// <p>The tags associated with the bundle.</p>
    ///
    ///          <note>
    ///             <p>To add tags at the same time when you're creating the bundle, you must create an IAM policy that
    ///             grants your IAM user permissions to use <code>workspaces:CreateTags</code>. </p>
    ///          </note>
    public let tags: [Tag]?
    /// <p>Describes the user volume for a WorkSpace bundle.</p>
    public let userStorage: UserStorage?

    public init (
        bundleDescription: String? = nil,
        bundleName: String? = nil,
        computeType: ComputeType? = nil,
        imageId: String? = nil,
        rootStorage: RootStorage? = nil,
        tags: [Tag]? = nil,
        userStorage: UserStorage? = nil
    )
    {
        self.bundleDescription = bundleDescription
        self.bundleName = bundleName
        self.computeType = computeType
        self.imageId = imageId
        self.rootStorage = rootStorage
        self.tags = tags
        self.userStorage = userStorage
    }
}

struct CreateWorkspaceBundleInputBody: Equatable {
    public let bundleName: String?
    public let bundleDescription: String?
    public let imageId: String?
    public let computeType: ComputeType?
    public let userStorage: UserStorage?
    public let rootStorage: RootStorage?
    public let tags: [Tag]?
}

extension CreateWorkspaceBundleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bundleDescription = "BundleDescription"
        case bundleName = "BundleName"
        case computeType = "ComputeType"
        case imageId = "ImageId"
        case rootStorage = "RootStorage"
        case tags = "Tags"
        case userStorage = "UserStorage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bundleName)
        bundleName = bundleNameDecoded
        let bundleDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bundleDescription)
        bundleDescription = bundleDescriptionDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let computeTypeDecoded = try containerValues.decodeIfPresent(ComputeType.self, forKey: .computeType)
        computeType = computeTypeDecoded
        let userStorageDecoded = try containerValues.decodeIfPresent(UserStorage.self, forKey: .userStorage)
        userStorage = userStorageDecoded
        let rootStorageDecoded = try containerValues.decodeIfPresent(RootStorage.self, forKey: .rootStorage)
        rootStorage = rootStorageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorkspaceBundleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkspaceBundleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWorkspaceBundleOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkspaceBundleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWorkspaceBundleOutputResponse(workspaceBundle: \(String(describing: workspaceBundle)))"}
}

extension CreateWorkspaceBundleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateWorkspaceBundleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.workspaceBundle = output.workspaceBundle
        } else {
            self.workspaceBundle = nil
        }
    }
}

public struct CreateWorkspaceBundleOutputResponse: Equatable {
    /// <p>Describes a WorkSpace bundle.</p>
    public let workspaceBundle: WorkspaceBundle?

    public init (
        workspaceBundle: WorkspaceBundle? = nil
    )
    {
        self.workspaceBundle = workspaceBundle
    }
}

struct CreateWorkspaceBundleOutputResponseBody: Equatable {
    public let workspaceBundle: WorkspaceBundle?
}

extension CreateWorkspaceBundleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case workspaceBundle = "WorkspaceBundle"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceBundleDecoded = try containerValues.decodeIfPresent(WorkspaceBundle.self, forKey: .workspaceBundle)
        workspaceBundle = workspaceBundleDecoded
    }
}

public struct CreateWorkspacesInputBodyMiddleware: Middleware {
    public let id: String = "CreateWorkspacesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorkspacesInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorkspacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorkspacesInput>
    public typealias MOutput = OperationOutput<CreateWorkspacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorkspacesOutputError>
}

extension CreateWorkspacesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWorkspacesInput(workspaces: \(String(describing: workspaces)))"}
}

extension CreateWorkspacesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case workspaces = "Workspaces"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaces = workspaces {
            var workspacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workspaces)
            for workspacerequestlist0 in workspaces {
                try workspacesContainer.encode(workspacerequestlist0)
            }
        }
    }
}

public struct CreateWorkspacesInputHeadersMiddleware: Middleware {
    public let id: String = "CreateWorkspacesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorkspacesInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorkspacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorkspacesInput>
    public typealias MOutput = OperationOutput<CreateWorkspacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorkspacesOutputError>
}

public struct CreateWorkspacesInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateWorkspacesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorkspacesInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorkspacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorkspacesInput>
    public typealias MOutput = OperationOutput<CreateWorkspacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorkspacesOutputError>
}

public struct CreateWorkspacesInput: Equatable {
    /// <p>The WorkSpaces to create. You can specify up to 25 WorkSpaces.</p>
    public let workspaces: [WorkspaceRequest]?

    public init (
        workspaces: [WorkspaceRequest]? = nil
    )
    {
        self.workspaces = workspaces
    }
}

struct CreateWorkspacesInputBody: Equatable {
    public let workspaces: [WorkspaceRequest]?
}

extension CreateWorkspacesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case workspaces = "Workspaces"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspacesContainer = try containerValues.decodeIfPresent([WorkspaceRequest?].self, forKey: .workspaces)
        var workspacesDecoded0:[WorkspaceRequest]? = nil
        if let workspacesContainer = workspacesContainer {
            workspacesDecoded0 = [WorkspaceRequest]()
            for structure0 in workspacesContainer {
                if let structure0 = structure0 {
                    workspacesDecoded0?.append(structure0)
                }
            }
        }
        workspaces = workspacesDecoded0
    }
}

extension CreateWorkspacesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkspacesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWorkspacesOutputError: Equatable {
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkspacesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWorkspacesOutputResponse(failedRequests: \(String(describing: failedRequests)), pendingRequests: \(String(describing: pendingRequests)))"}
}

extension CreateWorkspacesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateWorkspacesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedRequests = output.failedRequests
            self.pendingRequests = output.pendingRequests
        } else {
            self.failedRequests = nil
            self.pendingRequests = nil
        }
    }
}

public struct CreateWorkspacesOutputResponse: Equatable {
    /// <p>Information about the WorkSpaces that could not be created.</p>
    public let failedRequests: [FailedCreateWorkspaceRequest]?
    /// <p>Information about the WorkSpaces that were created.</p>
    ///          <p>Because this operation is asynchronous, the identifier returned is not immediately
    ///          available for use with other operations. For example, if you call <a>DescribeWorkspaces</a> before the WorkSpace is created, the information returned
    ///          can be incomplete.</p>
    public let pendingRequests: [Workspace]?

    public init (
        failedRequests: [FailedCreateWorkspaceRequest]? = nil,
        pendingRequests: [Workspace]? = nil
    )
    {
        self.failedRequests = failedRequests
        self.pendingRequests = pendingRequests
    }
}

struct CreateWorkspacesOutputResponseBody: Equatable {
    public let failedRequests: [FailedCreateWorkspaceRequest]?
    public let pendingRequests: [Workspace]?
}

extension CreateWorkspacesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedRequests = "FailedRequests"
        case pendingRequests = "PendingRequests"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedRequestsContainer = try containerValues.decodeIfPresent([FailedCreateWorkspaceRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[FailedCreateWorkspaceRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [FailedCreateWorkspaceRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
        let pendingRequestsContainer = try containerValues.decodeIfPresent([Workspace?].self, forKey: .pendingRequests)
        var pendingRequestsDecoded0:[Workspace]? = nil
        if let pendingRequestsContainer = pendingRequestsContainer {
            pendingRequestsDecoded0 = [Workspace]()
            for structure0 in pendingRequestsContainer {
                if let structure0 = structure0 {
                    pendingRequestsDecoded0?.append(structure0)
                }
            }
        }
        pendingRequests = pendingRequestsDecoded0
    }
}

public enum DedicatedTenancyModificationStateEnum {
    case completed
    case failed
    case pending
    case sdkUnknown(String)
}

extension DedicatedTenancyModificationStateEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DedicatedTenancyModificationStateEnum] {
        return [
            .completed,
            .failed,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "COMPLETED"
        case .failed: return "FAILED"
        case .pending: return "PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DedicatedTenancyModificationStateEnum(rawValue: rawValue) ?? DedicatedTenancyModificationStateEnum.sdkUnknown(rawValue)
    }
}

public enum DedicatedTenancySupportEnum {
    case enabled
    case sdkUnknown(String)
}

extension DedicatedTenancySupportEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DedicatedTenancySupportEnum] {
        return [
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DedicatedTenancySupportEnum(rawValue: rawValue) ?? DedicatedTenancySupportEnum.sdkUnknown(rawValue)
    }
}

public enum DedicatedTenancySupportResultEnum {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension DedicatedTenancySupportResultEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DedicatedTenancySupportResultEnum] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DedicatedTenancySupportResultEnum(rawValue: rawValue) ?? DedicatedTenancySupportResultEnum.sdkUnknown(rawValue)
    }
}

extension DefaultWorkspaceCreationProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customSecurityGroupId = "CustomSecurityGroupId"
        case defaultOu = "DefaultOu"
        case enableInternetAccess = "EnableInternetAccess"
        case enableMaintenanceMode = "EnableMaintenanceMode"
        case enableWorkDocs = "EnableWorkDocs"
        case userEnabledAsLocalAdministrator = "UserEnabledAsLocalAdministrator"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customSecurityGroupId = customSecurityGroupId {
            try encodeContainer.encode(customSecurityGroupId, forKey: .customSecurityGroupId)
        }
        if let defaultOu = defaultOu {
            try encodeContainer.encode(defaultOu, forKey: .defaultOu)
        }
        if let enableInternetAccess = enableInternetAccess {
            try encodeContainer.encode(enableInternetAccess, forKey: .enableInternetAccess)
        }
        if let enableMaintenanceMode = enableMaintenanceMode {
            try encodeContainer.encode(enableMaintenanceMode, forKey: .enableMaintenanceMode)
        }
        if let enableWorkDocs = enableWorkDocs {
            try encodeContainer.encode(enableWorkDocs, forKey: .enableWorkDocs)
        }
        if let userEnabledAsLocalAdministrator = userEnabledAsLocalAdministrator {
            try encodeContainer.encode(userEnabledAsLocalAdministrator, forKey: .userEnabledAsLocalAdministrator)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableWorkDocsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableWorkDocs)
        enableWorkDocs = enableWorkDocsDecoded
        let enableInternetAccessDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableInternetAccess)
        enableInternetAccess = enableInternetAccessDecoded
        let defaultOuDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultOu)
        defaultOu = defaultOuDecoded
        let customSecurityGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customSecurityGroupId)
        customSecurityGroupId = customSecurityGroupIdDecoded
        let userEnabledAsLocalAdministratorDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .userEnabledAsLocalAdministrator)
        userEnabledAsLocalAdministrator = userEnabledAsLocalAdministratorDecoded
        let enableMaintenanceModeDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableMaintenanceMode)
        enableMaintenanceMode = enableMaintenanceModeDecoded
    }
}

extension DefaultWorkspaceCreationProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DefaultWorkspaceCreationProperties(customSecurityGroupId: \(String(describing: customSecurityGroupId)), defaultOu: \(String(describing: defaultOu)), enableInternetAccess: \(String(describing: enableInternetAccess)), enableMaintenanceMode: \(String(describing: enableMaintenanceMode)), enableWorkDocs: \(String(describing: enableWorkDocs)), userEnabledAsLocalAdministrator: \(String(describing: userEnabledAsLocalAdministrator)))"}
}

/// <p>Describes the default values that are used to create WorkSpaces. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/update-directory-details.html">Update Directory Details for Your WorkSpaces</a>.</p>
public struct DefaultWorkspaceCreationProperties: Equatable {
    /// <p>The identifier of the default security group to apply to WorkSpaces when they are created.
    ///          For more information, see
    ///          <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/amazon-workspaces-security-groups.html">
    ///             Security Groups for Your WorkSpaces</a>.</p>
    public let customSecurityGroupId: String?
    /// <p>The organizational unit (OU) in the directory for the WorkSpace machine accounts.</p>
    public let defaultOu: String?
    /// <p>Specifies whether to automatically assign an Elastic public IP address to WorkSpaces in this directory by default.
    ///          If enabled, the Elastic public IP address allows outbound internet access from your WorkSpaces when you’re using an
    ///          internet gateway in the Amazon VPC in which your WorkSpaces are located. If you're using a Network Address
    ///          Translation (NAT) gateway for outbound internet access from your VPC, or if your WorkSpaces are in public
    ///          subnets and you manually assign them Elastic IP addresses, you should disable this setting. This setting
    ///          applies to new WorkSpaces that you launch or to existing WorkSpaces that you rebuild. For more information,
    ///          see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/amazon-workspaces-vpc.html">
    ///             Configure a VPC for Amazon WorkSpaces</a>.</p>
    public let enableInternetAccess: Bool?
    /// <p>Specifies whether maintenance mode is enabled for WorkSpaces. For more information, see
    ///             <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/workspace-maintenance.html">WorkSpace
    ///             Maintenance</a>.</p>
    public let enableMaintenanceMode: Bool?
    /// <p>Specifies whether the directory is enabled for Amazon WorkDocs.</p>
    public let enableWorkDocs: Bool?
    /// <p>Specifies whether WorkSpace users are local administrators on their WorkSpaces.</p>
    public let userEnabledAsLocalAdministrator: Bool?

    public init (
        customSecurityGroupId: String? = nil,
        defaultOu: String? = nil,
        enableInternetAccess: Bool? = nil,
        enableMaintenanceMode: Bool? = nil,
        enableWorkDocs: Bool? = nil,
        userEnabledAsLocalAdministrator: Bool? = nil
    )
    {
        self.customSecurityGroupId = customSecurityGroupId
        self.defaultOu = defaultOu
        self.enableInternetAccess = enableInternetAccess
        self.enableMaintenanceMode = enableMaintenanceMode
        self.enableWorkDocs = enableWorkDocs
        self.userEnabledAsLocalAdministrator = userEnabledAsLocalAdministrator
    }
}

public struct DeleteConnectionAliasInputBodyMiddleware: Middleware {
    public let id: String = "DeleteConnectionAliasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConnectionAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConnectionAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConnectionAliasInput>
    public typealias MOutput = OperationOutput<DeleteConnectionAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConnectionAliasOutputError>
}

extension DeleteConnectionAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConnectionAliasInput(aliasId: \(String(describing: aliasId)))"}
}

extension DeleteConnectionAliasInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aliasId = "AliasId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasId = aliasId {
            try encodeContainer.encode(aliasId, forKey: .aliasId)
        }
    }
}

public struct DeleteConnectionAliasInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteConnectionAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConnectionAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConnectionAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConnectionAliasInput>
    public typealias MOutput = OperationOutput<DeleteConnectionAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConnectionAliasOutputError>
}

public struct DeleteConnectionAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteConnectionAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConnectionAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConnectionAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConnectionAliasInput>
    public typealias MOutput = OperationOutput<DeleteConnectionAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConnectionAliasOutputError>
}

public struct DeleteConnectionAliasInput: Equatable {
    /// <p>The identifier of the connection alias to delete.</p>
    public let aliasId: String?

    public init (
        aliasId: String? = nil
    )
    {
        self.aliasId = aliasId
    }
}

struct DeleteConnectionAliasInputBody: Equatable {
    public let aliasId: String?
}

extension DeleteConnectionAliasInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aliasId = "AliasId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
    }
}

extension DeleteConnectionAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConnectionAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAssociatedException" : self = .resourceAssociatedException(try ResourceAssociatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConnectionAliasOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceAssociatedException(ResourceAssociatedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConnectionAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConnectionAliasOutputResponse()"}
}

extension DeleteConnectionAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteConnectionAliasOutputResponse: Equatable {

    public init() {}
}

struct DeleteConnectionAliasOutputResponseBody: Equatable {
}

extension DeleteConnectionAliasOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteIpGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteIpGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIpGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIpGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIpGroupInput>
    public typealias MOutput = OperationOutput<DeleteIpGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIpGroupOutputError>
}

extension DeleteIpGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIpGroupInput(groupId: \(String(describing: groupId)))"}
}

extension DeleteIpGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupId = "GroupId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
    }
}

public struct DeleteIpGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteIpGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIpGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIpGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIpGroupInput>
    public typealias MOutput = OperationOutput<DeleteIpGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIpGroupOutputError>
}

public struct DeleteIpGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteIpGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIpGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIpGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIpGroupInput>
    public typealias MOutput = OperationOutput<DeleteIpGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIpGroupOutputError>
}

public struct DeleteIpGroupInput: Equatable {
    /// <p>The identifier of the IP access control group.</p>
    public let groupId: String?

    public init (
        groupId: String? = nil
    )
    {
        self.groupId = groupId
    }
}

struct DeleteIpGroupInputBody: Equatable {
    public let groupId: String?
}

extension DeleteIpGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupId = "GroupId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension DeleteIpGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIpGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAssociatedException" : self = .resourceAssociatedException(try ResourceAssociatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIpGroupOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceAssociatedException(ResourceAssociatedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIpGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIpGroupOutputResponse()"}
}

extension DeleteIpGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteIpGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteIpGroupOutputResponseBody: Equatable {
}

extension DeleteIpGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteTagsInputBodyMiddleware: Middleware {
    public let id: String = "DeleteTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTagsInput>
    public typealias MOutput = OperationOutput<DeleteTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTagsOutputError>
}

extension DeleteTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTagsInput(resourceId: \(String(describing: resourceId)), tagKeys: \(String(describing: tagKeys)))"}
}

extension DeleteTagsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct DeleteTagsInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTagsInput>
    public typealias MOutput = OperationOutput<DeleteTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTagsOutputError>
}

public struct DeleteTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTagsInput>
    public typealias MOutput = OperationOutput<DeleteTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTagsOutputError>
}

public struct DeleteTagsInput: Equatable {
    /// <p>The identifier of the WorkSpaces resource. The supported resource types are WorkSpaces,
    ///          registered directories, images, custom bundles, IP access control groups, and connection aliases.</p>
    public let resourceId: String?
    /// <p>The tag keys.</p>
    public let tagKeys: [String]?

    public init (
        resourceId: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceId = resourceId
        self.tagKeys = tagKeys
    }
}

struct DeleteTagsInputBody: Equatable {
    public let resourceId: String?
    public let tagKeys: [String]?
}

extension DeleteTagsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension DeleteTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTagsOutputError: Equatable {
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTagsOutputResponse()"}
}

extension DeleteTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTagsOutputResponse: Equatable {

    public init() {}
}

struct DeleteTagsOutputResponseBody: Equatable {
}

extension DeleteTagsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteWorkspaceBundleInputBodyMiddleware: Middleware {
    public let id: String = "DeleteWorkspaceBundleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWorkspaceBundleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWorkspaceBundleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWorkspaceBundleInput>
    public typealias MOutput = OperationOutput<DeleteWorkspaceBundleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWorkspaceBundleOutputError>
}

extension DeleteWorkspaceBundleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWorkspaceBundleInput(bundleId: \(String(describing: bundleId)))"}
}

extension DeleteWorkspaceBundleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bundleId = "BundleId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
    }
}

public struct DeleteWorkspaceBundleInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteWorkspaceBundleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWorkspaceBundleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWorkspaceBundleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWorkspaceBundleInput>
    public typealias MOutput = OperationOutput<DeleteWorkspaceBundleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWorkspaceBundleOutputError>
}

public struct DeleteWorkspaceBundleInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteWorkspaceBundleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWorkspaceBundleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWorkspaceBundleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWorkspaceBundleInput>
    public typealias MOutput = OperationOutput<DeleteWorkspaceBundleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWorkspaceBundleOutputError>
}

public struct DeleteWorkspaceBundleInput: Equatable {
    /// <p>The identifier of the bundle.</p>
    public let bundleId: String?

    public init (
        bundleId: String? = nil
    )
    {
        self.bundleId = bundleId
    }
}

struct DeleteWorkspaceBundleInputBody: Equatable {
    public let bundleId: String?
}

extension DeleteWorkspaceBundleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bundleId = "BundleId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
    }
}

extension DeleteWorkspaceBundleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorkspaceBundleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAssociatedException" : self = .resourceAssociatedException(try ResourceAssociatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWorkspaceBundleOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceAssociatedException(ResourceAssociatedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorkspaceBundleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWorkspaceBundleOutputResponse()"}
}

extension DeleteWorkspaceBundleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWorkspaceBundleOutputResponse: Equatable {

    public init() {}
}

struct DeleteWorkspaceBundleOutputResponseBody: Equatable {
}

extension DeleteWorkspaceBundleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteWorkspaceImageInputBodyMiddleware: Middleware {
    public let id: String = "DeleteWorkspaceImageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWorkspaceImageInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWorkspaceImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWorkspaceImageInput>
    public typealias MOutput = OperationOutput<DeleteWorkspaceImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWorkspaceImageOutputError>
}

extension DeleteWorkspaceImageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWorkspaceImageInput(imageId: \(String(describing: imageId)))"}
}

extension DeleteWorkspaceImageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case imageId = "ImageId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
    }
}

public struct DeleteWorkspaceImageInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteWorkspaceImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWorkspaceImageInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWorkspaceImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWorkspaceImageInput>
    public typealias MOutput = OperationOutput<DeleteWorkspaceImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWorkspaceImageOutputError>
}

public struct DeleteWorkspaceImageInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteWorkspaceImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWorkspaceImageInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWorkspaceImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWorkspaceImageInput>
    public typealias MOutput = OperationOutput<DeleteWorkspaceImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWorkspaceImageOutputError>
}

public struct DeleteWorkspaceImageInput: Equatable {
    /// <p>The identifier of the image.</p>
    public let imageId: String?

    public init (
        imageId: String? = nil
    )
    {
        self.imageId = imageId
    }
}

struct DeleteWorkspaceImageInputBody: Equatable {
    public let imageId: String?
}

extension DeleteWorkspaceImageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageId = "ImageId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageId)
        imageId = imageIdDecoded
    }
}

extension DeleteWorkspaceImageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorkspaceImageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAssociatedException" : self = .resourceAssociatedException(try ResourceAssociatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWorkspaceImageOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidResourceStateException(InvalidResourceStateException)
    case resourceAssociatedException(ResourceAssociatedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorkspaceImageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWorkspaceImageOutputResponse()"}
}

extension DeleteWorkspaceImageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWorkspaceImageOutputResponse: Equatable {

    public init() {}
}

struct DeleteWorkspaceImageOutputResponseBody: Equatable {
}

extension DeleteWorkspaceImageOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeregisterWorkspaceDirectoryInputBodyMiddleware: Middleware {
    public let id: String = "DeregisterWorkspaceDirectoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterWorkspaceDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterWorkspaceDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterWorkspaceDirectoryInput>
    public typealias MOutput = OperationOutput<DeregisterWorkspaceDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterWorkspaceDirectoryOutputError>
}

extension DeregisterWorkspaceDirectoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterWorkspaceDirectoryInput(directoryId: \(String(describing: directoryId)))"}
}

extension DeregisterWorkspaceDirectoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
    }
}

public struct DeregisterWorkspaceDirectoryInputHeadersMiddleware: Middleware {
    public let id: String = "DeregisterWorkspaceDirectoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterWorkspaceDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterWorkspaceDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterWorkspaceDirectoryInput>
    public typealias MOutput = OperationOutput<DeregisterWorkspaceDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterWorkspaceDirectoryOutputError>
}

public struct DeregisterWorkspaceDirectoryInputQueryItemMiddleware: Middleware {
    public let id: String = "DeregisterWorkspaceDirectoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterWorkspaceDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterWorkspaceDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterWorkspaceDirectoryInput>
    public typealias MOutput = OperationOutput<DeregisterWorkspaceDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterWorkspaceDirectoryOutputError>
}

public struct DeregisterWorkspaceDirectoryInput: Equatable {
    /// <p>The identifier of the directory. If any WorkSpaces are registered to this directory, you must
    ///          remove them before you deregister the directory, or you will receive an OperationNotSupportedException
    ///          error.</p>
    public let directoryId: String?

    public init (
        directoryId: String? = nil
    )
    {
        self.directoryId = directoryId
    }
}

struct DeregisterWorkspaceDirectoryInputBody: Equatable {
    public let directoryId: String?
}

extension DeregisterWorkspaceDirectoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
    }
}

extension DeregisterWorkspaceDirectoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterWorkspaceDirectoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterWorkspaceDirectoryOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterWorkspaceDirectoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterWorkspaceDirectoryOutputResponse()"}
}

extension DeregisterWorkspaceDirectoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterWorkspaceDirectoryOutputResponse: Equatable {

    public init() {}
}

struct DeregisterWorkspaceDirectoryOutputResponseBody: Equatable {
}

extension DeregisterWorkspaceDirectoryOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountInput()"}
}

extension DescribeAccountInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeAccountInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountInput>
    public typealias MOutput = OperationOutput<DescribeAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountOutputError>
}

public struct DescribeAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountInput>
    public typealias MOutput = OperationOutput<DescribeAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountOutputError>
}

public struct DescribeAccountInput: Equatable {

    public init() {}
}

struct DescribeAccountInputBody: Equatable {
}

extension DescribeAccountInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeAccountModificationsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAccountModificationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountModificationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountModificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountModificationsInput>
    public typealias MOutput = OperationOutput<DescribeAccountModificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountModificationsOutputError>
}

extension DescribeAccountModificationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountModificationsInput(nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAccountModificationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeAccountModificationsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAccountModificationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountModificationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountModificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountModificationsInput>
    public typealias MOutput = OperationOutput<DescribeAccountModificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountModificationsOutputError>
}

public struct DescribeAccountModificationsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAccountModificationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountModificationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountModificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountModificationsInput>
    public typealias MOutput = OperationOutput<DescribeAccountModificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountModificationsOutputError>
}

public struct DescribeAccountModificationsInput: Equatable {
    /// <p>If you received a <code>NextToken</code> from a previous call that was paginated,
    ///          provide this token to receive the next set of results.</p>
    public let nextToken: String?

    public init (
        nextToken: String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct DescribeAccountModificationsInputBody: Equatable {
    public let nextToken: String?
}

extension DescribeAccountModificationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAccountModificationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccountModificationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountModificationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountModificationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountModificationsOutputResponse(accountModifications: \(String(describing: accountModifications)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAccountModificationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAccountModificationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountModifications = output.accountModifications
            self.nextToken = output.nextToken
        } else {
            self.accountModifications = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAccountModificationsOutputResponse: Equatable {
    /// <p>The list of modifications to the configuration of BYOL.</p>
    public let accountModifications: [AccountModification]?
    /// <p>The token to use to retrieve the next page of results. This value is null when there
    ///          are no more results to return. </p>
    public let nextToken: String?

    public init (
        accountModifications: [AccountModification]? = nil,
        nextToken: String? = nil
    )
    {
        self.accountModifications = accountModifications
        self.nextToken = nextToken
    }
}

struct DescribeAccountModificationsOutputResponseBody: Equatable {
    public let accountModifications: [AccountModification]?
    public let nextToken: String?
}

extension DescribeAccountModificationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountModifications = "AccountModifications"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountModificationsContainer = try containerValues.decodeIfPresent([AccountModification?].self, forKey: .accountModifications)
        var accountModificationsDecoded0:[AccountModification]? = nil
        if let accountModificationsContainer = accountModificationsContainer {
            accountModificationsDecoded0 = [AccountModification]()
            for structure0 in accountModificationsContainer {
                if let structure0 = structure0 {
                    accountModificationsDecoded0?.append(structure0)
                }
            }
        }
        accountModifications = accountModificationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountOutputResponse(dedicatedTenancyManagementCidrRange: \(String(describing: dedicatedTenancyManagementCidrRange)), dedicatedTenancySupport: \(String(describing: dedicatedTenancySupport)))"}
}

extension DescribeAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAccountOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dedicatedTenancyManagementCidrRange = output.dedicatedTenancyManagementCidrRange
            self.dedicatedTenancySupport = output.dedicatedTenancySupport
        } else {
            self.dedicatedTenancyManagementCidrRange = nil
            self.dedicatedTenancySupport = nil
        }
    }
}

public struct DescribeAccountOutputResponse: Equatable {
    /// <p>The IP address range, specified as an IPv4 CIDR block, used for the management network
    ///          interface.</p>
    ///          <p>The management network interface is connected to a secure Amazon WorkSpaces management
    ///          network. It is used for interactive streaming of the WorkSpace desktop to Amazon WorkSpaces
    ///          clients, and to allow Amazon WorkSpaces to manage the WorkSpace.</p>
    public let dedicatedTenancyManagementCidrRange: String?
    /// <p>The status of BYOL (whether BYOL is enabled or disabled).</p>
    public let dedicatedTenancySupport: DedicatedTenancySupportResultEnum?

    public init (
        dedicatedTenancyManagementCidrRange: String? = nil,
        dedicatedTenancySupport: DedicatedTenancySupportResultEnum? = nil
    )
    {
        self.dedicatedTenancyManagementCidrRange = dedicatedTenancyManagementCidrRange
        self.dedicatedTenancySupport = dedicatedTenancySupport
    }
}

struct DescribeAccountOutputResponseBody: Equatable {
    public let dedicatedTenancySupport: DedicatedTenancySupportResultEnum?
    public let dedicatedTenancyManagementCidrRange: String?
}

extension DescribeAccountOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dedicatedTenancyManagementCidrRange = "DedicatedTenancyManagementCidrRange"
        case dedicatedTenancySupport = "DedicatedTenancySupport"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dedicatedTenancySupportDecoded = try containerValues.decodeIfPresent(DedicatedTenancySupportResultEnum.self, forKey: .dedicatedTenancySupport)
        dedicatedTenancySupport = dedicatedTenancySupportDecoded
        let dedicatedTenancyManagementCidrRangeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dedicatedTenancyManagementCidrRange)
        dedicatedTenancyManagementCidrRange = dedicatedTenancyManagementCidrRangeDecoded
    }
}

public struct DescribeClientPropertiesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeClientPropertiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClientPropertiesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClientPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClientPropertiesInput>
    public typealias MOutput = OperationOutput<DescribeClientPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClientPropertiesOutputError>
}

extension DescribeClientPropertiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClientPropertiesInput(resourceIds: \(String(describing: resourceIds)))"}
}

extension DescribeClientPropertiesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceIds = "ResourceIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceIds = resourceIds {
            var resourceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceIds)
            for resourceidlist0 in resourceIds {
                try resourceIdsContainer.encode(resourceidlist0)
            }
        }
    }
}

public struct DescribeClientPropertiesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeClientPropertiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClientPropertiesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClientPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClientPropertiesInput>
    public typealias MOutput = OperationOutput<DescribeClientPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClientPropertiesOutputError>
}

public struct DescribeClientPropertiesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeClientPropertiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClientPropertiesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClientPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClientPropertiesInput>
    public typealias MOutput = OperationOutput<DescribeClientPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClientPropertiesOutputError>
}

public struct DescribeClientPropertiesInput: Equatable {
    /// <p>The resource identifier, in the form of directory IDs.</p>
    public let resourceIds: [String]?

    public init (
        resourceIds: [String]? = nil
    )
    {
        self.resourceIds = resourceIds
    }
}

struct DescribeClientPropertiesInputBody: Equatable {
    public let resourceIds: [String]?
}

extension DescribeClientPropertiesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceIds = "ResourceIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceIds)
        var resourceIdsDecoded0:[String]? = nil
        if let resourceIdsContainer = resourceIdsContainer {
            resourceIdsDecoded0 = [String]()
            for string0 in resourceIdsContainer {
                if let string0 = string0 {
                    resourceIdsDecoded0?.append(string0)
                }
            }
        }
        resourceIds = resourceIdsDecoded0
    }
}

extension DescribeClientPropertiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeClientPropertiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClientPropertiesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClientPropertiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClientPropertiesOutputResponse(clientPropertiesList: \(String(describing: clientPropertiesList)))"}
}

extension DescribeClientPropertiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeClientPropertiesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientPropertiesList = output.clientPropertiesList
        } else {
            self.clientPropertiesList = nil
        }
    }
}

public struct DescribeClientPropertiesOutputResponse: Equatable {
    /// <p>Information about the specified Amazon WorkSpaces clients.</p>
    public let clientPropertiesList: [ClientPropertiesResult]?

    public init (
        clientPropertiesList: [ClientPropertiesResult]? = nil
    )
    {
        self.clientPropertiesList = clientPropertiesList
    }
}

struct DescribeClientPropertiesOutputResponseBody: Equatable {
    public let clientPropertiesList: [ClientPropertiesResult]?
}

extension DescribeClientPropertiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientPropertiesList = "ClientPropertiesList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientPropertiesListContainer = try containerValues.decodeIfPresent([ClientPropertiesResult?].self, forKey: .clientPropertiesList)
        var clientPropertiesListDecoded0:[ClientPropertiesResult]? = nil
        if let clientPropertiesListContainer = clientPropertiesListContainer {
            clientPropertiesListDecoded0 = [ClientPropertiesResult]()
            for structure0 in clientPropertiesListContainer {
                if let structure0 = structure0 {
                    clientPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        clientPropertiesList = clientPropertiesListDecoded0
    }
}

public struct DescribeConnectionAliasPermissionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeConnectionAliasPermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConnectionAliasPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConnectionAliasPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConnectionAliasPermissionsInput>
    public typealias MOutput = OperationOutput<DescribeConnectionAliasPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConnectionAliasPermissionsOutputError>
}

extension DescribeConnectionAliasPermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConnectionAliasPermissionsInput(aliasId: \(String(describing: aliasId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeConnectionAliasPermissionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aliasId = "AliasId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasId = aliasId {
            try encodeContainer.encode(aliasId, forKey: .aliasId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeConnectionAliasPermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeConnectionAliasPermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConnectionAliasPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConnectionAliasPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConnectionAliasPermissionsInput>
    public typealias MOutput = OperationOutput<DescribeConnectionAliasPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConnectionAliasPermissionsOutputError>
}

public struct DescribeConnectionAliasPermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeConnectionAliasPermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConnectionAliasPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConnectionAliasPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConnectionAliasPermissionsInput>
    public typealias MOutput = OperationOutput<DescribeConnectionAliasPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConnectionAliasPermissionsOutputError>
}

public struct DescribeConnectionAliasPermissionsInput: Equatable {
    /// <p>The identifier of the connection alias.</p>
    public let aliasId: String?
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int?
    /// <p>If you received a <code>NextToken</code> from a previous call that was paginated, provide this token to receive the
    ///          next set of results. </p>
    public let nextToken: String?

    public init (
        aliasId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.aliasId = aliasId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeConnectionAliasPermissionsInputBody: Equatable {
    public let aliasId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribeConnectionAliasPermissionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aliasId = "AliasId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeConnectionAliasPermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConnectionAliasPermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConnectionAliasPermissionsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConnectionAliasPermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConnectionAliasPermissionsOutputResponse(aliasId: \(String(describing: aliasId)), connectionAliasPermissions: \(String(describing: connectionAliasPermissions)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeConnectionAliasPermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeConnectionAliasPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.aliasId = output.aliasId
            self.connectionAliasPermissions = output.connectionAliasPermissions
            self.nextToken = output.nextToken
        } else {
            self.aliasId = nil
            self.connectionAliasPermissions = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeConnectionAliasPermissionsOutputResponse: Equatable {
    /// <p>The identifier of the connection alias.</p>
    public let aliasId: String?
    /// <p>The permissions associated with a connection alias.</p>
    public let connectionAliasPermissions: [ConnectionAliasPermission]?
    /// <p>The token to use to retrieve the next page of results. This value is null when there are no more results to return. </p>
    public let nextToken: String?

    public init (
        aliasId: String? = nil,
        connectionAliasPermissions: [ConnectionAliasPermission]? = nil,
        nextToken: String? = nil
    )
    {
        self.aliasId = aliasId
        self.connectionAliasPermissions = connectionAliasPermissions
        self.nextToken = nextToken
    }
}

struct DescribeConnectionAliasPermissionsOutputResponseBody: Equatable {
    public let aliasId: String?
    public let connectionAliasPermissions: [ConnectionAliasPermission]?
    public let nextToken: String?
}

extension DescribeConnectionAliasPermissionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aliasId = "AliasId"
        case connectionAliasPermissions = "ConnectionAliasPermissions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
        let connectionAliasPermissionsContainer = try containerValues.decodeIfPresent([ConnectionAliasPermission?].self, forKey: .connectionAliasPermissions)
        var connectionAliasPermissionsDecoded0:[ConnectionAliasPermission]? = nil
        if let connectionAliasPermissionsContainer = connectionAliasPermissionsContainer {
            connectionAliasPermissionsDecoded0 = [ConnectionAliasPermission]()
            for structure0 in connectionAliasPermissionsContainer {
                if let structure0 = structure0 {
                    connectionAliasPermissionsDecoded0?.append(structure0)
                }
            }
        }
        connectionAliasPermissions = connectionAliasPermissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeConnectionAliasesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeConnectionAliasesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConnectionAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConnectionAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConnectionAliasesInput>
    public typealias MOutput = OperationOutput<DescribeConnectionAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConnectionAliasesOutputError>
}

extension DescribeConnectionAliasesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConnectionAliasesInput(aliasIds: \(String(describing: aliasIds)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), resourceId: \(String(describing: resourceId)))"}
}

extension DescribeConnectionAliasesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aliasIds = "AliasIds"
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasIds = aliasIds {
            var aliasIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aliasIds)
            for connectionaliasidlist0 in aliasIds {
                try aliasIdsContainer.encode(connectionaliasidlist0)
            }
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

public struct DescribeConnectionAliasesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeConnectionAliasesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConnectionAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConnectionAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConnectionAliasesInput>
    public typealias MOutput = OperationOutput<DescribeConnectionAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConnectionAliasesOutputError>
}

public struct DescribeConnectionAliasesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeConnectionAliasesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConnectionAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConnectionAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConnectionAliasesInput>
    public typealias MOutput = OperationOutput<DescribeConnectionAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConnectionAliasesOutputError>
}

public struct DescribeConnectionAliasesInput: Equatable {
    /// <p>The identifiers of the connection aliases to describe.</p>
    public let aliasIds: [String]?
    /// <p>The maximum number of connection aliases to return.</p>
    public let limit: Int?
    /// <p>If you received a <code>NextToken</code> from a previous call that was paginated, provide this token to receive the
    ///          next set of results. </p>
    public let nextToken: String?
    /// <p>The identifier of the directory associated with the connection alias.</p>
    public let resourceId: String?

    public init (
        aliasIds: [String]? = nil,
        limit: Int? = nil,
        nextToken: String? = nil,
        resourceId: String? = nil
    )
    {
        self.aliasIds = aliasIds
        self.limit = limit
        self.nextToken = nextToken
        self.resourceId = resourceId
    }
}

struct DescribeConnectionAliasesInputBody: Equatable {
    public let aliasIds: [String]?
    public let resourceId: String?
    public let limit: Int?
    public let nextToken: String?
}

extension DescribeConnectionAliasesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aliasIds = "AliasIds"
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .aliasIds)
        var aliasIdsDecoded0:[String]? = nil
        if let aliasIdsContainer = aliasIdsContainer {
            aliasIdsDecoded0 = [String]()
            for string0 in aliasIdsContainer {
                if let string0 = string0 {
                    aliasIdsDecoded0?.append(string0)
                }
            }
        }
        aliasIds = aliasIdsDecoded0
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeConnectionAliasesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConnectionAliasesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConnectionAliasesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case operationNotSupportedException(OperationNotSupportedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConnectionAliasesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConnectionAliasesOutputResponse(connectionAliases: \(String(describing: connectionAliases)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeConnectionAliasesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeConnectionAliasesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.connectionAliases = output.connectionAliases
            self.nextToken = output.nextToken
        } else {
            self.connectionAliases = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeConnectionAliasesOutputResponse: Equatable {
    /// <p>Information about the specified connection aliases.</p>
    public let connectionAliases: [ConnectionAlias]?
    /// <p>The token to use to retrieve the next page of results. This value is null when there are no more results to return. </p>
    public let nextToken: String?

    public init (
        connectionAliases: [ConnectionAlias]? = nil,
        nextToken: String? = nil
    )
    {
        self.connectionAliases = connectionAliases
        self.nextToken = nextToken
    }
}

struct DescribeConnectionAliasesOutputResponseBody: Equatable {
    public let connectionAliases: [ConnectionAlias]?
    public let nextToken: String?
}

extension DescribeConnectionAliasesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionAliases = "ConnectionAliases"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionAliasesContainer = try containerValues.decodeIfPresent([ConnectionAlias?].self, forKey: .connectionAliases)
        var connectionAliasesDecoded0:[ConnectionAlias]? = nil
        if let connectionAliasesContainer = connectionAliasesContainer {
            connectionAliasesDecoded0 = [ConnectionAlias]()
            for structure0 in connectionAliasesContainer {
                if let structure0 = structure0 {
                    connectionAliasesDecoded0?.append(structure0)
                }
            }
        }
        connectionAliases = connectionAliasesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeIpGroupsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeIpGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIpGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIpGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIpGroupsInput>
    public typealias MOutput = OperationOutput<DescribeIpGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIpGroupsOutputError>
}

extension DescribeIpGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeIpGroupsInput(groupIds: \(String(describing: groupIds)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeIpGroupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupIds = "GroupIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupIds = groupIds {
            var groupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupIds)
            for ipgroupidlist0 in groupIds {
                try groupIdsContainer.encode(ipgroupidlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeIpGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeIpGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIpGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIpGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIpGroupsInput>
    public typealias MOutput = OperationOutput<DescribeIpGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIpGroupsOutputError>
}

public struct DescribeIpGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeIpGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIpGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIpGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIpGroupsInput>
    public typealias MOutput = OperationOutput<DescribeIpGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIpGroupsOutputError>
}

public struct DescribeIpGroupsInput: Equatable {
    /// <p>The identifiers of one or more IP access control groups.</p>
    public let groupIds: [String]?
    /// <p>The maximum number of items to return.</p>
    public let maxResults: Int?
    /// <p>If you received a <code>NextToken</code> from a previous call that was paginated,
    ///          provide this token to receive the next set of results.</p>
    public let nextToken: String?

    public init (
        groupIds: [String]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.groupIds = groupIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeIpGroupsInputBody: Equatable {
    public let groupIds: [String]?
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribeIpGroupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupIds = "GroupIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .groupIds)
        var groupIdsDecoded0:[String]? = nil
        if let groupIdsContainer = groupIdsContainer {
            groupIdsDecoded0 = [String]()
            for string0 in groupIdsContainer {
                if let string0 = string0 {
                    groupIdsDecoded0?.append(string0)
                }
            }
        }
        groupIds = groupIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeIpGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeIpGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeIpGroupsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIpGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeIpGroupsOutputResponse(nextToken: \(String(describing: nextToken)), result: \(String(describing: result)))"}
}

extension DescribeIpGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeIpGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.result = output.result
        } else {
            self.nextToken = nil
            self.result = nil
        }
    }
}

public struct DescribeIpGroupsOutputResponse: Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is null when there are no more results to return. </p>
    public let nextToken: String?
    /// <p>Information about the IP access control groups.</p>
    public let result: [WorkspacesIpGroup]?

    public init (
        nextToken: String? = nil,
        result: [WorkspacesIpGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.result = result
    }
}

struct DescribeIpGroupsOutputResponseBody: Equatable {
    public let result: [WorkspacesIpGroup]?
    public let nextToken: String?
}

extension DescribeIpGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case result = "Result"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultContainer = try containerValues.decodeIfPresent([WorkspacesIpGroup?].self, forKey: .result)
        var resultDecoded0:[WorkspacesIpGroup]? = nil
        if let resultContainer = resultContainer {
            resultDecoded0 = [WorkspacesIpGroup]()
            for structure0 in resultContainer {
                if let structure0 = structure0 {
                    resultDecoded0?.append(structure0)
                }
            }
        }
        result = resultDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeTagsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTagsInput>
    public typealias MOutput = OperationOutput<DescribeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTagsOutputError>
}

extension DescribeTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTagsInput(resourceId: \(String(describing: resourceId)))"}
}

extension DescribeTagsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

public struct DescribeTagsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTagsInput>
    public typealias MOutput = OperationOutput<DescribeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTagsOutputError>
}

public struct DescribeTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTagsInput>
    public typealias MOutput = OperationOutput<DescribeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTagsOutputError>
}

public struct DescribeTagsInput: Equatable {
    /// <p>The identifier of the WorkSpaces resource. The supported resource types are WorkSpaces,
    ///          registered directories, images, custom bundles, IP access control groups, and connection aliases.</p>
    public let resourceId: String?

    public init (
        resourceId: String? = nil
    )
    {
        self.resourceId = resourceId
    }
}

struct DescribeTagsInputBody: Equatable {
    public let resourceId: String?
}

extension DescribeTagsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension DescribeTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTagsOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTagsOutputResponse(tagList: \(String(describing: tagList)))"}
}

extension DescribeTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeTagsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

public struct DescribeTagsOutputResponse: Equatable {
    /// <p>The tags.</p>
    public let tagList: [Tag]?

    public init (
        tagList: [Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct DescribeTagsOutputResponseBody: Equatable {
    public let tagList: [Tag]?
}

extension DescribeTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tagList = "TagList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagListContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tagList)
        var tagListDecoded0:[Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

public struct DescribeWorkspaceBundlesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeWorkspaceBundlesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorkspaceBundlesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorkspaceBundlesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorkspaceBundlesInput>
    public typealias MOutput = OperationOutput<DescribeWorkspaceBundlesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorkspaceBundlesOutputError>
}

extension DescribeWorkspaceBundlesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeWorkspaceBundlesInput(bundleIds: \(String(describing: bundleIds)), nextToken: \(String(describing: nextToken)), owner: \(String(describing: owner)))"}
}

extension DescribeWorkspaceBundlesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bundleIds = "BundleIds"
        case nextToken = "NextToken"
        case owner = "Owner"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleIds = bundleIds {
            var bundleIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bundleIds)
            for bundleidlist0 in bundleIds {
                try bundleIdsContainer.encode(bundleidlist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
    }
}

public struct DescribeWorkspaceBundlesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeWorkspaceBundlesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorkspaceBundlesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorkspaceBundlesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorkspaceBundlesInput>
    public typealias MOutput = OperationOutput<DescribeWorkspaceBundlesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorkspaceBundlesOutputError>
}

public struct DescribeWorkspaceBundlesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeWorkspaceBundlesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorkspaceBundlesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorkspaceBundlesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorkspaceBundlesInput>
    public typealias MOutput = OperationOutput<DescribeWorkspaceBundlesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorkspaceBundlesOutputError>
}

public struct DescribeWorkspaceBundlesInput: Equatable {
    /// <p>The identifiers of the bundles. You cannot combine this parameter with any other filter.</p>
    public let bundleIds: [String]?
    /// <p>The token for the next set of results. (You received this token from a previous call.)</p>
    public let nextToken: String?
    /// <p>The owner of the bundles. You cannot combine this parameter with any other filter.</p>
    ///          <p>To describe the bundles provided by AWS, specify <code>AMAZON</code>. To describe the
    ///          bundles that belong to your account, don't specify a value.</p>
    public let owner: String?

    public init (
        bundleIds: [String]? = nil,
        nextToken: String? = nil,
        owner: String? = nil
    )
    {
        self.bundleIds = bundleIds
        self.nextToken = nextToken
        self.owner = owner
    }
}

struct DescribeWorkspaceBundlesInputBody: Equatable {
    public let bundleIds: [String]?
    public let owner: String?
    public let nextToken: String?
}

extension DescribeWorkspaceBundlesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bundleIds = "BundleIds"
        case nextToken = "NextToken"
        case owner = "Owner"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .bundleIds)
        var bundleIdsDecoded0:[String]? = nil
        if let bundleIdsContainer = bundleIdsContainer {
            bundleIdsDecoded0 = [String]()
            for string0 in bundleIdsContainer {
                if let string0 = string0 {
                    bundleIdsDecoded0?.append(string0)
                }
            }
        }
        bundleIds = bundleIdsDecoded0
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeWorkspaceBundlesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorkspaceBundlesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWorkspaceBundlesOutputError: Equatable {
    case invalidParameterValuesException(InvalidParameterValuesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorkspaceBundlesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeWorkspaceBundlesOutputResponse(bundles: \(String(describing: bundles)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeWorkspaceBundlesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeWorkspaceBundlesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.bundles = output.bundles
            self.nextToken = output.nextToken
        } else {
            self.bundles = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeWorkspaceBundlesOutputResponse: Equatable {
    /// <p>Information about the bundles.</p>
    public let bundles: [WorkspaceBundle]?
    /// <p>The token to use to retrieve the next page of results. This value is null when there are no more
    ///          results to return. This token is valid for one day and must be used within that time
    ///          frame.</p>
    public let nextToken: String?

    public init (
        bundles: [WorkspaceBundle]? = nil,
        nextToken: String? = nil
    )
    {
        self.bundles = bundles
        self.nextToken = nextToken
    }
}

struct DescribeWorkspaceBundlesOutputResponseBody: Equatable {
    public let bundles: [WorkspaceBundle]?
    public let nextToken: String?
}

extension DescribeWorkspaceBundlesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bundles = "Bundles"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundlesContainer = try containerValues.decodeIfPresent([WorkspaceBundle?].self, forKey: .bundles)
        var bundlesDecoded0:[WorkspaceBundle]? = nil
        if let bundlesContainer = bundlesContainer {
            bundlesDecoded0 = [WorkspaceBundle]()
            for structure0 in bundlesContainer {
                if let structure0 = structure0 {
                    bundlesDecoded0?.append(structure0)
                }
            }
        }
        bundles = bundlesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeWorkspaceDirectoriesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeWorkspaceDirectoriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorkspaceDirectoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorkspaceDirectoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorkspaceDirectoriesInput>
    public typealias MOutput = OperationOutput<DescribeWorkspaceDirectoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorkspaceDirectoriesOutputError>
}

extension DescribeWorkspaceDirectoriesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeWorkspaceDirectoriesInput(directoryIds: \(String(describing: directoryIds)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeWorkspaceDirectoriesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryIds = "DirectoryIds"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryIds = directoryIds {
            var directoryIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .directoryIds)
            for directoryidlist0 in directoryIds {
                try directoryIdsContainer.encode(directoryidlist0)
            }
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeWorkspaceDirectoriesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeWorkspaceDirectoriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorkspaceDirectoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorkspaceDirectoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorkspaceDirectoriesInput>
    public typealias MOutput = OperationOutput<DescribeWorkspaceDirectoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorkspaceDirectoriesOutputError>
}

public struct DescribeWorkspaceDirectoriesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeWorkspaceDirectoriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorkspaceDirectoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorkspaceDirectoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorkspaceDirectoriesInput>
    public typealias MOutput = OperationOutput<DescribeWorkspaceDirectoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorkspaceDirectoriesOutputError>
}

public struct DescribeWorkspaceDirectoriesInput: Equatable {
    /// <p>The identifiers of the directories. If the value is null, all directories are
    ///          retrieved.</p>
    public let directoryIds: [String]?
    /// <p>The maximum number of directories to return.</p>
    public let limit: Int?
    /// <p>If you received a <code>NextToken</code> from a previous call that was paginated,
    ///          provide this token to receive the next set of results.</p>
    public let nextToken: String?

    public init (
        directoryIds: [String]? = nil,
        limit: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.directoryIds = directoryIds
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct DescribeWorkspaceDirectoriesInputBody: Equatable {
    public let directoryIds: [String]?
    public let limit: Int?
    public let nextToken: String?
}

extension DescribeWorkspaceDirectoriesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryIds = "DirectoryIds"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .directoryIds)
        var directoryIdsDecoded0:[String]? = nil
        if let directoryIdsContainer = directoryIdsContainer {
            directoryIdsDecoded0 = [String]()
            for string0 in directoryIdsContainer {
                if let string0 = string0 {
                    directoryIdsDecoded0?.append(string0)
                }
            }
        }
        directoryIds = directoryIdsDecoded0
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeWorkspaceDirectoriesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorkspaceDirectoriesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWorkspaceDirectoriesOutputError: Equatable {
    case invalidParameterValuesException(InvalidParameterValuesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorkspaceDirectoriesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeWorkspaceDirectoriesOutputResponse(directories: \(String(describing: directories)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeWorkspaceDirectoriesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeWorkspaceDirectoriesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.directories = output.directories
            self.nextToken = output.nextToken
        } else {
            self.directories = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeWorkspaceDirectoriesOutputResponse: Equatable {
    /// <p>Information about the directories.</p>
    public let directories: [WorkspaceDirectory]?
    /// <p>The token to use to retrieve the next page of results. This value is null when there are no more results to return. </p>
    public let nextToken: String?

    public init (
        directories: [WorkspaceDirectory]? = nil,
        nextToken: String? = nil
    )
    {
        self.directories = directories
        self.nextToken = nextToken
    }
}

struct DescribeWorkspaceDirectoriesOutputResponseBody: Equatable {
    public let directories: [WorkspaceDirectory]?
    public let nextToken: String?
}

extension DescribeWorkspaceDirectoriesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directories = "Directories"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoriesContainer = try containerValues.decodeIfPresent([WorkspaceDirectory?].self, forKey: .directories)
        var directoriesDecoded0:[WorkspaceDirectory]? = nil
        if let directoriesContainer = directoriesContainer {
            directoriesDecoded0 = [WorkspaceDirectory]()
            for structure0 in directoriesContainer {
                if let structure0 = structure0 {
                    directoriesDecoded0?.append(structure0)
                }
            }
        }
        directories = directoriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeWorkspaceImagePermissionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeWorkspaceImagePermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorkspaceImagePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorkspaceImagePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorkspaceImagePermissionsInput>
    public typealias MOutput = OperationOutput<DescribeWorkspaceImagePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorkspaceImagePermissionsOutputError>
}

extension DescribeWorkspaceImagePermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeWorkspaceImagePermissionsInput(imageId: \(String(describing: imageId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeWorkspaceImagePermissionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case imageId = "ImageId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeWorkspaceImagePermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeWorkspaceImagePermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorkspaceImagePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorkspaceImagePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorkspaceImagePermissionsInput>
    public typealias MOutput = OperationOutput<DescribeWorkspaceImagePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorkspaceImagePermissionsOutputError>
}

public struct DescribeWorkspaceImagePermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeWorkspaceImagePermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorkspaceImagePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorkspaceImagePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorkspaceImagePermissionsInput>
    public typealias MOutput = OperationOutput<DescribeWorkspaceImagePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorkspaceImagePermissionsOutputError>
}

public struct DescribeWorkspaceImagePermissionsInput: Equatable {
    /// <p>The identifier of the image.</p>
    public let imageId: String?
    /// <p>The maximum number of items to return.</p>
    public let maxResults: Int?
    /// <p>If you received a <code>NextToken</code> from a previous call that was paginated,
    ///          provide this token to receive the next set of results.</p>
    public let nextToken: String?

    public init (
        imageId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.imageId = imageId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeWorkspaceImagePermissionsInputBody: Equatable {
    public let imageId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribeWorkspaceImagePermissionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageId = "ImageId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeWorkspaceImagePermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorkspaceImagePermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWorkspaceImagePermissionsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorkspaceImagePermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeWorkspaceImagePermissionsOutputResponse(imageId: \(String(describing: imageId)), imagePermissions: \(String(describing: imagePermissions)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeWorkspaceImagePermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeWorkspaceImagePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.imageId = output.imageId
            self.imagePermissions = output.imagePermissions
            self.nextToken = output.nextToken
        } else {
            self.imageId = nil
            self.imagePermissions = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeWorkspaceImagePermissionsOutputResponse: Equatable {
    /// <p>The identifier of the image.</p>
    public let imageId: String?
    /// <p>The identifiers of the AWS accounts that the image has been shared with.</p>
    public let imagePermissions: [ImagePermission]?
    /// <p>The token to use to retrieve the next page of results. This value is null when there are no more results to return. </p>
    public let nextToken: String?

    public init (
        imageId: String? = nil,
        imagePermissions: [ImagePermission]? = nil,
        nextToken: String? = nil
    )
    {
        self.imageId = imageId
        self.imagePermissions = imagePermissions
        self.nextToken = nextToken
    }
}

struct DescribeWorkspaceImagePermissionsOutputResponseBody: Equatable {
    public let imageId: String?
    public let imagePermissions: [ImagePermission]?
    public let nextToken: String?
}

extension DescribeWorkspaceImagePermissionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageId = "ImageId"
        case imagePermissions = "ImagePermissions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let imagePermissionsContainer = try containerValues.decodeIfPresent([ImagePermission?].self, forKey: .imagePermissions)
        var imagePermissionsDecoded0:[ImagePermission]? = nil
        if let imagePermissionsContainer = imagePermissionsContainer {
            imagePermissionsDecoded0 = [ImagePermission]()
            for structure0 in imagePermissionsContainer {
                if let structure0 = structure0 {
                    imagePermissionsDecoded0?.append(structure0)
                }
            }
        }
        imagePermissions = imagePermissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeWorkspaceImagesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeWorkspaceImagesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorkspaceImagesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorkspaceImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorkspaceImagesInput>
    public typealias MOutput = OperationOutput<DescribeWorkspaceImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorkspaceImagesOutputError>
}

extension DescribeWorkspaceImagesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeWorkspaceImagesInput(imageIds: \(String(describing: imageIds)), imageType: \(String(describing: imageType)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeWorkspaceImagesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case imageIds = "ImageIds"
        case imageType = "ImageType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageIds = imageIds {
            var imageIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageIds)
            for workspaceimageidlist0 in imageIds {
                try imageIdsContainer.encode(workspaceimageidlist0)
            }
        }
        if let imageType = imageType {
            try encodeContainer.encode(imageType.rawValue, forKey: .imageType)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeWorkspaceImagesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeWorkspaceImagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorkspaceImagesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorkspaceImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorkspaceImagesInput>
    public typealias MOutput = OperationOutput<DescribeWorkspaceImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorkspaceImagesOutputError>
}

public struct DescribeWorkspaceImagesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeWorkspaceImagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorkspaceImagesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorkspaceImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorkspaceImagesInput>
    public typealias MOutput = OperationOutput<DescribeWorkspaceImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorkspaceImagesOutputError>
}

public struct DescribeWorkspaceImagesInput: Equatable {
    /// <p>The identifier of the image.</p>
    public let imageIds: [String]?
    /// <p>The type (owned or shared) of the image.</p>
    public let imageType: ImageType?
    /// <p>The maximum number of items to return.</p>
    public let maxResults: Int?
    /// <p>If you received a <code>NextToken</code> from a previous call that was paginated,
    ///          provide this token to receive the next set of results.</p>
    public let nextToken: String?

    public init (
        imageIds: [String]? = nil,
        imageType: ImageType? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.imageIds = imageIds
        self.imageType = imageType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeWorkspaceImagesInputBody: Equatable {
    public let imageIds: [String]?
    public let imageType: ImageType?
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribeWorkspaceImagesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageIds = "ImageIds"
        case imageType = "ImageType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .imageIds)
        var imageIdsDecoded0:[String]? = nil
        if let imageIdsContainer = imageIdsContainer {
            imageIdsDecoded0 = [String]()
            for string0 in imageIdsContainer {
                if let string0 = string0 {
                    imageIdsDecoded0?.append(string0)
                }
            }
        }
        imageIds = imageIdsDecoded0
        let imageTypeDecoded = try containerValues.decodeIfPresent(ImageType.self, forKey: .imageType)
        imageType = imageTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeWorkspaceImagesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorkspaceImagesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWorkspaceImagesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorkspaceImagesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeWorkspaceImagesOutputResponse(images: \(String(describing: images)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeWorkspaceImagesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeWorkspaceImagesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.images = output.images
            self.nextToken = output.nextToken
        } else {
            self.images = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeWorkspaceImagesOutputResponse: Equatable {
    /// <p>Information about the images.</p>
    public let images: [WorkspaceImage]?
    /// <p>The token to use to retrieve the next page of results. This value is null when there are no more results to return. </p>
    public let nextToken: String?

    public init (
        images: [WorkspaceImage]? = nil,
        nextToken: String? = nil
    )
    {
        self.images = images
        self.nextToken = nextToken
    }
}

struct DescribeWorkspaceImagesOutputResponseBody: Equatable {
    public let images: [WorkspaceImage]?
    public let nextToken: String?
}

extension DescribeWorkspaceImagesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case images = "Images"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imagesContainer = try containerValues.decodeIfPresent([WorkspaceImage?].self, forKey: .images)
        var imagesDecoded0:[WorkspaceImage]? = nil
        if let imagesContainer = imagesContainer {
            imagesDecoded0 = [WorkspaceImage]()
            for structure0 in imagesContainer {
                if let structure0 = structure0 {
                    imagesDecoded0?.append(structure0)
                }
            }
        }
        images = imagesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeWorkspaceSnapshotsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeWorkspaceSnapshotsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorkspaceSnapshotsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorkspaceSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorkspaceSnapshotsInput>
    public typealias MOutput = OperationOutput<DescribeWorkspaceSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorkspaceSnapshotsOutputError>
}

extension DescribeWorkspaceSnapshotsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeWorkspaceSnapshotsInput(workspaceId: \(String(describing: workspaceId)))"}
}

extension DescribeWorkspaceSnapshotsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }
}

public struct DescribeWorkspaceSnapshotsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeWorkspaceSnapshotsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorkspaceSnapshotsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorkspaceSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorkspaceSnapshotsInput>
    public typealias MOutput = OperationOutput<DescribeWorkspaceSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorkspaceSnapshotsOutputError>
}

public struct DescribeWorkspaceSnapshotsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeWorkspaceSnapshotsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorkspaceSnapshotsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorkspaceSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorkspaceSnapshotsInput>
    public typealias MOutput = OperationOutput<DescribeWorkspaceSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorkspaceSnapshotsOutputError>
}

public struct DescribeWorkspaceSnapshotsInput: Equatable {
    /// <p>The identifier of the WorkSpace.</p>
    public let workspaceId: String?

    public init (
        workspaceId: String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

struct DescribeWorkspaceSnapshotsInputBody: Equatable {
    public let workspaceId: String?
}

extension DescribeWorkspaceSnapshotsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

extension DescribeWorkspaceSnapshotsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorkspaceSnapshotsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWorkspaceSnapshotsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorkspaceSnapshotsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeWorkspaceSnapshotsOutputResponse(rebuildSnapshots: \(String(describing: rebuildSnapshots)), restoreSnapshots: \(String(describing: restoreSnapshots)))"}
}

extension DescribeWorkspaceSnapshotsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeWorkspaceSnapshotsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.rebuildSnapshots = output.rebuildSnapshots
            self.restoreSnapshots = output.restoreSnapshots
        } else {
            self.rebuildSnapshots = nil
            self.restoreSnapshots = nil
        }
    }
}

public struct DescribeWorkspaceSnapshotsOutputResponse: Equatable {
    /// <p>Information about the snapshots that can be used to rebuild a WorkSpace. These snapshots include
    ///          the user volume.</p>
    public let rebuildSnapshots: [Snapshot]?
    /// <p>Information about the snapshots that can be used to restore a WorkSpace. These snapshots
    ///          include both the root volume and the user volume.</p>
    public let restoreSnapshots: [Snapshot]?

    public init (
        rebuildSnapshots: [Snapshot]? = nil,
        restoreSnapshots: [Snapshot]? = nil
    )
    {
        self.rebuildSnapshots = rebuildSnapshots
        self.restoreSnapshots = restoreSnapshots
    }
}

struct DescribeWorkspaceSnapshotsOutputResponseBody: Equatable {
    public let rebuildSnapshots: [Snapshot]?
    public let restoreSnapshots: [Snapshot]?
}

extension DescribeWorkspaceSnapshotsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case rebuildSnapshots = "RebuildSnapshots"
        case restoreSnapshots = "RestoreSnapshots"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rebuildSnapshotsContainer = try containerValues.decodeIfPresent([Snapshot?].self, forKey: .rebuildSnapshots)
        var rebuildSnapshotsDecoded0:[Snapshot]? = nil
        if let rebuildSnapshotsContainer = rebuildSnapshotsContainer {
            rebuildSnapshotsDecoded0 = [Snapshot]()
            for structure0 in rebuildSnapshotsContainer {
                if let structure0 = structure0 {
                    rebuildSnapshotsDecoded0?.append(structure0)
                }
            }
        }
        rebuildSnapshots = rebuildSnapshotsDecoded0
        let restoreSnapshotsContainer = try containerValues.decodeIfPresent([Snapshot?].self, forKey: .restoreSnapshots)
        var restoreSnapshotsDecoded0:[Snapshot]? = nil
        if let restoreSnapshotsContainer = restoreSnapshotsContainer {
            restoreSnapshotsDecoded0 = [Snapshot]()
            for structure0 in restoreSnapshotsContainer {
                if let structure0 = structure0 {
                    restoreSnapshotsDecoded0?.append(structure0)
                }
            }
        }
        restoreSnapshots = restoreSnapshotsDecoded0
    }
}

public struct DescribeWorkspacesConnectionStatusInputBodyMiddleware: Middleware {
    public let id: String = "DescribeWorkspacesConnectionStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorkspacesConnectionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorkspacesConnectionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorkspacesConnectionStatusInput>
    public typealias MOutput = OperationOutput<DescribeWorkspacesConnectionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorkspacesConnectionStatusOutputError>
}

extension DescribeWorkspacesConnectionStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeWorkspacesConnectionStatusInput(nextToken: \(String(describing: nextToken)), workspaceIds: \(String(describing: workspaceIds)))"}
}

extension DescribeWorkspacesConnectionStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case workspaceIds = "WorkspaceIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let workspaceIds = workspaceIds {
            var workspaceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workspaceIds)
            for workspaceidlist0 in workspaceIds {
                try workspaceIdsContainer.encode(workspaceidlist0)
            }
        }
    }
}

public struct DescribeWorkspacesConnectionStatusInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeWorkspacesConnectionStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorkspacesConnectionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorkspacesConnectionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorkspacesConnectionStatusInput>
    public typealias MOutput = OperationOutput<DescribeWorkspacesConnectionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorkspacesConnectionStatusOutputError>
}

public struct DescribeWorkspacesConnectionStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeWorkspacesConnectionStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorkspacesConnectionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorkspacesConnectionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorkspacesConnectionStatusInput>
    public typealias MOutput = OperationOutput<DescribeWorkspacesConnectionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorkspacesConnectionStatusOutputError>
}

public struct DescribeWorkspacesConnectionStatusInput: Equatable {
    /// <p>If you received a <code>NextToken</code> from a previous call that was paginated,
    ///          provide this token to receive the next set of results.</p>
    public let nextToken: String?
    /// <p>The identifiers of the WorkSpaces. You can specify up to 25 WorkSpaces.</p>
    public let workspaceIds: [String]?

    public init (
        nextToken: String? = nil,
        workspaceIds: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.workspaceIds = workspaceIds
    }
}

struct DescribeWorkspacesConnectionStatusInputBody: Equatable {
    public let workspaceIds: [String]?
    public let nextToken: String?
}

extension DescribeWorkspacesConnectionStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case workspaceIds = "WorkspaceIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .workspaceIds)
        var workspaceIdsDecoded0:[String]? = nil
        if let workspaceIdsContainer = workspaceIdsContainer {
            workspaceIdsDecoded0 = [String]()
            for string0 in workspaceIdsContainer {
                if let string0 = string0 {
                    workspaceIdsDecoded0?.append(string0)
                }
            }
        }
        workspaceIds = workspaceIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeWorkspacesConnectionStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorkspacesConnectionStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWorkspacesConnectionStatusOutputError: Equatable {
    case invalidParameterValuesException(InvalidParameterValuesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorkspacesConnectionStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeWorkspacesConnectionStatusOutputResponse(nextToken: \(String(describing: nextToken)), workspacesConnectionStatus: \(String(describing: workspacesConnectionStatus)))"}
}

extension DescribeWorkspacesConnectionStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeWorkspacesConnectionStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.workspacesConnectionStatus = output.workspacesConnectionStatus
        } else {
            self.nextToken = nil
            self.workspacesConnectionStatus = nil
        }
    }
}

public struct DescribeWorkspacesConnectionStatusOutputResponse: Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is null when there are no more results to return. </p>
    public let nextToken: String?
    /// <p>Information about the connection status of the WorkSpace.</p>
    public let workspacesConnectionStatus: [WorkspaceConnectionStatus]?

    public init (
        nextToken: String? = nil,
        workspacesConnectionStatus: [WorkspaceConnectionStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.workspacesConnectionStatus = workspacesConnectionStatus
    }
}

struct DescribeWorkspacesConnectionStatusOutputResponseBody: Equatable {
    public let workspacesConnectionStatus: [WorkspaceConnectionStatus]?
    public let nextToken: String?
}

extension DescribeWorkspacesConnectionStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case workspacesConnectionStatus = "WorkspacesConnectionStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspacesConnectionStatusContainer = try containerValues.decodeIfPresent([WorkspaceConnectionStatus?].self, forKey: .workspacesConnectionStatus)
        var workspacesConnectionStatusDecoded0:[WorkspaceConnectionStatus]? = nil
        if let workspacesConnectionStatusContainer = workspacesConnectionStatusContainer {
            workspacesConnectionStatusDecoded0 = [WorkspaceConnectionStatus]()
            for structure0 in workspacesConnectionStatusContainer {
                if let structure0 = structure0 {
                    workspacesConnectionStatusDecoded0?.append(structure0)
                }
            }
        }
        workspacesConnectionStatus = workspacesConnectionStatusDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeWorkspacesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeWorkspacesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorkspacesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorkspacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorkspacesInput>
    public typealias MOutput = OperationOutput<DescribeWorkspacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorkspacesOutputError>
}

extension DescribeWorkspacesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeWorkspacesInput(bundleId: \(String(describing: bundleId)), directoryId: \(String(describing: directoryId)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), userName: \(String(describing: userName)), workspaceIds: \(String(describing: workspaceIds)))"}
}

extension DescribeWorkspacesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bundleId = "BundleId"
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
        case userName = "UserName"
        case workspaceIds = "WorkspaceIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let workspaceIds = workspaceIds {
            var workspaceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workspaceIds)
            for workspaceidlist0 in workspaceIds {
                try workspaceIdsContainer.encode(workspaceidlist0)
            }
        }
    }
}

public struct DescribeWorkspacesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeWorkspacesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorkspacesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorkspacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorkspacesInput>
    public typealias MOutput = OperationOutput<DescribeWorkspacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorkspacesOutputError>
}

public struct DescribeWorkspacesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeWorkspacesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorkspacesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorkspacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorkspacesInput>
    public typealias MOutput = OperationOutput<DescribeWorkspacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorkspacesOutputError>
}

public struct DescribeWorkspacesInput: Equatable {
    /// <p>The identifier of the bundle. All WorkSpaces that are created from this bundle are
    ///          retrieved. You cannot combine this parameter with any other filter.</p>
    public let bundleId: String?
    /// <p>The identifier of the directory. In addition, you can optionally specify a specific
    ///          directory user (see <code>UserName</code>). You cannot combine this parameter with any
    ///          other filter.</p>
    public let directoryId: String?
    /// <p>The maximum number of items to return.</p>
    public let limit: Int?
    /// <p>If you received a <code>NextToken</code> from a previous call that was paginated,
    ///          provide this token to receive the next set of results.</p>
    public let nextToken: String?
    /// <p>The name of the directory user. You must specify this parameter with
    ///             <code>DirectoryId</code>.</p>
    public let userName: String?
    /// <p>The identifiers of the WorkSpaces. You cannot combine this parameter with any other
    ///          filter.</p>
    ///          <p>Because the <a>CreateWorkspaces</a> operation is asynchronous, the identifier
    ///          it returns is not immediately available. If you immediately call <a>DescribeWorkspaces</a> with this identifier, no information is returned.</p>
    public let workspaceIds: [String]?

    public init (
        bundleId: String? = nil,
        directoryId: String? = nil,
        limit: Int? = nil,
        nextToken: String? = nil,
        userName: String? = nil,
        workspaceIds: [String]? = nil
    )
    {
        self.bundleId = bundleId
        self.directoryId = directoryId
        self.limit = limit
        self.nextToken = nextToken
        self.userName = userName
        self.workspaceIds = workspaceIds
    }
}

struct DescribeWorkspacesInputBody: Equatable {
    public let workspaceIds: [String]?
    public let directoryId: String?
    public let userName: String?
    public let bundleId: String?
    public let limit: Int?
    public let nextToken: String?
}

extension DescribeWorkspacesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bundleId = "BundleId"
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
        case userName = "UserName"
        case workspaceIds = "WorkspaceIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .workspaceIds)
        var workspaceIdsDecoded0:[String]? = nil
        if let workspaceIdsContainer = workspaceIdsContainer {
            workspaceIdsDecoded0 = [String]()
            for string0 in workspaceIdsContainer {
                if let string0 = string0 {
                    workspaceIdsDecoded0?.append(string0)
                }
            }
        }
        workspaceIds = workspaceIdsDecoded0
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let bundleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeWorkspacesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorkspacesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWorkspacesOutputError: Equatable {
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceUnavailableException(ResourceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorkspacesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeWorkspacesOutputResponse(nextToken: \(String(describing: nextToken)), workspaces: \(String(describing: workspaces)))"}
}

extension DescribeWorkspacesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeWorkspacesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.workspaces = output.workspaces
        } else {
            self.nextToken = nil
            self.workspaces = nil
        }
    }
}

public struct DescribeWorkspacesOutputResponse: Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is null when there are no more results to return. </p>
    public let nextToken: String?
    /// <p>Information about the WorkSpaces.</p>
    ///          <p>Because <a>CreateWorkspaces</a> is an asynchronous operation, some of the
    ///          returned information could be incomplete.</p>
    public let workspaces: [Workspace]?

    public init (
        nextToken: String? = nil,
        workspaces: [Workspace]? = nil
    )
    {
        self.nextToken = nextToken
        self.workspaces = workspaces
    }
}

struct DescribeWorkspacesOutputResponseBody: Equatable {
    public let workspaces: [Workspace]?
    public let nextToken: String?
}

extension DescribeWorkspacesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case workspaces = "Workspaces"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspacesContainer = try containerValues.decodeIfPresent([Workspace?].self, forKey: .workspaces)
        var workspacesDecoded0:[Workspace]? = nil
        if let workspacesContainer = workspacesContainer {
            workspacesDecoded0 = [Workspace]()
            for structure0 in workspacesContainer {
                if let structure0 = structure0 {
                    workspacesDecoded0?.append(structure0)
                }
            }
        }
        workspaces = workspacesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DisassociateConnectionAliasInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateConnectionAliasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateConnectionAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateConnectionAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateConnectionAliasInput>
    public typealias MOutput = OperationOutput<DisassociateConnectionAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateConnectionAliasOutputError>
}

extension DisassociateConnectionAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateConnectionAliasInput(aliasId: \(String(describing: aliasId)))"}
}

extension DisassociateConnectionAliasInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aliasId = "AliasId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasId = aliasId {
            try encodeContainer.encode(aliasId, forKey: .aliasId)
        }
    }
}

public struct DisassociateConnectionAliasInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateConnectionAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateConnectionAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateConnectionAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateConnectionAliasInput>
    public typealias MOutput = OperationOutput<DisassociateConnectionAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateConnectionAliasOutputError>
}

public struct DisassociateConnectionAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateConnectionAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateConnectionAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateConnectionAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateConnectionAliasInput>
    public typealias MOutput = OperationOutput<DisassociateConnectionAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateConnectionAliasOutputError>
}

public struct DisassociateConnectionAliasInput: Equatable {
    /// <p>The identifier of the connection alias to disassociate.</p>
    public let aliasId: String?

    public init (
        aliasId: String? = nil
    )
    {
        self.aliasId = aliasId
    }
}

struct DisassociateConnectionAliasInputBody: Equatable {
    public let aliasId: String?
}

extension DisassociateConnectionAliasInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aliasId = "AliasId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
    }
}

extension DisassociateConnectionAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateConnectionAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateConnectionAliasOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateConnectionAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateConnectionAliasOutputResponse()"}
}

extension DisassociateConnectionAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateConnectionAliasOutputResponse: Equatable {

    public init() {}
}

struct DisassociateConnectionAliasOutputResponseBody: Equatable {
}

extension DisassociateConnectionAliasOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisassociateIpGroupsInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateIpGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateIpGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateIpGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateIpGroupsInput>
    public typealias MOutput = OperationOutput<DisassociateIpGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateIpGroupsOutputError>
}

extension DisassociateIpGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateIpGroupsInput(directoryId: \(String(describing: directoryId)), groupIds: \(String(describing: groupIds)))"}
}

extension DisassociateIpGroupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case groupIds = "GroupIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let groupIds = groupIds {
            var groupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupIds)
            for ipgroupidlist0 in groupIds {
                try groupIdsContainer.encode(ipgroupidlist0)
            }
        }
    }
}

public struct DisassociateIpGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateIpGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateIpGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateIpGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateIpGroupsInput>
    public typealias MOutput = OperationOutput<DisassociateIpGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateIpGroupsOutputError>
}

public struct DisassociateIpGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateIpGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateIpGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateIpGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateIpGroupsInput>
    public typealias MOutput = OperationOutput<DisassociateIpGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateIpGroupsOutputError>
}

public struct DisassociateIpGroupsInput: Equatable {
    /// <p>The identifier of the directory.</p>
    public let directoryId: String?
    /// <p>The identifiers of one or more IP access control groups.</p>
    public let groupIds: [String]?

    public init (
        directoryId: String? = nil,
        groupIds: [String]? = nil
    )
    {
        self.directoryId = directoryId
        self.groupIds = groupIds
    }
}

struct DisassociateIpGroupsInputBody: Equatable {
    public let directoryId: String?
    public let groupIds: [String]?
}

extension DisassociateIpGroupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case groupIds = "GroupIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let groupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .groupIds)
        var groupIdsDecoded0:[String]? = nil
        if let groupIdsContainer = groupIdsContainer {
            groupIdsDecoded0 = [String]()
            for string0 in groupIdsContainer {
                if let string0 = string0 {
                    groupIdsDecoded0?.append(string0)
                }
            }
        }
        groupIds = groupIdsDecoded0
    }
}

extension DisassociateIpGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateIpGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateIpGroupsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateIpGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateIpGroupsOutputResponse()"}
}

extension DisassociateIpGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateIpGroupsOutputResponse: Equatable {

    public init() {}
}

struct DisassociateIpGroupsOutputResponseBody: Equatable {
}

extension DisassociateIpGroupsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension FailedCreateWorkspaceRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case workspaceRequest = "WorkspaceRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let workspaceRequest = workspaceRequest {
            try encodeContainer.encode(workspaceRequest, forKey: .workspaceRequest)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceRequestDecoded = try containerValues.decodeIfPresent(WorkspaceRequest.self, forKey: .workspaceRequest)
        workspaceRequest = workspaceRequestDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension FailedCreateWorkspaceRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FailedCreateWorkspaceRequest(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), workspaceRequest: \(String(describing: workspaceRequest)))"}
}

/// <p>Describes a WorkSpace that cannot be created.</p>
public struct FailedCreateWorkspaceRequest: Equatable {
    /// <p>The error code that is returned if the WorkSpace cannot be created.</p>
    public let errorCode: String?
    /// <p>The text of the error message that is returned if the WorkSpace cannot be
    ///          created.</p>
    public let errorMessage: String?
    /// <p>Information about the WorkSpace.</p>
    public let workspaceRequest: WorkspaceRequest?

    public init (
        errorCode: String? = nil,
        errorMessage: String? = nil,
        workspaceRequest: WorkspaceRequest? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.workspaceRequest = workspaceRequest
    }
}

extension FailedWorkspaceChangeRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let workspaceId = workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension FailedWorkspaceChangeRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FailedWorkspaceChangeRequest(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), workspaceId: \(String(describing: workspaceId)))"}
}

/// <p>Describes a WorkSpace that could not be rebooted.
///          (<a>RebootWorkspaces</a>), rebuilt (<a>RebuildWorkspaces</a>), restored (<a>RestoreWorkspace</a>), terminated
///          (<a>TerminateWorkspaces</a>), started (<a>StartWorkspaces</a>), or stopped (<a>StopWorkspaces</a>).</p>
public struct FailedWorkspaceChangeRequest: Equatable {
    /// <p>The error code that is returned if the WorkSpace cannot be rebooted.</p>
    public let errorCode: String?
    /// <p>The text of the error message that is returned if the WorkSpace cannot be
    ///          rebooted.</p>
    public let errorMessage: String?
    /// <p>The identifier of the WorkSpace.</p>
    public let workspaceId: String?

    public init (
        errorCode: String? = nil,
        errorMessage: String? = nil,
        workspaceId: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.workspaceId = workspaceId
    }
}

extension ImagePermission: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sharedAccountId = "SharedAccountId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sharedAccountId = sharedAccountId {
            try encodeContainer.encode(sharedAccountId, forKey: .sharedAccountId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sharedAccountId)
        sharedAccountId = sharedAccountIdDecoded
    }
}

extension ImagePermission: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImagePermission(sharedAccountId: \(String(describing: sharedAccountId)))"}
}

/// <p>Describes the AWS accounts that have been granted permission to use a shared image. For more
///          information about sharing images, see
///          <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/share-custom-image.html">
///             Share or Unshare a Custom WorkSpaces Image</a>.</p>
public struct ImagePermission: Equatable {
    /// <p>The identifier of the AWS account that an image has been shared with.</p>
    public let sharedAccountId: String?

    public init (
        sharedAccountId: String? = nil
    )
    {
        self.sharedAccountId = sharedAccountId
    }
}

public enum ImageType {
    case owned
    case shared
    case sdkUnknown(String)
}

extension ImageType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ImageType] {
        return [
            .owned,
            .shared,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .owned: return "OWNED"
        case .shared: return "SHARED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ImageType(rawValue: rawValue) ?? ImageType.sdkUnknown(rawValue)
    }
}

public struct ImportWorkspaceImageInputBodyMiddleware: Middleware {
    public let id: String = "ImportWorkspaceImageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportWorkspaceImageInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportWorkspaceImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportWorkspaceImageInput>
    public typealias MOutput = OperationOutput<ImportWorkspaceImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportWorkspaceImageOutputError>
}

extension ImportWorkspaceImageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportWorkspaceImageInput(applications: \(String(describing: applications)), ec2ImageId: \(String(describing: ec2ImageId)), imageDescription: \(String(describing: imageDescription)), imageName: \(String(describing: imageName)), ingestionProcess: \(String(describing: ingestionProcess)), tags: \(String(describing: tags)))"}
}

extension ImportWorkspaceImageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applications = "Applications"
        case ec2ImageId = "Ec2ImageId"
        case imageDescription = "ImageDescription"
        case imageName = "ImageName"
        case ingestionProcess = "IngestionProcess"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applications = applications {
            var applicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applications)
            for applicationlist0 in applications {
                try applicationsContainer.encode(applicationlist0.rawValue)
            }
        }
        if let ec2ImageId = ec2ImageId {
            try encodeContainer.encode(ec2ImageId, forKey: .ec2ImageId)
        }
        if let imageDescription = imageDescription {
            try encodeContainer.encode(imageDescription, forKey: .imageDescription)
        }
        if let imageName = imageName {
            try encodeContainer.encode(imageName, forKey: .imageName)
        }
        if let ingestionProcess = ingestionProcess {
            try encodeContainer.encode(ingestionProcess.rawValue, forKey: .ingestionProcess)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct ImportWorkspaceImageInputHeadersMiddleware: Middleware {
    public let id: String = "ImportWorkspaceImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportWorkspaceImageInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportWorkspaceImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportWorkspaceImageInput>
    public typealias MOutput = OperationOutput<ImportWorkspaceImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportWorkspaceImageOutputError>
}

public struct ImportWorkspaceImageInputQueryItemMiddleware: Middleware {
    public let id: String = "ImportWorkspaceImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportWorkspaceImageInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportWorkspaceImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportWorkspaceImageInput>
    public typealias MOutput = OperationOutput<ImportWorkspaceImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportWorkspaceImageOutputError>
}

public struct ImportWorkspaceImageInput: Equatable {
    /// <p>If specified, the version of Microsoft Office to subscribe to. Valid only for Windows 10
    ///          BYOL images. For more information about subscribing to Office for BYOL images, see
    ///          <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.html">
    ///             Bring Your Own Windows Desktop Licenses</a>.</p>
    ///
    ///          <note>
    ///             <p>Although this parameter is an array, only one item is allowed at this time.</p>
    ///          </note>
    public let applications: [Application]?
    /// <p>The identifier of the EC2 image.</p>
    public let ec2ImageId: String?
    /// <p>The description of the WorkSpace image.</p>
    public let imageDescription: String?
    /// <p>The name of the WorkSpace image.</p>
    public let imageName: String?
    /// <p>The ingestion process to be used when importing the image, depending on which protocol
    ///          you want to use for your BYOL Workspace image, either PCoIP or WorkSpaces Streaming Protocol
    ///          (WSP). To use WSP, specify a value that ends in <code>_WSP</code>. To use PCoIP, specify a value
    ///          that does not end in <code>_WSP</code>. </p>
    ///
    ///          <p>For non-GPU-enabled bundles (bundles other than Graphics or GraphicsPro), specify
    ///          <code>BYOL_REGULAR</code> or <code>BYOL_REGULAR_WSP</code>, depending on the protocol.</p>
    public let ingestionProcess: WorkspaceImageIngestionProcess?
    /// <p>The tags. Each WorkSpaces resource can have a maximum of 50 tags.</p>
    public let tags: [Tag]?

    public init (
        applications: [Application]? = nil,
        ec2ImageId: String? = nil,
        imageDescription: String? = nil,
        imageName: String? = nil,
        ingestionProcess: WorkspaceImageIngestionProcess? = nil,
        tags: [Tag]? = nil
    )
    {
        self.applications = applications
        self.ec2ImageId = ec2ImageId
        self.imageDescription = imageDescription
        self.imageName = imageName
        self.ingestionProcess = ingestionProcess
        self.tags = tags
    }
}

struct ImportWorkspaceImageInputBody: Equatable {
    public let ec2ImageId: String?
    public let ingestionProcess: WorkspaceImageIngestionProcess?
    public let imageName: String?
    public let imageDescription: String?
    public let tags: [Tag]?
    public let applications: [Application]?
}

extension ImportWorkspaceImageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applications = "Applications"
        case ec2ImageId = "Ec2ImageId"
        case imageDescription = "ImageDescription"
        case imageName = "ImageName"
        case ingestionProcess = "IngestionProcess"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ec2ImageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ec2ImageId)
        ec2ImageId = ec2ImageIdDecoded
        let ingestionProcessDecoded = try containerValues.decodeIfPresent(WorkspaceImageIngestionProcess.self, forKey: .ingestionProcess)
        ingestionProcess = ingestionProcessDecoded
        let imageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageName)
        imageName = imageNameDecoded
        let imageDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageDescription)
        imageDescription = imageDescriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let applicationsContainer = try containerValues.decodeIfPresent([Application?].self, forKey: .applications)
        var applicationsDecoded0:[Application]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [Application]()
            for string0 in applicationsContainer {
                if let string0 = string0 {
                    applicationsDecoded0?.append(string0)
                }
            }
        }
        applications = applicationsDecoded0
    }
}

extension ImportWorkspaceImageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportWorkspaceImageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportWorkspaceImageOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportWorkspaceImageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportWorkspaceImageOutputResponse(imageId: \(String(describing: imageId)))"}
}

extension ImportWorkspaceImageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ImportWorkspaceImageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.imageId = output.imageId
        } else {
            self.imageId = nil
        }
    }
}

public struct ImportWorkspaceImageOutputResponse: Equatable {
    /// <p>The identifier of the WorkSpace image.</p>
    public let imageId: String?

    public init (
        imageId: String? = nil
    )
    {
        self.imageId = imageId
    }
}

struct ImportWorkspaceImageOutputResponseBody: Equatable {
    public let imageId: String?
}

extension ImportWorkspaceImageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageId = "ImageId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageId)
        imageId = imageIdDecoded
    }
}

extension InvalidParameterValuesException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterValuesException(message: \(String(describing: message)))"}
}

extension InvalidParameterValuesException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterValuesExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more parameter values are not valid.</p>
public struct InvalidParameterValuesException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The exception error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterValuesExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParameterValuesExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceStateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidResourceStateException(message: \(String(describing: message)))"}
}

extension InvalidResourceStateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidResourceStateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The state of the resource is not valid for this operation.</p>
public struct InvalidResourceStateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResourceStateExceptionBody: Equatable {
    public let message: String?
}

extension InvalidResourceStateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IpRuleItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ipRule
        case ruleDesc
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipRule = ipRule {
            try encodeContainer.encode(ipRule, forKey: .ipRule)
        }
        if let ruleDesc = ruleDesc {
            try encodeContainer.encode(ruleDesc, forKey: .ruleDesc)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipRuleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ipRule)
        ipRule = ipRuleDecoded
        let ruleDescDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleDesc)
        ruleDesc = ruleDescDecoded
    }
}

extension IpRuleItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IpRuleItem(ipRule: \(String(describing: ipRule)), ruleDesc: \(String(describing: ruleDesc)))"}
}

/// <p>Describes a rule for an IP access control group.</p>
public struct IpRuleItem: Equatable {
    /// <p>The IP address range, in CIDR notation.</p>
    public let ipRule: String?
    /// <p>The description.</p>
    public let ruleDesc: String?

    public init (
        ipRule: String? = nil,
        ruleDesc: String? = nil
    )
    {
        self.ipRule = ipRule
        self.ruleDesc = ruleDesc
    }
}

public struct ListAvailableManagementCidrRangesInputBodyMiddleware: Middleware {
    public let id: String = "ListAvailableManagementCidrRangesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAvailableManagementCidrRangesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAvailableManagementCidrRangesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAvailableManagementCidrRangesInput>
    public typealias MOutput = OperationOutput<ListAvailableManagementCidrRangesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAvailableManagementCidrRangesOutputError>
}

extension ListAvailableManagementCidrRangesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAvailableManagementCidrRangesInput(managementCidrRangeConstraint: \(String(describing: managementCidrRangeConstraint)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAvailableManagementCidrRangesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case managementCidrRangeConstraint = "ManagementCidrRangeConstraint"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let managementCidrRangeConstraint = managementCidrRangeConstraint {
            try encodeContainer.encode(managementCidrRangeConstraint, forKey: .managementCidrRangeConstraint)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAvailableManagementCidrRangesInputHeadersMiddleware: Middleware {
    public let id: String = "ListAvailableManagementCidrRangesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAvailableManagementCidrRangesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAvailableManagementCidrRangesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAvailableManagementCidrRangesInput>
    public typealias MOutput = OperationOutput<ListAvailableManagementCidrRangesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAvailableManagementCidrRangesOutputError>
}

public struct ListAvailableManagementCidrRangesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAvailableManagementCidrRangesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAvailableManagementCidrRangesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAvailableManagementCidrRangesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAvailableManagementCidrRangesInput>
    public typealias MOutput = OperationOutput<ListAvailableManagementCidrRangesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAvailableManagementCidrRangesOutputError>
}

public struct ListAvailableManagementCidrRangesInput: Equatable {
    /// <p>The IP address range to search. Specify an IP address range that is compatible with your
    ///          network and in CIDR notation (that is, specify the range as an IPv4 CIDR block).</p>
    public let managementCidrRangeConstraint: String?
    /// <p>The maximum number of items to return.</p>
    public let maxResults: Int?
    /// <p>If you received a <code>NextToken</code> from a previous call that was paginated,
    ///          provide this token to receive the next set of results.</p>
    public let nextToken: String?

    public init (
        managementCidrRangeConstraint: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.managementCidrRangeConstraint = managementCidrRangeConstraint
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAvailableManagementCidrRangesInputBody: Equatable {
    public let managementCidrRangeConstraint: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListAvailableManagementCidrRangesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case managementCidrRangeConstraint = "ManagementCidrRangeConstraint"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let managementCidrRangeConstraintDecoded = try containerValues.decodeIfPresent(String.self, forKey: .managementCidrRangeConstraint)
        managementCidrRangeConstraint = managementCidrRangeConstraintDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAvailableManagementCidrRangesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAvailableManagementCidrRangesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAvailableManagementCidrRangesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAvailableManagementCidrRangesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAvailableManagementCidrRangesOutputResponse(managementCidrRanges: \(String(describing: managementCidrRanges)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAvailableManagementCidrRangesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAvailableManagementCidrRangesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.managementCidrRanges = output.managementCidrRanges
            self.nextToken = output.nextToken
        } else {
            self.managementCidrRanges = nil
            self.nextToken = nil
        }
    }
}

public struct ListAvailableManagementCidrRangesOutputResponse: Equatable {
    /// <p>The list of available IP address ranges, specified as IPv4 CIDR blocks.</p>
    public let managementCidrRanges: [String]?
    /// <p>The token to use to retrieve the next page of results. This value is null when there are no more results to return. </p>
    public let nextToken: String?

    public init (
        managementCidrRanges: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.managementCidrRanges = managementCidrRanges
        self.nextToken = nextToken
    }
}

struct ListAvailableManagementCidrRangesOutputResponseBody: Equatable {
    public let managementCidrRanges: [String]?
    public let nextToken: String?
}

extension ListAvailableManagementCidrRangesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case managementCidrRanges = "ManagementCidrRanges"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let managementCidrRangesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .managementCidrRanges)
        var managementCidrRangesDecoded0:[String]? = nil
        if let managementCidrRangesContainer = managementCidrRangesContainer {
            managementCidrRangesDecoded0 = [String]()
            for string0 in managementCidrRangesContainer {
                if let string0 = string0 {
                    managementCidrRangesDecoded0?.append(string0)
                }
            }
        }
        managementCidrRanges = managementCidrRangesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct MigrateWorkspaceInputBodyMiddleware: Middleware {
    public let id: String = "MigrateWorkspaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MigrateWorkspaceInput>,
                  next: H) -> Swift.Result<OperationOutput<MigrateWorkspaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MigrateWorkspaceInput>
    public typealias MOutput = OperationOutput<MigrateWorkspaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MigrateWorkspaceOutputError>
}

extension MigrateWorkspaceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MigrateWorkspaceInput(bundleId: \(String(describing: bundleId)), sourceWorkspaceId: \(String(describing: sourceWorkspaceId)))"}
}

extension MigrateWorkspaceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bundleId = "BundleId"
        case sourceWorkspaceId = "SourceWorkspaceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let sourceWorkspaceId = sourceWorkspaceId {
            try encodeContainer.encode(sourceWorkspaceId, forKey: .sourceWorkspaceId)
        }
    }
}

public struct MigrateWorkspaceInputHeadersMiddleware: Middleware {
    public let id: String = "MigrateWorkspaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MigrateWorkspaceInput>,
                  next: H) -> Swift.Result<OperationOutput<MigrateWorkspaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MigrateWorkspaceInput>
    public typealias MOutput = OperationOutput<MigrateWorkspaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MigrateWorkspaceOutputError>
}

public struct MigrateWorkspaceInputQueryItemMiddleware: Middleware {
    public let id: String = "MigrateWorkspaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MigrateWorkspaceInput>,
                  next: H) -> Swift.Result<OperationOutput<MigrateWorkspaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MigrateWorkspaceInput>
    public typealias MOutput = OperationOutput<MigrateWorkspaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MigrateWorkspaceOutputError>
}

public struct MigrateWorkspaceInput: Equatable {
    /// <p>The identifier of the target bundle type to migrate the WorkSpace to.</p>
    public let bundleId: String?
    /// <p>The identifier of the WorkSpace to migrate from.</p>
    public let sourceWorkspaceId: String?

    public init (
        bundleId: String? = nil,
        sourceWorkspaceId: String? = nil
    )
    {
        self.bundleId = bundleId
        self.sourceWorkspaceId = sourceWorkspaceId
    }
}

struct MigrateWorkspaceInputBody: Equatable {
    public let sourceWorkspaceId: String?
    public let bundleId: String?
}

extension MigrateWorkspaceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bundleId = "BundleId"
        case sourceWorkspaceId = "SourceWorkspaceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceWorkspaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceWorkspaceId)
        sourceWorkspaceId = sourceWorkspaceIdDecoded
        let bundleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
    }
}

extension MigrateWorkspaceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension MigrateWorkspaceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationInProgressException" : self = .operationInProgressException(try OperationInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum MigrateWorkspaceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case operationInProgressException(OperationInProgressException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension MigrateWorkspaceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MigrateWorkspaceOutputResponse(sourceWorkspaceId: \(String(describing: sourceWorkspaceId)), targetWorkspaceId: \(String(describing: targetWorkspaceId)))"}
}

extension MigrateWorkspaceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MigrateWorkspaceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.sourceWorkspaceId = output.sourceWorkspaceId
            self.targetWorkspaceId = output.targetWorkspaceId
        } else {
            self.sourceWorkspaceId = nil
            self.targetWorkspaceId = nil
        }
    }
}

public struct MigrateWorkspaceOutputResponse: Equatable {
    /// <p>The original identifier of the WorkSpace that is being migrated.</p>
    public let sourceWorkspaceId: String?
    /// <p>The new identifier of the WorkSpace that is being migrated. If the migration does not succeed,
    ///          the target WorkSpace ID will not be used, and the WorkSpace will still have the original WorkSpace ID.</p>
    public let targetWorkspaceId: String?

    public init (
        sourceWorkspaceId: String? = nil,
        targetWorkspaceId: String? = nil
    )
    {
        self.sourceWorkspaceId = sourceWorkspaceId
        self.targetWorkspaceId = targetWorkspaceId
    }
}

struct MigrateWorkspaceOutputResponseBody: Equatable {
    public let sourceWorkspaceId: String?
    public let targetWorkspaceId: String?
}

extension MigrateWorkspaceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sourceWorkspaceId = "SourceWorkspaceId"
        case targetWorkspaceId = "TargetWorkspaceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceWorkspaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceWorkspaceId)
        sourceWorkspaceId = sourceWorkspaceIdDecoded
        let targetWorkspaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetWorkspaceId)
        targetWorkspaceId = targetWorkspaceIdDecoded
    }
}

public enum ModificationResourceEnum {
    case computeType
    case rootVolume
    case userVolume
    case sdkUnknown(String)
}

extension ModificationResourceEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ModificationResourceEnum] {
        return [
            .computeType,
            .rootVolume,
            .userVolume,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .computeType: return "COMPUTE_TYPE"
        case .rootVolume: return "ROOT_VOLUME"
        case .userVolume: return "USER_VOLUME"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ModificationResourceEnum(rawValue: rawValue) ?? ModificationResourceEnum.sdkUnknown(rawValue)
    }
}

extension ModificationState: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resource = "Resource"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resource = resource {
            try encodeContainer.encode(resource.rawValue, forKey: .resource)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDecoded = try containerValues.decodeIfPresent(ModificationResourceEnum.self, forKey: .resource)
        resource = resourceDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ModificationStateEnum.self, forKey: .state)
        state = stateDecoded
    }
}

extension ModificationState: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModificationState(resource: \(String(describing: resource)), state: \(String(describing: state)))"}
}

/// <p>Describes a WorkSpace modification.</p>
public struct ModificationState: Equatable {
    /// <p>The resource.</p>
    public let resource: ModificationResourceEnum?
    /// <p>The modification state.</p>
    public let state: ModificationStateEnum?

    public init (
        resource: ModificationResourceEnum? = nil,
        state: ModificationStateEnum? = nil
    )
    {
        self.resource = resource
        self.state = state
    }
}

public enum ModificationStateEnum {
    case updateInitiated
    case updateInProgress
    case sdkUnknown(String)
}

extension ModificationStateEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ModificationStateEnum] {
        return [
            .updateInitiated,
            .updateInProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .updateInitiated: return "UPDATE_INITIATED"
        case .updateInProgress: return "UPDATE_IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ModificationStateEnum(rawValue: rawValue) ?? ModificationStateEnum.sdkUnknown(rawValue)
    }
}

public struct ModifyAccountInputBodyMiddleware: Middleware {
    public let id: String = "ModifyAccountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyAccountInput>
    public typealias MOutput = OperationOutput<ModifyAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyAccountOutputError>
}

extension ModifyAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyAccountInput(dedicatedTenancyManagementCidrRange: \(String(describing: dedicatedTenancyManagementCidrRange)), dedicatedTenancySupport: \(String(describing: dedicatedTenancySupport)))"}
}

extension ModifyAccountInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dedicatedTenancyManagementCidrRange = "DedicatedTenancyManagementCidrRange"
        case dedicatedTenancySupport = "DedicatedTenancySupport"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dedicatedTenancyManagementCidrRange = dedicatedTenancyManagementCidrRange {
            try encodeContainer.encode(dedicatedTenancyManagementCidrRange, forKey: .dedicatedTenancyManagementCidrRange)
        }
        if let dedicatedTenancySupport = dedicatedTenancySupport {
            try encodeContainer.encode(dedicatedTenancySupport.rawValue, forKey: .dedicatedTenancySupport)
        }
    }
}

public struct ModifyAccountInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyAccountInput>
    public typealias MOutput = OperationOutput<ModifyAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyAccountOutputError>
}

public struct ModifyAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyAccountInput>
    public typealias MOutput = OperationOutput<ModifyAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyAccountOutputError>
}

public struct ModifyAccountInput: Equatable {
    /// <p>The IP address range, specified as an IPv4 CIDR block, for the management network
    ///          interface. Specify an IP address range that is compatible with your network and in CIDR
    ///          notation (that is, specify the range as an IPv4 CIDR block). The CIDR block size must be
    ///          /16 (for example, 203.0.113.25/16). It must also be specified as available by the
    ///             <code>ListAvailableManagementCidrRanges</code> operation.</p>
    public let dedicatedTenancyManagementCidrRange: String?
    /// <p>The status of BYOL.</p>
    public let dedicatedTenancySupport: DedicatedTenancySupportEnum?

    public init (
        dedicatedTenancyManagementCidrRange: String? = nil,
        dedicatedTenancySupport: DedicatedTenancySupportEnum? = nil
    )
    {
        self.dedicatedTenancyManagementCidrRange = dedicatedTenancyManagementCidrRange
        self.dedicatedTenancySupport = dedicatedTenancySupport
    }
}

struct ModifyAccountInputBody: Equatable {
    public let dedicatedTenancySupport: DedicatedTenancySupportEnum?
    public let dedicatedTenancyManagementCidrRange: String?
}

extension ModifyAccountInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dedicatedTenancyManagementCidrRange = "DedicatedTenancyManagementCidrRange"
        case dedicatedTenancySupport = "DedicatedTenancySupport"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dedicatedTenancySupportDecoded = try containerValues.decodeIfPresent(DedicatedTenancySupportEnum.self, forKey: .dedicatedTenancySupport)
        dedicatedTenancySupport = dedicatedTenancySupportDecoded
        let dedicatedTenancyManagementCidrRangeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dedicatedTenancyManagementCidrRange)
        dedicatedTenancyManagementCidrRange = dedicatedTenancyManagementCidrRangeDecoded
    }
}

extension ModifyAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyAccountOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyAccountOutputResponse()"}
}

extension ModifyAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ModifyAccountOutputResponse: Equatable {

    public init() {}
}

struct ModifyAccountOutputResponseBody: Equatable {
}

extension ModifyAccountOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct ModifyClientPropertiesInputBodyMiddleware: Middleware {
    public let id: String = "ModifyClientPropertiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyClientPropertiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyClientPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyClientPropertiesInput>
    public typealias MOutput = OperationOutput<ModifyClientPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyClientPropertiesOutputError>
}

extension ModifyClientPropertiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyClientPropertiesInput(clientProperties: \(String(describing: clientProperties)), resourceId: \(String(describing: resourceId)))"}
}

extension ModifyClientPropertiesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientProperties = "ClientProperties"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientProperties = clientProperties {
            try encodeContainer.encode(clientProperties, forKey: .clientProperties)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

public struct ModifyClientPropertiesInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyClientPropertiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyClientPropertiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyClientPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyClientPropertiesInput>
    public typealias MOutput = OperationOutput<ModifyClientPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyClientPropertiesOutputError>
}

public struct ModifyClientPropertiesInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyClientPropertiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyClientPropertiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyClientPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyClientPropertiesInput>
    public typealias MOutput = OperationOutput<ModifyClientPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyClientPropertiesOutputError>
}

public struct ModifyClientPropertiesInput: Equatable {
    /// <p>Information about the Amazon WorkSpaces client.</p>
    public let clientProperties: ClientProperties?
    /// <p>The resource identifiers, in the form of directory IDs.</p>
    public let resourceId: String?

    public init (
        clientProperties: ClientProperties? = nil,
        resourceId: String? = nil
    )
    {
        self.clientProperties = clientProperties
        self.resourceId = resourceId
    }
}

struct ModifyClientPropertiesInputBody: Equatable {
    public let resourceId: String?
    public let clientProperties: ClientProperties?
}

extension ModifyClientPropertiesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientProperties = "ClientProperties"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let clientPropertiesDecoded = try containerValues.decodeIfPresent(ClientProperties.self, forKey: .clientProperties)
        clientProperties = clientPropertiesDecoded
    }
}

extension ModifyClientPropertiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyClientPropertiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyClientPropertiesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyClientPropertiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyClientPropertiesOutputResponse()"}
}

extension ModifyClientPropertiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ModifyClientPropertiesOutputResponse: Equatable {

    public init() {}
}

struct ModifyClientPropertiesOutputResponseBody: Equatable {
}

extension ModifyClientPropertiesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct ModifySelfservicePermissionsInputBodyMiddleware: Middleware {
    public let id: String = "ModifySelfservicePermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifySelfservicePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifySelfservicePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifySelfservicePermissionsInput>
    public typealias MOutput = OperationOutput<ModifySelfservicePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifySelfservicePermissionsOutputError>
}

extension ModifySelfservicePermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifySelfservicePermissionsInput(resourceId: \(String(describing: resourceId)), selfservicePermissions: \(String(describing: selfservicePermissions)))"}
}

extension ModifySelfservicePermissionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case selfservicePermissions = "SelfservicePermissions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let selfservicePermissions = selfservicePermissions {
            try encodeContainer.encode(selfservicePermissions, forKey: .selfservicePermissions)
        }
    }
}

public struct ModifySelfservicePermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "ModifySelfservicePermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifySelfservicePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifySelfservicePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifySelfservicePermissionsInput>
    public typealias MOutput = OperationOutput<ModifySelfservicePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifySelfservicePermissionsOutputError>
}

public struct ModifySelfservicePermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifySelfservicePermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifySelfservicePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifySelfservicePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifySelfservicePermissionsInput>
    public typealias MOutput = OperationOutput<ModifySelfservicePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifySelfservicePermissionsOutputError>
}

public struct ModifySelfservicePermissionsInput: Equatable {
    /// <p>The identifier of the directory.</p>
    public let resourceId: String?
    /// <p>The permissions to enable or disable self-service capabilities.</p>
    public let selfservicePermissions: SelfservicePermissions?

    public init (
        resourceId: String? = nil,
        selfservicePermissions: SelfservicePermissions? = nil
    )
    {
        self.resourceId = resourceId
        self.selfservicePermissions = selfservicePermissions
    }
}

struct ModifySelfservicePermissionsInputBody: Equatable {
    public let resourceId: String?
    public let selfservicePermissions: SelfservicePermissions?
}

extension ModifySelfservicePermissionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case selfservicePermissions = "SelfservicePermissions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let selfservicePermissionsDecoded = try containerValues.decodeIfPresent(SelfservicePermissions.self, forKey: .selfservicePermissions)
        selfservicePermissions = selfservicePermissionsDecoded
    }
}

extension ModifySelfservicePermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifySelfservicePermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifySelfservicePermissionsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifySelfservicePermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifySelfservicePermissionsOutputResponse()"}
}

extension ModifySelfservicePermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ModifySelfservicePermissionsOutputResponse: Equatable {

    public init() {}
}

struct ModifySelfservicePermissionsOutputResponseBody: Equatable {
}

extension ModifySelfservicePermissionsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct ModifyWorkspaceAccessPropertiesInputBodyMiddleware: Middleware {
    public let id: String = "ModifyWorkspaceAccessPropertiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyWorkspaceAccessPropertiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyWorkspaceAccessPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyWorkspaceAccessPropertiesInput>
    public typealias MOutput = OperationOutput<ModifyWorkspaceAccessPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyWorkspaceAccessPropertiesOutputError>
}

extension ModifyWorkspaceAccessPropertiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyWorkspaceAccessPropertiesInput(resourceId: \(String(describing: resourceId)), workspaceAccessProperties: \(String(describing: workspaceAccessProperties)))"}
}

extension ModifyWorkspaceAccessPropertiesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case workspaceAccessProperties = "WorkspaceAccessProperties"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let workspaceAccessProperties = workspaceAccessProperties {
            try encodeContainer.encode(workspaceAccessProperties, forKey: .workspaceAccessProperties)
        }
    }
}

public struct ModifyWorkspaceAccessPropertiesInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyWorkspaceAccessPropertiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyWorkspaceAccessPropertiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyWorkspaceAccessPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyWorkspaceAccessPropertiesInput>
    public typealias MOutput = OperationOutput<ModifyWorkspaceAccessPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyWorkspaceAccessPropertiesOutputError>
}

public struct ModifyWorkspaceAccessPropertiesInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyWorkspaceAccessPropertiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyWorkspaceAccessPropertiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyWorkspaceAccessPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyWorkspaceAccessPropertiesInput>
    public typealias MOutput = OperationOutput<ModifyWorkspaceAccessPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyWorkspaceAccessPropertiesOutputError>
}

public struct ModifyWorkspaceAccessPropertiesInput: Equatable {
    /// <p>The identifier of the directory.</p>
    public let resourceId: String?
    /// <p>The device types and operating systems to enable or disable for access.</p>
    public let workspaceAccessProperties: WorkspaceAccessProperties?

    public init (
        resourceId: String? = nil,
        workspaceAccessProperties: WorkspaceAccessProperties? = nil
    )
    {
        self.resourceId = resourceId
        self.workspaceAccessProperties = workspaceAccessProperties
    }
}

struct ModifyWorkspaceAccessPropertiesInputBody: Equatable {
    public let resourceId: String?
    public let workspaceAccessProperties: WorkspaceAccessProperties?
}

extension ModifyWorkspaceAccessPropertiesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case workspaceAccessProperties = "WorkspaceAccessProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let workspaceAccessPropertiesDecoded = try containerValues.decodeIfPresent(WorkspaceAccessProperties.self, forKey: .workspaceAccessProperties)
        workspaceAccessProperties = workspaceAccessPropertiesDecoded
    }
}

extension ModifyWorkspaceAccessPropertiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyWorkspaceAccessPropertiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyWorkspaceAccessPropertiesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyWorkspaceAccessPropertiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyWorkspaceAccessPropertiesOutputResponse()"}
}

extension ModifyWorkspaceAccessPropertiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ModifyWorkspaceAccessPropertiesOutputResponse: Equatable {

    public init() {}
}

struct ModifyWorkspaceAccessPropertiesOutputResponseBody: Equatable {
}

extension ModifyWorkspaceAccessPropertiesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct ModifyWorkspaceCreationPropertiesInputBodyMiddleware: Middleware {
    public let id: String = "ModifyWorkspaceCreationPropertiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyWorkspaceCreationPropertiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyWorkspaceCreationPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyWorkspaceCreationPropertiesInput>
    public typealias MOutput = OperationOutput<ModifyWorkspaceCreationPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyWorkspaceCreationPropertiesOutputError>
}

extension ModifyWorkspaceCreationPropertiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyWorkspaceCreationPropertiesInput(resourceId: \(String(describing: resourceId)), workspaceCreationProperties: \(String(describing: workspaceCreationProperties)))"}
}

extension ModifyWorkspaceCreationPropertiesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case workspaceCreationProperties = "WorkspaceCreationProperties"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let workspaceCreationProperties = workspaceCreationProperties {
            try encodeContainer.encode(workspaceCreationProperties, forKey: .workspaceCreationProperties)
        }
    }
}

public struct ModifyWorkspaceCreationPropertiesInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyWorkspaceCreationPropertiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyWorkspaceCreationPropertiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyWorkspaceCreationPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyWorkspaceCreationPropertiesInput>
    public typealias MOutput = OperationOutput<ModifyWorkspaceCreationPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyWorkspaceCreationPropertiesOutputError>
}

public struct ModifyWorkspaceCreationPropertiesInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyWorkspaceCreationPropertiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyWorkspaceCreationPropertiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyWorkspaceCreationPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyWorkspaceCreationPropertiesInput>
    public typealias MOutput = OperationOutput<ModifyWorkspaceCreationPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyWorkspaceCreationPropertiesOutputError>
}

public struct ModifyWorkspaceCreationPropertiesInput: Equatable {
    /// <p>The identifier of the directory.</p>
    public let resourceId: String?
    /// <p>The default properties for creating WorkSpaces.</p>
    public let workspaceCreationProperties: WorkspaceCreationProperties?

    public init (
        resourceId: String? = nil,
        workspaceCreationProperties: WorkspaceCreationProperties? = nil
    )
    {
        self.resourceId = resourceId
        self.workspaceCreationProperties = workspaceCreationProperties
    }
}

struct ModifyWorkspaceCreationPropertiesInputBody: Equatable {
    public let resourceId: String?
    public let workspaceCreationProperties: WorkspaceCreationProperties?
}

extension ModifyWorkspaceCreationPropertiesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case workspaceCreationProperties = "WorkspaceCreationProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let workspaceCreationPropertiesDecoded = try containerValues.decodeIfPresent(WorkspaceCreationProperties.self, forKey: .workspaceCreationProperties)
        workspaceCreationProperties = workspaceCreationPropertiesDecoded
    }
}

extension ModifyWorkspaceCreationPropertiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyWorkspaceCreationPropertiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyWorkspaceCreationPropertiesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyWorkspaceCreationPropertiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyWorkspaceCreationPropertiesOutputResponse()"}
}

extension ModifyWorkspaceCreationPropertiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ModifyWorkspaceCreationPropertiesOutputResponse: Equatable {

    public init() {}
}

struct ModifyWorkspaceCreationPropertiesOutputResponseBody: Equatable {
}

extension ModifyWorkspaceCreationPropertiesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct ModifyWorkspacePropertiesInputBodyMiddleware: Middleware {
    public let id: String = "ModifyWorkspacePropertiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyWorkspacePropertiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyWorkspacePropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyWorkspacePropertiesInput>
    public typealias MOutput = OperationOutput<ModifyWorkspacePropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyWorkspacePropertiesOutputError>
}

extension ModifyWorkspacePropertiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyWorkspacePropertiesInput(workspaceId: \(String(describing: workspaceId)), workspaceProperties: \(String(describing: workspaceProperties)))"}
}

extension ModifyWorkspacePropertiesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case workspaceId = "WorkspaceId"
        case workspaceProperties = "WorkspaceProperties"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
        if let workspaceProperties = workspaceProperties {
            try encodeContainer.encode(workspaceProperties, forKey: .workspaceProperties)
        }
    }
}

public struct ModifyWorkspacePropertiesInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyWorkspacePropertiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyWorkspacePropertiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyWorkspacePropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyWorkspacePropertiesInput>
    public typealias MOutput = OperationOutput<ModifyWorkspacePropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyWorkspacePropertiesOutputError>
}

public struct ModifyWorkspacePropertiesInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyWorkspacePropertiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyWorkspacePropertiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyWorkspacePropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyWorkspacePropertiesInput>
    public typealias MOutput = OperationOutput<ModifyWorkspacePropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyWorkspacePropertiesOutputError>
}

public struct ModifyWorkspacePropertiesInput: Equatable {
    /// <p>The identifier of the WorkSpace.</p>
    public let workspaceId: String?
    /// <p>The properties of the WorkSpace.</p>
    public let workspaceProperties: WorkspaceProperties?

    public init (
        workspaceId: String? = nil,
        workspaceProperties: WorkspaceProperties? = nil
    )
    {
        self.workspaceId = workspaceId
        self.workspaceProperties = workspaceProperties
    }
}

struct ModifyWorkspacePropertiesInputBody: Equatable {
    public let workspaceId: String?
    public let workspaceProperties: WorkspaceProperties?
}

extension ModifyWorkspacePropertiesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case workspaceId = "WorkspaceId"
        case workspaceProperties = "WorkspaceProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let workspacePropertiesDecoded = try containerValues.decodeIfPresent(WorkspaceProperties.self, forKey: .workspaceProperties)
        workspaceProperties = workspacePropertiesDecoded
    }
}

extension ModifyWorkspacePropertiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyWorkspacePropertiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationInProgressException" : self = .operationInProgressException(try OperationInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedWorkspaceConfigurationException" : self = .unsupportedWorkspaceConfigurationException(try UnsupportedWorkspaceConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyWorkspacePropertiesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case operationInProgressException(OperationInProgressException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case unsupportedWorkspaceConfigurationException(UnsupportedWorkspaceConfigurationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyWorkspacePropertiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyWorkspacePropertiesOutputResponse()"}
}

extension ModifyWorkspacePropertiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ModifyWorkspacePropertiesOutputResponse: Equatable {

    public init() {}
}

struct ModifyWorkspacePropertiesOutputResponseBody: Equatable {
}

extension ModifyWorkspacePropertiesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct ModifyWorkspaceStateInputBodyMiddleware: Middleware {
    public let id: String = "ModifyWorkspaceStateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyWorkspaceStateInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyWorkspaceStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyWorkspaceStateInput>
    public typealias MOutput = OperationOutput<ModifyWorkspaceStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyWorkspaceStateOutputError>
}

extension ModifyWorkspaceStateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyWorkspaceStateInput(workspaceId: \(String(describing: workspaceId)), workspaceState: \(String(describing: workspaceState)))"}
}

extension ModifyWorkspaceStateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case workspaceId = "WorkspaceId"
        case workspaceState = "WorkspaceState"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
        if let workspaceState = workspaceState {
            try encodeContainer.encode(workspaceState.rawValue, forKey: .workspaceState)
        }
    }
}

public struct ModifyWorkspaceStateInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyWorkspaceStateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyWorkspaceStateInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyWorkspaceStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyWorkspaceStateInput>
    public typealias MOutput = OperationOutput<ModifyWorkspaceStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyWorkspaceStateOutputError>
}

public struct ModifyWorkspaceStateInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyWorkspaceStateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyWorkspaceStateInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyWorkspaceStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyWorkspaceStateInput>
    public typealias MOutput = OperationOutput<ModifyWorkspaceStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyWorkspaceStateOutputError>
}

public struct ModifyWorkspaceStateInput: Equatable {
    /// <p>The identifier of the WorkSpace.</p>
    public let workspaceId: String?
    /// <p>The WorkSpace state.</p>
    public let workspaceState: TargetWorkspaceState?

    public init (
        workspaceId: String? = nil,
        workspaceState: TargetWorkspaceState? = nil
    )
    {
        self.workspaceId = workspaceId
        self.workspaceState = workspaceState
    }
}

struct ModifyWorkspaceStateInputBody: Equatable {
    public let workspaceId: String?
    public let workspaceState: TargetWorkspaceState?
}

extension ModifyWorkspaceStateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case workspaceId = "WorkspaceId"
        case workspaceState = "WorkspaceState"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let workspaceStateDecoded = try containerValues.decodeIfPresent(TargetWorkspaceState.self, forKey: .workspaceState)
        workspaceState = workspaceStateDecoded
    }
}

extension ModifyWorkspaceStateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyWorkspaceStateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyWorkspaceStateOutputError: Equatable {
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyWorkspaceStateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyWorkspaceStateOutputResponse()"}
}

extension ModifyWorkspaceStateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ModifyWorkspaceStateOutputResponse: Equatable {

    public init() {}
}

struct ModifyWorkspaceStateOutputResponseBody: Equatable {
}

extension ModifyWorkspaceStateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension OperatingSystem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OperatingSystemType.self, forKey: .type)
        type = typeDecoded
    }
}

extension OperatingSystem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OperatingSystem(type: \(String(describing: type)))"}
}

/// <p>The operating system that the image is running.</p>
public struct OperatingSystem: Equatable {
    /// <p>The operating system.</p>
    public let type: OperatingSystemType?

    public init (
        type: OperatingSystemType? = nil
    )
    {
        self.type = type
    }
}

public enum OperatingSystemType {
    case linux
    case windows
    case sdkUnknown(String)
}

extension OperatingSystemType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OperatingSystemType] {
        return [
            .linux,
            .windows,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .linux: return "LINUX"
        case .windows: return "WINDOWS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OperatingSystemType(rawValue: rawValue) ?? OperatingSystemType.sdkUnknown(rawValue)
    }
}

extension OperationInProgressException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OperationInProgressException(message: \(String(describing: message)))"}
}

extension OperationInProgressException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OperationInProgressExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The properties of this WorkSpace are currently being modified. Try again in a moment.</p>
public struct OperationInProgressException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OperationInProgressExceptionBody: Equatable {
    public let message: String?
}

extension OperationInProgressExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OperationNotSupportedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OperationNotSupportedException(message: \(String(describing: message)))"}
}

extension OperationNotSupportedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OperationNotSupportedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This operation is not supported.</p>
public struct OperationNotSupportedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OperationNotSupportedExceptionBody: Equatable {
    public let message: String?
}

extension OperationNotSupportedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RebootRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

extension RebootRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RebootRequest(workspaceId: \(String(describing: workspaceId)))"}
}

/// <p>Describes the information used to reboot a WorkSpace.</p>
public struct RebootRequest: Equatable {
    /// <p>The identifier of the WorkSpace.</p>
    public let workspaceId: String?

    public init (
        workspaceId: String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

public struct RebootWorkspacesInputBodyMiddleware: Middleware {
    public let id: String = "RebootWorkspacesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebootWorkspacesInput>,
                  next: H) -> Swift.Result<OperationOutput<RebootWorkspacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebootWorkspacesInput>
    public typealias MOutput = OperationOutput<RebootWorkspacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebootWorkspacesOutputError>
}

extension RebootWorkspacesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RebootWorkspacesInput(rebootWorkspaceRequests: \(String(describing: rebootWorkspaceRequests)))"}
}

extension RebootWorkspacesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case rebootWorkspaceRequests = "RebootWorkspaceRequests"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rebootWorkspaceRequests = rebootWorkspaceRequests {
            var rebootWorkspaceRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rebootWorkspaceRequests)
            for rebootworkspacerequests0 in rebootWorkspaceRequests {
                try rebootWorkspaceRequestsContainer.encode(rebootworkspacerequests0)
            }
        }
    }
}

public struct RebootWorkspacesInputHeadersMiddleware: Middleware {
    public let id: String = "RebootWorkspacesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebootWorkspacesInput>,
                  next: H) -> Swift.Result<OperationOutput<RebootWorkspacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebootWorkspacesInput>
    public typealias MOutput = OperationOutput<RebootWorkspacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebootWorkspacesOutputError>
}

public struct RebootWorkspacesInputQueryItemMiddleware: Middleware {
    public let id: String = "RebootWorkspacesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebootWorkspacesInput>,
                  next: H) -> Swift.Result<OperationOutput<RebootWorkspacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebootWorkspacesInput>
    public typealias MOutput = OperationOutput<RebootWorkspacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebootWorkspacesOutputError>
}

public struct RebootWorkspacesInput: Equatable {
    /// <p>The WorkSpaces to reboot. You can specify up to 25 WorkSpaces.</p>
    public let rebootWorkspaceRequests: [RebootRequest]?

    public init (
        rebootWorkspaceRequests: [RebootRequest]? = nil
    )
    {
        self.rebootWorkspaceRequests = rebootWorkspaceRequests
    }
}

struct RebootWorkspacesInputBody: Equatable {
    public let rebootWorkspaceRequests: [RebootRequest]?
}

extension RebootWorkspacesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case rebootWorkspaceRequests = "RebootWorkspaceRequests"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rebootWorkspaceRequestsContainer = try containerValues.decodeIfPresent([RebootRequest?].self, forKey: .rebootWorkspaceRequests)
        var rebootWorkspaceRequestsDecoded0:[RebootRequest]? = nil
        if let rebootWorkspaceRequestsContainer = rebootWorkspaceRequestsContainer {
            rebootWorkspaceRequestsDecoded0 = [RebootRequest]()
            for structure0 in rebootWorkspaceRequestsContainer {
                if let structure0 = structure0 {
                    rebootWorkspaceRequestsDecoded0?.append(structure0)
                }
            }
        }
        rebootWorkspaceRequests = rebootWorkspaceRequestsDecoded0
    }
}

extension RebootWorkspacesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RebootWorkspacesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RebootWorkspacesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension RebootWorkspacesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RebootWorkspacesOutputResponse(failedRequests: \(String(describing: failedRequests)))"}
}

extension RebootWorkspacesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RebootWorkspacesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedRequests = output.failedRequests
        } else {
            self.failedRequests = nil
        }
    }
}

public struct RebootWorkspacesOutputResponse: Equatable {
    /// <p>Information about the WorkSpaces that could not be rebooted.</p>
    public let failedRequests: [FailedWorkspaceChangeRequest]?

    public init (
        failedRequests: [FailedWorkspaceChangeRequest]? = nil
    )
    {
        self.failedRequests = failedRequests
    }
}

struct RebootWorkspacesOutputResponseBody: Equatable {
    public let failedRequests: [FailedWorkspaceChangeRequest]?
}

extension RebootWorkspacesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedRequests = "FailedRequests"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedRequestsContainer = try containerValues.decodeIfPresent([FailedWorkspaceChangeRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[FailedWorkspaceChangeRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [FailedWorkspaceChangeRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
    }
}

extension RebuildRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

extension RebuildRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RebuildRequest(workspaceId: \(String(describing: workspaceId)))"}
}

/// <p>Describes the information used to rebuild a WorkSpace.</p>
public struct RebuildRequest: Equatable {
    /// <p>The identifier of the WorkSpace.</p>
    public let workspaceId: String?

    public init (
        workspaceId: String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

public struct RebuildWorkspacesInputBodyMiddleware: Middleware {
    public let id: String = "RebuildWorkspacesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebuildWorkspacesInput>,
                  next: H) -> Swift.Result<OperationOutput<RebuildWorkspacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebuildWorkspacesInput>
    public typealias MOutput = OperationOutput<RebuildWorkspacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebuildWorkspacesOutputError>
}

extension RebuildWorkspacesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RebuildWorkspacesInput(rebuildWorkspaceRequests: \(String(describing: rebuildWorkspaceRequests)))"}
}

extension RebuildWorkspacesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case rebuildWorkspaceRequests = "RebuildWorkspaceRequests"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rebuildWorkspaceRequests = rebuildWorkspaceRequests {
            var rebuildWorkspaceRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rebuildWorkspaceRequests)
            for rebuildworkspacerequests0 in rebuildWorkspaceRequests {
                try rebuildWorkspaceRequestsContainer.encode(rebuildworkspacerequests0)
            }
        }
    }
}

public struct RebuildWorkspacesInputHeadersMiddleware: Middleware {
    public let id: String = "RebuildWorkspacesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebuildWorkspacesInput>,
                  next: H) -> Swift.Result<OperationOutput<RebuildWorkspacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebuildWorkspacesInput>
    public typealias MOutput = OperationOutput<RebuildWorkspacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebuildWorkspacesOutputError>
}

public struct RebuildWorkspacesInputQueryItemMiddleware: Middleware {
    public let id: String = "RebuildWorkspacesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebuildWorkspacesInput>,
                  next: H) -> Swift.Result<OperationOutput<RebuildWorkspacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebuildWorkspacesInput>
    public typealias MOutput = OperationOutput<RebuildWorkspacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebuildWorkspacesOutputError>
}

public struct RebuildWorkspacesInput: Equatable {
    /// <p>The WorkSpace to rebuild. You can specify a single WorkSpace.</p>
    public let rebuildWorkspaceRequests: [RebuildRequest]?

    public init (
        rebuildWorkspaceRequests: [RebuildRequest]? = nil
    )
    {
        self.rebuildWorkspaceRequests = rebuildWorkspaceRequests
    }
}

struct RebuildWorkspacesInputBody: Equatable {
    public let rebuildWorkspaceRequests: [RebuildRequest]?
}

extension RebuildWorkspacesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case rebuildWorkspaceRequests = "RebuildWorkspaceRequests"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rebuildWorkspaceRequestsContainer = try containerValues.decodeIfPresent([RebuildRequest?].self, forKey: .rebuildWorkspaceRequests)
        var rebuildWorkspaceRequestsDecoded0:[RebuildRequest]? = nil
        if let rebuildWorkspaceRequestsContainer = rebuildWorkspaceRequestsContainer {
            rebuildWorkspaceRequestsDecoded0 = [RebuildRequest]()
            for structure0 in rebuildWorkspaceRequestsContainer {
                if let structure0 = structure0 {
                    rebuildWorkspaceRequestsDecoded0?.append(structure0)
                }
            }
        }
        rebuildWorkspaceRequests = rebuildWorkspaceRequestsDecoded0
    }
}

extension RebuildWorkspacesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RebuildWorkspacesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RebuildWorkspacesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension RebuildWorkspacesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RebuildWorkspacesOutputResponse(failedRequests: \(String(describing: failedRequests)))"}
}

extension RebuildWorkspacesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RebuildWorkspacesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedRequests = output.failedRequests
        } else {
            self.failedRequests = nil
        }
    }
}

public struct RebuildWorkspacesOutputResponse: Equatable {
    /// <p>Information about the WorkSpace that could not be rebuilt.</p>
    public let failedRequests: [FailedWorkspaceChangeRequest]?

    public init (
        failedRequests: [FailedWorkspaceChangeRequest]? = nil
    )
    {
        self.failedRequests = failedRequests
    }
}

struct RebuildWorkspacesOutputResponseBody: Equatable {
    public let failedRequests: [FailedWorkspaceChangeRequest]?
}

extension RebuildWorkspacesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedRequests = "FailedRequests"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedRequestsContainer = try containerValues.decodeIfPresent([FailedWorkspaceChangeRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[FailedWorkspaceChangeRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [FailedWorkspaceChangeRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
    }
}

public enum ReconnectEnum {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension ReconnectEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReconnectEnum] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReconnectEnum(rawValue: rawValue) ?? ReconnectEnum.sdkUnknown(rawValue)
    }
}

public struct RegisterWorkspaceDirectoryInputBodyMiddleware: Middleware {
    public let id: String = "RegisterWorkspaceDirectoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterWorkspaceDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterWorkspaceDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterWorkspaceDirectoryInput>
    public typealias MOutput = OperationOutput<RegisterWorkspaceDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterWorkspaceDirectoryOutputError>
}

extension RegisterWorkspaceDirectoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterWorkspaceDirectoryInput(directoryId: \(String(describing: directoryId)), enableSelfService: \(String(describing: enableSelfService)), enableWorkDocs: \(String(describing: enableWorkDocs)), subnetIds: \(String(describing: subnetIds)), tags: \(String(describing: tags)), tenancy: \(String(describing: tenancy)))"}
}

extension RegisterWorkspaceDirectoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case enableSelfService = "EnableSelfService"
        case enableWorkDocs = "EnableWorkDocs"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
        case tenancy = "Tenancy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let enableSelfService = enableSelfService {
            try encodeContainer.encode(enableSelfService, forKey: .enableSelfService)
        }
        if let enableWorkDocs = enableWorkDocs {
            try encodeContainer.encode(enableWorkDocs, forKey: .enableWorkDocs)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let tenancy = tenancy {
            try encodeContainer.encode(tenancy.rawValue, forKey: .tenancy)
        }
    }
}

public struct RegisterWorkspaceDirectoryInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterWorkspaceDirectoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterWorkspaceDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterWorkspaceDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterWorkspaceDirectoryInput>
    public typealias MOutput = OperationOutput<RegisterWorkspaceDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterWorkspaceDirectoryOutputError>
}

public struct RegisterWorkspaceDirectoryInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterWorkspaceDirectoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterWorkspaceDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterWorkspaceDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterWorkspaceDirectoryInput>
    public typealias MOutput = OperationOutput<RegisterWorkspaceDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterWorkspaceDirectoryOutputError>
}

public struct RegisterWorkspaceDirectoryInput: Equatable {
    /// <p>The identifier of the directory. You cannot register a directory if it does not have a status
    ///          of Active. If the directory does not have a status of Active, you will receive an
    ///          InvalidResourceStateException error. If you have already registered the maximum number of directories
    ///          that you can register with Amazon WorkSpaces, you will receive a ResourceLimitExceededException error.
    ///          Deregister directories that you are not using for WorkSpaces, and try again.</p>
    public let directoryId: String?
    /// <p>Indicates whether self-service capabilities are enabled or disabled.</p>
    public let enableSelfService: Bool?
    /// <p>Indicates whether Amazon WorkDocs is enabled or disabled. If you have enabled this parameter and
    ///          WorkDocs is not available in the Region, you will receive an OperationNotSupportedException error. Set
    ///          <code>EnableWorkDocs</code> to disabled, and try again.</p>
    public let enableWorkDocs: Bool?
    /// <p>The identifiers of the subnets for your virtual private cloud (VPC). Make sure that the subnets
    ///          are in supported Availability Zones. The subnets must also be in separate Availability Zones. If these
    ///          conditions are not met, you will receive an OperationNotSupportedException error.</p>
    public let subnetIds: [String]?
    /// <p>The tags associated with the directory.</p>
    public let tags: [Tag]?
    /// <p>Indicates whether your WorkSpace directory is dedicated or shared. To use Bring Your Own
    ///          License (BYOL) images, this value must be set to <code>DEDICATED</code> and your AWS account must be
    ///          enabled for BYOL. If your account has not been enabled for BYOL, you will receive an
    ///          InvalidParameterValuesException error. For more information about BYOL images, see
    ///             <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.html">Bring Your Own Windows Desktop Images</a>.</p>
    public let tenancy: Tenancy?

    public init (
        directoryId: String? = nil,
        enableSelfService: Bool? = nil,
        enableWorkDocs: Bool? = nil,
        subnetIds: [String]? = nil,
        tags: [Tag]? = nil,
        tenancy: Tenancy? = nil
    )
    {
        self.directoryId = directoryId
        self.enableSelfService = enableSelfService
        self.enableWorkDocs = enableWorkDocs
        self.subnetIds = subnetIds
        self.tags = tags
        self.tenancy = tenancy
    }
}

struct RegisterWorkspaceDirectoryInputBody: Equatable {
    public let directoryId: String?
    public let subnetIds: [String]?
    public let enableWorkDocs: Bool?
    public let enableSelfService: Bool?
    public let tenancy: Tenancy?
    public let tags: [Tag]?
}

extension RegisterWorkspaceDirectoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case enableSelfService = "EnableSelfService"
        case enableWorkDocs = "EnableWorkDocs"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
        case tenancy = "Tenancy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let enableWorkDocsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableWorkDocs)
        enableWorkDocs = enableWorkDocsDecoded
        let enableSelfServiceDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableSelfService)
        enableSelfService = enableSelfServiceDecoded
        let tenancyDecoded = try containerValues.decodeIfPresent(Tenancy.self, forKey: .tenancy)
        tenancy = tenancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension RegisterWorkspaceDirectoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterWorkspaceDirectoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedNetworkConfigurationException" : self = .unsupportedNetworkConfigurationException(try UnsupportedNetworkConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WorkspacesDefaultRoleNotFoundException" : self = .workspacesDefaultRoleNotFoundException(try WorkspacesDefaultRoleNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterWorkspaceDirectoryOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedNetworkConfigurationException(UnsupportedNetworkConfigurationException)
    case workspacesDefaultRoleNotFoundException(WorkspacesDefaultRoleNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterWorkspaceDirectoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterWorkspaceDirectoryOutputResponse()"}
}

extension RegisterWorkspaceDirectoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RegisterWorkspaceDirectoryOutputResponse: Equatable {

    public init() {}
}

struct RegisterWorkspaceDirectoryOutputResponseBody: Equatable {
}

extension RegisterWorkspaceDirectoryOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ResourceAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceAlreadyExistsException(message: \(String(describing: message)))"}
}

extension ResourceAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource already exists.</p>
public struct ResourceAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension ResourceAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceAssociatedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceAssociatedException(message: \(String(describing: message)))"}
}

extension ResourceAssociatedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceAssociatedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource is associated with a directory.</p>
public struct ResourceAssociatedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAssociatedExceptionBody: Equatable {
    public let message: String?
}

extension ResourceAssociatedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceCreationFailedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceCreationFailedException(message: \(String(describing: message)))"}
}

extension ResourceCreationFailedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceCreationFailedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource could not be created.</p>
public struct ResourceCreationFailedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceCreationFailedExceptionBody: Equatable {
    public let message: String?
}

extension ResourceCreationFailedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceLimitExceededException(message: \(String(describing: message)))"}
}

extension ResourceLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your resource limits have been exceeded.</p>
public struct ResourceLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The exception error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension ResourceLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(resourceId: \(String(describing: resourceId)), message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceId = output.resourceId
        } else {
            self.resourceId = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource could not be found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The resource could not be found.</p>
    public var message: String?
    /// <p>The ID of the resource that could not be found.</p>
    public var resourceId: String?

    public init (
        message: String? = nil,
        resourceId: String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension ResourceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceUnavailableException(resourceId: \(String(describing: resourceId)), message: \(String(describing: message)))"}
}

extension ResourceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceId = output.resourceId
        } else {
            self.resourceId = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource is not available.</p>
public struct ResourceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The exception error message.</p>
    public var message: String?
    /// <p>The identifier of the resource that is not available.</p>
    public var resourceId: String?

    public init (
        message: String? = nil,
        resourceId: String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
    }
}

struct ResourceUnavailableExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
}

extension ResourceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

public struct RestoreWorkspaceInputBodyMiddleware: Middleware {
    public let id: String = "RestoreWorkspaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreWorkspaceInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreWorkspaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreWorkspaceInput>
    public typealias MOutput = OperationOutput<RestoreWorkspaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreWorkspaceOutputError>
}

extension RestoreWorkspaceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreWorkspaceInput(workspaceId: \(String(describing: workspaceId)))"}
}

extension RestoreWorkspaceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }
}

public struct RestoreWorkspaceInputHeadersMiddleware: Middleware {
    public let id: String = "RestoreWorkspaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreWorkspaceInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreWorkspaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreWorkspaceInput>
    public typealias MOutput = OperationOutput<RestoreWorkspaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreWorkspaceOutputError>
}

public struct RestoreWorkspaceInputQueryItemMiddleware: Middleware {
    public let id: String = "RestoreWorkspaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreWorkspaceInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreWorkspaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreWorkspaceInput>
    public typealias MOutput = OperationOutput<RestoreWorkspaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreWorkspaceOutputError>
}

public struct RestoreWorkspaceInput: Equatable {
    /// <p>The identifier of the WorkSpace.</p>
    public let workspaceId: String?

    public init (
        workspaceId: String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

struct RestoreWorkspaceInputBody: Equatable {
    public let workspaceId: String?
}

extension RestoreWorkspaceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

extension RestoreWorkspaceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RestoreWorkspaceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreWorkspaceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreWorkspaceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreWorkspaceOutputResponse()"}
}

extension RestoreWorkspaceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RestoreWorkspaceOutputResponse: Equatable {

    public init() {}
}

struct RestoreWorkspaceOutputResponseBody: Equatable {
}

extension RestoreWorkspaceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct RevokeIpRulesInputBodyMiddleware: Middleware {
    public let id: String = "RevokeIpRulesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeIpRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeIpRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeIpRulesInput>
    public typealias MOutput = OperationOutput<RevokeIpRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeIpRulesOutputError>
}

extension RevokeIpRulesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevokeIpRulesInput(groupId: \(String(describing: groupId)), userRules: \(String(describing: userRules)))"}
}

extension RevokeIpRulesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupId = "GroupId"
        case userRules = "UserRules"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let userRules = userRules {
            var userRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userRules)
            for iprevokedrulelist0 in userRules {
                try userRulesContainer.encode(iprevokedrulelist0)
            }
        }
    }
}

public struct RevokeIpRulesInputHeadersMiddleware: Middleware {
    public let id: String = "RevokeIpRulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeIpRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeIpRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeIpRulesInput>
    public typealias MOutput = OperationOutput<RevokeIpRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeIpRulesOutputError>
}

public struct RevokeIpRulesInputQueryItemMiddleware: Middleware {
    public let id: String = "RevokeIpRulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeIpRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeIpRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeIpRulesInput>
    public typealias MOutput = OperationOutput<RevokeIpRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeIpRulesOutputError>
}

public struct RevokeIpRulesInput: Equatable {
    /// <p>The identifier of the group.</p>
    public let groupId: String?
    /// <p>The rules to remove from the group.</p>
    public let userRules: [String]?

    public init (
        groupId: String? = nil,
        userRules: [String]? = nil
    )
    {
        self.groupId = groupId
        self.userRules = userRules
    }
}

struct RevokeIpRulesInputBody: Equatable {
    public let groupId: String?
    public let userRules: [String]?
}

extension RevokeIpRulesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupId = "GroupId"
        case userRules = "UserRules"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let userRulesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .userRules)
        var userRulesDecoded0:[String]? = nil
        if let userRulesContainer = userRulesContainer {
            userRulesDecoded0 = [String]()
            for string0 in userRulesContainer {
                if let string0 = string0 {
                    userRulesDecoded0?.append(string0)
                }
            }
        }
        userRules = userRulesDecoded0
    }
}

extension RevokeIpRulesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RevokeIpRulesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RevokeIpRulesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RevokeIpRulesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevokeIpRulesOutputResponse()"}
}

extension RevokeIpRulesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RevokeIpRulesOutputResponse: Equatable {

    public init() {}
}

struct RevokeIpRulesOutputResponseBody: Equatable {
}

extension RevokeIpRulesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RootStorage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case capacity = "Capacity"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacity = capacity {
            try encodeContainer.encode(capacity, forKey: .capacity)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .capacity)
        capacity = capacityDecoded
    }
}

extension RootStorage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RootStorage(capacity: \(String(describing: capacity)))"}
}

/// <p>Describes the root volume for a WorkSpace bundle.</p>
public struct RootStorage: Equatable {
    /// <p>The size of the root volume.</p>
    public let capacity: String?

    public init (
        capacity: String? = nil
    )
    {
        self.capacity = capacity
    }
}

public enum RunningMode {
    case alwaysOn
    case autoStop
    case sdkUnknown(String)
}

extension RunningMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RunningMode] {
        return [
            .alwaysOn,
            .autoStop,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .alwaysOn: return "ALWAYS_ON"
        case .autoStop: return "AUTO_STOP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RunningMode(rawValue: rawValue) ?? RunningMode.sdkUnknown(rawValue)
    }
}

extension SelfservicePermissions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeComputeType = "ChangeComputeType"
        case increaseVolumeSize = "IncreaseVolumeSize"
        case rebuildWorkspace = "RebuildWorkspace"
        case restartWorkspace = "RestartWorkspace"
        case switchRunningMode = "SwitchRunningMode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeComputeType = changeComputeType {
            try encodeContainer.encode(changeComputeType.rawValue, forKey: .changeComputeType)
        }
        if let increaseVolumeSize = increaseVolumeSize {
            try encodeContainer.encode(increaseVolumeSize.rawValue, forKey: .increaseVolumeSize)
        }
        if let rebuildWorkspace = rebuildWorkspace {
            try encodeContainer.encode(rebuildWorkspace.rawValue, forKey: .rebuildWorkspace)
        }
        if let restartWorkspace = restartWorkspace {
            try encodeContainer.encode(restartWorkspace.rawValue, forKey: .restartWorkspace)
        }
        if let switchRunningMode = switchRunningMode {
            try encodeContainer.encode(switchRunningMode.rawValue, forKey: .switchRunningMode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let restartWorkspaceDecoded = try containerValues.decodeIfPresent(ReconnectEnum.self, forKey: .restartWorkspace)
        restartWorkspace = restartWorkspaceDecoded
        let increaseVolumeSizeDecoded = try containerValues.decodeIfPresent(ReconnectEnum.self, forKey: .increaseVolumeSize)
        increaseVolumeSize = increaseVolumeSizeDecoded
        let changeComputeTypeDecoded = try containerValues.decodeIfPresent(ReconnectEnum.self, forKey: .changeComputeType)
        changeComputeType = changeComputeTypeDecoded
        let switchRunningModeDecoded = try containerValues.decodeIfPresent(ReconnectEnum.self, forKey: .switchRunningMode)
        switchRunningMode = switchRunningModeDecoded
        let rebuildWorkspaceDecoded = try containerValues.decodeIfPresent(ReconnectEnum.self, forKey: .rebuildWorkspace)
        rebuildWorkspace = rebuildWorkspaceDecoded
    }
}

extension SelfservicePermissions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SelfservicePermissions(changeComputeType: \(String(describing: changeComputeType)), increaseVolumeSize: \(String(describing: increaseVolumeSize)), rebuildWorkspace: \(String(describing: rebuildWorkspace)), restartWorkspace: \(String(describing: restartWorkspace)), switchRunningMode: \(String(describing: switchRunningMode)))"}
}

/// <p>Describes the self-service permissions for a directory. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/enable-user-self-service-workspace-management.html">Enable Self-Service WorkSpace Management Capabilities for Your Users</a>.</p>
public struct SelfservicePermissions: Equatable {
    /// <p>Specifies whether users can change the compute type (bundle) for their WorkSpace.</p>
    public let changeComputeType: ReconnectEnum?
    /// <p>Specifies whether users can increase the volume size of the drives on their
    ///          WorkSpace.</p>
    public let increaseVolumeSize: ReconnectEnum?
    /// <p>Specifies whether users can rebuild the operating system of a WorkSpace to its original
    ///          state.</p>
    public let rebuildWorkspace: ReconnectEnum?
    /// <p>Specifies whether users can restart their WorkSpace.</p>
    public let restartWorkspace: ReconnectEnum?
    /// <p>Specifies whether users can switch the running mode of their WorkSpace.</p>
    public let switchRunningMode: ReconnectEnum?

    public init (
        changeComputeType: ReconnectEnum? = nil,
        increaseVolumeSize: ReconnectEnum? = nil,
        rebuildWorkspace: ReconnectEnum? = nil,
        restartWorkspace: ReconnectEnum? = nil,
        switchRunningMode: ReconnectEnum? = nil
    )
    {
        self.changeComputeType = changeComputeType
        self.increaseVolumeSize = increaseVolumeSize
        self.rebuildWorkspace = rebuildWorkspace
        self.restartWorkspace = restartWorkspace
        self.switchRunningMode = switchRunningMode
    }
}

extension Snapshot: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case snapshotTime = "SnapshotTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snapshotTime = snapshotTime {
            try encodeContainer.encode(snapshotTime.timeIntervalSince1970, forKey: .snapshotTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .snapshotTime)
        snapshotTime = snapshotTimeDecoded
    }
}

extension Snapshot: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Snapshot(snapshotTime: \(String(describing: snapshotTime)))"}
}

/// <p>Describes a snapshot.</p>
public struct Snapshot: Equatable {
    /// <p>The time when the snapshot was created.</p>
    public let snapshotTime: Date?

    public init (
        snapshotTime: Date? = nil
    )
    {
        self.snapshotTime = snapshotTime
    }
}

extension StartRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

extension StartRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartRequest(workspaceId: \(String(describing: workspaceId)))"}
}

/// <p>Information used to start a WorkSpace.</p>
public struct StartRequest: Equatable {
    /// <p>The identifier of the WorkSpace.</p>
    public let workspaceId: String?

    public init (
        workspaceId: String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

public struct StartWorkspacesInputBodyMiddleware: Middleware {
    public let id: String = "StartWorkspacesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartWorkspacesInput>,
                  next: H) -> Swift.Result<OperationOutput<StartWorkspacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartWorkspacesInput>
    public typealias MOutput = OperationOutput<StartWorkspacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartWorkspacesOutputError>
}

extension StartWorkspacesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartWorkspacesInput(startWorkspaceRequests: \(String(describing: startWorkspaceRequests)))"}
}

extension StartWorkspacesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case startWorkspaceRequests = "StartWorkspaceRequests"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let startWorkspaceRequests = startWorkspaceRequests {
            var startWorkspaceRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startWorkspaceRequests)
            for startworkspacerequests0 in startWorkspaceRequests {
                try startWorkspaceRequestsContainer.encode(startworkspacerequests0)
            }
        }
    }
}

public struct StartWorkspacesInputHeadersMiddleware: Middleware {
    public let id: String = "StartWorkspacesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartWorkspacesInput>,
                  next: H) -> Swift.Result<OperationOutput<StartWorkspacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartWorkspacesInput>
    public typealias MOutput = OperationOutput<StartWorkspacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartWorkspacesOutputError>
}

public struct StartWorkspacesInputQueryItemMiddleware: Middleware {
    public let id: String = "StartWorkspacesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartWorkspacesInput>,
                  next: H) -> Swift.Result<OperationOutput<StartWorkspacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartWorkspacesInput>
    public typealias MOutput = OperationOutput<StartWorkspacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartWorkspacesOutputError>
}

public struct StartWorkspacesInput: Equatable {
    /// <p>The WorkSpaces to start. You can specify up to 25 WorkSpaces.</p>
    public let startWorkspaceRequests: [StartRequest]?

    public init (
        startWorkspaceRequests: [StartRequest]? = nil
    )
    {
        self.startWorkspaceRequests = startWorkspaceRequests
    }
}

struct StartWorkspacesInputBody: Equatable {
    public let startWorkspaceRequests: [StartRequest]?
}

extension StartWorkspacesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case startWorkspaceRequests = "StartWorkspaceRequests"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startWorkspaceRequestsContainer = try containerValues.decodeIfPresent([StartRequest?].self, forKey: .startWorkspaceRequests)
        var startWorkspaceRequestsDecoded0:[StartRequest]? = nil
        if let startWorkspaceRequestsContainer = startWorkspaceRequestsContainer {
            startWorkspaceRequestsDecoded0 = [StartRequest]()
            for structure0 in startWorkspaceRequestsContainer {
                if let structure0 = structure0 {
                    startWorkspaceRequestsDecoded0?.append(structure0)
                }
            }
        }
        startWorkspaceRequests = startWorkspaceRequestsDecoded0
    }
}

extension StartWorkspacesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartWorkspacesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartWorkspacesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension StartWorkspacesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartWorkspacesOutputResponse(failedRequests: \(String(describing: failedRequests)))"}
}

extension StartWorkspacesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartWorkspacesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedRequests = output.failedRequests
        } else {
            self.failedRequests = nil
        }
    }
}

public struct StartWorkspacesOutputResponse: Equatable {
    /// <p>Information about the WorkSpaces that could not be started.</p>
    public let failedRequests: [FailedWorkspaceChangeRequest]?

    public init (
        failedRequests: [FailedWorkspaceChangeRequest]? = nil
    )
    {
        self.failedRequests = failedRequests
    }
}

struct StartWorkspacesOutputResponseBody: Equatable {
    public let failedRequests: [FailedWorkspaceChangeRequest]?
}

extension StartWorkspacesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedRequests = "FailedRequests"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedRequestsContainer = try containerValues.decodeIfPresent([FailedWorkspaceChangeRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[FailedWorkspaceChangeRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [FailedWorkspaceChangeRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
    }
}

extension StopRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

extension StopRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopRequest(workspaceId: \(String(describing: workspaceId)))"}
}

/// <p>Describes the information used to stop a WorkSpace.</p>
public struct StopRequest: Equatable {
    /// <p>The identifier of the WorkSpace.</p>
    public let workspaceId: String?

    public init (
        workspaceId: String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

public struct StopWorkspacesInputBodyMiddleware: Middleware {
    public let id: String = "StopWorkspacesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopWorkspacesInput>,
                  next: H) -> Swift.Result<OperationOutput<StopWorkspacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopWorkspacesInput>
    public typealias MOutput = OperationOutput<StopWorkspacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopWorkspacesOutputError>
}

extension StopWorkspacesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopWorkspacesInput(stopWorkspaceRequests: \(String(describing: stopWorkspaceRequests)))"}
}

extension StopWorkspacesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case stopWorkspaceRequests = "StopWorkspaceRequests"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stopWorkspaceRequests = stopWorkspaceRequests {
            var stopWorkspaceRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stopWorkspaceRequests)
            for stopworkspacerequests0 in stopWorkspaceRequests {
                try stopWorkspaceRequestsContainer.encode(stopworkspacerequests0)
            }
        }
    }
}

public struct StopWorkspacesInputHeadersMiddleware: Middleware {
    public let id: String = "StopWorkspacesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopWorkspacesInput>,
                  next: H) -> Swift.Result<OperationOutput<StopWorkspacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopWorkspacesInput>
    public typealias MOutput = OperationOutput<StopWorkspacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopWorkspacesOutputError>
}

public struct StopWorkspacesInputQueryItemMiddleware: Middleware {
    public let id: String = "StopWorkspacesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopWorkspacesInput>,
                  next: H) -> Swift.Result<OperationOutput<StopWorkspacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopWorkspacesInput>
    public typealias MOutput = OperationOutput<StopWorkspacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopWorkspacesOutputError>
}

public struct StopWorkspacesInput: Equatable {
    /// <p>The WorkSpaces to stop. You can specify up to 25 WorkSpaces.</p>
    public let stopWorkspaceRequests: [StopRequest]?

    public init (
        stopWorkspaceRequests: [StopRequest]? = nil
    )
    {
        self.stopWorkspaceRequests = stopWorkspaceRequests
    }
}

struct StopWorkspacesInputBody: Equatable {
    public let stopWorkspaceRequests: [StopRequest]?
}

extension StopWorkspacesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stopWorkspaceRequests = "StopWorkspaceRequests"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stopWorkspaceRequestsContainer = try containerValues.decodeIfPresent([StopRequest?].self, forKey: .stopWorkspaceRequests)
        var stopWorkspaceRequestsDecoded0:[StopRequest]? = nil
        if let stopWorkspaceRequestsContainer = stopWorkspaceRequestsContainer {
            stopWorkspaceRequestsDecoded0 = [StopRequest]()
            for structure0 in stopWorkspaceRequestsContainer {
                if let structure0 = structure0 {
                    stopWorkspaceRequestsDecoded0?.append(structure0)
                }
            }
        }
        stopWorkspaceRequests = stopWorkspaceRequestsDecoded0
    }
}

extension StopWorkspacesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopWorkspacesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopWorkspacesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension StopWorkspacesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopWorkspacesOutputResponse(failedRequests: \(String(describing: failedRequests)))"}
}

extension StopWorkspacesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopWorkspacesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedRequests = output.failedRequests
        } else {
            self.failedRequests = nil
        }
    }
}

public struct StopWorkspacesOutputResponse: Equatable {
    /// <p>Information about the WorkSpaces that could not be stopped.</p>
    public let failedRequests: [FailedWorkspaceChangeRequest]?

    public init (
        failedRequests: [FailedWorkspaceChangeRequest]? = nil
    )
    {
        self.failedRequests = failedRequests
    }
}

struct StopWorkspacesOutputResponseBody: Equatable {
    public let failedRequests: [FailedWorkspaceChangeRequest]?
}

extension StopWorkspacesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedRequests = "FailedRequests"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedRequestsContainer = try containerValues.decodeIfPresent([FailedWorkspaceChangeRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[FailedWorkspaceChangeRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [FailedWorkspaceChangeRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Describes a tag.</p>
public struct Tag: Equatable {
    /// <p>The key of the tag.</p>
    public let key: String?
    /// <p>The value of the tag.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public enum TargetWorkspaceState {
    case adminMaintenance
    case available
    case sdkUnknown(String)
}

extension TargetWorkspaceState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TargetWorkspaceState] {
        return [
            .adminMaintenance,
            .available,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .adminMaintenance: return "ADMIN_MAINTENANCE"
        case .available: return "AVAILABLE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TargetWorkspaceState(rawValue: rawValue) ?? TargetWorkspaceState.sdkUnknown(rawValue)
    }
}

public enum Tenancy {
    case dedicated
    case shared
    case sdkUnknown(String)
}

extension Tenancy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Tenancy] {
        return [
            .dedicated,
            .shared,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dedicated: return "DEDICATED"
        case .shared: return "SHARED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Tenancy(rawValue: rawValue) ?? Tenancy.sdkUnknown(rawValue)
    }
}

extension TerminateRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

extension TerminateRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TerminateRequest(workspaceId: \(String(describing: workspaceId)))"}
}

/// <p>Describes the information used to terminate a WorkSpace.</p>
public struct TerminateRequest: Equatable {
    /// <p>The identifier of the WorkSpace.</p>
    public let workspaceId: String?

    public init (
        workspaceId: String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

public struct TerminateWorkspacesInputBodyMiddleware: Middleware {
    public let id: String = "TerminateWorkspacesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TerminateWorkspacesInput>,
                  next: H) -> Swift.Result<OperationOutput<TerminateWorkspacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TerminateWorkspacesInput>
    public typealias MOutput = OperationOutput<TerminateWorkspacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TerminateWorkspacesOutputError>
}

extension TerminateWorkspacesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TerminateWorkspacesInput(terminateWorkspaceRequests: \(String(describing: terminateWorkspaceRequests)))"}
}

extension TerminateWorkspacesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case terminateWorkspaceRequests = "TerminateWorkspaceRequests"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let terminateWorkspaceRequests = terminateWorkspaceRequests {
            var terminateWorkspaceRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .terminateWorkspaceRequests)
            for terminateworkspacerequests0 in terminateWorkspaceRequests {
                try terminateWorkspaceRequestsContainer.encode(terminateworkspacerequests0)
            }
        }
    }
}

public struct TerminateWorkspacesInputHeadersMiddleware: Middleware {
    public let id: String = "TerminateWorkspacesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TerminateWorkspacesInput>,
                  next: H) -> Swift.Result<OperationOutput<TerminateWorkspacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TerminateWorkspacesInput>
    public typealias MOutput = OperationOutput<TerminateWorkspacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TerminateWorkspacesOutputError>
}

public struct TerminateWorkspacesInputQueryItemMiddleware: Middleware {
    public let id: String = "TerminateWorkspacesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TerminateWorkspacesInput>,
                  next: H) -> Swift.Result<OperationOutput<TerminateWorkspacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TerminateWorkspacesInput>
    public typealias MOutput = OperationOutput<TerminateWorkspacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TerminateWorkspacesOutputError>
}

public struct TerminateWorkspacesInput: Equatable {
    /// <p>The WorkSpaces to terminate. You can specify up to 25 WorkSpaces.</p>
    public let terminateWorkspaceRequests: [TerminateRequest]?

    public init (
        terminateWorkspaceRequests: [TerminateRequest]? = nil
    )
    {
        self.terminateWorkspaceRequests = terminateWorkspaceRequests
    }
}

struct TerminateWorkspacesInputBody: Equatable {
    public let terminateWorkspaceRequests: [TerminateRequest]?
}

extension TerminateWorkspacesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case terminateWorkspaceRequests = "TerminateWorkspaceRequests"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminateWorkspaceRequestsContainer = try containerValues.decodeIfPresent([TerminateRequest?].self, forKey: .terminateWorkspaceRequests)
        var terminateWorkspaceRequestsDecoded0:[TerminateRequest]? = nil
        if let terminateWorkspaceRequestsContainer = terminateWorkspaceRequestsContainer {
            terminateWorkspaceRequestsDecoded0 = [TerminateRequest]()
            for structure0 in terminateWorkspaceRequestsContainer {
                if let structure0 = structure0 {
                    terminateWorkspaceRequestsDecoded0?.append(structure0)
                }
            }
        }
        terminateWorkspaceRequests = terminateWorkspaceRequestsDecoded0
    }
}

extension TerminateWorkspacesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TerminateWorkspacesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TerminateWorkspacesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension TerminateWorkspacesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TerminateWorkspacesOutputResponse(failedRequests: \(String(describing: failedRequests)))"}
}

extension TerminateWorkspacesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TerminateWorkspacesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedRequests = output.failedRequests
        } else {
            self.failedRequests = nil
        }
    }
}

public struct TerminateWorkspacesOutputResponse: Equatable {
    /// <p>Information about the WorkSpaces that could not be terminated.</p>
    public let failedRequests: [FailedWorkspaceChangeRequest]?

    public init (
        failedRequests: [FailedWorkspaceChangeRequest]? = nil
    )
    {
        self.failedRequests = failedRequests
    }
}

struct TerminateWorkspacesOutputResponseBody: Equatable {
    public let failedRequests: [FailedWorkspaceChangeRequest]?
}

extension TerminateWorkspacesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedRequests = "FailedRequests"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedRequestsContainer = try containerValues.decodeIfPresent([FailedWorkspaceChangeRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[FailedWorkspaceChangeRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [FailedWorkspaceChangeRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
    }
}

extension UnsupportedNetworkConfigurationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedNetworkConfigurationException(message: \(String(describing: message)))"}
}

extension UnsupportedNetworkConfigurationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedNetworkConfigurationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The configuration of this network is not supported for this operation, or your network configuration
///          conflicts with the Amazon WorkSpaces management network IP range. For more information, see
///          <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/amazon-workspaces-vpc.html">
///             Configure a VPC for Amazon WorkSpaces</a>.</p>
public struct UnsupportedNetworkConfigurationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedNetworkConfigurationExceptionBody: Equatable {
    public let message: String?
}

extension UnsupportedNetworkConfigurationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedWorkspaceConfigurationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedWorkspaceConfigurationException(message: \(String(describing: message)))"}
}

extension UnsupportedWorkspaceConfigurationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedWorkspaceConfigurationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The configuration of this WorkSpace is not supported for this operation. For more information, see
///          <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/required-service-components.html">Required
///             Configuration and Service Components for WorkSpaces </a>.</p>
public struct UnsupportedWorkspaceConfigurationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedWorkspaceConfigurationExceptionBody: Equatable {
    public let message: String?
}

extension UnsupportedWorkspaceConfigurationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UpdateConnectionAliasPermissionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateConnectionAliasPermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConnectionAliasPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConnectionAliasPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConnectionAliasPermissionInput>
    public typealias MOutput = OperationOutput<UpdateConnectionAliasPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConnectionAliasPermissionOutputError>
}

extension UpdateConnectionAliasPermissionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConnectionAliasPermissionInput(aliasId: \(String(describing: aliasId)), connectionAliasPermission: \(String(describing: connectionAliasPermission)))"}
}

extension UpdateConnectionAliasPermissionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aliasId = "AliasId"
        case connectionAliasPermission = "ConnectionAliasPermission"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasId = aliasId {
            try encodeContainer.encode(aliasId, forKey: .aliasId)
        }
        if let connectionAliasPermission = connectionAliasPermission {
            try encodeContainer.encode(connectionAliasPermission, forKey: .connectionAliasPermission)
        }
    }
}

public struct UpdateConnectionAliasPermissionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateConnectionAliasPermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConnectionAliasPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConnectionAliasPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConnectionAliasPermissionInput>
    public typealias MOutput = OperationOutput<UpdateConnectionAliasPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConnectionAliasPermissionOutputError>
}

public struct UpdateConnectionAliasPermissionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateConnectionAliasPermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConnectionAliasPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConnectionAliasPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConnectionAliasPermissionInput>
    public typealias MOutput = OperationOutput<UpdateConnectionAliasPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConnectionAliasPermissionOutputError>
}

public struct UpdateConnectionAliasPermissionInput: Equatable {
    /// <p>The identifier of the connection alias that you want to update permissions for.</p>
    public let aliasId: String?
    /// <p>Indicates whether to share or unshare the connection alias with the specified AWS account.</p>
    public let connectionAliasPermission: ConnectionAliasPermission?

    public init (
        aliasId: String? = nil,
        connectionAliasPermission: ConnectionAliasPermission? = nil
    )
    {
        self.aliasId = aliasId
        self.connectionAliasPermission = connectionAliasPermission
    }
}

struct UpdateConnectionAliasPermissionInputBody: Equatable {
    public let aliasId: String?
    public let connectionAliasPermission: ConnectionAliasPermission?
}

extension UpdateConnectionAliasPermissionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aliasId = "AliasId"
        case connectionAliasPermission = "ConnectionAliasPermission"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
        let connectionAliasPermissionDecoded = try containerValues.decodeIfPresent(ConnectionAliasPermission.self, forKey: .connectionAliasPermission)
        connectionAliasPermission = connectionAliasPermissionDecoded
    }
}

extension UpdateConnectionAliasPermissionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConnectionAliasPermissionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAssociatedException" : self = .resourceAssociatedException(try ResourceAssociatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConnectionAliasPermissionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceAssociatedException(ResourceAssociatedException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConnectionAliasPermissionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConnectionAliasPermissionOutputResponse()"}
}

extension UpdateConnectionAliasPermissionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateConnectionAliasPermissionOutputResponse: Equatable {

    public init() {}
}

struct UpdateConnectionAliasPermissionOutputResponseBody: Equatable {
}

extension UpdateConnectionAliasPermissionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateRulesOfIpGroupInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRulesOfIpGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRulesOfIpGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRulesOfIpGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRulesOfIpGroupInput>
    public typealias MOutput = OperationOutput<UpdateRulesOfIpGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRulesOfIpGroupOutputError>
}

extension UpdateRulesOfIpGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRulesOfIpGroupInput(groupId: \(String(describing: groupId)), userRules: \(String(describing: userRules)))"}
}

extension UpdateRulesOfIpGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupId = "GroupId"
        case userRules = "UserRules"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let userRules = userRules {
            var userRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userRules)
            for iprulelist0 in userRules {
                try userRulesContainer.encode(iprulelist0)
            }
        }
    }
}

public struct UpdateRulesOfIpGroupInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRulesOfIpGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRulesOfIpGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRulesOfIpGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRulesOfIpGroupInput>
    public typealias MOutput = OperationOutput<UpdateRulesOfIpGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRulesOfIpGroupOutputError>
}

public struct UpdateRulesOfIpGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRulesOfIpGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRulesOfIpGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRulesOfIpGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRulesOfIpGroupInput>
    public typealias MOutput = OperationOutput<UpdateRulesOfIpGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRulesOfIpGroupOutputError>
}

public struct UpdateRulesOfIpGroupInput: Equatable {
    /// <p>The identifier of the group.</p>
    public let groupId: String?
    /// <p>One or more rules.</p>
    public let userRules: [IpRuleItem]?

    public init (
        groupId: String? = nil,
        userRules: [IpRuleItem]? = nil
    )
    {
        self.groupId = groupId
        self.userRules = userRules
    }
}

struct UpdateRulesOfIpGroupInputBody: Equatable {
    public let groupId: String?
    public let userRules: [IpRuleItem]?
}

extension UpdateRulesOfIpGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupId = "GroupId"
        case userRules = "UserRules"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let userRulesContainer = try containerValues.decodeIfPresent([IpRuleItem?].self, forKey: .userRules)
        var userRulesDecoded0:[IpRuleItem]? = nil
        if let userRulesContainer = userRulesContainer {
            userRulesDecoded0 = [IpRuleItem]()
            for structure0 in userRulesContainer {
                if let structure0 = structure0 {
                    userRulesDecoded0?.append(structure0)
                }
            }
        }
        userRules = userRulesDecoded0
    }
}

extension UpdateRulesOfIpGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRulesOfIpGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRulesOfIpGroupOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRulesOfIpGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRulesOfIpGroupOutputResponse()"}
}

extension UpdateRulesOfIpGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRulesOfIpGroupOutputResponse: Equatable {

    public init() {}
}

struct UpdateRulesOfIpGroupOutputResponseBody: Equatable {
}

extension UpdateRulesOfIpGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateWorkspaceBundleInputBodyMiddleware: Middleware {
    public let id: String = "UpdateWorkspaceBundleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWorkspaceBundleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWorkspaceBundleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWorkspaceBundleInput>
    public typealias MOutput = OperationOutput<UpdateWorkspaceBundleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWorkspaceBundleOutputError>
}

extension UpdateWorkspaceBundleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateWorkspaceBundleInput(bundleId: \(String(describing: bundleId)), imageId: \(String(describing: imageId)))"}
}

extension UpdateWorkspaceBundleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bundleId = "BundleId"
        case imageId = "ImageId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
    }
}

public struct UpdateWorkspaceBundleInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateWorkspaceBundleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWorkspaceBundleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWorkspaceBundleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWorkspaceBundleInput>
    public typealias MOutput = OperationOutput<UpdateWorkspaceBundleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWorkspaceBundleOutputError>
}

public struct UpdateWorkspaceBundleInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateWorkspaceBundleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWorkspaceBundleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWorkspaceBundleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWorkspaceBundleInput>
    public typealias MOutput = OperationOutput<UpdateWorkspaceBundleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWorkspaceBundleOutputError>
}

public struct UpdateWorkspaceBundleInput: Equatable {
    /// <p>The identifier of the bundle.</p>
    public let bundleId: String?
    /// <p>The identifier of the image.</p>
    public let imageId: String?

    public init (
        bundleId: String? = nil,
        imageId: String? = nil
    )
    {
        self.bundleId = bundleId
        self.imageId = imageId
    }
}

struct UpdateWorkspaceBundleInputBody: Equatable {
    public let bundleId: String?
    public let imageId: String?
}

extension UpdateWorkspaceBundleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bundleId = "BundleId"
        case imageId = "ImageId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageId)
        imageId = imageIdDecoded
    }
}

extension UpdateWorkspaceBundleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWorkspaceBundleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateWorkspaceBundleOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWorkspaceBundleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateWorkspaceBundleOutputResponse()"}
}

extension UpdateWorkspaceBundleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateWorkspaceBundleOutputResponse: Equatable {

    public init() {}
}

struct UpdateWorkspaceBundleOutputResponseBody: Equatable {
}

extension UpdateWorkspaceBundleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateWorkspaceImagePermissionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateWorkspaceImagePermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWorkspaceImagePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWorkspaceImagePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWorkspaceImagePermissionInput>
    public typealias MOutput = OperationOutput<UpdateWorkspaceImagePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWorkspaceImagePermissionOutputError>
}

extension UpdateWorkspaceImagePermissionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateWorkspaceImagePermissionInput(allowCopyImage: \(String(describing: allowCopyImage)), imageId: \(String(describing: imageId)), sharedAccountId: \(String(describing: sharedAccountId)))"}
}

extension UpdateWorkspaceImagePermissionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowCopyImage = "AllowCopyImage"
        case imageId = "ImageId"
        case sharedAccountId = "SharedAccountId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowCopyImage = allowCopyImage {
            try encodeContainer.encode(allowCopyImage, forKey: .allowCopyImage)
        }
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let sharedAccountId = sharedAccountId {
            try encodeContainer.encode(sharedAccountId, forKey: .sharedAccountId)
        }
    }
}

public struct UpdateWorkspaceImagePermissionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateWorkspaceImagePermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWorkspaceImagePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWorkspaceImagePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWorkspaceImagePermissionInput>
    public typealias MOutput = OperationOutput<UpdateWorkspaceImagePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWorkspaceImagePermissionOutputError>
}

public struct UpdateWorkspaceImagePermissionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateWorkspaceImagePermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWorkspaceImagePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWorkspaceImagePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWorkspaceImagePermissionInput>
    public typealias MOutput = OperationOutput<UpdateWorkspaceImagePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWorkspaceImagePermissionOutputError>
}

public struct UpdateWorkspaceImagePermissionInput: Equatable {
    /// <p>The permission to copy the image. This permission can be revoked only after an image
    ///       has been shared.</p>
    public let allowCopyImage: Bool?
    /// <p>The identifier of the image.</p>
    public let imageId: String?
    /// <p>The identifier of the AWS account to share or unshare the image with.</p>
    ///
    ///          <important>
    ///             <p>Before sharing the image, confirm that you are sharing to the correct AWS account ID.</p>
    ///          </important>
    public let sharedAccountId: String?

    public init (
        allowCopyImage: Bool? = nil,
        imageId: String? = nil,
        sharedAccountId: String? = nil
    )
    {
        self.allowCopyImage = allowCopyImage
        self.imageId = imageId
        self.sharedAccountId = sharedAccountId
    }
}

struct UpdateWorkspaceImagePermissionInputBody: Equatable {
    public let imageId: String?
    public let allowCopyImage: Bool?
    public let sharedAccountId: String?
}

extension UpdateWorkspaceImagePermissionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allowCopyImage = "AllowCopyImage"
        case imageId = "ImageId"
        case sharedAccountId = "SharedAccountId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let allowCopyImageDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowCopyImage)
        allowCopyImage = allowCopyImageDecoded
        let sharedAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sharedAccountId)
        sharedAccountId = sharedAccountIdDecoded
    }
}

extension UpdateWorkspaceImagePermissionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWorkspaceImagePermissionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateWorkspaceImagePermissionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWorkspaceImagePermissionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateWorkspaceImagePermissionOutputResponse()"}
}

extension UpdateWorkspaceImagePermissionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateWorkspaceImagePermissionOutputResponse: Equatable {

    public init() {}
}

struct UpdateWorkspaceImagePermissionOutputResponseBody: Equatable {
}

extension UpdateWorkspaceImagePermissionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UserStorage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case capacity = "Capacity"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacity = capacity {
            try encodeContainer.encode(capacity, forKey: .capacity)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .capacity)
        capacity = capacityDecoded
    }
}

extension UserStorage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserStorage(capacity: \(String(describing: capacity)))"}
}

/// <p>Describes the user volume for a WorkSpace bundle.</p>
public struct UserStorage: Equatable {
    /// <p>The size of the user volume.</p>
    public let capacity: String?

    public init (
        capacity: String? = nil
    )
    {
        self.capacity = capacity
    }
}

extension Workspace: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bundleId = "BundleId"
        case computerName = "ComputerName"
        case directoryId = "DirectoryId"
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case ipAddress = "IpAddress"
        case modificationStates = "ModificationStates"
        case rootVolumeEncryptionEnabled = "RootVolumeEncryptionEnabled"
        case state = "State"
        case subnetId = "SubnetId"
        case userName = "UserName"
        case userVolumeEncryptionEnabled = "UserVolumeEncryptionEnabled"
        case volumeEncryptionKey = "VolumeEncryptionKey"
        case workspaceId = "WorkspaceId"
        case workspaceProperties = "WorkspaceProperties"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let computerName = computerName {
            try encodeContainer.encode(computerName, forKey: .computerName)
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let ipAddress = ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let modificationStates = modificationStates {
            var modificationStatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .modificationStates)
            for modificationstatelist0 in modificationStates {
                try modificationStatesContainer.encode(modificationstatelist0)
            }
        }
        if let rootVolumeEncryptionEnabled = rootVolumeEncryptionEnabled {
            try encodeContainer.encode(rootVolumeEncryptionEnabled, forKey: .rootVolumeEncryptionEnabled)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let userVolumeEncryptionEnabled = userVolumeEncryptionEnabled {
            try encodeContainer.encode(userVolumeEncryptionEnabled, forKey: .userVolumeEncryptionEnabled)
        }
        if let volumeEncryptionKey = volumeEncryptionKey {
            try encodeContainer.encode(volumeEncryptionKey, forKey: .volumeEncryptionKey)
        }
        if let workspaceId = workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
        if let workspaceProperties = workspaceProperties {
            try encodeContainer.encode(workspaceProperties, forKey: .workspaceProperties)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkspaceState.self, forKey: .state)
        state = stateDecoded
        let bundleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let computerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .computerName)
        computerName = computerNameDecoded
        let volumeEncryptionKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeEncryptionKey)
        volumeEncryptionKey = volumeEncryptionKeyDecoded
        let userVolumeEncryptionEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .userVolumeEncryptionEnabled)
        userVolumeEncryptionEnabled = userVolumeEncryptionEnabledDecoded
        let rootVolumeEncryptionEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .rootVolumeEncryptionEnabled)
        rootVolumeEncryptionEnabled = rootVolumeEncryptionEnabledDecoded
        let workspacePropertiesDecoded = try containerValues.decodeIfPresent(WorkspaceProperties.self, forKey: .workspaceProperties)
        workspaceProperties = workspacePropertiesDecoded
        let modificationStatesContainer = try containerValues.decodeIfPresent([ModificationState?].self, forKey: .modificationStates)
        var modificationStatesDecoded0:[ModificationState]? = nil
        if let modificationStatesContainer = modificationStatesContainer {
            modificationStatesDecoded0 = [ModificationState]()
            for structure0 in modificationStatesContainer {
                if let structure0 = structure0 {
                    modificationStatesDecoded0?.append(structure0)
                }
            }
        }
        modificationStates = modificationStatesDecoded0
    }
}

extension Workspace: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Workspace(bundleId: \(String(describing: bundleId)), computerName: \(String(describing: computerName)), directoryId: \(String(describing: directoryId)), errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), ipAddress: \(String(describing: ipAddress)), modificationStates: \(String(describing: modificationStates)), rootVolumeEncryptionEnabled: \(String(describing: rootVolumeEncryptionEnabled)), state: \(String(describing: state)), subnetId: \(String(describing: subnetId)), userName: \(String(describing: userName)), userVolumeEncryptionEnabled: \(String(describing: userVolumeEncryptionEnabled)), volumeEncryptionKey: \(String(describing: volumeEncryptionKey)), workspaceId: \(String(describing: workspaceId)), workspaceProperties: \(String(describing: workspaceProperties)))"}
}

/// <p>Describes a WorkSpace.</p>
public struct Workspace: Equatable {
    /// <p>The identifier of the bundle used to create the WorkSpace.</p>
    public let bundleId: String?
    /// <p>The name of the WorkSpace, as seen by the operating system. The format of this name varies.
    ///          For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/launch-workspaces-tutorials.html">
    ///             Launch a WorkSpace</a>. </p>
    public let computerName: String?
    /// <p>The identifier of the AWS Directory Service directory for the WorkSpace.</p>
    public let directoryId: String?
    /// <p>The error code that is returned if the WorkSpace cannot be created.</p>
    public let errorCode: String?
    /// <p>The text of the error message that is returned if the WorkSpace cannot be
    ///          created.</p>
    public let errorMessage: String?
    /// <p>The IP address of the WorkSpace.</p>
    public let ipAddress: String?
    /// <p>The modification states of the WorkSpace.</p>
    public let modificationStates: [ModificationState]?
    /// <p>Indicates whether the data stored on the root volume is encrypted.</p>
    public let rootVolumeEncryptionEnabled: Bool?
    /// <p>The operational state of the WorkSpace.</p>
    ///
    ///          <note>
    ///             <p>After a WorkSpace is terminated, the <code>TERMINATED</code> state is returned
    ///             only briefly before the WorkSpace directory metadata is cleaned up, so this state is rarely
    ///             returned. To confirm that a WorkSpace is terminated, check for the WorkSpace ID by using
    ///             <a href="https://docs.aws.amazon.com/workspaces/latest/api/API_DescribeWorkspaces.html">
    ///                DescribeWorkSpaces</a>. If the WorkSpace ID isn't returned, then the WorkSpace has
    ///             been successfully terminated.</p>
    ///          </note>
    public let state: WorkspaceState?
    /// <p>The identifier of the subnet for the WorkSpace.</p>
    public let subnetId: String?
    /// <p>The user for the WorkSpace.</p>
    public let userName: String?
    /// <p>Indicates whether the data stored on the user volume is encrypted.</p>
    public let userVolumeEncryptionEnabled: Bool?
    /// <p>The symmetric AWS KMS customer master key (CMK) used to encrypt data stored on your WorkSpace.
    ///          Amazon WorkSpaces does not support asymmetric CMKs.</p>
    public let volumeEncryptionKey: String?
    /// <p>The identifier of the WorkSpace.</p>
    public let workspaceId: String?
    /// <p>The properties of the WorkSpace.</p>
    public let workspaceProperties: WorkspaceProperties?

    public init (
        bundleId: String? = nil,
        computerName: String? = nil,
        directoryId: String? = nil,
        errorCode: String? = nil,
        errorMessage: String? = nil,
        ipAddress: String? = nil,
        modificationStates: [ModificationState]? = nil,
        rootVolumeEncryptionEnabled: Bool? = nil,
        state: WorkspaceState? = nil,
        subnetId: String? = nil,
        userName: String? = nil,
        userVolumeEncryptionEnabled: Bool? = nil,
        volumeEncryptionKey: String? = nil,
        workspaceId: String? = nil,
        workspaceProperties: WorkspaceProperties? = nil
    )
    {
        self.bundleId = bundleId
        self.computerName = computerName
        self.directoryId = directoryId
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.ipAddress = ipAddress
        self.modificationStates = modificationStates
        self.rootVolumeEncryptionEnabled = rootVolumeEncryptionEnabled
        self.state = state
        self.subnetId = subnetId
        self.userName = userName
        self.userVolumeEncryptionEnabled = userVolumeEncryptionEnabled
        self.volumeEncryptionKey = volumeEncryptionKey
        self.workspaceId = workspaceId
        self.workspaceProperties = workspaceProperties
    }
}

extension WorkspaceAccessProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceTypeAndroid = "DeviceTypeAndroid"
        case deviceTypeChromeOs = "DeviceTypeChromeOs"
        case deviceTypeIos = "DeviceTypeIos"
        case deviceTypeLinux = "DeviceTypeLinux"
        case deviceTypeOsx = "DeviceTypeOsx"
        case deviceTypeWeb = "DeviceTypeWeb"
        case deviceTypeWindows = "DeviceTypeWindows"
        case deviceTypeZeroClient = "DeviceTypeZeroClient"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceTypeAndroid = deviceTypeAndroid {
            try encodeContainer.encode(deviceTypeAndroid.rawValue, forKey: .deviceTypeAndroid)
        }
        if let deviceTypeChromeOs = deviceTypeChromeOs {
            try encodeContainer.encode(deviceTypeChromeOs.rawValue, forKey: .deviceTypeChromeOs)
        }
        if let deviceTypeIos = deviceTypeIos {
            try encodeContainer.encode(deviceTypeIos.rawValue, forKey: .deviceTypeIos)
        }
        if let deviceTypeLinux = deviceTypeLinux {
            try encodeContainer.encode(deviceTypeLinux.rawValue, forKey: .deviceTypeLinux)
        }
        if let deviceTypeOsx = deviceTypeOsx {
            try encodeContainer.encode(deviceTypeOsx.rawValue, forKey: .deviceTypeOsx)
        }
        if let deviceTypeWeb = deviceTypeWeb {
            try encodeContainer.encode(deviceTypeWeb.rawValue, forKey: .deviceTypeWeb)
        }
        if let deviceTypeWindows = deviceTypeWindows {
            try encodeContainer.encode(deviceTypeWindows.rawValue, forKey: .deviceTypeWindows)
        }
        if let deviceTypeZeroClient = deviceTypeZeroClient {
            try encodeContainer.encode(deviceTypeZeroClient.rawValue, forKey: .deviceTypeZeroClient)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceTypeWindowsDecoded = try containerValues.decodeIfPresent(AccessPropertyValue.self, forKey: .deviceTypeWindows)
        deviceTypeWindows = deviceTypeWindowsDecoded
        let deviceTypeOsxDecoded = try containerValues.decodeIfPresent(AccessPropertyValue.self, forKey: .deviceTypeOsx)
        deviceTypeOsx = deviceTypeOsxDecoded
        let deviceTypeWebDecoded = try containerValues.decodeIfPresent(AccessPropertyValue.self, forKey: .deviceTypeWeb)
        deviceTypeWeb = deviceTypeWebDecoded
        let deviceTypeIosDecoded = try containerValues.decodeIfPresent(AccessPropertyValue.self, forKey: .deviceTypeIos)
        deviceTypeIos = deviceTypeIosDecoded
        let deviceTypeAndroidDecoded = try containerValues.decodeIfPresent(AccessPropertyValue.self, forKey: .deviceTypeAndroid)
        deviceTypeAndroid = deviceTypeAndroidDecoded
        let deviceTypeChromeOsDecoded = try containerValues.decodeIfPresent(AccessPropertyValue.self, forKey: .deviceTypeChromeOs)
        deviceTypeChromeOs = deviceTypeChromeOsDecoded
        let deviceTypeZeroClientDecoded = try containerValues.decodeIfPresent(AccessPropertyValue.self, forKey: .deviceTypeZeroClient)
        deviceTypeZeroClient = deviceTypeZeroClientDecoded
        let deviceTypeLinuxDecoded = try containerValues.decodeIfPresent(AccessPropertyValue.self, forKey: .deviceTypeLinux)
        deviceTypeLinux = deviceTypeLinuxDecoded
    }
}

extension WorkspaceAccessProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorkspaceAccessProperties(deviceTypeAndroid: \(String(describing: deviceTypeAndroid)), deviceTypeChromeOs: \(String(describing: deviceTypeChromeOs)), deviceTypeIos: \(String(describing: deviceTypeIos)), deviceTypeLinux: \(String(describing: deviceTypeLinux)), deviceTypeOsx: \(String(describing: deviceTypeOsx)), deviceTypeWeb: \(String(describing: deviceTypeWeb)), deviceTypeWindows: \(String(describing: deviceTypeWindows)), deviceTypeZeroClient: \(String(describing: deviceTypeZeroClient)))"}
}

/// <p>The device types and operating systems that can be used to access a WorkSpace. For more
///          information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/workspaces-network-requirements.html">Amazon
///             WorkSpaces Client Network Requirements</a>.</p>
public struct WorkspaceAccessProperties: Equatable {
    /// <p>Indicates whether users can use Android devices to access their WorkSpaces.</p>
    public let deviceTypeAndroid: AccessPropertyValue?
    /// <p>Indicates whether users can use Chromebooks to access their WorkSpaces.</p>
    public let deviceTypeChromeOs: AccessPropertyValue?
    /// <p>Indicates whether users can use iOS devices to access their WorkSpaces.</p>
    public let deviceTypeIos: AccessPropertyValue?
    /// <p>Indicates whether users can use Linux clients to access their WorkSpaces.</p>
    public let deviceTypeLinux: AccessPropertyValue?
    /// <p>Indicates whether users can use macOS clients to access their WorkSpaces. To restrict
    ///          WorkSpaces access to trusted devices (also known as managed devices) with valid
    ///          certificates, specify a value of <code>TRUST</code>. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/trusted-devices.html">Restrict
    ///             WorkSpaces Access to Trusted Devices</a>. </p>
    public let deviceTypeOsx: AccessPropertyValue?
    /// <p>Indicates whether users can access their WorkSpaces through a web browser.</p>
    public let deviceTypeWeb: AccessPropertyValue?
    /// <p>Indicates whether users can use Windows clients to access their WorkSpaces. To restrict
    ///          WorkSpaces access to trusted devices (also known as managed devices) with valid
    ///          certificates, specify a value of <code>TRUST</code>. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/trusted-devices.html">Restrict
    ///             WorkSpaces Access to Trusted Devices</a>. </p>
    public let deviceTypeWindows: AccessPropertyValue?
    /// <p>Indicates whether users can use zero client devices to access their WorkSpaces.</p>
    public let deviceTypeZeroClient: AccessPropertyValue?

    public init (
        deviceTypeAndroid: AccessPropertyValue? = nil,
        deviceTypeChromeOs: AccessPropertyValue? = nil,
        deviceTypeIos: AccessPropertyValue? = nil,
        deviceTypeLinux: AccessPropertyValue? = nil,
        deviceTypeOsx: AccessPropertyValue? = nil,
        deviceTypeWeb: AccessPropertyValue? = nil,
        deviceTypeWindows: AccessPropertyValue? = nil,
        deviceTypeZeroClient: AccessPropertyValue? = nil
    )
    {
        self.deviceTypeAndroid = deviceTypeAndroid
        self.deviceTypeChromeOs = deviceTypeChromeOs
        self.deviceTypeIos = deviceTypeIos
        self.deviceTypeLinux = deviceTypeLinux
        self.deviceTypeOsx = deviceTypeOsx
        self.deviceTypeWeb = deviceTypeWeb
        self.deviceTypeWindows = deviceTypeWindows
        self.deviceTypeZeroClient = deviceTypeZeroClient
    }
}

extension WorkspaceBundle: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bundleId = "BundleId"
        case computeType = "ComputeType"
        case creationTime = "CreationTime"
        case description = "Description"
        case imageId = "ImageId"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case owner = "Owner"
        case rootStorage = "RootStorage"
        case userStorage = "UserStorage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let computeType = computeType {
            try encodeContainer.encode(computeType, forKey: .computeType)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let rootStorage = rootStorage {
            try encodeContainer.encode(rootStorage, forKey: .rootStorage)
        }
        if let userStorage = userStorage {
            try encodeContainer.encode(userStorage, forKey: .userStorage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let rootStorageDecoded = try containerValues.decodeIfPresent(RootStorage.self, forKey: .rootStorage)
        rootStorage = rootStorageDecoded
        let userStorageDecoded = try containerValues.decodeIfPresent(UserStorage.self, forKey: .userStorage)
        userStorage = userStorageDecoded
        let computeTypeDecoded = try containerValues.decodeIfPresent(ComputeType.self, forKey: .computeType)
        computeType = computeTypeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension WorkspaceBundle: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorkspaceBundle(bundleId: \(String(describing: bundleId)), computeType: \(String(describing: computeType)), creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), imageId: \(String(describing: imageId)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), name: \(String(describing: name)), owner: \(String(describing: owner)), rootStorage: \(String(describing: rootStorage)), userStorage: \(String(describing: userStorage)))"}
}

/// <p>Describes a WorkSpace bundle.</p>
public struct WorkspaceBundle: Equatable {
    /// <p>The identifier of the bundle.</p>
    public let bundleId: String?
    /// <p>The compute type of the bundle. For more information, see
    ///          <a href="http://aws.amazon.com/workspaces/details/#Amazon_WorkSpaces_Bundles">Amazon WorkSpaces Bundles</a>.</p>
    public let computeType: ComputeType?
    /// <p>The time when the bundle was created.</p>
    public let creationTime: Date?
    /// <p>The description of the bundle.</p>
    public let description: String?
    /// <p>The identifier of the image that was used to create the bundle.</p>
    public let imageId: String?
    /// <p>The last time that the bundle was updated.</p>
    public let lastUpdatedTime: Date?
    /// <p>The name of the bundle.</p>
    public let name: String?
    /// <p>The owner of the bundle. This is the account identifier of the owner, or
    ///          <code>AMAZON</code> if the bundle is provided by AWS.</p>
    public let owner: String?
    /// <p>The size of the root volume.</p>
    public let rootStorage: RootStorage?
    /// <p>The size of the user volume.</p>
    public let userStorage: UserStorage?

    public init (
        bundleId: String? = nil,
        computeType: ComputeType? = nil,
        creationTime: Date? = nil,
        description: String? = nil,
        imageId: String? = nil,
        lastUpdatedTime: Date? = nil,
        name: String? = nil,
        owner: String? = nil,
        rootStorage: RootStorage? = nil,
        userStorage: UserStorage? = nil
    )
    {
        self.bundleId = bundleId
        self.computeType = computeType
        self.creationTime = creationTime
        self.description = description
        self.imageId = imageId
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.owner = owner
        self.rootStorage = rootStorage
        self.userStorage = userStorage
    }
}

extension WorkspaceConnectionStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionState = "ConnectionState"
        case connectionStateCheckTimestamp = "ConnectionStateCheckTimestamp"
        case lastKnownUserConnectionTimestamp = "LastKnownUserConnectionTimestamp"
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionState = connectionState {
            try encodeContainer.encode(connectionState.rawValue, forKey: .connectionState)
        }
        if let connectionStateCheckTimestamp = connectionStateCheckTimestamp {
            try encodeContainer.encode(connectionStateCheckTimestamp.timeIntervalSince1970, forKey: .connectionStateCheckTimestamp)
        }
        if let lastKnownUserConnectionTimestamp = lastKnownUserConnectionTimestamp {
            try encodeContainer.encode(lastKnownUserConnectionTimestamp.timeIntervalSince1970, forKey: .lastKnownUserConnectionTimestamp)
        }
        if let workspaceId = workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let connectionStateCheckTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .connectionStateCheckTimestamp)
        connectionStateCheckTimestamp = connectionStateCheckTimestampDecoded
        let lastKnownUserConnectionTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastKnownUserConnectionTimestamp)
        lastKnownUserConnectionTimestamp = lastKnownUserConnectionTimestampDecoded
    }
}

extension WorkspaceConnectionStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorkspaceConnectionStatus(connectionState: \(String(describing: connectionState)), connectionStateCheckTimestamp: \(String(describing: connectionStateCheckTimestamp)), lastKnownUserConnectionTimestamp: \(String(describing: lastKnownUserConnectionTimestamp)), workspaceId: \(String(describing: workspaceId)))"}
}

/// <p>Describes the connection status of a WorkSpace.</p>
public struct WorkspaceConnectionStatus: Equatable {
    /// <p>The connection state of the WorkSpace. The connection state is unknown if the WorkSpace
    ///          is stopped.</p>
    public let connectionState: ConnectionState?
    /// <p>The timestamp of the connection status check.</p>
    public let connectionStateCheckTimestamp: Date?
    /// <p>The timestamp of the last known user connection.</p>
    public let lastKnownUserConnectionTimestamp: Date?
    /// <p>The identifier of the WorkSpace.</p>
    public let workspaceId: String?

    public init (
        connectionState: ConnectionState? = nil,
        connectionStateCheckTimestamp: Date? = nil,
        lastKnownUserConnectionTimestamp: Date? = nil,
        workspaceId: String? = nil
    )
    {
        self.connectionState = connectionState
        self.connectionStateCheckTimestamp = connectionStateCheckTimestamp
        self.lastKnownUserConnectionTimestamp = lastKnownUserConnectionTimestamp
        self.workspaceId = workspaceId
    }
}

extension WorkspaceCreationProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customSecurityGroupId = "CustomSecurityGroupId"
        case defaultOu = "DefaultOu"
        case enableInternetAccess = "EnableInternetAccess"
        case enableMaintenanceMode = "EnableMaintenanceMode"
        case enableWorkDocs = "EnableWorkDocs"
        case userEnabledAsLocalAdministrator = "UserEnabledAsLocalAdministrator"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customSecurityGroupId = customSecurityGroupId {
            try encodeContainer.encode(customSecurityGroupId, forKey: .customSecurityGroupId)
        }
        if let defaultOu = defaultOu {
            try encodeContainer.encode(defaultOu, forKey: .defaultOu)
        }
        if let enableInternetAccess = enableInternetAccess {
            try encodeContainer.encode(enableInternetAccess, forKey: .enableInternetAccess)
        }
        if let enableMaintenanceMode = enableMaintenanceMode {
            try encodeContainer.encode(enableMaintenanceMode, forKey: .enableMaintenanceMode)
        }
        if let enableWorkDocs = enableWorkDocs {
            try encodeContainer.encode(enableWorkDocs, forKey: .enableWorkDocs)
        }
        if let userEnabledAsLocalAdministrator = userEnabledAsLocalAdministrator {
            try encodeContainer.encode(userEnabledAsLocalAdministrator, forKey: .userEnabledAsLocalAdministrator)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableWorkDocsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableWorkDocs)
        enableWorkDocs = enableWorkDocsDecoded
        let enableInternetAccessDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableInternetAccess)
        enableInternetAccess = enableInternetAccessDecoded
        let defaultOuDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultOu)
        defaultOu = defaultOuDecoded
        let customSecurityGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customSecurityGroupId)
        customSecurityGroupId = customSecurityGroupIdDecoded
        let userEnabledAsLocalAdministratorDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .userEnabledAsLocalAdministrator)
        userEnabledAsLocalAdministrator = userEnabledAsLocalAdministratorDecoded
        let enableMaintenanceModeDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableMaintenanceMode)
        enableMaintenanceMode = enableMaintenanceModeDecoded
    }
}

extension WorkspaceCreationProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorkspaceCreationProperties(customSecurityGroupId: \(String(describing: customSecurityGroupId)), defaultOu: \(String(describing: defaultOu)), enableInternetAccess: \(String(describing: enableInternetAccess)), enableMaintenanceMode: \(String(describing: enableMaintenanceMode)), enableWorkDocs: \(String(describing: enableWorkDocs)), userEnabledAsLocalAdministrator: \(String(describing: userEnabledAsLocalAdministrator)))"}
}

/// <p>Describes the default properties that are used for creating WorkSpaces. For more
///          information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/update-directory-details.html">Update Directory
///             Details for Your WorkSpaces</a>. </p>
public struct WorkspaceCreationProperties: Equatable {
    /// <p>The identifier of your custom security group.</p>
    public let customSecurityGroupId: String?
    /// <p>The default organizational unit (OU) for your WorkSpaces directories. This string must be the full Lightweight
    ///          Directory Access Protocol (LDAP) distinguished name for the target domain and OU. It must be in the form
    ///          <code>"OU=<i>value</i>,DC=<i>value</i>,DC=<i>value</i>"</code>,
    ///          where <i>value</i> is any string of characters, and the number of domain components (DCs) is
    ///          two or more. For example, <code>OU=WorkSpaces_machines,DC=machines,DC=example,DC=com</code>. </p>
    ///
    ///          <important>
    ///             <ul>
    ///                <li>
    ///                   <p>To avoid errors, certain characters in the distinguished name must be escaped. For more information,
    ///                   see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/ldap/distinguished-names">
    ///                      Distinguished Names</a> in the Microsoft documentation.</p>
    ///                </li>
    ///                <li>
    ///                   <p>The API doesn't validate whether the OU exists.</p>
    ///                </li>
    ///             </ul>
    ///          </important>
    public let defaultOu: String?
    /// <p>Indicates whether internet access is enabled for your WorkSpaces.</p>
    public let enableInternetAccess: Bool?
    /// <p>Indicates whether maintenance mode is enabled for your WorkSpaces. For more information,
    ///          see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/workspace-maintenance.html">WorkSpace
    ///             Maintenance</a>. </p>
    public let enableMaintenanceMode: Bool?
    /// <p>Indicates whether Amazon WorkDocs is enabled for your WorkSpaces.</p>
    ///
    ///          <note>
    ///             <p>If WorkDocs is already enabled for a WorkSpaces directory and you disable it, new WorkSpaces launched in the
    ///             directory will not have WorkDocs enabled. However, WorkDocs remains enabled for any existing WorkSpaces, unless
    ///             you either disable users' access to WorkDocs or you delete the WorkDocs site. To disable users' access to WorkDocs,
    ///             see <a href="https://docs.aws.amazon.com/workdocs/latest/adminguide/inactive-user.html">Disabling Users</a> in the
    ///             <i>Amazon WorkDocs Administration Guide</i>. To delete a WorkDocs site, see
    ///             <a href="https://docs.aws.amazon.com/workdocs/latest/adminguide/manage-sites.html">Deleting a Site</a> in the
    ///             <i>Amazon WorkDocs Administration Guide</i>.</p>
    ///
    ///             <p>If you enable WorkDocs on a directory that already has existing WorkSpaces, the existing WorkSpaces and any
    ///          new WorkSpaces that are launched in the directory will have WorkDocs enabled.</p>
    ///          </note>
    public let enableWorkDocs: Bool?
    /// <p>Indicates whether users are local administrators of their WorkSpaces.</p>
    public let userEnabledAsLocalAdministrator: Bool?

    public init (
        customSecurityGroupId: String? = nil,
        defaultOu: String? = nil,
        enableInternetAccess: Bool? = nil,
        enableMaintenanceMode: Bool? = nil,
        enableWorkDocs: Bool? = nil,
        userEnabledAsLocalAdministrator: Bool? = nil
    )
    {
        self.customSecurityGroupId = customSecurityGroupId
        self.defaultOu = defaultOu
        self.enableInternetAccess = enableInternetAccess
        self.enableMaintenanceMode = enableMaintenanceMode
        self.enableWorkDocs = enableWorkDocs
        self.userEnabledAsLocalAdministrator = userEnabledAsLocalAdministrator
    }
}

extension WorkspaceDirectory: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alias = "Alias"
        case customerUserName = "CustomerUserName"
        case directoryId = "DirectoryId"
        case directoryName = "DirectoryName"
        case directoryType = "DirectoryType"
        case dnsIpAddresses = "DnsIpAddresses"
        case iamRoleId = "IamRoleId"
        case registrationCode = "RegistrationCode"
        case selfservicePermissions = "SelfservicePermissions"
        case state = "State"
        case subnetIds = "SubnetIds"
        case tenancy = "Tenancy"
        case workspaceAccessProperties = "WorkspaceAccessProperties"
        case workspaceCreationProperties = "WorkspaceCreationProperties"
        case workspaceSecurityGroupId = "WorkspaceSecurityGroupId"
        case ipGroupIds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let customerUserName = customerUserName {
            try encodeContainer.encode(customerUserName, forKey: .customerUserName)
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let directoryName = directoryName {
            try encodeContainer.encode(directoryName, forKey: .directoryName)
        }
        if let directoryType = directoryType {
            try encodeContainer.encode(directoryType.rawValue, forKey: .directoryType)
        }
        if let dnsIpAddresses = dnsIpAddresses {
            var dnsIpAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsIpAddresses)
            for dnsipaddresses0 in dnsIpAddresses {
                try dnsIpAddressesContainer.encode(dnsipaddresses0)
            }
        }
        if let iamRoleId = iamRoleId {
            try encodeContainer.encode(iamRoleId, forKey: .iamRoleId)
        }
        if let registrationCode = registrationCode {
            try encodeContainer.encode(registrationCode, forKey: .registrationCode)
        }
        if let selfservicePermissions = selfservicePermissions {
            try encodeContainer.encode(selfservicePermissions, forKey: .selfservicePermissions)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let tenancy = tenancy {
            try encodeContainer.encode(tenancy.rawValue, forKey: .tenancy)
        }
        if let workspaceAccessProperties = workspaceAccessProperties {
            try encodeContainer.encode(workspaceAccessProperties, forKey: .workspaceAccessProperties)
        }
        if let workspaceCreationProperties = workspaceCreationProperties {
            try encodeContainer.encode(workspaceCreationProperties, forKey: .workspaceCreationProperties)
        }
        if let workspaceSecurityGroupId = workspaceSecurityGroupId {
            try encodeContainer.encode(workspaceSecurityGroupId, forKey: .workspaceSecurityGroupId)
        }
        if let ipGroupIds = ipGroupIds {
            var ipGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipGroupIds)
            for ipgroupidlist0 in ipGroupIds {
                try ipGroupIdsContainer.encode(ipgroupidlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alias)
        alias = aliasDecoded
        let directoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryName)
        directoryName = directoryNameDecoded
        let registrationCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registrationCode)
        registrationCode = registrationCodeDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let dnsIpAddressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .dnsIpAddresses)
        var dnsIpAddressesDecoded0:[String]? = nil
        if let dnsIpAddressesContainer = dnsIpAddressesContainer {
            dnsIpAddressesDecoded0 = [String]()
            for string0 in dnsIpAddressesContainer {
                if let string0 = string0 {
                    dnsIpAddressesDecoded0?.append(string0)
                }
            }
        }
        dnsIpAddresses = dnsIpAddressesDecoded0
        let customerUserNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerUserName)
        customerUserName = customerUserNameDecoded
        let iamRoleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleId)
        iamRoleId = iamRoleIdDecoded
        let directoryTypeDecoded = try containerValues.decodeIfPresent(WorkspaceDirectoryType.self, forKey: .directoryType)
        directoryType = directoryTypeDecoded
        let workspaceSecurityGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workspaceSecurityGroupId)
        workspaceSecurityGroupId = workspaceSecurityGroupIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkspaceDirectoryState.self, forKey: .state)
        state = stateDecoded
        let workspaceCreationPropertiesDecoded = try containerValues.decodeIfPresent(DefaultWorkspaceCreationProperties.self, forKey: .workspaceCreationProperties)
        workspaceCreationProperties = workspaceCreationPropertiesDecoded
        let ipGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ipGroupIds)
        var ipGroupIdsDecoded0:[String]? = nil
        if let ipGroupIdsContainer = ipGroupIdsContainer {
            ipGroupIdsDecoded0 = [String]()
            for string0 in ipGroupIdsContainer {
                if let string0 = string0 {
                    ipGroupIdsDecoded0?.append(string0)
                }
            }
        }
        ipGroupIds = ipGroupIdsDecoded0
        let workspaceAccessPropertiesDecoded = try containerValues.decodeIfPresent(WorkspaceAccessProperties.self, forKey: .workspaceAccessProperties)
        workspaceAccessProperties = workspaceAccessPropertiesDecoded
        let tenancyDecoded = try containerValues.decodeIfPresent(Tenancy.self, forKey: .tenancy)
        tenancy = tenancyDecoded
        let selfservicePermissionsDecoded = try containerValues.decodeIfPresent(SelfservicePermissions.self, forKey: .selfservicePermissions)
        selfservicePermissions = selfservicePermissionsDecoded
    }
}

extension WorkspaceDirectory: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorkspaceDirectory(alias: \(String(describing: alias)), customerUserName: \(String(describing: customerUserName)), directoryId: \(String(describing: directoryId)), directoryName: \(String(describing: directoryName)), directoryType: \(String(describing: directoryType)), dnsIpAddresses: \(String(describing: dnsIpAddresses)), iamRoleId: \(String(describing: iamRoleId)), registrationCode: \(String(describing: registrationCode)), selfservicePermissions: \(String(describing: selfservicePermissions)), state: \(String(describing: state)), subnetIds: \(String(describing: subnetIds)), tenancy: \(String(describing: tenancy)), workspaceAccessProperties: \(String(describing: workspaceAccessProperties)), workspaceCreationProperties: \(String(describing: workspaceCreationProperties)), workspaceSecurityGroupId: \(String(describing: workspaceSecurityGroupId)), ipGroupIds: \(String(describing: ipGroupIds)))"}
}

/// <p>Describes a directory that is used with Amazon WorkSpaces.</p>
public struct WorkspaceDirectory: Equatable {
    /// <p>The directory alias.</p>
    public let alias: String?
    /// <p>The user name for the service account.</p>
    public let customerUserName: String?
    /// <p>The directory identifier.</p>
    public let directoryId: String?
    /// <p>The name of the directory.</p>
    public let directoryName: String?
    /// <p>The directory type.</p>
    public let directoryType: WorkspaceDirectoryType?
    /// <p>The IP addresses of the DNS servers for the directory.</p>
    public let dnsIpAddresses: [String]?
    /// <p>The identifier of the IAM role. This is the role that allows Amazon WorkSpaces to make
    ///          calls to other services, such as Amazon EC2, on your behalf.</p>
    public let iamRoleId: String?
    /// <p>The identifiers of the IP access control groups associated with the directory.</p>
    public let ipGroupIds: [String]?
    /// <p>The registration code for the directory. This is the code that users enter in their
    ///          Amazon WorkSpaces client application to connect to the directory.</p>
    public let registrationCode: String?
    /// <p>The default self-service permissions for WorkSpaces in the directory.</p>
    public let selfservicePermissions: SelfservicePermissions?
    /// <p>The state of the directory's registration with Amazon WorkSpaces. After a directory is
    ///          deregistered, the <code>DEREGISTERED</code> state is returned very briefly before the directory
    ///          metadata is cleaned up, so this state is rarely returned. To confirm that a directory is deregistered,
    ///          check for the directory ID by using
    ///          <a href="https://docs.aws.amazon.com/workspaces/latest/api/API_DescribeWorkspaceDirectories.html">
    ///             DescribeWorkspaceDirectories</a>. If the directory ID isn't returned, then the directory has been
    ///          successfully deregistered.</p>
    public let state: WorkspaceDirectoryState?
    /// <p>The identifiers of the subnets used with the directory.</p>
    public let subnetIds: [String]?
    /// <p>Specifies whether the directory is dedicated or shared. To use Bring Your Own License
    ///          (BYOL), this value must be set to <code>DEDICATED</code>. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.html">Bring
    ///             Your Own Windows Desktop Images</a>.</p>
    public let tenancy: Tenancy?
    /// <p>The devices and operating systems that users can use to access WorkSpaces.</p>
    public let workspaceAccessProperties: WorkspaceAccessProperties?
    /// <p>The default creation properties for all WorkSpaces in the directory.</p>
    public let workspaceCreationProperties: DefaultWorkspaceCreationProperties?
    /// <p>The identifier of the security group that is assigned to new WorkSpaces.</p>
    public let workspaceSecurityGroupId: String?

    public init (
        alias: String? = nil,
        customerUserName: String? = nil,
        directoryId: String? = nil,
        directoryName: String? = nil,
        directoryType: WorkspaceDirectoryType? = nil,
        dnsIpAddresses: [String]? = nil,
        iamRoleId: String? = nil,
        ipGroupIds: [String]? = nil,
        registrationCode: String? = nil,
        selfservicePermissions: SelfservicePermissions? = nil,
        state: WorkspaceDirectoryState? = nil,
        subnetIds: [String]? = nil,
        tenancy: Tenancy? = nil,
        workspaceAccessProperties: WorkspaceAccessProperties? = nil,
        workspaceCreationProperties: DefaultWorkspaceCreationProperties? = nil,
        workspaceSecurityGroupId: String? = nil
    )
    {
        self.alias = alias
        self.customerUserName = customerUserName
        self.directoryId = directoryId
        self.directoryName = directoryName
        self.directoryType = directoryType
        self.dnsIpAddresses = dnsIpAddresses
        self.iamRoleId = iamRoleId
        self.ipGroupIds = ipGroupIds
        self.registrationCode = registrationCode
        self.selfservicePermissions = selfservicePermissions
        self.state = state
        self.subnetIds = subnetIds
        self.tenancy = tenancy
        self.workspaceAccessProperties = workspaceAccessProperties
        self.workspaceCreationProperties = workspaceCreationProperties
        self.workspaceSecurityGroupId = workspaceSecurityGroupId
    }
}

public enum WorkspaceDirectoryState {
    case deregistered
    case deregistering
    case error
    case registered
    case registering
    case sdkUnknown(String)
}

extension WorkspaceDirectoryState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WorkspaceDirectoryState] {
        return [
            .deregistered,
            .deregistering,
            .error,
            .registered,
            .registering,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deregistered: return "DEREGISTERED"
        case .deregistering: return "DEREGISTERING"
        case .error: return "ERROR"
        case .registered: return "REGISTERED"
        case .registering: return "REGISTERING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WorkspaceDirectoryState(rawValue: rawValue) ?? WorkspaceDirectoryState.sdkUnknown(rawValue)
    }
}

public enum WorkspaceDirectoryType {
    case adConnector
    case simpleAd
    case sdkUnknown(String)
}

extension WorkspaceDirectoryType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WorkspaceDirectoryType] {
        return [
            .adConnector,
            .simpleAd,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .adConnector: return "AD_CONNECTOR"
        case .simpleAd: return "SIMPLE_AD"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WorkspaceDirectoryType(rawValue: rawValue) ?? WorkspaceDirectoryType.sdkUnknown(rawValue)
    }
}

extension WorkspaceImage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case created = "Created"
        case description = "Description"
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case imageId = "ImageId"
        case name = "Name"
        case operatingSystem = "OperatingSystem"
        case ownerAccountId = "OwnerAccountId"
        case requiredTenancy = "RequiredTenancy"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let operatingSystem = operatingSystem {
            try encodeContainer.encode(operatingSystem, forKey: .operatingSystem)
        }
        if let ownerAccountId = ownerAccountId {
            try encodeContainer.encode(ownerAccountId, forKey: .ownerAccountId)
        }
        if let requiredTenancy = requiredTenancy {
            try encodeContainer.encode(requiredTenancy.rawValue, forKey: .requiredTenancy)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkspaceImageState.self, forKey: .state)
        state = stateDecoded
        let requiredTenancyDecoded = try containerValues.decodeIfPresent(WorkspaceImageRequiredTenancy.self, forKey: .requiredTenancy)
        requiredTenancy = requiredTenancyDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let createdDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .created)
        created = createdDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
    }
}

extension WorkspaceImage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorkspaceImage(created: \(String(describing: created)), description: \(String(describing: description)), errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), imageId: \(String(describing: imageId)), name: \(String(describing: name)), operatingSystem: \(String(describing: operatingSystem)), ownerAccountId: \(String(describing: ownerAccountId)), requiredTenancy: \(String(describing: requiredTenancy)), state: \(String(describing: state)))"}
}

/// <p>Describes a WorkSpace image.</p>
public struct WorkspaceImage: Equatable {
    /// <p>The date when the image was created. If the image has been shared, the AWS account
    ///          that the image has been shared with sees the original creation date of the image.</p>
    public let created: Date?
    /// <p>The description of the image.</p>
    public let description: String?
    /// <p>The error code that is returned for the image.</p>
    public let errorCode: String?
    /// <p>The text of the error message that is returned for the image.</p>
    public let errorMessage: String?
    /// <p>The identifier of the image.</p>
    public let imageId: String?
    /// <p>The name of the image.</p>
    public let name: String?
    /// <p>The operating system that the image is running. </p>
    public let operatingSystem: OperatingSystem?
    /// <p>The identifier of the AWS account that owns the image.</p>
    public let ownerAccountId: String?
    /// <p>Specifies whether the image is running on dedicated hardware. When Bring Your Own
    ///          License (BYOL) is enabled, this value is set to <code>DEDICATED</code>. For more
    ///          information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.html">Bring Your Own Windows
    ///             Desktop Images</a>.</p>
    public let requiredTenancy: WorkspaceImageRequiredTenancy?
    /// <p>The status of the image.</p>
    public let state: WorkspaceImageState?

    public init (
        created: Date? = nil,
        description: String? = nil,
        errorCode: String? = nil,
        errorMessage: String? = nil,
        imageId: String? = nil,
        name: String? = nil,
        operatingSystem: OperatingSystem? = nil,
        ownerAccountId: String? = nil,
        requiredTenancy: WorkspaceImageRequiredTenancy? = nil,
        state: WorkspaceImageState? = nil
    )
    {
        self.created = created
        self.description = description
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.imageId = imageId
        self.name = name
        self.operatingSystem = operatingSystem
        self.ownerAccountId = ownerAccountId
        self.requiredTenancy = requiredTenancy
        self.state = state
    }
}

public enum WorkspaceImageIngestionProcess {
    case byolGraphics
    case byolGraphicspro
    case byolRegular
    case byolRegularWsp
    case sdkUnknown(String)
}

extension WorkspaceImageIngestionProcess : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WorkspaceImageIngestionProcess] {
        return [
            .byolGraphics,
            .byolGraphicspro,
            .byolRegular,
            .byolRegularWsp,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .byolGraphics: return "BYOL_GRAPHICS"
        case .byolGraphicspro: return "BYOL_GRAPHICSPRO"
        case .byolRegular: return "BYOL_REGULAR"
        case .byolRegularWsp: return "BYOL_REGULAR_WSP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WorkspaceImageIngestionProcess(rawValue: rawValue) ?? WorkspaceImageIngestionProcess.sdkUnknown(rawValue)
    }
}

public enum WorkspaceImageRequiredTenancy {
    case dedicated
    case `default`
    case sdkUnknown(String)
}

extension WorkspaceImageRequiredTenancy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WorkspaceImageRequiredTenancy] {
        return [
            .dedicated,
            .default,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dedicated: return "DEDICATED"
        case .default: return "DEFAULT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WorkspaceImageRequiredTenancy(rawValue: rawValue) ?? WorkspaceImageRequiredTenancy.sdkUnknown(rawValue)
    }
}

public enum WorkspaceImageState {
    case available
    case error
    case pending
    case sdkUnknown(String)
}

extension WorkspaceImageState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WorkspaceImageState] {
        return [
            .available,
            .error,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .error: return "ERROR"
        case .pending: return "PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WorkspaceImageState(rawValue: rawValue) ?? WorkspaceImageState.sdkUnknown(rawValue)
    }
}

extension WorkspaceProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case computeTypeName = "ComputeTypeName"
        case rootVolumeSizeGib = "RootVolumeSizeGib"
        case runningMode = "RunningMode"
        case runningModeAutoStopTimeoutInMinutes = "RunningModeAutoStopTimeoutInMinutes"
        case userVolumeSizeGib = "UserVolumeSizeGib"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computeTypeName = computeTypeName {
            try encodeContainer.encode(computeTypeName.rawValue, forKey: .computeTypeName)
        }
        if let rootVolumeSizeGib = rootVolumeSizeGib {
            try encodeContainer.encode(rootVolumeSizeGib, forKey: .rootVolumeSizeGib)
        }
        if let runningMode = runningMode {
            try encodeContainer.encode(runningMode.rawValue, forKey: .runningMode)
        }
        if let runningModeAutoStopTimeoutInMinutes = runningModeAutoStopTimeoutInMinutes {
            try encodeContainer.encode(runningModeAutoStopTimeoutInMinutes, forKey: .runningModeAutoStopTimeoutInMinutes)
        }
        if let userVolumeSizeGib = userVolumeSizeGib {
            try encodeContainer.encode(userVolumeSizeGib, forKey: .userVolumeSizeGib)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runningModeDecoded = try containerValues.decodeIfPresent(RunningMode.self, forKey: .runningMode)
        runningMode = runningModeDecoded
        let runningModeAutoStopTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .runningModeAutoStopTimeoutInMinutes)
        runningModeAutoStopTimeoutInMinutes = runningModeAutoStopTimeoutInMinutesDecoded
        let rootVolumeSizeGibDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .rootVolumeSizeGib)
        rootVolumeSizeGib = rootVolumeSizeGibDecoded
        let userVolumeSizeGibDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .userVolumeSizeGib)
        userVolumeSizeGib = userVolumeSizeGibDecoded
        let computeTypeNameDecoded = try containerValues.decodeIfPresent(Compute.self, forKey: .computeTypeName)
        computeTypeName = computeTypeNameDecoded
    }
}

extension WorkspaceProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorkspaceProperties(computeTypeName: \(String(describing: computeTypeName)), rootVolumeSizeGib: \(String(describing: rootVolumeSizeGib)), runningMode: \(String(describing: runningMode)), runningModeAutoStopTimeoutInMinutes: \(String(describing: runningModeAutoStopTimeoutInMinutes)), userVolumeSizeGib: \(String(describing: userVolumeSizeGib)))"}
}

/// <p>Describes a WorkSpace.</p>
public struct WorkspaceProperties: Equatable {
    /// <p>The compute type. For more information, see <a href="http://aws.amazon.com/workspaces/details/#Amazon_WorkSpaces_Bundles">Amazon WorkSpaces
    ///          Bundles</a>.</p>
    public let computeTypeName: Compute?
    /// <p>The size of the root volume. For important information about how to modify the size of the root and user volumes, see
    ///          <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/modify-workspaces.html">Modify a WorkSpace</a>.</p>
    public let rootVolumeSizeGib: Int?
    /// <p>The running mode. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/running-mode.html">Manage the WorkSpace Running
    ///             Mode</a>.</p>
    public let runningMode: RunningMode?
    /// <p>The time after a user logs off when WorkSpaces are automatically stopped. Configured in 60-minute intervals.</p>
    public let runningModeAutoStopTimeoutInMinutes: Int?
    /// <p>The size of the user storage. For important information about how to modify the size of the root and user volumes, see
    ///          <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/modify-workspaces.html">Modify a WorkSpace</a>.</p>
    public let userVolumeSizeGib: Int?

    public init (
        computeTypeName: Compute? = nil,
        rootVolumeSizeGib: Int? = nil,
        runningMode: RunningMode? = nil,
        runningModeAutoStopTimeoutInMinutes: Int? = nil,
        userVolumeSizeGib: Int? = nil
    )
    {
        self.computeTypeName = computeTypeName
        self.rootVolumeSizeGib = rootVolumeSizeGib
        self.runningMode = runningMode
        self.runningModeAutoStopTimeoutInMinutes = runningModeAutoStopTimeoutInMinutes
        self.userVolumeSizeGib = userVolumeSizeGib
    }
}

extension WorkspaceRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bundleId = "BundleId"
        case directoryId = "DirectoryId"
        case rootVolumeEncryptionEnabled = "RootVolumeEncryptionEnabled"
        case tags = "Tags"
        case userName = "UserName"
        case userVolumeEncryptionEnabled = "UserVolumeEncryptionEnabled"
        case volumeEncryptionKey = "VolumeEncryptionKey"
        case workspaceProperties = "WorkspaceProperties"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let rootVolumeEncryptionEnabled = rootVolumeEncryptionEnabled {
            try encodeContainer.encode(rootVolumeEncryptionEnabled, forKey: .rootVolumeEncryptionEnabled)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let userVolumeEncryptionEnabled = userVolumeEncryptionEnabled {
            try encodeContainer.encode(userVolumeEncryptionEnabled, forKey: .userVolumeEncryptionEnabled)
        }
        if let volumeEncryptionKey = volumeEncryptionKey {
            try encodeContainer.encode(volumeEncryptionKey, forKey: .volumeEncryptionKey)
        }
        if let workspaceProperties = workspaceProperties {
            try encodeContainer.encode(workspaceProperties, forKey: .workspaceProperties)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let bundleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
        let volumeEncryptionKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeEncryptionKey)
        volumeEncryptionKey = volumeEncryptionKeyDecoded
        let userVolumeEncryptionEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .userVolumeEncryptionEnabled)
        userVolumeEncryptionEnabled = userVolumeEncryptionEnabledDecoded
        let rootVolumeEncryptionEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .rootVolumeEncryptionEnabled)
        rootVolumeEncryptionEnabled = rootVolumeEncryptionEnabledDecoded
        let workspacePropertiesDecoded = try containerValues.decodeIfPresent(WorkspaceProperties.self, forKey: .workspaceProperties)
        workspaceProperties = workspacePropertiesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension WorkspaceRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorkspaceRequest(bundleId: \(String(describing: bundleId)), directoryId: \(String(describing: directoryId)), rootVolumeEncryptionEnabled: \(String(describing: rootVolumeEncryptionEnabled)), tags: \(String(describing: tags)), userName: \(String(describing: userName)), userVolumeEncryptionEnabled: \(String(describing: userVolumeEncryptionEnabled)), volumeEncryptionKey: \(String(describing: volumeEncryptionKey)), workspaceProperties: \(String(describing: workspaceProperties)))"}
}

/// <p>Describes the information used to create a WorkSpace.</p>
public struct WorkspaceRequest: Equatable {
    /// <p>The identifier of the bundle for the WorkSpace. You can use <a>DescribeWorkspaceBundles</a> to list the available bundles.</p>
    public let bundleId: String?
    /// <p>The identifier of the AWS Directory Service directory for the WorkSpace. You can use
    ///             <a>DescribeWorkspaceDirectories</a> to list the available directories.</p>
    public let directoryId: String?
    /// <p>Indicates whether the data stored on the root volume is encrypted.</p>
    public let rootVolumeEncryptionEnabled: Bool?
    /// <p>The tags for the WorkSpace.</p>
    public let tags: [Tag]?
    /// <p>The user name of the user for the WorkSpace. This user name must exist in the AWS
    ///          Directory Service directory for the WorkSpace.</p>
    public let userName: String?
    /// <p>Indicates whether the data stored on the user volume is encrypted.</p>
    public let userVolumeEncryptionEnabled: Bool?
    /// <p>The symmetric AWS KMS customer master key (CMK) used to encrypt data stored on your WorkSpace.
    ///          Amazon WorkSpaces does not support asymmetric CMKs.</p>
    public let volumeEncryptionKey: String?
    /// <p>The WorkSpace properties.</p>
    public let workspaceProperties: WorkspaceProperties?

    public init (
        bundleId: String? = nil,
        directoryId: String? = nil,
        rootVolumeEncryptionEnabled: Bool? = nil,
        tags: [Tag]? = nil,
        userName: String? = nil,
        userVolumeEncryptionEnabled: Bool? = nil,
        volumeEncryptionKey: String? = nil,
        workspaceProperties: WorkspaceProperties? = nil
    )
    {
        self.bundleId = bundleId
        self.directoryId = directoryId
        self.rootVolumeEncryptionEnabled = rootVolumeEncryptionEnabled
        self.tags = tags
        self.userName = userName
        self.userVolumeEncryptionEnabled = userVolumeEncryptionEnabled
        self.volumeEncryptionKey = volumeEncryptionKey
        self.workspaceProperties = workspaceProperties
    }
}

public enum WorkspaceState {
    case adminMaintenance
    case available
    case error
    case impaired
    case maintenance
    case pending
    case rebooting
    case rebuilding
    case restoring
    case starting
    case stopped
    case stopping
    case suspended
    case terminated
    case terminating
    case unhealthy
    case updating
    case sdkUnknown(String)
}

extension WorkspaceState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WorkspaceState] {
        return [
            .adminMaintenance,
            .available,
            .error,
            .impaired,
            .maintenance,
            .pending,
            .rebooting,
            .rebuilding,
            .restoring,
            .starting,
            .stopped,
            .stopping,
            .suspended,
            .terminated,
            .terminating,
            .unhealthy,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .adminMaintenance: return "ADMIN_MAINTENANCE"
        case .available: return "AVAILABLE"
        case .error: return "ERROR"
        case .impaired: return "IMPAIRED"
        case .maintenance: return "MAINTENANCE"
        case .pending: return "PENDING"
        case .rebooting: return "REBOOTING"
        case .rebuilding: return "REBUILDING"
        case .restoring: return "RESTORING"
        case .starting: return "STARTING"
        case .stopped: return "STOPPED"
        case .stopping: return "STOPPING"
        case .suspended: return "SUSPENDED"
        case .terminated: return "TERMINATED"
        case .terminating: return "TERMINATING"
        case .unhealthy: return "UNHEALTHY"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WorkspaceState(rawValue: rawValue) ?? WorkspaceState.sdkUnknown(rawValue)
    }
}

extension WorkspacesDefaultRoleNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorkspacesDefaultRoleNotFoundException(message: \(String(describing: message)))"}
}

extension WorkspacesDefaultRoleNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WorkspacesDefaultRoleNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The workspaces_DefaultRole role could not be found. If this is the first time you are registering a directory, you
///          will need to create the workspaces_DefaultRole role before you can register a directory. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/workspaces-access-control.html#create-default-role">Creating the workspaces_DefaultRole Role</a>.</p>
public struct WorkspacesDefaultRoleNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct WorkspacesDefaultRoleNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension WorkspacesDefaultRoleNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkspacesIpGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupDesc
        case groupId
        case groupName
        case userRules
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupDesc = groupDesc {
            try encodeContainer.encode(groupDesc, forKey: .groupDesc)
        }
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let userRules = userRules {
            var userRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userRules)
            for iprulelist0 in userRules {
                try userRulesContainer.encode(iprulelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupDescDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupDesc)
        groupDesc = groupDescDecoded
        let userRulesContainer = try containerValues.decodeIfPresent([IpRuleItem?].self, forKey: .userRules)
        var userRulesDecoded0:[IpRuleItem]? = nil
        if let userRulesContainer = userRulesContainer {
            userRulesDecoded0 = [IpRuleItem]()
            for structure0 in userRulesContainer {
                if let structure0 = structure0 {
                    userRulesDecoded0?.append(structure0)
                }
            }
        }
        userRules = userRulesDecoded0
    }
}

extension WorkspacesIpGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorkspacesIpGroup(groupDesc: \(String(describing: groupDesc)), groupId: \(String(describing: groupId)), groupName: \(String(describing: groupName)), userRules: \(String(describing: userRules)))"}
}

/// <p>Describes an IP access control group.</p>
public struct WorkspacesIpGroup: Equatable {
    /// <p>The description of the group.</p>
    public let groupDesc: String?
    /// <p>The identifier of the group.</p>
    public let groupId: String?
    /// <p>The name of the group.</p>
    public let groupName: String?
    /// <p>The rules.</p>
    public let userRules: [IpRuleItem]?

    public init (
        groupDesc: String? = nil,
        groupId: String? = nil,
        groupName: String? = nil,
        userRules: [IpRuleItem]? = nil
    )
    {
        self.groupDesc = groupDesc
        self.groupId = groupId
        self.groupName = groupName
        self.userRules = userRules
    }
}
