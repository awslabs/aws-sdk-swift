// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation
import Logging

public class LexModelsV2Client {
    let client: SdkHttpClient
    let config: LexModelsV2ClientConfiguration
    let serviceName = "Lex Models V2"
    let encoder: RequestEncoder
    let decoder: ResponseDecoder

    public init(config: LexModelsV2ClientConfiguration) {
        client = SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.encoder = config.encoder ?? encoder
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    deinit {
        client.close()
    }

    public class LexModelsV2ClientConfiguration: ClientRuntime.Configuration, AWSClientConfiguration {

        public var region: String
        public var credentialsProvider: AWSCredentialsProvider
        public var signingRegion: String
        public var endpointResolver: EndpointResolver

        public let clientLogMode: ClientLogMode
        public let logger: LogAgent

        public init (
            credentialsProvider: AWSCredentialsProvider,
            endpointResolver: EndpointResolver,
            region: String,
            signingRegion: String,
            clientLogMode: ClientLogMode = .request,
            logger: LogAgent? = nil
        ) throws
        {
            self.credentialsProvider = credentialsProvider
            self.endpointResolver = endpointResolver
            self.region = region
            self.signingRegion = signingRegion
            self.clientLogMode = clientLogMode
            self.logger = logger ?? SwiftLogger(label: "LexModelsV2Client")
        }

        public convenience init(credentialsProvider: AWSCredentialsProvider) throws {
            let region = "us-east-1"
            let signingRegion = "us-east-1"
            let endpointResolver = DefaultEndpointResolver()
            try self.init(
                credentialsProvider: credentialsProvider,
                endpointResolver: endpointResolver,
                region: region,
                signingRegion: signingRegion
            )
        }

        public static func `default`() throws -> LexModelsV2ClientConfiguration {
            let awsCredsProvider = try AWSCredentialsProvider.fromEnv()
            return try LexModelsV2ClientConfiguration(credentialsProvider: awsCredsProvider)
        }
    }
}

public struct LexModelsV2ClientLogHandlerFactory: SDKLogHandlerFactory {
    public var label = "LexModelsV2Client"
    let logLevel: SDKLogLevel
    public func construct(label: String) -> LogHandler {
        var handler = StreamLogHandler.standardOutput(label: label)
        handler.logLevel = logLevel.toLoggerType()
        return handler
    }
    public init(logLevel: SDKLogLevel) {
        self.logLevel = logLevel
    }
}

extension LexModelsV2Client: LexModelsV2ClientProtocol {
    /// <p>Builds a bot, its intents, and its slot types into a specific
    ///          locale. A bot can be built into multiple locales. At runtime the locale
    ///          is used to choose a specific build of the bot.</p>
    public func buildBotLocale(input: BuildBotLocaleInput, completion: @escaping (SdkResult<BuildBotLocaleOutputResponse, BuildBotLocaleOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        guard let botVersion = input.botVersion else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botVersion unexpectedly nil"))))
            return
        }
        guard let localeId = input.localeId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component localeId unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)/botversions/\(botVersion)/botlocales/\(localeId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "buildBotLocale")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<BuildBotLocaleInput, BuildBotLocaleOutputResponse, BuildBotLocaleOutputError>(id: "buildBotLocale")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: BuildBotLocaleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: BuildBotLocaleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<BuildBotLocaleInput, BuildBotLocaleOutputResponse, BuildBotLocaleOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates an Amazon Lex conversational bot. </p>
    public func createBot(input: CreateBotInput, completion: @escaping (SdkResult<CreateBotOutputResponse, CreateBotOutputError>) -> Void)
    {
        let urlPath = "/bots"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createBot")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateBotInput, CreateBotOutputResponse, CreateBotOutputError>(id: "createBot")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateBotInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateBotInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateBotInput, CreateBotOutputResponse, CreateBotOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateBotInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates an alias for the specified version of a bot. Use an alias to
    ///          enable you to change the version of a bot without updating applications
    ///          that use the bot.</p>
    ///          <p>For example, you can create an alias called "PROD" that your
    ///          applications use to call the Amazon Lex bot. </p>
    public func createBotAlias(input: CreateBotAliasInput, completion: @escaping (SdkResult<CreateBotAliasOutputResponse, CreateBotAliasOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)/botaliases"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createBotAlias")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateBotAliasInput, CreateBotAliasOutputResponse, CreateBotAliasOutputError>(id: "createBotAlias")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateBotAliasInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateBotAliasInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateBotAliasInput, CreateBotAliasOutputResponse, CreateBotAliasOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateBotAliasInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a locale in the bot. The locale contains the intents and
    ///          slot types that the bot uses in conversations with users in the
    ///          specified language and locale. You must add a locale to a bot before
    ///          you can add intents and slot types to the bot.</p>
    public func createBotLocale(input: CreateBotLocaleInput, completion: @escaping (SdkResult<CreateBotLocaleOutputResponse, CreateBotLocaleOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        guard let botVersion = input.botVersion else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botVersion unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)/botversions/\(botVersion)/botlocales"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createBotLocale")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateBotLocaleInput, CreateBotLocaleOutputResponse, CreateBotLocaleOutputError>(id: "createBotLocale")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateBotLocaleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateBotLocaleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateBotLocaleInput, CreateBotLocaleOutputResponse, CreateBotLocaleOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateBotLocaleInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new version of the bot based on the <code>DRAFT</code>
    ///          version. If the <code>DRAFT</code> version of this resource hasn't
    ///          changed since you created the last version, Amazon Lex doesn't create a new
    ///          version, it returns the last created version.</p>
    ///          <p>When you create the first version of a bot, Amazon Lex sets the version
    ///          to 1. Subsequent versions increment by 1.</p>
    public func createBotVersion(input: CreateBotVersionInput, completion: @escaping (SdkResult<CreateBotVersionOutputResponse, CreateBotVersionOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)/botversions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createBotVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateBotVersionInput, CreateBotVersionOutputResponse, CreateBotVersionOutputError>(id: "createBotVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateBotVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateBotVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateBotVersionInput, CreateBotVersionOutputResponse, CreateBotVersionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateBotVersionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a zip archive containing the contents of a bot or a bot
    ///          locale. The archive contains a directory structure that contains JSON
    ///          files that define the bot.</p>
    ///          <p>You can create an archive that contains the complete definition of a
    ///          bot, or you can specify that the archive contain only the definition of
    ///          a single bot locale.</p>
    ///          <p>For more information about exporting bots, and about the structure
    ///          of the export archive, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/importing-exporting.html"> Importing and
    ///             exporting bots </a>
    ///          </p>
    public func createExport(input: CreateExportInput, completion: @escaping (SdkResult<CreateExportOutputResponse, CreateExportOutputError>) -> Void)
    {
        let urlPath = "/exports"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createExport")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateExportInput, CreateExportOutputResponse, CreateExportOutputError>(id: "createExport")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateExportInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateExportInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateExportInput, CreateExportOutputResponse, CreateExportOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateExportInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates an intent.</p>
    ///          <p>To define the interaction between the user and your bot, you define
    ///          one or more intents. For example, for a pizza ordering bot you would
    ///          create an <code>OrderPizza</code> intent.</p>
    ///          <p>When you create an intent, you must provide a name. You can
    ///          optionally provide the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Sample utterances. For example, "I want to order a pizza" and
    ///                "Can I order a pizza." You can't provide utterances for built-in
    ///                intents.</p>
    ///             </li>
    ///             <li>
    ///                <p>Information to be gathered. You specify slots for the
    ///                information that you bot requests from the user. You can specify
    ///                standard slot types, such as date and time, or custom slot types
    ///                for your application.</p>
    ///             </li>
    ///             <li>
    ///                <p>How the intent is fulfilled. You can provide a Lambda function
    ///                or configure the intent to return the intent information to your
    ///                client application. If you use a Lambda function, Amazon Lex invokes
    ///                the function when all of the intent information is
    ///                available.</p>
    ///             </li>
    ///             <li>
    ///                <p>A confirmation prompt to send to the user to confirm an
    ///                intent. For example, "Shall I order your pizza?"</p>
    ///             </li>
    ///             <li>
    ///                <p>A conclusion statement to send to the user after the intent is
    ///                fulfilled. For example, "I ordered your pizza."</p>
    ///             </li>
    ///             <li>
    ///                <p>A follow-up prompt that asks the user for additional activity.
    ///                For example, "Do you want a drink with your pizza?"</p>
    ///             </li>
    ///          </ul>
    public func createIntent(input: CreateIntentInput, completion: @escaping (SdkResult<CreateIntentOutputResponse, CreateIntentOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        guard let botVersion = input.botVersion else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botVersion unexpectedly nil"))))
            return
        }
        guard let localeId = input.localeId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component localeId unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)/botversions/\(botVersion)/botlocales/\(localeId)/intents"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createIntent")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateIntentInput, CreateIntentOutputResponse, CreateIntentOutputError>(id: "createIntent")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateIntentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateIntentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateIntentInput, CreateIntentOutputResponse, CreateIntentOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateIntentInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new resource policy with the specified policy
    ///          statements.</p>
    public func createResourcePolicy(input: CreateResourcePolicyInput, completion: @escaping (SdkResult<CreateResourcePolicyOutputResponse, CreateResourcePolicyOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/policy/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createResourcePolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateResourcePolicyInput, CreateResourcePolicyOutputResponse, CreateResourcePolicyOutputError>(id: "createResourcePolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateResourcePolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateResourcePolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateResourcePolicyInput, CreateResourcePolicyOutputResponse, CreateResourcePolicyOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateResourcePolicyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Adds a new resource policy statement to a bot or bot alias. If a
    ///          resource policy exists, the statement is added to the current resource
    ///          policy. If a policy doesn't exist, a new policy is created.</p>
    ///          <p>You can create a resource policy statement that allows cross-account
    ///          access.</p>
    public func createResourcePolicyStatement(input: CreateResourcePolicyStatementInput, completion: @escaping (SdkResult<CreateResourcePolicyStatementOutputResponse, CreateResourcePolicyStatementOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/policy/\(resourceArn)/statements"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createResourcePolicyStatement")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateResourcePolicyStatementInput, CreateResourcePolicyStatementOutputResponse, CreateResourcePolicyStatementOutputError>(id: "createResourcePolicyStatement")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateResourcePolicyStatementInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateResourcePolicyStatementInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateResourcePolicyStatementInput, CreateResourcePolicyStatementOutputResponse, CreateResourcePolicyStatementOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateResourcePolicyStatementInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a slot in an intent. A slot is a variable needed to fulfill
    ///          an intent. For example, an <code>OrderPizza</code> intent might need
    ///          slots for size, crust, and number of pizzas. For each slot, you define
    ///          one or more utterances that Amazon Lex uses to elicit a response from the
    ///          user. </p>
    public func createSlot(input: CreateSlotInput, completion: @escaping (SdkResult<CreateSlotOutputResponse, CreateSlotOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        guard let botVersion = input.botVersion else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botVersion unexpectedly nil"))))
            return
        }
        guard let localeId = input.localeId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component localeId unexpectedly nil"))))
            return
        }
        guard let intentId = input.intentId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component intentId unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)/botversions/\(botVersion)/botlocales/\(localeId)/intents/\(intentId)/slots"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createSlot")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateSlotInput, CreateSlotOutputResponse, CreateSlotOutputError>(id: "createSlot")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateSlotInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateSlotInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateSlotInput, CreateSlotOutputResponse, CreateSlotOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateSlotInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a custom slot type</p>
    ///          <p> To create a custom slot type, specify a name for the slot type and
    ///          a set of enumeration values, the values that a slot of this type can
    ///          assume. </p>
    public func createSlotType(input: CreateSlotTypeInput, completion: @escaping (SdkResult<CreateSlotTypeOutputResponse, CreateSlotTypeOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        guard let botVersion = input.botVersion else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botVersion unexpectedly nil"))))
            return
        }
        guard let localeId = input.localeId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component localeId unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)/botversions/\(botVersion)/botlocales/\(localeId)/slottypes"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createSlotType")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateSlotTypeInput, CreateSlotTypeOutputResponse, CreateSlotTypeOutputError>(id: "createSlotType")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateSlotTypeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateSlotTypeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateSlotTypeInput, CreateSlotTypeOutputResponse, CreateSlotTypeOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateSlotTypeInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a pre-signed S3 write URL that you use to upload the zip
    ///          archive when importing a bot or a bot locale. </p>
    public func createUploadUrl(input: CreateUploadUrlInput, completion: @escaping (SdkResult<CreateUploadUrlOutputResponse, CreateUploadUrlOutputError>) -> Void)
    {
        let urlPath = "/createuploadurl"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createUploadUrl")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateUploadUrlInput, CreateUploadUrlOutputResponse, CreateUploadUrlOutputError>(id: "createUploadUrl")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateUploadUrlInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateUploadUrlInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateUploadUrlInput, CreateUploadUrlOutputResponse, CreateUploadUrlOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes all versions of a bot, including the <code>Draft</code>
    ///          version. To delete a specific version, use the
    ///             <code>DeleteBotVersion</code> operation.</p>
    ///          <p>When you delete a bot, all of the resources contained in the bot are
    ///          also deleted. Deleting a bot removes all locales, intents, slot, and
    ///          slot types defined for the bot.</p>
    ///          <p>If a bot has an alias, the <code>DeleteBot</code> operation returns
    ///          a <code>ResourceInUseException</code> exception. If you want to delete
    ///          the bot and the alias, set the <code>skipResourceInUseCheck</code>
    ///          parameter to <code>true</code>.</p>
    public func deleteBot(input: DeleteBotInput, completion: @escaping (SdkResult<DeleteBotOutputResponse, DeleteBotOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteBot")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteBotInput, DeleteBotOutputResponse, DeleteBotOutputError>(id: "deleteBot")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteBotInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteBotInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteBotInput, DeleteBotOutputResponse, DeleteBotOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified bot alias.</p>
    public func deleteBotAlias(input: DeleteBotAliasInput, completion: @escaping (SdkResult<DeleteBotAliasOutputResponse, DeleteBotAliasOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        guard let botAliasId = input.botAliasId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botAliasId unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)/botaliases/\(botAliasId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteBotAlias")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteBotAliasInput, DeleteBotAliasOutputResponse, DeleteBotAliasOutputError>(id: "deleteBotAlias")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteBotAliasInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteBotAliasInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteBotAliasInput, DeleteBotAliasOutputResponse, DeleteBotAliasOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes a locale from a bot.</p>
    ///          <p>When you delete a locale, all intents, slots, and slot types defined
    ///          for the locale are also deleted.</p>
    public func deleteBotLocale(input: DeleteBotLocaleInput, completion: @escaping (SdkResult<DeleteBotLocaleOutputResponse, DeleteBotLocaleOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        guard let botVersion = input.botVersion else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botVersion unexpectedly nil"))))
            return
        }
        guard let localeId = input.localeId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component localeId unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)/botversions/\(botVersion)/botlocales/\(localeId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteBotLocale")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteBotLocaleInput, DeleteBotLocaleOutputResponse, DeleteBotLocaleOutputError>(id: "deleteBotLocale")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteBotLocaleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteBotLocaleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteBotLocaleInput, DeleteBotLocaleOutputResponse, DeleteBotLocaleOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a specific version of a bot. To delete all version of a bot,
    ///          use the <a>DeleteBot</a> operation.</p>
    public func deleteBotVersion(input: DeleteBotVersionInput, completion: @escaping (SdkResult<DeleteBotVersionOutputResponse, DeleteBotVersionOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        guard let botVersion = input.botVersion else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botVersion unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)/botversions/\(botVersion)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteBotVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteBotVersionInput, DeleteBotVersionOutputResponse, DeleteBotVersionOutputError>(id: "deleteBotVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteBotVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteBotVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteBotVersionInput, DeleteBotVersionOutputResponse, DeleteBotVersionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes a previous export and the associated files stored in an S3
    ///          bucket.</p>
    public func deleteExport(input: DeleteExportInput, completion: @escaping (SdkResult<DeleteExportOutputResponse, DeleteExportOutputError>) -> Void)
    {
        guard let exportId = input.exportId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component exportId unexpectedly nil"))))
            return
        }
        let urlPath = "/exports/\(exportId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteExport")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteExportInput, DeleteExportOutputResponse, DeleteExportOutputError>(id: "deleteExport")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteExportInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteExportInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteExportInput, DeleteExportOutputResponse, DeleteExportOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes a previous import and the associated file stored in an S3
    ///          bucket.</p>
    public func deleteImport(input: DeleteImportInput, completion: @escaping (SdkResult<DeleteImportOutputResponse, DeleteImportOutputError>) -> Void)
    {
        guard let importId = input.importId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component importId unexpectedly nil"))))
            return
        }
        let urlPath = "/imports/\(importId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteImport")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteImportInput, DeleteImportOutputResponse, DeleteImportOutputError>(id: "deleteImport")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteImportInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteImportInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteImportInput, DeleteImportOutputResponse, DeleteImportOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes the specified intent.</p>
    ///          <p>Deleting an intent also deletes the slots associated with the
    ///          intent.</p>
    public func deleteIntent(input: DeleteIntentInput, completion: @escaping (SdkResult<DeleteIntentOutputResponse, DeleteIntentOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        guard let botVersion = input.botVersion else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botVersion unexpectedly nil"))))
            return
        }
        guard let localeId = input.localeId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component localeId unexpectedly nil"))))
            return
        }
        guard let intentId = input.intentId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component intentId unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)/botversions/\(botVersion)/botlocales/\(localeId)/intents/\(intentId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteIntent")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteIntentInput, DeleteIntentOutputResponse, DeleteIntentOutputError>(id: "deleteIntent")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteIntentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteIntentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteIntentInput, DeleteIntentOutputResponse, DeleteIntentOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes an existing policy from a bot or bot alias. If the resource
    ///          doesn't have a policy attached, Amazon Lex returns an exception.</p>
    public func deleteResourcePolicy(input: DeleteResourcePolicyInput, completion: @escaping (SdkResult<DeleteResourcePolicyOutputResponse, DeleteResourcePolicyOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/policy/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteResourcePolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteResourcePolicyInput, DeleteResourcePolicyOutputResponse, DeleteResourcePolicyOutputError>(id: "deleteResourcePolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteResourcePolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteResourcePolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteResourcePolicyInput, DeleteResourcePolicyOutputResponse, DeleteResourcePolicyOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a policy statement from a resource policy. If you delete the
    ///          last statement from a policy, the policy is deleted. If you specify a
    ///          statement ID that doesn't exist in the policy, or if the bot or bot
    ///          alias doesn't have a policy attached, Amazon Lex returns an
    ///          exception.</p>
    public func deleteResourcePolicyStatement(input: DeleteResourcePolicyStatementInput, completion: @escaping (SdkResult<DeleteResourcePolicyStatementOutputResponse, DeleteResourcePolicyStatementOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        guard let statementId = input.statementId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component statementId unexpectedly nil"))))
            return
        }
        let urlPath = "/policy/\(resourceArn)/statements/\(statementId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteResourcePolicyStatement")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteResourcePolicyStatementInput, DeleteResourcePolicyStatementOutputResponse, DeleteResourcePolicyStatementOutputError>(id: "deleteResourcePolicyStatement")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteResourcePolicyStatementInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteResourcePolicyStatementInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteResourcePolicyStatementInput, DeleteResourcePolicyStatementOutputResponse, DeleteResourcePolicyStatementOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified slot from an intent.</p>
    public func deleteSlot(input: DeleteSlotInput, completion: @escaping (SdkResult<DeleteSlotOutputResponse, DeleteSlotOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        guard let botVersion = input.botVersion else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botVersion unexpectedly nil"))))
            return
        }
        guard let localeId = input.localeId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component localeId unexpectedly nil"))))
            return
        }
        guard let intentId = input.intentId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component intentId unexpectedly nil"))))
            return
        }
        guard let slotId = input.slotId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component slotId unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)/botversions/\(botVersion)/botlocales/\(localeId)/intents/\(intentId)/slots/\(slotId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteSlot")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteSlotInput, DeleteSlotOutputResponse, DeleteSlotOutputError>(id: "deleteSlot")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteSlotInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteSlotInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteSlotInput, DeleteSlotOutputResponse, DeleteSlotOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a slot type from a bot locale.</p>
    ///          <p>If a slot is using the slot type, Amazon Lex throws a
    ///             <code>ResourceInUseException</code> exception. To avoid the
    ///          exception, set the <code>skipResourceInUseCheck</code> parameter to
    ///             <code>true</code>.</p>
    public func deleteSlotType(input: DeleteSlotTypeInput, completion: @escaping (SdkResult<DeleteSlotTypeOutputResponse, DeleteSlotTypeOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        guard let botVersion = input.botVersion else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botVersion unexpectedly nil"))))
            return
        }
        guard let localeId = input.localeId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component localeId unexpectedly nil"))))
            return
        }
        guard let slotTypeId = input.slotTypeId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component slotTypeId unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)/botversions/\(botVersion)/botlocales/\(localeId)/slottypes/\(slotTypeId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteSlotType")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteSlotTypeInput, DeleteSlotTypeOutputResponse, DeleteSlotTypeOutputError>(id: "deleteSlotType")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteSlotTypeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteSlotTypeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteSlotTypeInput, DeleteSlotTypeOutputResponse, DeleteSlotTypeOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provides metadata information about a bot. </p>
    public func describeBot(input: DescribeBotInput, completion: @escaping (SdkResult<DescribeBotOutputResponse, DescribeBotOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeBot")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeBotInput, DescribeBotOutputResponse, DescribeBotOutputError>(id: "describeBot")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeBotInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeBotInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeBotInput, DescribeBotOutputResponse, DescribeBotOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Get information about a specific bot alias.</p>
    public func describeBotAlias(input: DescribeBotAliasInput, completion: @escaping (SdkResult<DescribeBotAliasOutputResponse, DescribeBotAliasOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        guard let botAliasId = input.botAliasId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botAliasId unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)/botaliases/\(botAliasId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeBotAlias")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeBotAliasInput, DescribeBotAliasOutputResponse, DescribeBotAliasOutputError>(id: "describeBotAlias")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeBotAliasInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeBotAliasInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeBotAliasInput, DescribeBotAliasOutputResponse, DescribeBotAliasOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes the settings that a bot has for a specific locale. </p>
    public func describeBotLocale(input: DescribeBotLocaleInput, completion: @escaping (SdkResult<DescribeBotLocaleOutputResponse, DescribeBotLocaleOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        guard let botVersion = input.botVersion else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botVersion unexpectedly nil"))))
            return
        }
        guard let localeId = input.localeId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component localeId unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)/botversions/\(botVersion)/botlocales/\(localeId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeBotLocale")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeBotLocaleInput, DescribeBotLocaleOutputResponse, DescribeBotLocaleOutputError>(id: "describeBotLocale")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeBotLocaleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeBotLocaleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeBotLocaleInput, DescribeBotLocaleOutputResponse, DescribeBotLocaleOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provides metadata about a version of a bot.</p>
    public func describeBotVersion(input: DescribeBotVersionInput, completion: @escaping (SdkResult<DescribeBotVersionOutputResponse, DescribeBotVersionOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        guard let botVersion = input.botVersion else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botVersion unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)/botversions/\(botVersion)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeBotVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeBotVersionInput, DescribeBotVersionOutputResponse, DescribeBotVersionOutputError>(id: "describeBotVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeBotVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeBotVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeBotVersionInput, DescribeBotVersionOutputResponse, DescribeBotVersionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about a specific export.</p>
    public func describeExport(input: DescribeExportInput, completion: @escaping (SdkResult<DescribeExportOutputResponse, DescribeExportOutputError>) -> Void)
    {
        guard let exportId = input.exportId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component exportId unexpectedly nil"))))
            return
        }
        let urlPath = "/exports/\(exportId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeExport")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeExportInput, DescribeExportOutputResponse, DescribeExportOutputError>(id: "describeExport")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeExportInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeExportInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeExportInput, DescribeExportOutputResponse, DescribeExportOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about a specific import.</p>
    public func describeImport(input: DescribeImportInput, completion: @escaping (SdkResult<DescribeImportOutputResponse, DescribeImportOutputError>) -> Void)
    {
        guard let importId = input.importId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component importId unexpectedly nil"))))
            return
        }
        let urlPath = "/imports/\(importId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeImport")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeImportInput, DescribeImportOutputResponse, DescribeImportOutputError>(id: "describeImport")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeImportInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeImportInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeImportInput, DescribeImportOutputResponse, DescribeImportOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns metadata about an intent.</p>
    public func describeIntent(input: DescribeIntentInput, completion: @escaping (SdkResult<DescribeIntentOutputResponse, DescribeIntentOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        guard let botVersion = input.botVersion else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botVersion unexpectedly nil"))))
            return
        }
        guard let localeId = input.localeId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component localeId unexpectedly nil"))))
            return
        }
        guard let intentId = input.intentId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component intentId unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)/botversions/\(botVersion)/botlocales/\(localeId)/intents/\(intentId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeIntent")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeIntentInput, DescribeIntentOutputResponse, DescribeIntentOutputError>(id: "describeIntent")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeIntentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeIntentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeIntentInput, DescribeIntentOutputResponse, DescribeIntentOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets the resource policy and policy revision for a bot or bot
    ///          alias.</p>
    public func describeResourcePolicy(input: DescribeResourcePolicyInput, completion: @escaping (SdkResult<DescribeResourcePolicyOutputResponse, DescribeResourcePolicyOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/policy/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeResourcePolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeResourcePolicyInput, DescribeResourcePolicyOutputResponse, DescribeResourcePolicyOutputError>(id: "describeResourcePolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeResourcePolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeResourcePolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeResourcePolicyInput, DescribeResourcePolicyOutputResponse, DescribeResourcePolicyOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets metadata information about a slot.</p>
    public func describeSlot(input: DescribeSlotInput, completion: @escaping (SdkResult<DescribeSlotOutputResponse, DescribeSlotOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        guard let botVersion = input.botVersion else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botVersion unexpectedly nil"))))
            return
        }
        guard let localeId = input.localeId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component localeId unexpectedly nil"))))
            return
        }
        guard let intentId = input.intentId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component intentId unexpectedly nil"))))
            return
        }
        guard let slotId = input.slotId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component slotId unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)/botversions/\(botVersion)/botlocales/\(localeId)/intents/\(intentId)/slots/\(slotId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeSlot")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeSlotInput, DescribeSlotOutputResponse, DescribeSlotOutputError>(id: "describeSlot")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeSlotInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeSlotInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeSlotInput, DescribeSlotOutputResponse, DescribeSlotOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets metadata information about a slot type.</p>
    public func describeSlotType(input: DescribeSlotTypeInput, completion: @escaping (SdkResult<DescribeSlotTypeOutputResponse, DescribeSlotTypeOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        guard let botVersion = input.botVersion else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botVersion unexpectedly nil"))))
            return
        }
        guard let localeId = input.localeId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component localeId unexpectedly nil"))))
            return
        }
        guard let slotTypeId = input.slotTypeId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component slotTypeId unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)/botversions/\(botVersion)/botlocales/\(localeId)/slottypes/\(slotTypeId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeSlotType")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeSlotTypeInput, DescribeSlotTypeOutputResponse, DescribeSlotTypeOutputError>(id: "describeSlotType")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeSlotTypeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeSlotTypeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeSlotTypeInput, DescribeSlotTypeOutputResponse, DescribeSlotTypeOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a list of aliases for the specified bot.</p>
    public func listBotAliases(input: ListBotAliasesInput, completion: @escaping (SdkResult<ListBotAliasesOutputResponse, ListBotAliasesOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)/botaliases"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listBotAliases")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListBotAliasesInput, ListBotAliasesOutputResponse, ListBotAliasesOutputError>(id: "listBotAliases")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListBotAliasesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListBotAliasesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListBotAliasesInput, ListBotAliasesOutputResponse, ListBotAliasesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ListBotAliasesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a list of locales for the specified bot.</p>
    public func listBotLocales(input: ListBotLocalesInput, completion: @escaping (SdkResult<ListBotLocalesOutputResponse, ListBotLocalesOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        guard let botVersion = input.botVersion else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botVersion unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)/botversions/\(botVersion)/botlocales"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listBotLocales")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListBotLocalesInput, ListBotLocalesOutputResponse, ListBotLocalesOutputError>(id: "listBotLocales")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListBotLocalesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListBotLocalesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListBotLocalesInput, ListBotLocalesOutputResponse, ListBotLocalesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ListBotLocalesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about all of the versions of a bot.</p>
    ///          <p>The <code>ListBotVersions</code> operation returns a summary of each
    ///          version of a bot. For example, if a bot has three numbered versions,
    ///          the <code>ListBotVersions</code> operation returns for summaries, one
    ///          for each numbered version and one for the <code>DRAFT</code>
    ///          version.</p>
    ///          <p>The <code>ListBotVersions</code> operation always returns at least
    ///          one version, the <code>DRAFT</code> version.</p>
    public func listBotVersions(input: ListBotVersionsInput, completion: @escaping (SdkResult<ListBotVersionsOutputResponse, ListBotVersionsOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)/botversions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listBotVersions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListBotVersionsInput, ListBotVersionsOutputResponse, ListBotVersionsOutputError>(id: "listBotVersions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListBotVersionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListBotVersionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListBotVersionsInput, ListBotVersionsOutputResponse, ListBotVersionsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ListBotVersionsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a list of available bots.</p>
    public func listBots(input: ListBotsInput, completion: @escaping (SdkResult<ListBotsOutputResponse, ListBotsOutputError>) -> Void)
    {
        let urlPath = "/bots"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listBots")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListBotsInput, ListBotsOutputResponse, ListBotsOutputError>(id: "listBots")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListBotsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListBotsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListBotsInput, ListBotsOutputResponse, ListBotsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ListBotsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a list of built-in intents provided by Amazon Lex that you can use
    ///          in your bot. </p>
    ///          <p>To use a built-in intent as a the base for your own intent, include
    ///          the built-in intent signature in the <code>parentIntentSignature</code>
    ///          parameter when you call the <code>CreateIntent</code> operation. For
    ///          more information, see <a>CreateIntent</a>.</p>
    public func listBuiltInIntents(input: ListBuiltInIntentsInput, completion: @escaping (SdkResult<ListBuiltInIntentsOutputResponse, ListBuiltInIntentsOutputError>) -> Void)
    {
        guard let localeId = input.localeId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component localeId unexpectedly nil"))))
            return
        }
        let urlPath = "/builtins/locales/\(localeId)/intents"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listBuiltInIntents")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListBuiltInIntentsInput, ListBuiltInIntentsOutputResponse, ListBuiltInIntentsOutputError>(id: "listBuiltInIntents")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListBuiltInIntentsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListBuiltInIntentsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListBuiltInIntentsInput, ListBuiltInIntentsOutputResponse, ListBuiltInIntentsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ListBuiltInIntentsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a list of built-in slot types that meet the specified
    ///          criteria.</p>
    public func listBuiltInSlotTypes(input: ListBuiltInSlotTypesInput, completion: @escaping (SdkResult<ListBuiltInSlotTypesOutputResponse, ListBuiltInSlotTypesOutputError>) -> Void)
    {
        guard let localeId = input.localeId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component localeId unexpectedly nil"))))
            return
        }
        let urlPath = "/builtins/locales/\(localeId)/slottypes"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listBuiltInSlotTypes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListBuiltInSlotTypesInput, ListBuiltInSlotTypesOutputResponse, ListBuiltInSlotTypesOutputError>(id: "listBuiltInSlotTypes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListBuiltInSlotTypesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListBuiltInSlotTypesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListBuiltInSlotTypesInput, ListBuiltInSlotTypesOutputResponse, ListBuiltInSlotTypesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ListBuiltInSlotTypesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the exports for a bot or bot locale. Exports are kept in the list for 7
    ///          days.</p>
    public func listExports(input: ListExportsInput, completion: @escaping (SdkResult<ListExportsOutputResponse, ListExportsOutputError>) -> Void)
    {
        let urlPath = "/exports"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listExports")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListExportsInput, ListExportsOutputResponse, ListExportsOutputError>(id: "listExports")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListExportsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListExportsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListExportsInput, ListExportsOutputResponse, ListExportsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ListExportsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the imports for a bot or bot locale. Imports are kept in the list for 7
    ///          days.</p>
    public func listImports(input: ListImportsInput, completion: @escaping (SdkResult<ListImportsOutputResponse, ListImportsOutputError>) -> Void)
    {
        let urlPath = "/imports"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listImports")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListImportsInput, ListImportsOutputResponse, ListImportsOutputError>(id: "listImports")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListImportsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListImportsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListImportsInput, ListImportsOutputResponse, ListImportsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ListImportsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Get a list of intents that meet the specified criteria.</p>
    public func listIntents(input: ListIntentsInput, completion: @escaping (SdkResult<ListIntentsOutputResponse, ListIntentsOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        guard let botVersion = input.botVersion else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botVersion unexpectedly nil"))))
            return
        }
        guard let localeId = input.localeId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component localeId unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)/botversions/\(botVersion)/botlocales/\(localeId)/intents"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listIntents")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListIntentsInput, ListIntentsOutputResponse, ListIntentsOutputError>(id: "listIntents")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListIntentsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListIntentsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListIntentsInput, ListIntentsOutputResponse, ListIntentsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ListIntentsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a list of slot types that match the specified criteria.</p>
    public func listSlotTypes(input: ListSlotTypesInput, completion: @escaping (SdkResult<ListSlotTypesOutputResponse, ListSlotTypesOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        guard let botVersion = input.botVersion else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botVersion unexpectedly nil"))))
            return
        }
        guard let localeId = input.localeId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component localeId unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)/botversions/\(botVersion)/botlocales/\(localeId)/slottypes"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listSlotTypes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListSlotTypesInput, ListSlotTypesOutputResponse, ListSlotTypesOutputError>(id: "listSlotTypes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListSlotTypesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListSlotTypesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListSlotTypesInput, ListSlotTypesOutputResponse, ListSlotTypesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ListSlotTypesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a list of slots that match the specified criteria.</p>
    public func listSlots(input: ListSlotsInput, completion: @escaping (SdkResult<ListSlotsOutputResponse, ListSlotsOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        guard let botVersion = input.botVersion else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botVersion unexpectedly nil"))))
            return
        }
        guard let localeId = input.localeId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component localeId unexpectedly nil"))))
            return
        }
        guard let intentId = input.intentId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component intentId unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)/botversions/\(botVersion)/botlocales/\(localeId)/intents/\(intentId)/slots"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listSlots")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListSlotsInput, ListSlotsOutputResponse, ListSlotsOutputError>(id: "listSlots")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListSlotsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListSlotsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListSlotsInput, ListSlotsOutputResponse, ListSlotsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ListSlotsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a list of tags associated with a resource. Only bots, bot
    ///          aliases, and bot channels can have tags associated with them.</p>
    public func listTagsForResource(input: ListTagsForResourceInput, completion: @escaping (SdkResult<ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>) -> Void)
    {
        guard let resourceARN = input.resourceARN else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceARN unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(resourceARN)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTagsForResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(id: "listTagsForResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Starts importing a bot or bot locale from a zip archive that you
    ///          uploaded to an S3 bucket.</p>
    public func startImport(input: StartImportInput, completion: @escaping (SdkResult<StartImportOutputResponse, StartImportOutputError>) -> Void)
    {
        let urlPath = "/imports"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "startImport")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StartImportInput, StartImportOutputResponse, StartImportOutputError>(id: "startImport")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StartImportInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StartImportInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StartImportInput, StartImportOutputResponse, StartImportOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: StartImportInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Adds the specified tags to the specified resource. If a tag key
    ///          already exists, the existing value is replaced with the new
    ///          value.</p>
    public func tagResource(input: TagResourceInput, completion: @escaping (SdkResult<TagResourceOutputResponse, TagResourceOutputError>) -> Void)
    {
        guard let resourceARN = input.resourceARN else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceARN unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(resourceARN)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "tagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(id: "tagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes tags from a bot, bot alias, or bot channel.</p>
    public func untagResource(input: UntagResourceInput, completion: @escaping (SdkResult<UntagResourceOutputResponse, UntagResourceOutputError>) -> Void)
    {
        guard let resourceARN = input.resourceARN else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceARN unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(resourceARN)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "untagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(id: "untagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the configuration of an existing bot. </p>
    public func updateBot(input: UpdateBotInput, completion: @escaping (SdkResult<UpdateBotOutputResponse, UpdateBotOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateBot")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateBotInput, UpdateBotOutputResponse, UpdateBotOutputError>(id: "updateBot")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateBotInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateBotInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateBotInput, UpdateBotOutputResponse, UpdateBotOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateBotInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the configuration of an existing bot alias.</p>
    public func updateBotAlias(input: UpdateBotAliasInput, completion: @escaping (SdkResult<UpdateBotAliasOutputResponse, UpdateBotAliasOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        guard let botAliasId = input.botAliasId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botAliasId unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)/botaliases/\(botAliasId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateBotAlias")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateBotAliasInput, UpdateBotAliasOutputResponse, UpdateBotAliasOutputError>(id: "updateBotAlias")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateBotAliasInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateBotAliasInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateBotAliasInput, UpdateBotAliasOutputResponse, UpdateBotAliasOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateBotAliasInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the settings that a bot has for a specific locale.</p>
    public func updateBotLocale(input: UpdateBotLocaleInput, completion: @escaping (SdkResult<UpdateBotLocaleOutputResponse, UpdateBotLocaleOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        guard let botVersion = input.botVersion else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botVersion unexpectedly nil"))))
            return
        }
        guard let localeId = input.localeId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component localeId unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)/botversions/\(botVersion)/botlocales/\(localeId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateBotLocale")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateBotLocaleInput, UpdateBotLocaleOutputResponse, UpdateBotLocaleOutputError>(id: "updateBotLocale")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateBotLocaleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateBotLocaleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateBotLocaleInput, UpdateBotLocaleOutputResponse, UpdateBotLocaleOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateBotLocaleInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the password used to encrypt an export zip archive.</p>
    public func updateExport(input: UpdateExportInput, completion: @escaping (SdkResult<UpdateExportOutputResponse, UpdateExportOutputError>) -> Void)
    {
        guard let exportId = input.exportId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component exportId unexpectedly nil"))))
            return
        }
        let urlPath = "/exports/\(exportId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateExport")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateExportInput, UpdateExportOutputResponse, UpdateExportOutputError>(id: "updateExport")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateExportInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateExportInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateExportInput, UpdateExportOutputResponse, UpdateExportOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateExportInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the settings for an intent.</p>
    public func updateIntent(input: UpdateIntentInput, completion: @escaping (SdkResult<UpdateIntentOutputResponse, UpdateIntentOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        guard let botVersion = input.botVersion else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botVersion unexpectedly nil"))))
            return
        }
        guard let localeId = input.localeId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component localeId unexpectedly nil"))))
            return
        }
        guard let intentId = input.intentId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component intentId unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)/botversions/\(botVersion)/botlocales/\(localeId)/intents/\(intentId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateIntent")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateIntentInput, UpdateIntentOutputResponse, UpdateIntentOutputError>(id: "updateIntent")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateIntentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateIntentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateIntentInput, UpdateIntentOutputResponse, UpdateIntentOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateIntentInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Replaces the existing resource policy for a bot or bot alias with a
    ///          new one. If the policy doesn't exist, Amazon Lex returns an
    ///          exception.</p>
    public func updateResourcePolicy(input: UpdateResourcePolicyInput, completion: @escaping (SdkResult<UpdateResourcePolicyOutputResponse, UpdateResourcePolicyOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/policy/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateResourcePolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateResourcePolicyInput, UpdateResourcePolicyOutputResponse, UpdateResourcePolicyOutputError>(id: "updateResourcePolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateResourcePolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateResourcePolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateResourcePolicyInput, UpdateResourcePolicyOutputResponse, UpdateResourcePolicyOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateResourcePolicyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the settings for a slot.</p>
    public func updateSlot(input: UpdateSlotInput, completion: @escaping (SdkResult<UpdateSlotOutputResponse, UpdateSlotOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        guard let botVersion = input.botVersion else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botVersion unexpectedly nil"))))
            return
        }
        guard let localeId = input.localeId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component localeId unexpectedly nil"))))
            return
        }
        guard let intentId = input.intentId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component intentId unexpectedly nil"))))
            return
        }
        guard let slotId = input.slotId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component slotId unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)/botversions/\(botVersion)/botlocales/\(localeId)/intents/\(intentId)/slots/\(slotId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateSlot")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateSlotInput, UpdateSlotOutputResponse, UpdateSlotOutputError>(id: "updateSlot")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateSlotInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateSlotInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateSlotInput, UpdateSlotOutputResponse, UpdateSlotOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateSlotInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the configuration of an existing slot type.</p>
    public func updateSlotType(input: UpdateSlotTypeInput, completion: @escaping (SdkResult<UpdateSlotTypeOutputResponse, UpdateSlotTypeOutputError>) -> Void)
    {
        guard let botId = input.botId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botId unexpectedly nil"))))
            return
        }
        guard let botVersion = input.botVersion else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botVersion unexpectedly nil"))))
            return
        }
        guard let localeId = input.localeId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component localeId unexpectedly nil"))))
            return
        }
        guard let slotTypeId = input.slotTypeId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component slotTypeId unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botId)/botversions/\(botVersion)/botlocales/\(localeId)/slottypes/\(slotTypeId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateSlotType")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models-v2-lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateSlotTypeInput, UpdateSlotTypeOutputResponse, UpdateSlotTypeOutputError>(id: "updateSlotType")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateSlotTypeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateSlotTypeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateSlotTypeInput, UpdateSlotTypeOutputResponse, UpdateSlotTypeOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateSlotTypeInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
