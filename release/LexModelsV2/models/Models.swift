// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AudioLogDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Bucket
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(S3BucketLogDestination.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
    }
}

extension AudioLogDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AudioLogDestination(s3Bucket: \(String(describing: s3Bucket)))"}
}

/// <p>The location of audio log files collected when conversation logging
///          is enabled for a bot.</p>
public struct AudioLogDestination: Equatable {
    /// <p>The Amazon S3 bucket where the audio log files are stored. The IAM
    ///          role specified in the <code>roleArn</code> parameter of the <a>CreateBot</a> operation must have permission to write to
    ///          this bucket.</p>
    public let s3Bucket: S3BucketLogDestination?

    public init (
        s3Bucket: S3BucketLogDestination? = nil
    )
    {
        self.s3Bucket = s3Bucket
    }
}

extension AudioLogSetting: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destination
        case enabled
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(AudioLogDestination.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension AudioLogSetting: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AudioLogSetting(destination: \(String(describing: destination)), enabled: \(String(describing: enabled)))"}
}

/// <p>Settings for logging audio of conversations between Amazon Lex and a
///          user. You specify whether to log audio and the Amazon S3 bucket where
///          the audio file is stored.</p>
public struct AudioLogSetting: Equatable {
    /// <p>The location of audio log files collected when conversation logging
    ///          is enabled for a bot.</p>
    public let destination: AudioLogDestination?
    /// <p>Determines whether audio logging in enabled for the bot.</p>
    public let enabled: Bool

    public init (
        destination: AudioLogDestination? = nil,
        enabled: Bool = false
    )
    {
        self.destination = destination
        self.enabled = enabled
    }
}

extension BotAliasHistoryEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case botVersion
        case endDate
        case startDate
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botVersion = botVersion {
            try encodeContainer.encode(botVersion, forKey: .botVersion)
        }
        if let endDate = endDate {
            try encodeContainer.encode(endDate.timeIntervalSince1970, forKey: .endDate)
        }
        if let startDate = startDate {
            try encodeContainer.encode(startDate.timeIntervalSince1970, forKey: .startDate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endDate)
        endDate = endDateDecoded
    }
}

extension BotAliasHistoryEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BotAliasHistoryEvent(botVersion: \(String(describing: botVersion)), endDate: \(String(describing: endDate)), startDate: \(String(describing: startDate)))"}
}

/// <p>Provides a record of an event that affects a bot alias. For example,
///          when the version of a bot that the alias points to changes.</p>
public struct BotAliasHistoryEvent: Equatable {
    /// <p>The version of the bot that was used in the event. </p>
    public let botVersion: String?
    /// <p>The date and time that the event ended.</p>
    public let endDate: Date?
    /// <p>The date and time that the event started.</p>
    public let startDate: Date?

    public init (
        botVersion: String? = nil,
        endDate: Date? = nil,
        startDate: Date? = nil
    )
    {
        self.botVersion = botVersion
        self.endDate = endDate
        self.startDate = startDate
    }
}

extension BotAliasLocaleSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case codeHookSpecification
        case enabled
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeHookSpecification = codeHookSpecification {
            try encodeContainer.encode(codeHookSpecification, forKey: .codeHookSpecification)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let codeHookSpecificationDecoded = try containerValues.decodeIfPresent(CodeHookSpecification.self, forKey: .codeHookSpecification)
        codeHookSpecification = codeHookSpecificationDecoded
    }
}

extension BotAliasLocaleSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BotAliasLocaleSettings(codeHookSpecification: \(String(describing: codeHookSpecification)), enabled: \(String(describing: enabled)))"}
}

/// <p>Specifies settings that are unique to a locale. For example, you can
///          use different Lambda function depending on the bot's locale.</p>
public struct BotAliasLocaleSettings: Equatable {
    /// <p>Specifies the Lambda function that should be used in the
    ///          locale.</p>
    public let codeHookSpecification: CodeHookSpecification?
    /// <p>Determines whether the locale is enabled for the bot. If the value
    ///          is <code>false</code>, the locale isn't available for use.</p>
    public let enabled: Bool

    public init (
        codeHookSpecification: CodeHookSpecification? = nil,
        enabled: Bool = false
    )
    {
        self.codeHookSpecification = codeHookSpecification
        self.enabled = enabled
    }
}

public enum BotAliasStatus {
    case available
    case creating
    case deleting
    case failed
    case sdkUnknown(String)
}

extension BotAliasStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BotAliasStatus] {
        return [
            .available,
            .creating,
            .deleting,
            .failed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "Available"
        case .creating: return "Creating"
        case .deleting: return "Deleting"
        case .failed: return "Failed"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BotAliasStatus(rawValue: rawValue) ?? BotAliasStatus.sdkUnknown(rawValue)
    }
}

extension BotAliasSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case botAliasId
        case botAliasName
        case botAliasStatus
        case botVersion
        case creationDateTime
        case description
        case lastUpdatedDateTime
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botAliasId = botAliasId {
            try encodeContainer.encode(botAliasId, forKey: .botAliasId)
        }
        if let botAliasName = botAliasName {
            try encodeContainer.encode(botAliasName, forKey: .botAliasName)
        }
        if let botAliasStatus = botAliasStatus {
            try encodeContainer.encode(botAliasStatus.rawValue, forKey: .botAliasStatus)
        }
        if let botVersion = botVersion {
            try encodeContainer.encode(botVersion, forKey: .botVersion)
        }
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botAliasIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botAliasId)
        botAliasId = botAliasIdDecoded
        let botAliasNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botAliasName)
        botAliasName = botAliasNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let botAliasStatusDecoded = try containerValues.decodeIfPresent(BotAliasStatus.self, forKey: .botAliasStatus)
        botAliasStatus = botAliasStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension BotAliasSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BotAliasSummary(botAliasId: \(String(describing: botAliasId)), botAliasName: \(String(describing: botAliasName)), botAliasStatus: \(String(describing: botAliasStatus)), botVersion: \(String(describing: botVersion)), creationDateTime: \(String(describing: creationDateTime)), description: \(String(describing: description)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)))"}
}

/// <p>Summary information about bot aliases returned from the <a>ListBotAliases</a> operation.</p>
public struct BotAliasSummary: Equatable {
    /// <p>The unique identifier assigned to the bot alias. You can use this ID
    ///          to get detailed information about the alias using the <a>DescribeBotAlias</a> operation.</p>
    public let botAliasId: String?
    /// <p>The name of the bot alias.</p>
    public let botAliasName: String?
    /// <p>The current state of the bot alias. If the status is
    ///             <code>Available</code>, the alias is ready for use.</p>
    public let botAliasStatus: BotAliasStatus?
    /// <p>The version of the bot that the bot alias references.</p>
    public let botVersion: String?
    /// <p>A timestamp of the date and time that the bot alias was
    ///          created.</p>
    public let creationDateTime: Date?
    /// <p>The description of the bot alias.</p>
    public let description: String?
    /// <p>A timestamp of the date and time that the bot alias was last
    ///          updated.</p>
    public let lastUpdatedDateTime: Date?

    public init (
        botAliasId: String? = nil,
        botAliasName: String? = nil,
        botAliasStatus: BotAliasStatus? = nil,
        botVersion: String? = nil,
        creationDateTime: Date? = nil,
        description: String? = nil,
        lastUpdatedDateTime: Date? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botAliasName = botAliasName
        self.botAliasStatus = botAliasStatus
        self.botVersion = botVersion
        self.creationDateTime = creationDateTime
        self.description = description
        self.lastUpdatedDateTime = lastUpdatedDateTime
    }
}

extension BotExportSpecification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case botId
        case botVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botId = botId {
            try encodeContainer.encode(botId, forKey: .botId)
        }
        if let botVersion = botVersion {
            try encodeContainer.encode(botVersion, forKey: .botVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
    }
}

extension BotExportSpecification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BotExportSpecification(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)))"}
}

/// <p>Provided the identity of a the bot that was exported.</p>
public struct BotExportSpecification: Equatable {
    /// <p>The identifier of the bot assigned by Amazon Lex.</p>
    public let botId: String?
    /// <p>The version of the bot that was exported. This will be either
    ///             <code>DRAFT</code> or the version number.</p>
    public let botVersion: String?

    public init (
        botId: String? = nil,
        botVersion: String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
    }
}

extension BotFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(BotFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(BotFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension BotFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BotFilter(name: \(String(describing: name)), operator: \(String(describing: `operator`)), values: \(String(describing: values)))"}
}

/// <p>Filters the responses returned by the <code>ListBots</code>
///          operation.</p>
public struct BotFilter: Equatable {
    /// <p>The operator to use for the filter. Specify <code>EQ</code> when the
    ///             <code>ListBots</code> operation should return only aliases that
    ///          equal the specified value. Specify <code>CO</code> when the
    ///             <code>ListBots</code> operation should return aliases that contain
    ///          the specified value.</p>
    public let `operator`: BotFilterOperator?
    /// <p>The name of the field to filter the list of bots.</p>
    public let name: BotFilterName?
    /// <p>The value to use for filtering the list of bots.</p>
    public let values: [String]?

    public init (
        `operator`: BotFilterOperator? = nil,
        name: BotFilterName? = nil,
        values: [String]? = nil
    )
    {
        self.`operator` = `operator`
        self.name = name
        self.values = values
    }
}

public enum BotFilterName {
    case botname
    case sdkUnknown(String)
}

extension BotFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BotFilterName] {
        return [
            .botname,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .botname: return "BotName"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BotFilterName(rawValue: rawValue) ?? BotFilterName.sdkUnknown(rawValue)
    }
}

public enum BotFilterOperator {
    case contains
    case equals
    case sdkUnknown(String)
}

extension BotFilterOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BotFilterOperator] {
        return [
            .contains,
            .equals,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .contains: return "CO"
        case .equals: return "EQ"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BotFilterOperator(rawValue: rawValue) ?? BotFilterOperator.sdkUnknown(rawValue)
    }
}

extension BotImportSpecification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case botName
        case botTags
        case dataPrivacy
        case idleSessionTTLInSeconds
        case roleArn
        case testBotAliasTags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botName = botName {
            try encodeContainer.encode(botName, forKey: .botName)
        }
        if let botTags = botTags {
            var botTagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .botTags)
            for (dictKey0, tagmap0) in botTags {
                try botTagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let dataPrivacy = dataPrivacy {
            try encodeContainer.encode(dataPrivacy, forKey: .dataPrivacy)
        }
        if let idleSessionTTLInSeconds = idleSessionTTLInSeconds {
            try encodeContainer.encode(idleSessionTTLInSeconds, forKey: .idleSessionTTLInSeconds)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let testBotAliasTags = testBotAliasTags {
            var testBotAliasTagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .testBotAliasTags)
            for (dictKey0, tagmap0) in testBotAliasTags {
                try testBotAliasTagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botName)
        botName = botNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let dataPrivacyDecoded = try containerValues.decodeIfPresent(DataPrivacy.self, forKey: .dataPrivacy)
        dataPrivacy = dataPrivacyDecoded
        let idleSessionTTLInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .idleSessionTTLInSeconds)
        idleSessionTTLInSeconds = idleSessionTTLInSecondsDecoded
        let botTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .botTags)
        var botTagsDecoded0: [String:String]? = nil
        if let botTagsContainer = botTagsContainer {
            botTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in botTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    botTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        botTags = botTagsDecoded0
        let testBotAliasTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .testBotAliasTags)
        var testBotAliasTagsDecoded0: [String:String]? = nil
        if let testBotAliasTagsContainer = testBotAliasTagsContainer {
            testBotAliasTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in testBotAliasTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    testBotAliasTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        testBotAliasTags = testBotAliasTagsDecoded0
    }
}

extension BotImportSpecification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BotImportSpecification(botName: \(String(describing: botName)), botTags: \(String(describing: botTags)), dataPrivacy: \(String(describing: dataPrivacy)), idleSessionTTLInSeconds: \(String(describing: idleSessionTTLInSeconds)), roleArn: \(String(describing: roleArn)), testBotAliasTags: \(String(describing: testBotAliasTags)))"}
}

/// <p>Provides the bot parameters required for importing a bot.</p>
public struct BotImportSpecification: Equatable {
    /// <p>The name that Amazon Lex should use for the bot.</p>
    public let botName: String?
    /// <p>A list of tags to add to the bot. You can only add tags when you
    ///          import a bot. You can't use the <code>UpdateBot</code> operation to
    ///          update tags. To update tags, use the <code>TagResource</code>
    ///          operation.</p>
    public let botTags: [String:String]?
    /// <p>By default, data stored by Amazon Lex is encrypted. The
    ///             <code>DataPrivacy</code> structure provides settings that determine
    ///          how Amazon Lex handles special cases of securing the data for your bot.
    ///       </p>
    public let dataPrivacy: DataPrivacy?
    /// <p>The time, in seconds, that Amazon Lex should keep information about a
    ///          user's conversation with the bot. </p>
    ///          <p>A user interaction remains active for the amount of time specified.
    ///          If no conversation occurs during this time, the session expires and
    ///          Amazon Lex deletes any data provided before the timeout.</p>
    ///          <p>You can specify between 60 (1 minute) and 86,400 (24 hours)
    ///          seconds.</p>
    public let idleSessionTTLInSeconds: Int?
    /// <p>The Amazon Resource Name (ARN) of the IAM role used to build and run
    ///          the bot.</p>
    public let roleArn: String?
    /// <p>A list of tags to add to the test alias for a bot. You can only add
    ///          tags when you import a bot. You can't use the <code>UpdateAlias</code>
    ///          operation to update tags. To update tags on the test alias, use the
    ///             <code>TagResource</code> operation.</p>
    public let testBotAliasTags: [String:String]?

    public init (
        botName: String? = nil,
        botTags: [String:String]? = nil,
        dataPrivacy: DataPrivacy? = nil,
        idleSessionTTLInSeconds: Int? = nil,
        roleArn: String? = nil,
        testBotAliasTags: [String:String]? = nil
    )
    {
        self.botName = botName
        self.botTags = botTags
        self.dataPrivacy = dataPrivacy
        self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
        self.roleArn = roleArn
        self.testBotAliasTags = testBotAliasTags
    }
}

extension BotLocaleExportSpecification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case botId
        case botVersion
        case localeId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botId = botId {
            try encodeContainer.encode(botId, forKey: .botId)
        }
        if let botVersion = botVersion {
            try encodeContainer.encode(botVersion, forKey: .botVersion)
        }
        if let localeId = localeId {
            try encodeContainer.encode(localeId, forKey: .localeId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localeId)
        localeId = localeIdDecoded
    }
}

extension BotLocaleExportSpecification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BotLocaleExportSpecification(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), localeId: \(String(describing: localeId)))"}
}

/// <p>Provides the bot locale parameters required for exporting a bot
///          locale.</p>
public struct BotLocaleExportSpecification: Equatable {
    /// <p>The identifier of the bot to create the locale for.</p>
    public let botId: String?
    /// <p>The version of the bot to export.</p>
    public let botVersion: String?
    /// <p>The identifier of the language and locale to export. The string must
    ///          match one of the locales in the bot.</p>
    public let localeId: String?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        localeId: String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.localeId = localeId
    }
}

extension BotLocaleFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(BotLocaleFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(BotLocaleFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension BotLocaleFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BotLocaleFilter(name: \(String(describing: name)), operator: \(String(describing: `operator`)), values: \(String(describing: values)))"}
}

/// <p>Filters responses returned by the <code>ListBotLocales</code>
///          operation.</p>
public struct BotLocaleFilter: Equatable {
    /// <p>The operator to use for the filter. Specify <code>EQ</code> when the
    ///             <code>ListBotLocales</code> operation should return only aliases
    ///          that equal the specified value. Specify <code>CO</code> when the
    ///             <code>ListBotLocales</code> operation should return aliases that
    ///          contain the specified value.</p>
    public let `operator`: BotLocaleFilterOperator?
    /// <p>The name of the field to filter the list of bots.</p>
    public let name: BotLocaleFilterName?
    /// <p>The value to use for filtering the list of bots.</p>
    public let values: [String]?

    public init (
        `operator`: BotLocaleFilterOperator? = nil,
        name: BotLocaleFilterName? = nil,
        values: [String]? = nil
    )
    {
        self.`operator` = `operator`
        self.name = name
        self.values = values
    }
}

public enum BotLocaleFilterName {
    case botlocalename
    case sdkUnknown(String)
}

extension BotLocaleFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BotLocaleFilterName] {
        return [
            .botlocalename,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .botlocalename: return "BotLocaleName"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BotLocaleFilterName(rawValue: rawValue) ?? BotLocaleFilterName.sdkUnknown(rawValue)
    }
}

public enum BotLocaleFilterOperator {
    case contains
    case equals
    case sdkUnknown(String)
}

extension BotLocaleFilterOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BotLocaleFilterOperator] {
        return [
            .contains,
            .equals,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .contains: return "CO"
        case .equals: return "EQ"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BotLocaleFilterOperator(rawValue: rawValue) ?? BotLocaleFilterOperator.sdkUnknown(rawValue)
    }
}

extension BotLocaleHistoryEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case event
        case eventDate
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = event {
            try encodeContainer.encode(event, forKey: .event)
        }
        if let eventDate = eventDate {
            try encodeContainer.encode(eventDate.timeIntervalSince1970, forKey: .eventDate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDecoded = try containerValues.decodeIfPresent(String.self, forKey: .event)
        event = eventDecoded
        let eventDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .eventDate)
        eventDate = eventDateDecoded
    }
}

extension BotLocaleHistoryEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BotLocaleHistoryEvent(event: \(String(describing: event)), eventDate: \(String(describing: eventDate)))"}
}

/// <p>Provides information about an event that occurred affecting the bot
///          locale.</p>
public struct BotLocaleHistoryEvent: Equatable {
    /// <p>A description of the event that occurred.</p>
    public let event: String?
    /// <p>A timestamp of the date and time that the event occurred.</p>
    public let eventDate: Date?

    public init (
        event: String? = nil,
        eventDate: Date? = nil
    )
    {
        self.event = event
        self.eventDate = eventDate
    }
}

extension BotLocaleImportSpecification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case botId
        case botVersion
        case localeId
        case nluIntentConfidenceThreshold
        case voiceSettings
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botId = botId {
            try encodeContainer.encode(botId, forKey: .botId)
        }
        if let botVersion = botVersion {
            try encodeContainer.encode(botVersion, forKey: .botVersion)
        }
        if let localeId = localeId {
            try encodeContainer.encode(localeId, forKey: .localeId)
        }
        if let nluIntentConfidenceThreshold = nluIntentConfidenceThreshold {
            try encodeContainer.encode(nluIntentConfidenceThreshold, forKey: .nluIntentConfidenceThreshold)
        }
        if let voiceSettings = voiceSettings {
            try encodeContainer.encode(voiceSettings, forKey: .voiceSettings)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let nluIntentConfidenceThresholdDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .nluIntentConfidenceThreshold)
        nluIntentConfidenceThreshold = nluIntentConfidenceThresholdDecoded
        let voiceSettingsDecoded = try containerValues.decodeIfPresent(VoiceSettings.self, forKey: .voiceSettings)
        voiceSettings = voiceSettingsDecoded
    }
}

extension BotLocaleImportSpecification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BotLocaleImportSpecification(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), localeId: \(String(describing: localeId)), nluIntentConfidenceThreshold: \(String(describing: nluIntentConfidenceThreshold)), voiceSettings: \(String(describing: voiceSettings)))"}
}

/// <p>Provides the bot locale parameters required for importing a bot
///          locale.</p>
public struct BotLocaleImportSpecification: Equatable {
    /// <p>The identifier of the bot to import the locale to.</p>
    public let botId: String?
    /// <p>The version of the bot to import the locale to. This can only be the
    ///             <code>DRAFT</code> version of the bot.</p>
    public let botVersion: String?
    /// <p>The identifier of the language and locale that the bot will be used
    ///          in. The string must match one of the supported locales. All of the
    ///          intents, slot types, and slots used in the bot must have the same
    ///          locale. For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported
    ///          languages</a>.</p>
    public let localeId: String?
    /// <p>Determines the threshold where Amazon Lex will insert the
    ///             <code>AMAZON.FallbackIntent</code>,
    ///             <code>AMAZON.KendraSearchIntent</code>, or both when returning
    ///          alternative intents. <code>AMAZON.FallbackIntent</code> and
    ///             <code>AMAZON.KendraSearchIntent</code> are only inserted if they are
    ///          configured for the bot. </p>
    ///          <p>For example, suppose a bot is configured with the confidence
    ///          threshold of 0.80 and the <code>AMAZON.FallbackIntent</code>. Amazon
    ///          Lex returns three alternative intents with the following confidence
    ///          scores: IntentA (0.70), IntentB (0.60), IntentC (0.50). The response
    ///          from the <code>PostText</code> operation would be:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>AMAZON.FallbackIntent</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IntentA</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IntentB</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IntentC</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let nluIntentConfidenceThreshold: Double?
    /// <p>Defines settings for using an Amazon Polly voice to communicate with a
    ///          user.</p>
    public let voiceSettings: VoiceSettings?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        localeId: String? = nil,
        nluIntentConfidenceThreshold: Double? = nil,
        voiceSettings: VoiceSettings? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.localeId = localeId
        self.nluIntentConfidenceThreshold = nluIntentConfidenceThreshold
        self.voiceSettings = voiceSettings
    }
}

public enum BotLocaleSortAttribute {
    case botlocalename
    case sdkUnknown(String)
}

extension BotLocaleSortAttribute : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BotLocaleSortAttribute] {
        return [
            .botlocalename,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .botlocalename: return "BotLocaleName"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BotLocaleSortAttribute(rawValue: rawValue) ?? BotLocaleSortAttribute.sdkUnknown(rawValue)
    }
}

extension BotLocaleSortBy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attribute
        case order
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let order = order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(BotLocaleSortAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let orderDecoded = try containerValues.decodeIfPresent(SortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension BotLocaleSortBy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BotLocaleSortBy(attribute: \(String(describing: attribute)), order: \(String(describing: order)))"}
}

/// <p>Specifies attributes for sorting a list of bot locales.</p>
public struct BotLocaleSortBy: Equatable {
    /// <p>The bot locale attribute to sort by.</p>
    public let attribute: BotLocaleSortAttribute?
    /// <p>Specifies whether to sort the bot locales in ascending or descending
    ///          order.</p>
    public let order: SortOrder?

    public init (
        attribute: BotLocaleSortAttribute? = nil,
        order: SortOrder? = nil
    )
    {
        self.attribute = attribute
        self.order = order
    }
}

public enum BotLocaleStatus {
    case building
    case built
    case creating
    case deleting
    case failed
    case importing
    case notbuilt
    case readyexpresstesting
    case sdkUnknown(String)
}

extension BotLocaleStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BotLocaleStatus] {
        return [
            .building,
            .built,
            .creating,
            .deleting,
            .failed,
            .importing,
            .notbuilt,
            .readyexpresstesting,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .building: return "Building"
        case .built: return "Built"
        case .creating: return "Creating"
        case .deleting: return "Deleting"
        case .failed: return "Failed"
        case .importing: return "Importing"
        case .notbuilt: return "NotBuilt"
        case .readyexpresstesting: return "ReadyExpressTesting"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BotLocaleStatus(rawValue: rawValue) ?? BotLocaleStatus.sdkUnknown(rawValue)
    }
}

extension BotLocaleSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case botLocaleStatus
        case description
        case lastBuildSubmittedDateTime
        case lastUpdatedDateTime
        case localeId
        case localeName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botLocaleStatus = botLocaleStatus {
            try encodeContainer.encode(botLocaleStatus.rawValue, forKey: .botLocaleStatus)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastBuildSubmittedDateTime = lastBuildSubmittedDateTime {
            try encodeContainer.encode(lastBuildSubmittedDateTime.timeIntervalSince1970, forKey: .lastBuildSubmittedDateTime)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let localeId = localeId {
            try encodeContainer.encode(localeId, forKey: .localeId)
        }
        if let localeName = localeName {
            try encodeContainer.encode(localeName, forKey: .localeName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let localeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localeName)
        localeName = localeNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let botLocaleStatusDecoded = try containerValues.decodeIfPresent(BotLocaleStatus.self, forKey: .botLocaleStatus)
        botLocaleStatus = botLocaleStatusDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let lastBuildSubmittedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastBuildSubmittedDateTime)
        lastBuildSubmittedDateTime = lastBuildSubmittedDateTimeDecoded
    }
}

extension BotLocaleSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BotLocaleSummary(botLocaleStatus: \(String(describing: botLocaleStatus)), description: \(String(describing: description)), lastBuildSubmittedDateTime: \(String(describing: lastBuildSubmittedDateTime)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), localeId: \(String(describing: localeId)), localeName: \(String(describing: localeName)))"}
}

/// <p>Summary information about bot locales returned by the <a>ListBotLocales</a> operation.</p>
public struct BotLocaleSummary: Equatable {
    /// <p>The current status of the bot locale. When the status is
    ///             <code>Built</code> the locale is ready for use.</p>
    public let botLocaleStatus: BotLocaleStatus?
    /// <p>The description of the bot locale.</p>
    public let description: String?
    /// <p>A timestamp of the date and time that the bot locale was last
    ///          built.</p>
    public let lastBuildSubmittedDateTime: Date?
    /// <p>A timestamp of the date and time that the bot locale was last
    ///          updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The language and locale of the bot locale.</p>
    public let localeId: String?
    /// <p>The name of the bot locale.</p>
    public let localeName: String?

    public init (
        botLocaleStatus: BotLocaleStatus? = nil,
        description: String? = nil,
        lastBuildSubmittedDateTime: Date? = nil,
        lastUpdatedDateTime: Date? = nil,
        localeId: String? = nil,
        localeName: String? = nil
    )
    {
        self.botLocaleStatus = botLocaleStatus
        self.description = description
        self.lastBuildSubmittedDateTime = lastBuildSubmittedDateTime
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.localeId = localeId
        self.localeName = localeName
    }
}

public enum BotSortAttribute {
    case botname
    case sdkUnknown(String)
}

extension BotSortAttribute : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BotSortAttribute] {
        return [
            .botname,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .botname: return "BotName"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BotSortAttribute(rawValue: rawValue) ?? BotSortAttribute.sdkUnknown(rawValue)
    }
}

extension BotSortBy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attribute
        case order
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let order = order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(BotSortAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let orderDecoded = try containerValues.decodeIfPresent(SortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension BotSortBy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BotSortBy(attribute: \(String(describing: attribute)), order: \(String(describing: order)))"}
}

/// <p>Specifies attributes for sorting a list of bots.</p>
public struct BotSortBy: Equatable {
    /// <p>The attribute to use to sort the list of bots.</p>
    public let attribute: BotSortAttribute?
    /// <p>The order to sort the list. You can choose ascending or
    ///          descending.</p>
    public let order: SortOrder?

    public init (
        attribute: BotSortAttribute? = nil,
        order: SortOrder? = nil
    )
    {
        self.attribute = attribute
        self.order = order
    }
}

public enum BotStatus {
    case available
    case creating
    case deleting
    case failed
    case importing
    case inactive
    case versioning
    case sdkUnknown(String)
}

extension BotStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BotStatus] {
        return [
            .available,
            .creating,
            .deleting,
            .failed,
            .importing,
            .inactive,
            .versioning,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "Available"
        case .creating: return "Creating"
        case .deleting: return "Deleting"
        case .failed: return "Failed"
        case .importing: return "Importing"
        case .inactive: return "Inactive"
        case .versioning: return "Versioning"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BotStatus(rawValue: rawValue) ?? BotStatus.sdkUnknown(rawValue)
    }
}

extension BotSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case botId
        case botName
        case botStatus
        case description
        case lastUpdatedDateTime
        case latestBotVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botId = botId {
            try encodeContainer.encode(botId, forKey: .botId)
        }
        if let botName = botName {
            try encodeContainer.encode(botName, forKey: .botName)
        }
        if let botStatus = botStatus {
            try encodeContainer.encode(botStatus.rawValue, forKey: .botStatus)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let latestBotVersion = latestBotVersion {
            try encodeContainer.encode(latestBotVersion, forKey: .latestBotVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botName)
        botName = botNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let botStatusDecoded = try containerValues.decodeIfPresent(BotStatus.self, forKey: .botStatus)
        botStatus = botStatusDecoded
        let latestBotVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestBotVersion)
        latestBotVersion = latestBotVersionDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension BotSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BotSummary(botId: \(String(describing: botId)), botName: \(String(describing: botName)), botStatus: \(String(describing: botStatus)), description: \(String(describing: description)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), latestBotVersion: \(String(describing: latestBotVersion)))"}
}

/// <p>Summary information about a bot returned by the <a>ListBots</a> operation.</p>
public struct BotSummary: Equatable {
    /// <p>The unique identifier assigned to the bot. Use this ID to get
    ///          detailed information about the bot with the <a>DescribeBot</a> operation.</p>
    public let botId: String?
    /// <p>The name of the bot.</p>
    public let botName: String?
    /// <p>The current status of the bot. When the status is
    ///             <code>Available</code> the bot is ready for use.</p>
    public let botStatus: BotStatus?
    /// <p>The description of the bot.</p>
    public let description: String?
    /// <p>The date and time that the bot was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The latest numerical version in use for the bot.</p>
    public let latestBotVersion: String?

    public init (
        botId: String? = nil,
        botName: String? = nil,
        botStatus: BotStatus? = nil,
        description: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        latestBotVersion: String? = nil
    )
    {
        self.botId = botId
        self.botName = botName
        self.botStatus = botStatus
        self.description = description
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.latestBotVersion = latestBotVersion
    }
}

extension BotVersionLocaleDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sourceBotVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceBotVersion = sourceBotVersion {
            try encodeContainer.encode(sourceBotVersion, forKey: .sourceBotVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceBotVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceBotVersion)
        sourceBotVersion = sourceBotVersionDecoded
    }
}

extension BotVersionLocaleDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BotVersionLocaleDetails(sourceBotVersion: \(String(describing: sourceBotVersion)))"}
}

/// <p>The version of a bot used for a bot locale.</p>
public struct BotVersionLocaleDetails: Equatable {
    /// <p>The version of a bot used for a bot locale.</p>
    public let sourceBotVersion: String?

    public init (
        sourceBotVersion: String? = nil
    )
    {
        self.sourceBotVersion = sourceBotVersion
    }
}

public enum BotVersionSortAttribute {
    case botversion
    case sdkUnknown(String)
}

extension BotVersionSortAttribute : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BotVersionSortAttribute] {
        return [
            .botversion,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .botversion: return "BotVersion"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BotVersionSortAttribute(rawValue: rawValue) ?? BotVersionSortAttribute.sdkUnknown(rawValue)
    }
}

extension BotVersionSortBy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attribute
        case order
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let order = order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(BotVersionSortAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let orderDecoded = try containerValues.decodeIfPresent(SortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension BotVersionSortBy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BotVersionSortBy(attribute: \(String(describing: attribute)), order: \(String(describing: order)))"}
}

/// <p>Specifies attributes for sorting a list of bot versions.</p>
public struct BotVersionSortBy: Equatable {
    /// <p>The attribute to use to sort the list of versions.</p>
    public let attribute: BotVersionSortAttribute?
    /// <p>The order to sort the list. You can specify ascending or descending
    ///          order.</p>
    public let order: SortOrder?

    public init (
        attribute: BotVersionSortAttribute? = nil,
        order: SortOrder? = nil
    )
    {
        self.attribute = attribute
        self.order = order
    }
}

extension BotVersionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case botName
        case botStatus
        case botVersion
        case creationDateTime
        case description
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botName = botName {
            try encodeContainer.encode(botName, forKey: .botName)
        }
        if let botStatus = botStatus {
            try encodeContainer.encode(botStatus.rawValue, forKey: .botStatus)
        }
        if let botVersion = botVersion {
            try encodeContainer.encode(botVersion, forKey: .botVersion)
        }
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botName)
        botName = botNameDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let botStatusDecoded = try containerValues.decodeIfPresent(BotStatus.self, forKey: .botStatus)
        botStatus = botStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
    }
}

extension BotVersionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BotVersionSummary(botName: \(String(describing: botName)), botStatus: \(String(describing: botStatus)), botVersion: \(String(describing: botVersion)), creationDateTime: \(String(describing: creationDateTime)), description: \(String(describing: description)))"}
}

/// <p>Summary information about a bot version returned by the <a>ListBotVersions</a> operation.</p>
public struct BotVersionSummary: Equatable {
    /// <p>The name of the bot associated with the version.</p>
    public let botName: String?
    /// <p>The status of the bot. When the status is available, the version of
    ///          the bot is ready for use.</p>
    public let botStatus: BotStatus?
    /// <p>The numeric version of the bot, or <code>DRAFT</code> to indicate
    ///          that this is the version of the bot that can be updated..</p>
    public let botVersion: String?
    /// <p>A timestamp of the date and time that the version was
    ///          created.</p>
    public let creationDateTime: Date?
    /// <p>The description of the version.</p>
    public let description: String?

    public init (
        botName: String? = nil,
        botStatus: BotStatus? = nil,
        botVersion: String? = nil,
        creationDateTime: Date? = nil,
        description: String? = nil
    )
    {
        self.botName = botName
        self.botStatus = botStatus
        self.botVersion = botVersion
        self.creationDateTime = creationDateTime
        self.description = description
    }
}

extension BuildBotLocaleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BuildBotLocaleInput(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), localeId: \(String(describing: localeId)))"}
}

extension BuildBotLocaleInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct BuildBotLocaleInputHeadersMiddleware: Middleware {
    public let id: String = "BuildBotLocaleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BuildBotLocaleInput>,
                  next: H) -> Swift.Result<OperationOutput<BuildBotLocaleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BuildBotLocaleInput>
    public typealias MOutput = OperationOutput<BuildBotLocaleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BuildBotLocaleOutputError>
}

public struct BuildBotLocaleInputQueryItemMiddleware: Middleware {
    public let id: String = "BuildBotLocaleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BuildBotLocaleInput>,
                  next: H) -> Swift.Result<OperationOutput<BuildBotLocaleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BuildBotLocaleInput>
    public typealias MOutput = OperationOutput<BuildBotLocaleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BuildBotLocaleOutputError>
}

public struct BuildBotLocaleInput: Equatable {
    /// <p>The identifier of the bot to build. The identifier is returned in
    ///          the response from the  operation.</p>
    public let botId: String?
    /// <p>The version of the bot to build. This can only be the draft version
    ///          of the bot.</p>
    public let botVersion: String?
    /// <p>The identifier of the language and locale that the bot will be used
    ///          in. The string must match one of the supported locales. All of the
    ///          intents, slot types, and slots used in the bot must have the same
    ///          locale. For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
    public let localeId: String?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        localeId: String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.localeId = localeId
    }
}

struct BuildBotLocaleInputBody: Equatable {
}

extension BuildBotLocaleInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension BuildBotLocaleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BuildBotLocaleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BuildBotLocaleOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case preconditionFailedException(PreconditionFailedException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BuildBotLocaleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BuildBotLocaleOutputResponse(botId: \(String(describing: botId)), botLocaleStatus: \(String(describing: botLocaleStatus)), botVersion: \(String(describing: botVersion)), lastBuildSubmittedDateTime: \(String(describing: lastBuildSubmittedDateTime)), localeId: \(String(describing: localeId)))"}
}

extension BuildBotLocaleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BuildBotLocaleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botId = output.botId
            self.botLocaleStatus = output.botLocaleStatus
            self.botVersion = output.botVersion
            self.lastBuildSubmittedDateTime = output.lastBuildSubmittedDateTime
            self.localeId = output.localeId
        } else {
            self.botId = nil
            self.botLocaleStatus = nil
            self.botVersion = nil
            self.lastBuildSubmittedDateTime = nil
            self.localeId = nil
        }
    }
}

public struct BuildBotLocaleOutputResponse: Equatable {
    /// <p>The identifier of the specified bot.</p>
    public let botId: String?
    /// <p>The bot's build status. When the status is
    ///             <code>ReadyExpressTesting</code> you can test the bot using the
    ///          utterances defined for the intents and slot types. When the status is
    ///             <code>Built</code>, the bot is ready for use and can be tested using
    ///          any utterance.</p>
    public let botLocaleStatus: BotLocaleStatus?
    /// <p>The version of the bot that was built. This is only the draft
    ///          version of the bot.</p>
    public let botVersion: String?
    /// <p>A timestamp indicating the date and time that the bot was last built
    ///          for this locale.</p>
    public let lastBuildSubmittedDateTime: Date?
    /// <p>The language and locale specified of where the bot can be
    ///          used.</p>
    public let localeId: String?

    public init (
        botId: String? = nil,
        botLocaleStatus: BotLocaleStatus? = nil,
        botVersion: String? = nil,
        lastBuildSubmittedDateTime: Date? = nil,
        localeId: String? = nil
    )
    {
        self.botId = botId
        self.botLocaleStatus = botLocaleStatus
        self.botVersion = botVersion
        self.lastBuildSubmittedDateTime = lastBuildSubmittedDateTime
        self.localeId = localeId
    }
}

struct BuildBotLocaleOutputResponseBody: Equatable {
    public let botId: String?
    public let botVersion: String?
    public let localeId: String?
    public let botLocaleStatus: BotLocaleStatus?
    public let lastBuildSubmittedDateTime: Date?
}

extension BuildBotLocaleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botId
        case botLocaleStatus
        case botVersion
        case lastBuildSubmittedDateTime
        case localeId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let botLocaleStatusDecoded = try containerValues.decodeIfPresent(BotLocaleStatus.self, forKey: .botLocaleStatus)
        botLocaleStatus = botLocaleStatusDecoded
        let lastBuildSubmittedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastBuildSubmittedDateTime)
        lastBuildSubmittedDateTime = lastBuildSubmittedDateTimeDecoded
    }
}

public enum BuiltInIntentSortAttribute {
    case intentsignature
    case sdkUnknown(String)
}

extension BuiltInIntentSortAttribute : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BuiltInIntentSortAttribute] {
        return [
            .intentsignature,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .intentsignature: return "IntentSignature"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BuiltInIntentSortAttribute(rawValue: rawValue) ?? BuiltInIntentSortAttribute.sdkUnknown(rawValue)
    }
}

extension BuiltInIntentSortBy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attribute
        case order
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let order = order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(BuiltInIntentSortAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let orderDecoded = try containerValues.decodeIfPresent(SortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension BuiltInIntentSortBy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BuiltInIntentSortBy(attribute: \(String(describing: attribute)), order: \(String(describing: order)))"}
}

/// <p>Specifies attributes for sorting a list of built-in intents.</p>
public struct BuiltInIntentSortBy: Equatable {
    /// <p>The attribute to use to sort the list of built-in intents.</p>
    public let attribute: BuiltInIntentSortAttribute?
    /// <p>The order to sort the list. You can specify ascending or descending
    ///          order.</p>
    public let order: SortOrder?

    public init (
        attribute: BuiltInIntentSortAttribute? = nil,
        order: SortOrder? = nil
    )
    {
        self.attribute = attribute
        self.order = order
    }
}

extension BuiltInIntentSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case intentSignature
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let intentSignature = intentSignature {
            try encodeContainer.encode(intentSignature, forKey: .intentSignature)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentSignatureDecoded = try containerValues.decodeIfPresent(String.self, forKey: .intentSignature)
        intentSignature = intentSignatureDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension BuiltInIntentSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BuiltInIntentSummary(description: \(String(describing: description)), intentSignature: \(String(describing: intentSignature)))"}
}

/// <p>Provides summary information about a built-in intent for the <a>ListBuiltInIntents</a> operation.</p>
public struct BuiltInIntentSummary: Equatable {
    /// <p>The description of the intent.</p>
    public let description: String?
    /// <p>The signature of the built-in intent. Use this to specify the parent
    ///          intent of a derived intent.</p>
    public let intentSignature: String?

    public init (
        description: String? = nil,
        intentSignature: String? = nil
    )
    {
        self.description = description
        self.intentSignature = intentSignature
    }
}

public enum BuiltInSlotTypeSortAttribute {
    case slottypesignature
    case sdkUnknown(String)
}

extension BuiltInSlotTypeSortAttribute : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BuiltInSlotTypeSortAttribute] {
        return [
            .slottypesignature,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .slottypesignature: return "SlotTypeSignature"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BuiltInSlotTypeSortAttribute(rawValue: rawValue) ?? BuiltInSlotTypeSortAttribute.sdkUnknown(rawValue)
    }
}

extension BuiltInSlotTypeSortBy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attribute
        case order
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let order = order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(BuiltInSlotTypeSortAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let orderDecoded = try containerValues.decodeIfPresent(SortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension BuiltInSlotTypeSortBy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BuiltInSlotTypeSortBy(attribute: \(String(describing: attribute)), order: \(String(describing: order)))"}
}

/// <p>Specifies attributes for sorting a list of built-in slot
///          types.</p>
public struct BuiltInSlotTypeSortBy: Equatable {
    /// <p>The attribute to use to sort the list of built-in intents.</p>
    public let attribute: BuiltInSlotTypeSortAttribute?
    /// <p>The order to sort the list. You can choose ascending or
    ///          descending.</p>
    public let order: SortOrder?

    public init (
        attribute: BuiltInSlotTypeSortAttribute? = nil,
        order: SortOrder? = nil
    )
    {
        self.attribute = attribute
        self.order = order
    }
}

extension BuiltInSlotTypeSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case slotTypeSignature
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let slotTypeSignature = slotTypeSignature {
            try encodeContainer.encode(slotTypeSignature, forKey: .slotTypeSignature)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotTypeSignatureDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotTypeSignature)
        slotTypeSignature = slotTypeSignatureDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension BuiltInSlotTypeSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BuiltInSlotTypeSummary(description: \(String(describing: description)), slotTypeSignature: \(String(describing: slotTypeSignature)))"}
}

/// <p>Provides summary information about a built-in slot type for the
///             <a>ListBuiltInSlotTypes</a> operation.</p>
public struct BuiltInSlotTypeSummary: Equatable {
    /// <p>The description of the built-in slot type.</p>
    public let description: String?
    /// <p>The signature of the built-in slot type. Use this to specify the
    ///          parent slot type of a derived slot type.</p>
    public let slotTypeSignature: String?

    public init (
        description: String? = nil,
        slotTypeSignature: String? = nil
    )
    {
        self.description = description
        self.slotTypeSignature = slotTypeSignature
    }
}

extension Button: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case text
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Button: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Button(text: \(String(describing: text)), value: \(String(describing: value)))"}
}

/// <p>Describes a button to use on a response card used to gather slot
///          values from a user.</p>
public struct Button: Equatable {
    /// <p>The text that appears on the button. Use this to tell the user what
    ///          value is returned when they choose this button.</p>
    public let text: String?
    /// <p>The value returned to Amazon Lex when the user chooses this button. This
    ///          must be one of the slot values configured for the slot.</p>
    public let value: String?

    public init (
        text: String? = nil,
        value: String? = nil
    )
    {
        self.text = text
        self.value = value
    }
}

extension CloudWatchLogGroupLogDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLogGroupArn
        case logPrefix
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogGroupArn = cloudWatchLogGroupArn {
            try encodeContainer.encode(cloudWatchLogGroupArn, forKey: .cloudWatchLogGroupArn)
        }
        if let logPrefix = logPrefix {
            try encodeContainer.encode(logPrefix, forKey: .logPrefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchLogGroupArn)
        cloudWatchLogGroupArn = cloudWatchLogGroupArnDecoded
        let logPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logPrefix)
        logPrefix = logPrefixDecoded
    }
}

extension CloudWatchLogGroupLogDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudWatchLogGroupLogDestination(cloudWatchLogGroupArn: \(String(describing: cloudWatchLogGroupArn)), logPrefix: \(String(describing: logPrefix)))"}
}

/// <p>The Amazon CloudWatch Logs log group where the text and metadata logs are
///          delivered. The log group must exist before you enable logging.</p>
public struct CloudWatchLogGroupLogDestination: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the log group where text and
    ///          metadata logs are delivered.</p>
    public let cloudWatchLogGroupArn: String?
    /// <p>The prefix of the log stream name within the log group that you
    ///          specified </p>
    public let logPrefix: String?

    public init (
        cloudWatchLogGroupArn: String? = nil,
        logPrefix: String? = nil
    )
    {
        self.cloudWatchLogGroupArn = cloudWatchLogGroupArn
        self.logPrefix = logPrefix
    }
}

extension CodeHookSpecification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lambdaCodeHook
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaCodeHook = lambdaCodeHook {
            try encodeContainer.encode(lambdaCodeHook, forKey: .lambdaCodeHook)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaCodeHookDecoded = try containerValues.decodeIfPresent(LambdaCodeHook.self, forKey: .lambdaCodeHook)
        lambdaCodeHook = lambdaCodeHookDecoded
    }
}

extension CodeHookSpecification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeHookSpecification(lambdaCodeHook: \(String(describing: lambdaCodeHook)))"}
}

/// <p>Contains information about code hooks that Amazon Lex calls during a
///          conversation.</p>
public struct CodeHookSpecification: Equatable {
    /// <p>Specifies a Lambda function that verifies requests to a bot or
    ///          fulfilles the user's request to a bot.</p>
    public let lambdaCodeHook: LambdaCodeHook?

    public init (
        lambdaCodeHook: LambdaCodeHook? = nil
    )
    {
        self.lambdaCodeHook = lambdaCodeHook
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConversationLogSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case audioLogSettings
        case textLogSettings
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioLogSettings = audioLogSettings {
            var audioLogSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .audioLogSettings)
            for audiologsettingslist0 in audioLogSettings {
                try audioLogSettingsContainer.encode(audiologsettingslist0)
            }
        }
        if let textLogSettings = textLogSettings {
            var textLogSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .textLogSettings)
            for textlogsettingslist0 in textLogSettings {
                try textLogSettingsContainer.encode(textlogsettingslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textLogSettingsContainer = try containerValues.decodeIfPresent([TextLogSetting?].self, forKey: .textLogSettings)
        var textLogSettingsDecoded0:[TextLogSetting]? = nil
        if let textLogSettingsContainer = textLogSettingsContainer {
            textLogSettingsDecoded0 = [TextLogSetting]()
            for structure0 in textLogSettingsContainer {
                if let structure0 = structure0 {
                    textLogSettingsDecoded0?.append(structure0)
                }
            }
        }
        textLogSettings = textLogSettingsDecoded0
        let audioLogSettingsContainer = try containerValues.decodeIfPresent([AudioLogSetting?].self, forKey: .audioLogSettings)
        var audioLogSettingsDecoded0:[AudioLogSetting]? = nil
        if let audioLogSettingsContainer = audioLogSettingsContainer {
            audioLogSettingsDecoded0 = [AudioLogSetting]()
            for structure0 in audioLogSettingsContainer {
                if let structure0 = structure0 {
                    audioLogSettingsDecoded0?.append(structure0)
                }
            }
        }
        audioLogSettings = audioLogSettingsDecoded0
    }
}

extension ConversationLogSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConversationLogSettings(audioLogSettings: \(String(describing: audioLogSettings)), textLogSettings: \(String(describing: textLogSettings)))"}
}

/// <p>Configures conversation logging that saves audio, text, and metadata
///          for the conversations with your users.</p>
public struct ConversationLogSettings: Equatable {
    /// <p>The Amazon S3 settings for logging audio to an S3 bucket.</p>
    public let audioLogSettings: [AudioLogSetting]?
    /// <p>The Amazon CloudWatch Logs settings for logging text and metadata.</p>
    public let textLogSettings: [TextLogSetting]?

    public init (
        audioLogSettings: [AudioLogSetting]? = nil,
        textLogSettings: [TextLogSetting]? = nil
    )
    {
        self.audioLogSettings = audioLogSettings
        self.textLogSettings = textLogSettings
    }
}

public struct CreateBotAliasInputBodyMiddleware: Middleware {
    public let id: String = "CreateBotAliasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBotAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBotAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBotAliasInput>
    public typealias MOutput = OperationOutput<CreateBotAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBotAliasOutputError>
}

extension CreateBotAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBotAliasInput(botAliasLocaleSettings: \(String(describing: botAliasLocaleSettings)), botAliasName: \(String(describing: botAliasName)), botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), conversationLogSettings: \(String(describing: conversationLogSettings)), description: \(String(describing: description)), sentimentAnalysisSettings: \(String(describing: sentimentAnalysisSettings)), tags: \(String(describing: tags)))"}
}

extension CreateBotAliasInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case botAliasLocaleSettings
        case botAliasName
        case botVersion
        case conversationLogSettings
        case description
        case sentimentAnalysisSettings
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botAliasLocaleSettings = botAliasLocaleSettings {
            var botAliasLocaleSettingsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .botAliasLocaleSettings)
            for (dictKey0, botaliaslocalesettingsmap0) in botAliasLocaleSettings {
                try botAliasLocaleSettingsContainer.encode(botaliaslocalesettingsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let botAliasName = botAliasName {
            try encodeContainer.encode(botAliasName, forKey: .botAliasName)
        }
        if let botVersion = botVersion {
            try encodeContainer.encode(botVersion, forKey: .botVersion)
        }
        if let conversationLogSettings = conversationLogSettings {
            try encodeContainer.encode(conversationLogSettings, forKey: .conversationLogSettings)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let sentimentAnalysisSettings = sentimentAnalysisSettings {
            try encodeContainer.encode(sentimentAnalysisSettings, forKey: .sentimentAnalysisSettings)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateBotAliasInputHeadersMiddleware: Middleware {
    public let id: String = "CreateBotAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBotAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBotAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBotAliasInput>
    public typealias MOutput = OperationOutput<CreateBotAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBotAliasOutputError>
}

public struct CreateBotAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateBotAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBotAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBotAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBotAliasInput>
    public typealias MOutput = OperationOutput<CreateBotAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBotAliasOutputError>
}

public struct CreateBotAliasInput: Equatable {
    /// <p>Maps configuration information to a specific locale. You can use
    ///          this parameter to specify a specific Lambda function to run different
    ///          functions in different locales.</p>
    public let botAliasLocaleSettings: [String:BotAliasLocaleSettings]?
    /// <p>The alias to create. The name must be unique for the bot.</p>
    public let botAliasName: String?
    /// <p>The unique identifier of the bot that the alias applies to.</p>
    public let botId: String?
    /// <p>The version of the bot that this alias points to. You can use the
    ///              operation to change the bot
    ///          version associated with the alias.</p>
    public let botVersion: String?
    /// <p>Specifies whether Amazon Lex logs text and audio for a conversation with
    ///          the bot. When you enable conversation logs, text logs store text input,
    ///          transcripts of audio input, and associated metadata in Amazon CloudWatch Logs. Audio
    ///          logs store audio input in Amazon S3.</p>
    public let conversationLogSettings: ConversationLogSettings?
    /// <p>A description of the alias. Use this description to help identify
    ///          the alias.</p>
    public let description: String?
    /// <p>Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of
    ///          user utterances.</p>
    public let sentimentAnalysisSettings: SentimentAnalysisSettings?
    /// <p>A list of tags to add to the bot alias. You can only add tags when
    ///          you create an alias, you can't use the <code>UpdateBotAlias</code>
    ///          operation to update the tags on a bot alias. To update tags, use the
    ///             <code>TagResource</code> operation.</p>
    public let tags: [String:String]?

    public init (
        botAliasLocaleSettings: [String:BotAliasLocaleSettings]? = nil,
        botAliasName: String? = nil,
        botId: String? = nil,
        botVersion: String? = nil,
        conversationLogSettings: ConversationLogSettings? = nil,
        description: String? = nil,
        sentimentAnalysisSettings: SentimentAnalysisSettings? = nil,
        tags: [String:String]? = nil
    )
    {
        self.botAliasLocaleSettings = botAliasLocaleSettings
        self.botAliasName = botAliasName
        self.botId = botId
        self.botVersion = botVersion
        self.conversationLogSettings = conversationLogSettings
        self.description = description
        self.sentimentAnalysisSettings = sentimentAnalysisSettings
        self.tags = tags
    }
}

struct CreateBotAliasInputBody: Equatable {
    public let botAliasName: String?
    public let description: String?
    public let botVersion: String?
    public let botAliasLocaleSettings: [String:BotAliasLocaleSettings]?
    public let conversationLogSettings: ConversationLogSettings?
    public let sentimentAnalysisSettings: SentimentAnalysisSettings?
    public let tags: [String:String]?
}

extension CreateBotAliasInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botAliasLocaleSettings
        case botAliasName
        case botVersion
        case conversationLogSettings
        case description
        case sentimentAnalysisSettings
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botAliasNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botAliasName)
        botAliasName = botAliasNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let botAliasLocaleSettingsContainer = try containerValues.decodeIfPresent([String: BotAliasLocaleSettings?].self, forKey: .botAliasLocaleSettings)
        var botAliasLocaleSettingsDecoded0: [String:BotAliasLocaleSettings]? = nil
        if let botAliasLocaleSettingsContainer = botAliasLocaleSettingsContainer {
            botAliasLocaleSettingsDecoded0 = [String:BotAliasLocaleSettings]()
            for (key0, botaliaslocalesettings0) in botAliasLocaleSettingsContainer {
                if let botaliaslocalesettings0 = botaliaslocalesettings0 {
                    botAliasLocaleSettingsDecoded0?[key0] = botaliaslocalesettings0
                }
            }
        }
        botAliasLocaleSettings = botAliasLocaleSettingsDecoded0
        let conversationLogSettingsDecoded = try containerValues.decodeIfPresent(ConversationLogSettings.self, forKey: .conversationLogSettings)
        conversationLogSettings = conversationLogSettingsDecoded
        let sentimentAnalysisSettingsDecoded = try containerValues.decodeIfPresent(SentimentAnalysisSettings.self, forKey: .sentimentAnalysisSettings)
        sentimentAnalysisSettings = sentimentAnalysisSettingsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateBotAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBotAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBotAliasOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case preconditionFailedException(PreconditionFailedException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBotAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBotAliasOutputResponse(botAliasId: \(String(describing: botAliasId)), botAliasLocaleSettings: \(String(describing: botAliasLocaleSettings)), botAliasName: \(String(describing: botAliasName)), botAliasStatus: \(String(describing: botAliasStatus)), botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), conversationLogSettings: \(String(describing: conversationLogSettings)), creationDateTime: \(String(describing: creationDateTime)), description: \(String(describing: description)), sentimentAnalysisSettings: \(String(describing: sentimentAnalysisSettings)), tags: \(String(describing: tags)))"}
}

extension CreateBotAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateBotAliasOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botAliasId = output.botAliasId
            self.botAliasLocaleSettings = output.botAliasLocaleSettings
            self.botAliasName = output.botAliasName
            self.botAliasStatus = output.botAliasStatus
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.conversationLogSettings = output.conversationLogSettings
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.sentimentAnalysisSettings = output.sentimentAnalysisSettings
            self.tags = output.tags
        } else {
            self.botAliasId = nil
            self.botAliasLocaleSettings = nil
            self.botAliasName = nil
            self.botAliasStatus = nil
            self.botId = nil
            self.botVersion = nil
            self.conversationLogSettings = nil
            self.creationDateTime = nil
            self.description = nil
            self.sentimentAnalysisSettings = nil
            self.tags = nil
        }
    }
}

public struct CreateBotAliasOutputResponse: Equatable {
    /// <p>The unique identifier of the bot alias.</p>
    public let botAliasId: String?
    /// <p>Configuration information for a specific locale.</p>
    public let botAliasLocaleSettings: [String:BotAliasLocaleSettings]?
    /// <p>The name specified for the bot alias.</p>
    public let botAliasName: String?
    /// <p>The current status of the alias. The alias is first put into the
    ///             <code>Creating</code> state. When the alias is ready to be used, it
    ///          is put into the <code>Available</code> state. You can use the
    ///             <code>DescribeBotAlias</code> operation to get the current state of
    ///          an alias.</p>
    public let botAliasStatus: BotAliasStatus?
    /// <p>The unique identifier of the bot that this alias applies to.</p>
    public let botId: String?
    /// <p>The version of the bot associated with this alias.</p>
    public let botVersion: String?
    /// <p>The conversation log settings specified for the alias.</p>
    public let conversationLogSettings: ConversationLogSettings?
    /// <p>A Unix timestamp indicating the date and time that the bot alias was
    ///          created.</p>
    public let creationDateTime: Date?
    /// <p>The description specified for the bot alias.</p>
    public let description: String?
    /// <p>Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of
    ///          user utterances.</p>
    public let sentimentAnalysisSettings: SentimentAnalysisSettings?
    /// <p>A list of tags associated with the bot alias.</p>
    public let tags: [String:String]?

    public init (
        botAliasId: String? = nil,
        botAliasLocaleSettings: [String:BotAliasLocaleSettings]? = nil,
        botAliasName: String? = nil,
        botAliasStatus: BotAliasStatus? = nil,
        botId: String? = nil,
        botVersion: String? = nil,
        conversationLogSettings: ConversationLogSettings? = nil,
        creationDateTime: Date? = nil,
        description: String? = nil,
        sentimentAnalysisSettings: SentimentAnalysisSettings? = nil,
        tags: [String:String]? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botAliasLocaleSettings = botAliasLocaleSettings
        self.botAliasName = botAliasName
        self.botAliasStatus = botAliasStatus
        self.botId = botId
        self.botVersion = botVersion
        self.conversationLogSettings = conversationLogSettings
        self.creationDateTime = creationDateTime
        self.description = description
        self.sentimentAnalysisSettings = sentimentAnalysisSettings
        self.tags = tags
    }
}

struct CreateBotAliasOutputResponseBody: Equatable {
    public let botAliasId: String?
    public let botAliasName: String?
    public let description: String?
    public let botVersion: String?
    public let botAliasLocaleSettings: [String:BotAliasLocaleSettings]?
    public let conversationLogSettings: ConversationLogSettings?
    public let sentimentAnalysisSettings: SentimentAnalysisSettings?
    public let botAliasStatus: BotAliasStatus?
    public let botId: String?
    public let creationDateTime: Date?
    public let tags: [String:String]?
}

extension CreateBotAliasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botAliasId
        case botAliasLocaleSettings
        case botAliasName
        case botAliasStatus
        case botId
        case botVersion
        case conversationLogSettings
        case creationDateTime
        case description
        case sentimentAnalysisSettings
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botAliasIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botAliasId)
        botAliasId = botAliasIdDecoded
        let botAliasNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botAliasName)
        botAliasName = botAliasNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let botAliasLocaleSettingsContainer = try containerValues.decodeIfPresent([String: BotAliasLocaleSettings?].self, forKey: .botAliasLocaleSettings)
        var botAliasLocaleSettingsDecoded0: [String:BotAliasLocaleSettings]? = nil
        if let botAliasLocaleSettingsContainer = botAliasLocaleSettingsContainer {
            botAliasLocaleSettingsDecoded0 = [String:BotAliasLocaleSettings]()
            for (key0, botaliaslocalesettings0) in botAliasLocaleSettingsContainer {
                if let botaliaslocalesettings0 = botaliaslocalesettings0 {
                    botAliasLocaleSettingsDecoded0?[key0] = botaliaslocalesettings0
                }
            }
        }
        botAliasLocaleSettings = botAliasLocaleSettingsDecoded0
        let conversationLogSettingsDecoded = try containerValues.decodeIfPresent(ConversationLogSettings.self, forKey: .conversationLogSettings)
        conversationLogSettings = conversationLogSettingsDecoded
        let sentimentAnalysisSettingsDecoded = try containerValues.decodeIfPresent(SentimentAnalysisSettings.self, forKey: .sentimentAnalysisSettings)
        sentimentAnalysisSettings = sentimentAnalysisSettingsDecoded
        let botAliasStatusDecoded = try containerValues.decodeIfPresent(BotAliasStatus.self, forKey: .botAliasStatus)
        botAliasStatus = botAliasStatusDecoded
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateBotInputBodyMiddleware: Middleware {
    public let id: String = "CreateBotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBotInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBotInput>
    public typealias MOutput = OperationOutput<CreateBotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBotOutputError>
}

extension CreateBotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBotInput(botName: \(String(describing: botName)), botTags: \(String(describing: botTags)), dataPrivacy: \(String(describing: dataPrivacy)), description: \(String(describing: description)), idleSessionTTLInSeconds: \(String(describing: idleSessionTTLInSeconds)), roleArn: \(String(describing: roleArn)), testBotAliasTags: \(String(describing: testBotAliasTags)))"}
}

extension CreateBotInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case botName
        case botTags
        case dataPrivacy
        case description
        case idleSessionTTLInSeconds
        case roleArn
        case testBotAliasTags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botName = botName {
            try encodeContainer.encode(botName, forKey: .botName)
        }
        if let botTags = botTags {
            var botTagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .botTags)
            for (dictKey0, tagmap0) in botTags {
                try botTagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let dataPrivacy = dataPrivacy {
            try encodeContainer.encode(dataPrivacy, forKey: .dataPrivacy)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let idleSessionTTLInSeconds = idleSessionTTLInSeconds {
            try encodeContainer.encode(idleSessionTTLInSeconds, forKey: .idleSessionTTLInSeconds)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let testBotAliasTags = testBotAliasTags {
            var testBotAliasTagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .testBotAliasTags)
            for (dictKey0, tagmap0) in testBotAliasTags {
                try testBotAliasTagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateBotInputHeadersMiddleware: Middleware {
    public let id: String = "CreateBotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBotInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBotInput>
    public typealias MOutput = OperationOutput<CreateBotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBotOutputError>
}

public struct CreateBotInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateBotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBotInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBotInput>
    public typealias MOutput = OperationOutput<CreateBotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBotOutputError>
}

public struct CreateBotInput: Equatable {
    /// <p>The name of the bot. The bot name must be unique in the account that
    ///          creates the bot.</p>
    public let botName: String?
    /// <p>A list of tags to add to the bot. You can only add tags when you
    ///          create a bot. You can't use the <code>UpdateBot</code> operation to
    ///          update tags. To update tags, use the <code>TagResource</code>
    ///          operation.</p>
    public let botTags: [String:String]?
    /// <p>Provides information on additional privacy protections Amazon Lex should
    ///          use with the bot's data.</p>
    public let dataPrivacy: DataPrivacy?
    /// <p>A description of the bot. It appears in lists to help you identify a
    ///          particular bot.</p>
    public let description: String?
    /// <p>The time, in seconds, that Amazon Lex should keep information about a
    ///          user's conversation with the bot. </p>
    ///          <p>A user interaction remains active for the amount of time specified.
    ///          If no conversation occurs during this time, the session expires and
    ///          Amazon Lex deletes any data provided before the timeout.</p>
    ///          <p>You can specify between 60 (1 minute) and 86,400 (24 hours)
    ///          seconds.</p>
    public let idleSessionTTLInSeconds: Int?
    /// <p>The Amazon Resource Name (ARN) of an IAM role that has permission to
    ///          access the bot.</p>
    public let roleArn: String?
    /// <p>A list of tags to add to the test alias for a bot. You can only add
    ///          tags when you create a bot. You can't use the <code>UpdateAlias</code>
    ///          operation to update tags. To update tags on the test alias, use the
    ///             <code>TagResource</code> operation.</p>
    public let testBotAliasTags: [String:String]?

    public init (
        botName: String? = nil,
        botTags: [String:String]? = nil,
        dataPrivacy: DataPrivacy? = nil,
        description: String? = nil,
        idleSessionTTLInSeconds: Int? = nil,
        roleArn: String? = nil,
        testBotAliasTags: [String:String]? = nil
    )
    {
        self.botName = botName
        self.botTags = botTags
        self.dataPrivacy = dataPrivacy
        self.description = description
        self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
        self.roleArn = roleArn
        self.testBotAliasTags = testBotAliasTags
    }
}

struct CreateBotInputBody: Equatable {
    public let botName: String?
    public let description: String?
    public let roleArn: String?
    public let dataPrivacy: DataPrivacy?
    public let idleSessionTTLInSeconds: Int?
    public let botTags: [String:String]?
    public let testBotAliasTags: [String:String]?
}

extension CreateBotInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botName
        case botTags
        case dataPrivacy
        case description
        case idleSessionTTLInSeconds
        case roleArn
        case testBotAliasTags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botName)
        botName = botNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let dataPrivacyDecoded = try containerValues.decodeIfPresent(DataPrivacy.self, forKey: .dataPrivacy)
        dataPrivacy = dataPrivacyDecoded
        let idleSessionTTLInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .idleSessionTTLInSeconds)
        idleSessionTTLInSeconds = idleSessionTTLInSecondsDecoded
        let botTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .botTags)
        var botTagsDecoded0: [String:String]? = nil
        if let botTagsContainer = botTagsContainer {
            botTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in botTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    botTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        botTags = botTagsDecoded0
        let testBotAliasTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .testBotAliasTags)
        var testBotAliasTagsDecoded0: [String:String]? = nil
        if let testBotAliasTagsContainer = testBotAliasTagsContainer {
            testBotAliasTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in testBotAliasTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    testBotAliasTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        testBotAliasTags = testBotAliasTagsDecoded0
    }
}

public struct CreateBotLocaleInputBodyMiddleware: Middleware {
    public let id: String = "CreateBotLocaleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBotLocaleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBotLocaleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBotLocaleInput>
    public typealias MOutput = OperationOutput<CreateBotLocaleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBotLocaleOutputError>
}

extension CreateBotLocaleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBotLocaleInput(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), description: \(String(describing: description)), localeId: \(String(describing: localeId)), nluIntentConfidenceThreshold: \(String(describing: nluIntentConfidenceThreshold)), voiceSettings: \(String(describing: voiceSettings)))"}
}

extension CreateBotLocaleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case localeId
        case nluIntentConfidenceThreshold
        case voiceSettings
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let localeId = localeId {
            try encodeContainer.encode(localeId, forKey: .localeId)
        }
        if let nluIntentConfidenceThreshold = nluIntentConfidenceThreshold {
            try encodeContainer.encode(nluIntentConfidenceThreshold, forKey: .nluIntentConfidenceThreshold)
        }
        if let voiceSettings = voiceSettings {
            try encodeContainer.encode(voiceSettings, forKey: .voiceSettings)
        }
    }
}

public struct CreateBotLocaleInputHeadersMiddleware: Middleware {
    public let id: String = "CreateBotLocaleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBotLocaleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBotLocaleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBotLocaleInput>
    public typealias MOutput = OperationOutput<CreateBotLocaleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBotLocaleOutputError>
}

public struct CreateBotLocaleInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateBotLocaleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBotLocaleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBotLocaleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBotLocaleInput>
    public typealias MOutput = OperationOutput<CreateBotLocaleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBotLocaleOutputError>
}

public struct CreateBotLocaleInput: Equatable {
    /// <p>The identifier of the bot to create the locale for.</p>
    public let botId: String?
    /// <p>The version of the bot to create the locale for. This can only be
    ///          the draft version of the bot.</p>
    public let botVersion: String?
    /// <p>A description of the bot locale. Use this to help identify the bot
    ///          locale in lists.</p>
    public let description: String?
    /// <p>The identifier of the language and locale that the bot will be used
    ///          in. The string must match one of the supported locales. All of the
    ///          intents, slot types, and slots used in the bot must have the same
    ///          locale. For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
    public let localeId: String?
    /// <p>Determines the threshold where Amazon Lex will insert the
    ///             <code>AMAZON.FallbackIntent</code>,
    ///             <code>AMAZON.KendraSearchIntent</code>, or both when returning
    ///          alternative intents. <code>AMAZON.FallbackIntent</code> and
    ///             <code>AMAZON.KendraSearchIntent</code> are only inserted if they are
    ///          configured for the bot.</p>
    ///          <p>For example, suppose a bot is configured with the confidence
    ///          threshold of 0.80 and the <code>AMAZON.FallbackIntent</code>. Amazon Lex
    ///          returns three alternative intents with the following confidence scores:
    ///          IntentA (0.70), IntentB (0.60), IntentC (0.50). The response from the
    ///          PostText operation would be:</p>
    ///          <ul>
    ///             <li>
    ///                <p>AMAZON.FallbackIntent</p>
    ///             </li>
    ///             <li>
    ///                <p>IntentA</p>
    ///             </li>
    ///             <li>
    ///                <p>IntentB</p>
    ///             </li>
    ///             <li>
    ///                <p>IntentC</p>
    ///             </li>
    ///          </ul>
    public let nluIntentConfidenceThreshold: Double?
    /// <p>The Amazon Polly voice ID that Amazon Lex uses for voice interaction with the
    ///          user.</p>
    public let voiceSettings: VoiceSettings?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        description: String? = nil,
        localeId: String? = nil,
        nluIntentConfidenceThreshold: Double? = nil,
        voiceSettings: VoiceSettings? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.description = description
        self.localeId = localeId
        self.nluIntentConfidenceThreshold = nluIntentConfidenceThreshold
        self.voiceSettings = voiceSettings
    }
}

struct CreateBotLocaleInputBody: Equatable {
    public let localeId: String?
    public let description: String?
    public let nluIntentConfidenceThreshold: Double?
    public let voiceSettings: VoiceSettings?
}

extension CreateBotLocaleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case localeId
        case nluIntentConfidenceThreshold
        case voiceSettings
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let nluIntentConfidenceThresholdDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .nluIntentConfidenceThreshold)
        nluIntentConfidenceThreshold = nluIntentConfidenceThresholdDecoded
        let voiceSettingsDecoded = try containerValues.decodeIfPresent(VoiceSettings.self, forKey: .voiceSettings)
        voiceSettings = voiceSettingsDecoded
    }
}

extension CreateBotLocaleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBotLocaleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBotLocaleOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case preconditionFailedException(PreconditionFailedException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBotLocaleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBotLocaleOutputResponse(botId: \(String(describing: botId)), botLocaleStatus: \(String(describing: botLocaleStatus)), botVersion: \(String(describing: botVersion)), creationDateTime: \(String(describing: creationDateTime)), description: \(String(describing: description)), localeId: \(String(describing: localeId)), localeName: \(String(describing: localeName)), nluIntentConfidenceThreshold: \(String(describing: nluIntentConfidenceThreshold)), voiceSettings: \(String(describing: voiceSettings)))"}
}

extension CreateBotLocaleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateBotLocaleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botId = output.botId
            self.botLocaleStatus = output.botLocaleStatus
            self.botVersion = output.botVersion
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.localeId = output.localeId
            self.localeName = output.localeName
            self.nluIntentConfidenceThreshold = output.nluIntentConfidenceThreshold
            self.voiceSettings = output.voiceSettings
        } else {
            self.botId = nil
            self.botLocaleStatus = nil
            self.botVersion = nil
            self.creationDateTime = nil
            self.description = nil
            self.localeId = nil
            self.localeName = nil
            self.nluIntentConfidenceThreshold = nil
            self.voiceSettings = nil
        }
    }
}

public struct CreateBotLocaleOutputResponse: Equatable {
    /// <p>The specified bot identifier.</p>
    public let botId: String?
    /// <p>The status of the bot.</p>
    ///          <p>When the status is <code>Creating</code> the bot locale is being
    ///          configured. When the status is <code>Building</code> Amazon Lex is building
    ///          the bot for testing and use.</p>
    ///          <p>If the status of the bot is <code>ReadyExpressTesting</code>, you
    ///          can test the bot using the exact utterances specified in the bots'
    ///          intents. When the bot is ready for full testing or to run, the status
    ///          is <code>Built</code>.</p>
    ///          <p>If there was a problem with building the bot, the status is
    ///             <code>Failed</code>. If the bot was saved but not built, the status
    ///          is <code>NotBuilt</code>.</p>
    public let botLocaleStatus: BotLocaleStatus?
    /// <p>The specified bot version.</p>
    public let botVersion: String?
    /// <p>A timestamp specifying the date and time that the bot locale was
    ///          created.</p>
    public let creationDateTime: Date?
    /// <p>The specified description of the bot locale.</p>
    public let description: String?
    /// <p>The specified locale identifier.</p>
    public let localeId: String?
    /// <p>The specified locale name.</p>
    public let localeName: String?
    /// <p>The specified confidence threshold for inserting the
    ///             <code>AMAZON.FallbackIntent</code> and
    ///             <code>AMAZON.KendraSearchIntent</code> intents.</p>
    public let nluIntentConfidenceThreshold: Double?
    /// <p>The Amazon Polly voice ID that Amazon Lex uses for voice interaction with the
    ///          user.</p>
    public let voiceSettings: VoiceSettings?

    public init (
        botId: String? = nil,
        botLocaleStatus: BotLocaleStatus? = nil,
        botVersion: String? = nil,
        creationDateTime: Date? = nil,
        description: String? = nil,
        localeId: String? = nil,
        localeName: String? = nil,
        nluIntentConfidenceThreshold: Double? = nil,
        voiceSettings: VoiceSettings? = nil
    )
    {
        self.botId = botId
        self.botLocaleStatus = botLocaleStatus
        self.botVersion = botVersion
        self.creationDateTime = creationDateTime
        self.description = description
        self.localeId = localeId
        self.localeName = localeName
        self.nluIntentConfidenceThreshold = nluIntentConfidenceThreshold
        self.voiceSettings = voiceSettings
    }
}

struct CreateBotLocaleOutputResponseBody: Equatable {
    public let botId: String?
    public let botVersion: String?
    public let localeName: String?
    public let localeId: String?
    public let description: String?
    public let nluIntentConfidenceThreshold: Double?
    public let voiceSettings: VoiceSettings?
    public let botLocaleStatus: BotLocaleStatus?
    public let creationDateTime: Date?
}

extension CreateBotLocaleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botId
        case botLocaleStatus
        case botVersion
        case creationDateTime
        case description
        case localeId
        case localeName
        case nluIntentConfidenceThreshold
        case voiceSettings
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localeName)
        localeName = localeNameDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let nluIntentConfidenceThresholdDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .nluIntentConfidenceThreshold)
        nluIntentConfidenceThreshold = nluIntentConfidenceThresholdDecoded
        let voiceSettingsDecoded = try containerValues.decodeIfPresent(VoiceSettings.self, forKey: .voiceSettings)
        voiceSettings = voiceSettingsDecoded
        let botLocaleStatusDecoded = try containerValues.decodeIfPresent(BotLocaleStatus.self, forKey: .botLocaleStatus)
        botLocaleStatus = botLocaleStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
    }
}

extension CreateBotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBotOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case preconditionFailedException(PreconditionFailedException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBotOutputResponse(botId: \(String(describing: botId)), botName: \(String(describing: botName)), botStatus: \(String(describing: botStatus)), botTags: \(String(describing: botTags)), creationDateTime: \(String(describing: creationDateTime)), dataPrivacy: \(String(describing: dataPrivacy)), description: \(String(describing: description)), idleSessionTTLInSeconds: \(String(describing: idleSessionTTLInSeconds)), roleArn: \(String(describing: roleArn)), testBotAliasTags: \(String(describing: testBotAliasTags)))"}
}

extension CreateBotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateBotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botId = output.botId
            self.botName = output.botName
            self.botStatus = output.botStatus
            self.botTags = output.botTags
            self.creationDateTime = output.creationDateTime
            self.dataPrivacy = output.dataPrivacy
            self.description = output.description
            self.idleSessionTTLInSeconds = output.idleSessionTTLInSeconds
            self.roleArn = output.roleArn
            self.testBotAliasTags = output.testBotAliasTags
        } else {
            self.botId = nil
            self.botName = nil
            self.botStatus = nil
            self.botTags = nil
            self.creationDateTime = nil
            self.dataPrivacy = nil
            self.description = nil
            self.idleSessionTTLInSeconds = nil
            self.roleArn = nil
            self.testBotAliasTags = nil
        }
    }
}

public struct CreateBotOutputResponse: Equatable {
    /// <p>A unique identifier for a particular bot. You use this to identify
    ///          the bot when you call other Amazon Lex API operations.</p>
    public let botId: String?
    /// <p>The name specified for the bot.</p>
    public let botName: String?
    /// <p>Shows the current status of the bot. The bot is first in the
    ///             <code>Creating</code> status. Once the bot is read for use, it
    ///          changes to the <code>Available</code> status. After the bot is created,
    ///          you can use the <code>Draft</code> version of the bot.</p>
    public let botStatus: BotStatus?
    /// <p>A list of tags associated with the bot.</p>
    public let botTags: [String:String]?
    /// <p>A timestamp indicating the date and time that the bot was
    ///          created.</p>
    public let creationDateTime: Date?
    /// <p>The data privacy settings specified for the bot.</p>
    public let dataPrivacy: DataPrivacy?
    /// <p>The description specified for the bot.</p>
    public let description: String?
    /// <p>The session idle time specified for the bot.</p>
    public let idleSessionTTLInSeconds: Int?
    /// <p>The IAM role specified for the bot.</p>
    public let roleArn: String?
    /// <p>A list of tags associated with the test alias for the bot.</p>
    public let testBotAliasTags: [String:String]?

    public init (
        botId: String? = nil,
        botName: String? = nil,
        botStatus: BotStatus? = nil,
        botTags: [String:String]? = nil,
        creationDateTime: Date? = nil,
        dataPrivacy: DataPrivacy? = nil,
        description: String? = nil,
        idleSessionTTLInSeconds: Int? = nil,
        roleArn: String? = nil,
        testBotAliasTags: [String:String]? = nil
    )
    {
        self.botId = botId
        self.botName = botName
        self.botStatus = botStatus
        self.botTags = botTags
        self.creationDateTime = creationDateTime
        self.dataPrivacy = dataPrivacy
        self.description = description
        self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
        self.roleArn = roleArn
        self.testBotAliasTags = testBotAliasTags
    }
}

struct CreateBotOutputResponseBody: Equatable {
    public let botId: String?
    public let botName: String?
    public let description: String?
    public let roleArn: String?
    public let dataPrivacy: DataPrivacy?
    public let idleSessionTTLInSeconds: Int?
    public let botStatus: BotStatus?
    public let creationDateTime: Date?
    public let botTags: [String:String]?
    public let testBotAliasTags: [String:String]?
}

extension CreateBotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botId
        case botName
        case botStatus
        case botTags
        case creationDateTime
        case dataPrivacy
        case description
        case idleSessionTTLInSeconds
        case roleArn
        case testBotAliasTags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botName)
        botName = botNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let dataPrivacyDecoded = try containerValues.decodeIfPresent(DataPrivacy.self, forKey: .dataPrivacy)
        dataPrivacy = dataPrivacyDecoded
        let idleSessionTTLInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .idleSessionTTLInSeconds)
        idleSessionTTLInSeconds = idleSessionTTLInSecondsDecoded
        let botStatusDecoded = try containerValues.decodeIfPresent(BotStatus.self, forKey: .botStatus)
        botStatus = botStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let botTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .botTags)
        var botTagsDecoded0: [String:String]? = nil
        if let botTagsContainer = botTagsContainer {
            botTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in botTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    botTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        botTags = botTagsDecoded0
        let testBotAliasTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .testBotAliasTags)
        var testBotAliasTagsDecoded0: [String:String]? = nil
        if let testBotAliasTagsContainer = testBotAliasTagsContainer {
            testBotAliasTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in testBotAliasTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    testBotAliasTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        testBotAliasTags = testBotAliasTagsDecoded0
    }
}

public struct CreateBotVersionInputBodyMiddleware: Middleware {
    public let id: String = "CreateBotVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBotVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBotVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBotVersionInput>
    public typealias MOutput = OperationOutput<CreateBotVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBotVersionOutputError>
}

extension CreateBotVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBotVersionInput(botId: \(String(describing: botId)), botVersionLocaleSpecification: \(String(describing: botVersionLocaleSpecification)), description: \(String(describing: description)))"}
}

extension CreateBotVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case botVersionLocaleSpecification
        case description
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botVersionLocaleSpecification = botVersionLocaleSpecification {
            var botVersionLocaleSpecificationContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .botVersionLocaleSpecification)
            for (dictKey0, botversionlocalespecification0) in botVersionLocaleSpecification {
                try botVersionLocaleSpecificationContainer.encode(botversionlocalespecification0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

public struct CreateBotVersionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateBotVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBotVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBotVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBotVersionInput>
    public typealias MOutput = OperationOutput<CreateBotVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBotVersionOutputError>
}

public struct CreateBotVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateBotVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBotVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBotVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBotVersionInput>
    public typealias MOutput = OperationOutput<CreateBotVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBotVersionOutputError>
}

public struct CreateBotVersionInput: Equatable {
    /// <p>The identifier of the bot to create the version for.</p>
    public let botId: String?
    /// <p>Specifies the locales that Amazon Lex adds to this version. You can
    ///          choose the <code>Draft</code> version or any other previously published
    ///          version for each locale. When you specify a source version, the locale
    ///          data is copied from the source version to the new version.</p>
    public let botVersionLocaleSpecification: [String:BotVersionLocaleDetails]?
    /// <p>A description of the version. Use the description to help identify
    ///          the version in lists.</p>
    public let description: String?

    public init (
        botId: String? = nil,
        botVersionLocaleSpecification: [String:BotVersionLocaleDetails]? = nil,
        description: String? = nil
    )
    {
        self.botId = botId
        self.botVersionLocaleSpecification = botVersionLocaleSpecification
        self.description = description
    }
}

struct CreateBotVersionInputBody: Equatable {
    public let description: String?
    public let botVersionLocaleSpecification: [String:BotVersionLocaleDetails]?
}

extension CreateBotVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botVersionLocaleSpecification
        case description
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let botVersionLocaleSpecificationContainer = try containerValues.decodeIfPresent([String: BotVersionLocaleDetails?].self, forKey: .botVersionLocaleSpecification)
        var botVersionLocaleSpecificationDecoded0: [String:BotVersionLocaleDetails]? = nil
        if let botVersionLocaleSpecificationContainer = botVersionLocaleSpecificationContainer {
            botVersionLocaleSpecificationDecoded0 = [String:BotVersionLocaleDetails]()
            for (key0, botversionlocaledetails0) in botVersionLocaleSpecificationContainer {
                if let botversionlocaledetails0 = botversionlocaledetails0 {
                    botVersionLocaleSpecificationDecoded0?[key0] = botversionlocaledetails0
                }
            }
        }
        botVersionLocaleSpecification = botVersionLocaleSpecificationDecoded0
    }
}

extension CreateBotVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBotVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBotVersionOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case preconditionFailedException(PreconditionFailedException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBotVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBotVersionOutputResponse(botId: \(String(describing: botId)), botStatus: \(String(describing: botStatus)), botVersion: \(String(describing: botVersion)), botVersionLocaleSpecification: \(String(describing: botVersionLocaleSpecification)), creationDateTime: \(String(describing: creationDateTime)), description: \(String(describing: description)))"}
}

extension CreateBotVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateBotVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botId = output.botId
            self.botStatus = output.botStatus
            self.botVersion = output.botVersion
            self.botVersionLocaleSpecification = output.botVersionLocaleSpecification
            self.creationDateTime = output.creationDateTime
            self.description = output.description
        } else {
            self.botId = nil
            self.botStatus = nil
            self.botVersion = nil
            self.botVersionLocaleSpecification = nil
            self.creationDateTime = nil
            self.description = nil
        }
    }
}

public struct CreateBotVersionOutputResponse: Equatable {
    /// <p>The bot identifier specified in the request.</p>
    public let botId: String?
    /// <p>When you send a request to create or update a bot, Amazon Lex sets the
    ///          status response element to <code>Creating</code>. After Amazon Lex builds
    ///          the bot, it sets status to <code>Available</code>. If Amazon Lex can't build
    ///          the bot, it sets status to <code>Failed</code>.</p>
    public let botStatus: BotStatus?
    /// <p>The version number assigned to the version.</p>
    public let botVersion: String?
    /// <p>The source versions used for each locale in the new version.</p>
    public let botVersionLocaleSpecification: [String:BotVersionLocaleDetails]?
    /// <p>A timestamp of the date and time that the version was
    ///          created.</p>
    public let creationDateTime: Date?
    /// <p>The description of the version specified in the request.</p>
    public let description: String?

    public init (
        botId: String? = nil,
        botStatus: BotStatus? = nil,
        botVersion: String? = nil,
        botVersionLocaleSpecification: [String:BotVersionLocaleDetails]? = nil,
        creationDateTime: Date? = nil,
        description: String? = nil
    )
    {
        self.botId = botId
        self.botStatus = botStatus
        self.botVersion = botVersion
        self.botVersionLocaleSpecification = botVersionLocaleSpecification
        self.creationDateTime = creationDateTime
        self.description = description
    }
}

struct CreateBotVersionOutputResponseBody: Equatable {
    public let botId: String?
    public let description: String?
    public let botVersion: String?
    public let botVersionLocaleSpecification: [String:BotVersionLocaleDetails]?
    public let botStatus: BotStatus?
    public let creationDateTime: Date?
}

extension CreateBotVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botId
        case botStatus
        case botVersion
        case botVersionLocaleSpecification
        case creationDateTime
        case description
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let botVersionLocaleSpecificationContainer = try containerValues.decodeIfPresent([String: BotVersionLocaleDetails?].self, forKey: .botVersionLocaleSpecification)
        var botVersionLocaleSpecificationDecoded0: [String:BotVersionLocaleDetails]? = nil
        if let botVersionLocaleSpecificationContainer = botVersionLocaleSpecificationContainer {
            botVersionLocaleSpecificationDecoded0 = [String:BotVersionLocaleDetails]()
            for (key0, botversionlocaledetails0) in botVersionLocaleSpecificationContainer {
                if let botversionlocaledetails0 = botversionlocaledetails0 {
                    botVersionLocaleSpecificationDecoded0?[key0] = botversionlocaledetails0
                }
            }
        }
        botVersionLocaleSpecification = botVersionLocaleSpecificationDecoded0
        let botStatusDecoded = try containerValues.decodeIfPresent(BotStatus.self, forKey: .botStatus)
        botStatus = botStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
    }
}

public struct CreateExportInputBodyMiddleware: Middleware {
    public let id: String = "CreateExportInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateExportInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateExportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateExportInput>
    public typealias MOutput = OperationOutput<CreateExportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateExportOutputError>
}

extension CreateExportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateExportInput(fileFormat: \(String(describing: fileFormat)), filePassword: \(String(describing: filePassword)), resourceSpecification: \(String(describing: resourceSpecification)))"}
}

extension CreateExportInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fileFormat
        case filePassword
        case resourceSpecification
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileFormat = fileFormat {
            try encodeContainer.encode(fileFormat.rawValue, forKey: .fileFormat)
        }
        if let filePassword = filePassword {
            try encodeContainer.encode(filePassword, forKey: .filePassword)
        }
        if let resourceSpecification = resourceSpecification {
            try encodeContainer.encode(resourceSpecification, forKey: .resourceSpecification)
        }
    }
}

public struct CreateExportInputHeadersMiddleware: Middleware {
    public let id: String = "CreateExportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateExportInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateExportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateExportInput>
    public typealias MOutput = OperationOutput<CreateExportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateExportOutputError>
}

public struct CreateExportInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateExportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateExportInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateExportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateExportInput>
    public typealias MOutput = OperationOutput<CreateExportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateExportOutputError>
}

public struct CreateExportInput: Equatable {
    /// <p>The file format of the bot or bot locale definition files.</p>
    public let fileFormat: ImportExportFileFormat?
    /// <p>An password to use to encrypt the exported archive. Using a password
    ///          is optional, but you should encrypt the archive to protect the data in
    ///          transit between Amazon Lex and your local computer.</p>
    public let filePassword: String?
    /// <p>Specifies the type of resource to export, either a bot or a bot
    ///          locale. You can only specify one type of resource to export.</p>
    public let resourceSpecification: ExportResourceSpecification?

    public init (
        fileFormat: ImportExportFileFormat? = nil,
        filePassword: String? = nil,
        resourceSpecification: ExportResourceSpecification? = nil
    )
    {
        self.fileFormat = fileFormat
        self.filePassword = filePassword
        self.resourceSpecification = resourceSpecification
    }
}

struct CreateExportInputBody: Equatable {
    public let resourceSpecification: ExportResourceSpecification?
    public let fileFormat: ImportExportFileFormat?
    public let filePassword: String?
}

extension CreateExportInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileFormat
        case filePassword
        case resourceSpecification
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSpecificationDecoded = try containerValues.decodeIfPresent(ExportResourceSpecification.self, forKey: .resourceSpecification)
        resourceSpecification = resourceSpecificationDecoded
        let fileFormatDecoded = try containerValues.decodeIfPresent(ImportExportFileFormat.self, forKey: .fileFormat)
        fileFormat = fileFormatDecoded
        let filePasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filePassword)
        filePassword = filePasswordDecoded
    }
}

extension CreateExportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateExportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateExportOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateExportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateExportOutputResponse(creationDateTime: \(String(describing: creationDateTime)), exportId: \(String(describing: exportId)), exportStatus: \(String(describing: exportStatus)), fileFormat: \(String(describing: fileFormat)), resourceSpecification: \(String(describing: resourceSpecification)))"}
}

extension CreateExportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateExportOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.creationDateTime = output.creationDateTime
            self.exportId = output.exportId
            self.exportStatus = output.exportStatus
            self.fileFormat = output.fileFormat
            self.resourceSpecification = output.resourceSpecification
        } else {
            self.creationDateTime = nil
            self.exportId = nil
            self.exportStatus = nil
            self.fileFormat = nil
            self.resourceSpecification = nil
        }
    }
}

public struct CreateExportOutputResponse: Equatable {
    /// <p>The date and time that the request to export a bot was
    ///          created.</p>
    public let creationDateTime: Date?
    /// <p>An identifier for a specific request to create an export.</p>
    public let exportId: String?
    /// <p>The status of the export. When the status is <code>Completed</code>,
    ///          you can use the  operation to get
    ///          the pre-signed S3 URL link to your exported bot or bot locale.</p>
    public let exportStatus: ExportStatus?
    /// <p>The file format used for the bot or bot locale definition
    ///          files.</p>
    public let fileFormat: ImportExportFileFormat?
    /// <p>A description of the type of resource that was exported, either a
    ///          bot or a bot locale.</p>
    public let resourceSpecification: ExportResourceSpecification?

    public init (
        creationDateTime: Date? = nil,
        exportId: String? = nil,
        exportStatus: ExportStatus? = nil,
        fileFormat: ImportExportFileFormat? = nil,
        resourceSpecification: ExportResourceSpecification? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.exportId = exportId
        self.exportStatus = exportStatus
        self.fileFormat = fileFormat
        self.resourceSpecification = resourceSpecification
    }
}

struct CreateExportOutputResponseBody: Equatable {
    public let exportId: String?
    public let resourceSpecification: ExportResourceSpecification?
    public let fileFormat: ImportExportFileFormat?
    public let exportStatus: ExportStatus?
    public let creationDateTime: Date?
}

extension CreateExportOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationDateTime
        case exportId
        case exportStatus
        case fileFormat
        case resourceSpecification
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exportId)
        exportId = exportIdDecoded
        let resourceSpecificationDecoded = try containerValues.decodeIfPresent(ExportResourceSpecification.self, forKey: .resourceSpecification)
        resourceSpecification = resourceSpecificationDecoded
        let fileFormatDecoded = try containerValues.decodeIfPresent(ImportExportFileFormat.self, forKey: .fileFormat)
        fileFormat = fileFormatDecoded
        let exportStatusDecoded = try containerValues.decodeIfPresent(ExportStatus.self, forKey: .exportStatus)
        exportStatus = exportStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
    }
}

public struct CreateIntentInputBodyMiddleware: Middleware {
    public let id: String = "CreateIntentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIntentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIntentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIntentInput>
    public typealias MOutput = OperationOutput<CreateIntentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIntentOutputError>
}

extension CreateIntentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateIntentInput(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), description: \(String(describing: description)), dialogCodeHook: \(String(describing: dialogCodeHook)), fulfillmentCodeHook: \(String(describing: fulfillmentCodeHook)), inputContexts: \(String(describing: inputContexts)), intentClosingSetting: \(String(describing: intentClosingSetting)), intentConfirmationSetting: \(String(describing: intentConfirmationSetting)), intentName: \(String(describing: intentName)), kendraConfiguration: \(String(describing: kendraConfiguration)), localeId: \(String(describing: localeId)), outputContexts: \(String(describing: outputContexts)), parentIntentSignature: \(String(describing: parentIntentSignature)), sampleUtterances: \(String(describing: sampleUtterances)))"}
}

extension CreateIntentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case dialogCodeHook
        case fulfillmentCodeHook
        case inputContexts
        case intentClosingSetting
        case intentConfirmationSetting
        case intentName
        case kendraConfiguration
        case outputContexts
        case parentIntentSignature
        case sampleUtterances
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dialogCodeHook = dialogCodeHook {
            try encodeContainer.encode(dialogCodeHook, forKey: .dialogCodeHook)
        }
        if let fulfillmentCodeHook = fulfillmentCodeHook {
            try encodeContainer.encode(fulfillmentCodeHook, forKey: .fulfillmentCodeHook)
        }
        if let inputContexts = inputContexts {
            var inputContextsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputContexts)
            for inputcontextslist0 in inputContexts {
                try inputContextsContainer.encode(inputcontextslist0)
            }
        }
        if let intentClosingSetting = intentClosingSetting {
            try encodeContainer.encode(intentClosingSetting, forKey: .intentClosingSetting)
        }
        if let intentConfirmationSetting = intentConfirmationSetting {
            try encodeContainer.encode(intentConfirmationSetting, forKey: .intentConfirmationSetting)
        }
        if let intentName = intentName {
            try encodeContainer.encode(intentName, forKey: .intentName)
        }
        if let kendraConfiguration = kendraConfiguration {
            try encodeContainer.encode(kendraConfiguration, forKey: .kendraConfiguration)
        }
        if let outputContexts = outputContexts {
            var outputContextsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputContexts)
            for outputcontextslist0 in outputContexts {
                try outputContextsContainer.encode(outputcontextslist0)
            }
        }
        if let parentIntentSignature = parentIntentSignature {
            try encodeContainer.encode(parentIntentSignature, forKey: .parentIntentSignature)
        }
        if let sampleUtterances = sampleUtterances {
            var sampleUtterancesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sampleUtterances)
            for sampleutteranceslist0 in sampleUtterances {
                try sampleUtterancesContainer.encode(sampleutteranceslist0)
            }
        }
    }
}

public struct CreateIntentInputHeadersMiddleware: Middleware {
    public let id: String = "CreateIntentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIntentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIntentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIntentInput>
    public typealias MOutput = OperationOutput<CreateIntentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIntentOutputError>
}

public struct CreateIntentInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateIntentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIntentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIntentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIntentInput>
    public typealias MOutput = OperationOutput<CreateIntentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIntentOutputError>
}

public struct CreateIntentInput: Equatable {
    /// <p>The identifier of the bot associated with this intent.</p>
    public let botId: String?
    /// <p>The identifier of the version of the bot associated with this
    ///          intent.</p>
    public let botVersion: String?
    /// <p>A description of the intent. Use the description to help identify
    ///          the intent in lists.</p>
    public let description: String?
    /// <p>Specifies that Amazon Lex invokes the alias Lambda function for each user
    ///          input. You can invoke this Lambda function to personalize user
    ///          interaction.</p>
    ///          <p>For example, suppose that your bot determines that the user's name
    ///          is John. You Lambda function might retrieve John's information from a
    ///          backend database and prepopulate some of the values. For example, if
    ///          you find that John is gluten intolerant, you might set the
    ///          corresponding intent slot, <code>glutenIntolerant</code> to
    ///             <code>true</code>. You might find John's phone number and set the
    ///          corresponding session attribute.</p>
    public let dialogCodeHook: DialogCodeHookSettings?
    /// <p>Specifies that Amazon Lex invokes the alias Lambda function when the
    ///          intent is ready for fulfillment. You can invoke this function to
    ///          complete the bot's transaction with the user.</p>
    ///          <p>For example, in a pizza ordering bot, the Lambda function can look up
    ///          the closest pizza restaurant to the customer's location and then place
    ///          an order on the customer's behalf.</p>
    public let fulfillmentCodeHook: FulfillmentCodeHookSettings?
    /// <p>A list of contexts that must be active for this intent to be
    ///          considered by Amazon Lex.</p>
    ///          <p>When an intent has an input context list, Amazon Lex only considers using
    ///          the intent in an interaction with the user when the specified contexts
    ///          are included in the active context list for the session. If the
    ///          contexts are not active, then Amazon Lex will not use the intent.</p>
    ///          <p>A context can be automatically activated using the
    ///             <code>outputContexts</code> property or it can be set at
    ///          runtime.</p>
    ///          <p> For example, if there are two intents with different input contexts
    ///          that respond to the same utterances, only the intent with the active
    ///          context will respond.</p>
    ///          <p>An intent may have up to 5 input contexts. If an intent has multiple
    ///          input contexts, all of the contexts must be active to consider the
    ///          intent.</p>
    public let inputContexts: [InputContext]?
    /// <p>Sets the response that Amazon Lex sends to the user when the intent is
    ///          closed.</p>
    public let intentClosingSetting: IntentClosingSetting?
    /// <p>Provides prompts that Amazon Lex sends to the user to confirm the
    ///          completion of an intent. If the user answers "no," the settings contain
    ///          a statement that is sent to the user to end the intent.</p>
    public let intentConfirmationSetting: IntentConfirmationSetting?
    /// <p>The name of the intent. Intent names must be unique in the locale
    ///          that contains the intent and cannot match the name of any built-in
    ///          intent.</p>
    public let intentName: String?
    /// <p>Configuration information required to use the
    ///             <code>AMAZON.KendraSearchIntent</code> intent to connect to an Amazon Kendra
    ///          index. The <code>AMAZON.KendraSearchIntent</code> intent is called when
    ///          Amazon Lex can't determine another intent to invoke.</p>
    public let kendraConfiguration: KendraConfiguration?
    /// <p>The identifier of the language and locale where this intent is used.
    ///          All of the bots, slot types, and slots used by the intent must have the
    ///          same locale. For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
    public let localeId: String?
    /// <p>A lists of contexts that the intent activates when it is
    ///          fulfilled.</p>
    ///          <p>You can use an output context to indicate the intents that Amazon Lex
    ///          should consider for the next turn of the conversation with a customer. </p>
    ///          <p>When you use the <code>outputContextsList</code> property, all of
    ///          the contexts specified in the list are activated when the intent is
    ///          fulfilled. You can set up to 10 output contexts. You can also set the
    ///          number of conversation turns that the context should be active, or the
    ///          length of time that the context should be active.</p>
    public let outputContexts: [OutputContext]?
    /// <p>A unique identifier for the built-in intent to base this intent
    ///          on.</p>
    public let parentIntentSignature: String?
    /// <p>An array of strings that a user might say to signal the intent. For
    ///          example, "I want a pizza", or "I want a {PizzaSize} pizza". </p>
    ///          <p>In an utterance, slot names are enclosed in curly braces ("{", "}")
    ///          to indicate where they should be displayed in the utterance shown to
    ///          the user.. </p>
    public let sampleUtterances: [SampleUtterance]?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        description: String? = nil,
        dialogCodeHook: DialogCodeHookSettings? = nil,
        fulfillmentCodeHook: FulfillmentCodeHookSettings? = nil,
        inputContexts: [InputContext]? = nil,
        intentClosingSetting: IntentClosingSetting? = nil,
        intentConfirmationSetting: IntentConfirmationSetting? = nil,
        intentName: String? = nil,
        kendraConfiguration: KendraConfiguration? = nil,
        localeId: String? = nil,
        outputContexts: [OutputContext]? = nil,
        parentIntentSignature: String? = nil,
        sampleUtterances: [SampleUtterance]? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.description = description
        self.dialogCodeHook = dialogCodeHook
        self.fulfillmentCodeHook = fulfillmentCodeHook
        self.inputContexts = inputContexts
        self.intentClosingSetting = intentClosingSetting
        self.intentConfirmationSetting = intentConfirmationSetting
        self.intentName = intentName
        self.kendraConfiguration = kendraConfiguration
        self.localeId = localeId
        self.outputContexts = outputContexts
        self.parentIntentSignature = parentIntentSignature
        self.sampleUtterances = sampleUtterances
    }
}

struct CreateIntentInputBody: Equatable {
    public let intentName: String?
    public let description: String?
    public let parentIntentSignature: String?
    public let sampleUtterances: [SampleUtterance]?
    public let dialogCodeHook: DialogCodeHookSettings?
    public let fulfillmentCodeHook: FulfillmentCodeHookSettings?
    public let intentConfirmationSetting: IntentConfirmationSetting?
    public let intentClosingSetting: IntentClosingSetting?
    public let inputContexts: [InputContext]?
    public let outputContexts: [OutputContext]?
    public let kendraConfiguration: KendraConfiguration?
}

extension CreateIntentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case dialogCodeHook
        case fulfillmentCodeHook
        case inputContexts
        case intentClosingSetting
        case intentConfirmationSetting
        case intentName
        case kendraConfiguration
        case outputContexts
        case parentIntentSignature
        case sampleUtterances
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .intentName)
        intentName = intentNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let parentIntentSignatureDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentIntentSignature)
        parentIntentSignature = parentIntentSignatureDecoded
        let sampleUtterancesContainer = try containerValues.decodeIfPresent([SampleUtterance?].self, forKey: .sampleUtterances)
        var sampleUtterancesDecoded0:[SampleUtterance]? = nil
        if let sampleUtterancesContainer = sampleUtterancesContainer {
            sampleUtterancesDecoded0 = [SampleUtterance]()
            for structure0 in sampleUtterancesContainer {
                if let structure0 = structure0 {
                    sampleUtterancesDecoded0?.append(structure0)
                }
            }
        }
        sampleUtterances = sampleUtterancesDecoded0
        let dialogCodeHookDecoded = try containerValues.decodeIfPresent(DialogCodeHookSettings.self, forKey: .dialogCodeHook)
        dialogCodeHook = dialogCodeHookDecoded
        let fulfillmentCodeHookDecoded = try containerValues.decodeIfPresent(FulfillmentCodeHookSettings.self, forKey: .fulfillmentCodeHook)
        fulfillmentCodeHook = fulfillmentCodeHookDecoded
        let intentConfirmationSettingDecoded = try containerValues.decodeIfPresent(IntentConfirmationSetting.self, forKey: .intentConfirmationSetting)
        intentConfirmationSetting = intentConfirmationSettingDecoded
        let intentClosingSettingDecoded = try containerValues.decodeIfPresent(IntentClosingSetting.self, forKey: .intentClosingSetting)
        intentClosingSetting = intentClosingSettingDecoded
        let inputContextsContainer = try containerValues.decodeIfPresent([InputContext?].self, forKey: .inputContexts)
        var inputContextsDecoded0:[InputContext]? = nil
        if let inputContextsContainer = inputContextsContainer {
            inputContextsDecoded0 = [InputContext]()
            for structure0 in inputContextsContainer {
                if let structure0 = structure0 {
                    inputContextsDecoded0?.append(structure0)
                }
            }
        }
        inputContexts = inputContextsDecoded0
        let outputContextsContainer = try containerValues.decodeIfPresent([OutputContext?].self, forKey: .outputContexts)
        var outputContextsDecoded0:[OutputContext]? = nil
        if let outputContextsContainer = outputContextsContainer {
            outputContextsDecoded0 = [OutputContext]()
            for structure0 in outputContextsContainer {
                if let structure0 = structure0 {
                    outputContextsDecoded0?.append(structure0)
                }
            }
        }
        outputContexts = outputContextsDecoded0
        let kendraConfigurationDecoded = try containerValues.decodeIfPresent(KendraConfiguration.self, forKey: .kendraConfiguration)
        kendraConfiguration = kendraConfigurationDecoded
    }
}

extension CreateIntentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateIntentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateIntentOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case preconditionFailedException(PreconditionFailedException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateIntentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateIntentOutputResponse(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), creationDateTime: \(String(describing: creationDateTime)), description: \(String(describing: description)), dialogCodeHook: \(String(describing: dialogCodeHook)), fulfillmentCodeHook: \(String(describing: fulfillmentCodeHook)), inputContexts: \(String(describing: inputContexts)), intentClosingSetting: \(String(describing: intentClosingSetting)), intentConfirmationSetting: \(String(describing: intentConfirmationSetting)), intentId: \(String(describing: intentId)), intentName: \(String(describing: intentName)), kendraConfiguration: \(String(describing: kendraConfiguration)), localeId: \(String(describing: localeId)), outputContexts: \(String(describing: outputContexts)), parentIntentSignature: \(String(describing: parentIntentSignature)), sampleUtterances: \(String(describing: sampleUtterances)))"}
}

extension CreateIntentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateIntentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.dialogCodeHook = output.dialogCodeHook
            self.fulfillmentCodeHook = output.fulfillmentCodeHook
            self.inputContexts = output.inputContexts
            self.intentClosingSetting = output.intentClosingSetting
            self.intentConfirmationSetting = output.intentConfirmationSetting
            self.intentId = output.intentId
            self.intentName = output.intentName
            self.kendraConfiguration = output.kendraConfiguration
            self.localeId = output.localeId
            self.outputContexts = output.outputContexts
            self.parentIntentSignature = output.parentIntentSignature
            self.sampleUtterances = output.sampleUtterances
        } else {
            self.botId = nil
            self.botVersion = nil
            self.creationDateTime = nil
            self.description = nil
            self.dialogCodeHook = nil
            self.fulfillmentCodeHook = nil
            self.inputContexts = nil
            self.intentClosingSetting = nil
            self.intentConfirmationSetting = nil
            self.intentId = nil
            self.intentName = nil
            self.kendraConfiguration = nil
            self.localeId = nil
            self.outputContexts = nil
            self.parentIntentSignature = nil
            self.sampleUtterances = nil
        }
    }
}

public struct CreateIntentOutputResponse: Equatable {
    /// <p>The identifier of the bot associated with the intent.</p>
    public let botId: String?
    /// <p>The identifier of the version of the bot associated with the
    ///          intent.</p>
    public let botVersion: String?
    /// <p>A timestamp of the date and time that the intent was created.</p>
    public let creationDateTime: Date?
    /// <p>The description specified for the intent.</p>
    public let description: String?
    /// <p>The dialog Lambda function specified for the intent.</p>
    public let dialogCodeHook: DialogCodeHookSettings?
    /// <p>The fulfillment Lambda function specified for the intent.</p>
    public let fulfillmentCodeHook: FulfillmentCodeHookSettings?
    /// <p>The list of input contexts specified for the intent.</p>
    public let inputContexts: [InputContext]?
    /// <p>The closing setting specified for the intent.</p>
    public let intentClosingSetting: IntentClosingSetting?
    /// <p>The confirmation setting specified for the intent.</p>
    public let intentConfirmationSetting: IntentConfirmationSetting?
    /// <p>A unique identifier for the intent.</p>
    public let intentId: String?
    /// <p>The name specified for the intent.</p>
    public let intentName: String?
    /// <p>Configuration for searching a Amazon Kendra index specified for the
    ///          intent.</p>
    public let kendraConfiguration: KendraConfiguration?
    /// <p>The locale that the intent is specified to use.</p>
    public let localeId: String?
    /// <p>The list of output contexts specified for the intent.</p>
    public let outputContexts: [OutputContext]?
    /// <p>The signature of the parent intent specified for the intent.</p>
    public let parentIntentSignature: String?
    /// <p>The sample utterances specified for the intent.</p>
    public let sampleUtterances: [SampleUtterance]?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        creationDateTime: Date? = nil,
        description: String? = nil,
        dialogCodeHook: DialogCodeHookSettings? = nil,
        fulfillmentCodeHook: FulfillmentCodeHookSettings? = nil,
        inputContexts: [InputContext]? = nil,
        intentClosingSetting: IntentClosingSetting? = nil,
        intentConfirmationSetting: IntentConfirmationSetting? = nil,
        intentId: String? = nil,
        intentName: String? = nil,
        kendraConfiguration: KendraConfiguration? = nil,
        localeId: String? = nil,
        outputContexts: [OutputContext]? = nil,
        parentIntentSignature: String? = nil,
        sampleUtterances: [SampleUtterance]? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.creationDateTime = creationDateTime
        self.description = description
        self.dialogCodeHook = dialogCodeHook
        self.fulfillmentCodeHook = fulfillmentCodeHook
        self.inputContexts = inputContexts
        self.intentClosingSetting = intentClosingSetting
        self.intentConfirmationSetting = intentConfirmationSetting
        self.intentId = intentId
        self.intentName = intentName
        self.kendraConfiguration = kendraConfiguration
        self.localeId = localeId
        self.outputContexts = outputContexts
        self.parentIntentSignature = parentIntentSignature
        self.sampleUtterances = sampleUtterances
    }
}

struct CreateIntentOutputResponseBody: Equatable {
    public let intentId: String?
    public let intentName: String?
    public let description: String?
    public let parentIntentSignature: String?
    public let sampleUtterances: [SampleUtterance]?
    public let dialogCodeHook: DialogCodeHookSettings?
    public let fulfillmentCodeHook: FulfillmentCodeHookSettings?
    public let intentConfirmationSetting: IntentConfirmationSetting?
    public let intentClosingSetting: IntentClosingSetting?
    public let inputContexts: [InputContext]?
    public let outputContexts: [OutputContext]?
    public let kendraConfiguration: KendraConfiguration?
    public let botId: String?
    public let botVersion: String?
    public let localeId: String?
    public let creationDateTime: Date?
}

extension CreateIntentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botId
        case botVersion
        case creationDateTime
        case description
        case dialogCodeHook
        case fulfillmentCodeHook
        case inputContexts
        case intentClosingSetting
        case intentConfirmationSetting
        case intentId
        case intentName
        case kendraConfiguration
        case localeId
        case outputContexts
        case parentIntentSignature
        case sampleUtterances
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .intentId)
        intentId = intentIdDecoded
        let intentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .intentName)
        intentName = intentNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let parentIntentSignatureDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentIntentSignature)
        parentIntentSignature = parentIntentSignatureDecoded
        let sampleUtterancesContainer = try containerValues.decodeIfPresent([SampleUtterance?].self, forKey: .sampleUtterances)
        var sampleUtterancesDecoded0:[SampleUtterance]? = nil
        if let sampleUtterancesContainer = sampleUtterancesContainer {
            sampleUtterancesDecoded0 = [SampleUtterance]()
            for structure0 in sampleUtterancesContainer {
                if let structure0 = structure0 {
                    sampleUtterancesDecoded0?.append(structure0)
                }
            }
        }
        sampleUtterances = sampleUtterancesDecoded0
        let dialogCodeHookDecoded = try containerValues.decodeIfPresent(DialogCodeHookSettings.self, forKey: .dialogCodeHook)
        dialogCodeHook = dialogCodeHookDecoded
        let fulfillmentCodeHookDecoded = try containerValues.decodeIfPresent(FulfillmentCodeHookSettings.self, forKey: .fulfillmentCodeHook)
        fulfillmentCodeHook = fulfillmentCodeHookDecoded
        let intentConfirmationSettingDecoded = try containerValues.decodeIfPresent(IntentConfirmationSetting.self, forKey: .intentConfirmationSetting)
        intentConfirmationSetting = intentConfirmationSettingDecoded
        let intentClosingSettingDecoded = try containerValues.decodeIfPresent(IntentClosingSetting.self, forKey: .intentClosingSetting)
        intentClosingSetting = intentClosingSettingDecoded
        let inputContextsContainer = try containerValues.decodeIfPresent([InputContext?].self, forKey: .inputContexts)
        var inputContextsDecoded0:[InputContext]? = nil
        if let inputContextsContainer = inputContextsContainer {
            inputContextsDecoded0 = [InputContext]()
            for structure0 in inputContextsContainer {
                if let structure0 = structure0 {
                    inputContextsDecoded0?.append(structure0)
                }
            }
        }
        inputContexts = inputContextsDecoded0
        let outputContextsContainer = try containerValues.decodeIfPresent([OutputContext?].self, forKey: .outputContexts)
        var outputContextsDecoded0:[OutputContext]? = nil
        if let outputContextsContainer = outputContextsContainer {
            outputContextsDecoded0 = [OutputContext]()
            for structure0 in outputContextsContainer {
                if let structure0 = structure0 {
                    outputContextsDecoded0?.append(structure0)
                }
            }
        }
        outputContexts = outputContextsDecoded0
        let kendraConfigurationDecoded = try containerValues.decodeIfPresent(KendraConfiguration.self, forKey: .kendraConfiguration)
        kendraConfiguration = kendraConfigurationDecoded
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
    }
}

public struct CreateResourcePolicyInputBodyMiddleware: Middleware {
    public let id: String = "CreateResourcePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResourcePolicyInput>
    public typealias MOutput = OperationOutput<CreateResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResourcePolicyOutputError>
}

extension CreateResourcePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateResourcePolicyInput(policy: \(String(describing: policy)), resourceArn: \(String(describing: resourceArn)))"}
}

extension CreateResourcePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

public struct CreateResourcePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "CreateResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResourcePolicyInput>
    public typealias MOutput = OperationOutput<CreateResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResourcePolicyOutputError>
}

public struct CreateResourcePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResourcePolicyInput>
    public typealias MOutput = OperationOutput<CreateResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResourcePolicyOutputError>
}

public struct CreateResourcePolicyInput: Equatable {
    /// <p>A resource policy to add to the resource. The policy is a JSON
    ///          structure that contains one or more statements that define the policy.
    ///          The policy must follow the IAM syntax. For more information about the
    ///          contents of a JSON policy document, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies.html"> IAM JSON policy
    ///             reference </a>. </p>
    ///          <p>If the policy isn't valid, Amazon Lex returns a validation
    ///          exception.</p>
    public let policy: String?
    /// <p>The Amazon Resource Name (ARN) of the bot or bot alias that the
    ///          resource policy is attached to.</p>
    public let resourceArn: String?

    public init (
        policy: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

struct CreateResourcePolicyInputBody: Equatable {
    public let policy: String?
}

extension CreateResourcePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension CreateResourcePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResourcePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateResourcePolicyOutputError: Equatable {
    case internalServerException(InternalServerException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResourcePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateResourcePolicyOutputResponse(resourceArn: \(String(describing: resourceArn)), revisionId: \(String(describing: revisionId)))"}
}

extension CreateResourcePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resourceArn = output.resourceArn
            self.revisionId = output.revisionId
        } else {
            self.resourceArn = nil
            self.revisionId = nil
        }
    }
}

public struct CreateResourcePolicyOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the bot or bot alias that the
    ///          resource policy was attached to.</p>
    public let resourceArn: String?
    /// <p>The current revision of the resource policy. Use the revision ID to
    ///          make sure that you are updating the most current version of a resource
    ///          policy when you add a policy statement to a resource, delete a
    ///          resource, or update a resource.</p>
    public let revisionId: String?

    public init (
        resourceArn: String? = nil,
        revisionId: String? = nil
    )
    {
        self.resourceArn = resourceArn
        self.revisionId = revisionId
    }
}

struct CreateResourcePolicyOutputResponseBody: Equatable {
    public let resourceArn: String?
    public let revisionId: String?
}

extension CreateResourcePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case revisionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

public struct CreateResourcePolicyStatementInputBodyMiddleware: Middleware {
    public let id: String = "CreateResourcePolicyStatementInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResourcePolicyStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResourcePolicyStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResourcePolicyStatementInput>
    public typealias MOutput = OperationOutput<CreateResourcePolicyStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResourcePolicyStatementOutputError>
}

extension CreateResourcePolicyStatementInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateResourcePolicyStatementInput(action: \(String(describing: action)), condition: \(String(describing: condition)), effect: \(String(describing: effect)), expectedRevisionId: \(String(describing: expectedRevisionId)), principal: \(String(describing: principal)), resourceArn: \(String(describing: resourceArn)), statementId: \(String(describing: statementId)))"}
}

extension CreateResourcePolicyStatementInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action
        case condition
        case effect
        case principal
        case statementId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            var actionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .action)
            for operationlist0 in action {
                try actionContainer.encode(operationlist0)
            }
        }
        if let condition = condition {
            var conditionContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .condition)
            for (dictKey0, conditionmap0) in condition {
                try conditionContainer.encode(conditionmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let effect = effect {
            try encodeContainer.encode(effect.rawValue, forKey: .effect)
        }
        if let principal = principal {
            var principalContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principal)
            for principallist0 in principal {
                try principalContainer.encode(principallist0)
            }
        }
        if let statementId = statementId {
            try encodeContainer.encode(statementId, forKey: .statementId)
        }
    }
}

public struct CreateResourcePolicyStatementInputHeadersMiddleware: Middleware {
    public let id: String = "CreateResourcePolicyStatementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResourcePolicyStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResourcePolicyStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResourcePolicyStatementInput>
    public typealias MOutput = OperationOutput<CreateResourcePolicyStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResourcePolicyStatementOutputError>
}

public struct CreateResourcePolicyStatementInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateResourcePolicyStatementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResourcePolicyStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResourcePolicyStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedRevisionId = input.operationInput.expectedRevisionId {
            let expectedRevisionIdQueryItem = URLQueryItem(name: "expectedRevisionId".urlPercentEncoding(), value: String(expectedRevisionId).urlPercentEncoding())
            input.builder.withQueryItem(expectedRevisionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResourcePolicyStatementInput>
    public typealias MOutput = OperationOutput<CreateResourcePolicyStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResourcePolicyStatementOutputError>
}

public struct CreateResourcePolicyStatementInput: Equatable {
    /// <p>The Amazon Lex action that this policy either allows or denies. The
    ///          action must apply to the resource type of the specified ARN. For more
    ///          information, see <a href="https://docs.aws.amazon.com/service-authorization/latest/reference/list_amazonlexv2.html">
    ///             Actions, resources, and condition keys for Amazon Lex V2</a>.</p>
    public let action: [String]?
    /// <p>Specifies a condition when the policy is in effect. If the principal
    ///          of the policy is a service principal, you must provide two condition
    ///          blocks, one with a SourceAccount global condition key and one with a
    ///          SourceArn global condition key.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_condition.html">IAM JSON policy elements: Condition </a>.</p>
    public let condition: [String:[String:String]]?
    /// <p>Determines whether the statement allows or denies access to the
    ///          resource.</p>
    public let effect: Effect?
    /// <p>The identifier of the revision of the policy to edit. If this
    ///          revision ID doesn't match the current revision ID, Amazon Lex throws an
    ///          exception.</p>
    ///          <p>If you don't specify a revision, Amazon Lex overwrites the contents of
    ///          the policy with the new values.</p>
    public let expectedRevisionId: String?
    /// <p>An IAM principal, such as an IAM users, IAM roles, or AWS services
    ///          that is allowed or denied access to a resource. For more information,
    ///          see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_principal.html">AWS JSON policy elements: Principal</a>.</p>
    public let principal: [Principal]?
    /// <p>The Amazon Resource Name (ARN) of the bot or bot alias that the
    ///          resource policy is attached to.</p>
    public let resourceArn: String?
    /// <p>The name of the statement. The ID is the same as the
    ///             <code>Sid</code> IAM property. The statement name must be unique
    ///          within the policy. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_sid.html">IAM
    ///             JSON policy elements: Sid</a>. </p>
    public let statementId: String?

    public init (
        action: [String]? = nil,
        condition: [String:[String:String]]? = nil,
        effect: Effect? = nil,
        expectedRevisionId: String? = nil,
        principal: [Principal]? = nil,
        resourceArn: String? = nil,
        statementId: String? = nil
    )
    {
        self.action = action
        self.condition = condition
        self.effect = effect
        self.expectedRevisionId = expectedRevisionId
        self.principal = principal
        self.resourceArn = resourceArn
        self.statementId = statementId
    }
}

struct CreateResourcePolicyStatementInputBody: Equatable {
    public let statementId: String?
    public let effect: Effect?
    public let principal: [Principal]?
    public let action: [String]?
    public let condition: [String:[String:String]]?
}

extension CreateResourcePolicyStatementInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case action
        case condition
        case effect
        case principal
        case statementId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statementId)
        statementId = statementIdDecoded
        let effectDecoded = try containerValues.decodeIfPresent(Effect.self, forKey: .effect)
        effect = effectDecoded
        let principalContainer = try containerValues.decodeIfPresent([Principal?].self, forKey: .principal)
        var principalDecoded0:[Principal]? = nil
        if let principalContainer = principalContainer {
            principalDecoded0 = [Principal]()
            for structure0 in principalContainer {
                if let structure0 = structure0 {
                    principalDecoded0?.append(structure0)
                }
            }
        }
        principal = principalDecoded0
        let actionContainer = try containerValues.decodeIfPresent([String?].self, forKey: .action)
        var actionDecoded0:[String]? = nil
        if let actionContainer = actionContainer {
            actionDecoded0 = [String]()
            for string0 in actionContainer {
                if let string0 = string0 {
                    actionDecoded0?.append(string0)
                }
            }
        }
        action = actionDecoded0
        let conditionContainer = try containerValues.decodeIfPresent([String: [String: String?]?].self, forKey: .condition)
        var conditionDecoded0: [String:[String:String]]? = nil
        if let conditionContainer = conditionContainer {
            conditionDecoded0 = [String:[String:String]]()
            for (key0, conditionkeyvaluemap0) in conditionContainer {
                var conditionkeyvaluemap0Decoded0: [String: String]? = nil
                if let conditionkeyvaluemap0 = conditionkeyvaluemap0 {
                    conditionkeyvaluemap0Decoded0 = [String: String]()
                    for (key1, conditionvalue1) in conditionkeyvaluemap0 {
                        if let conditionvalue1 = conditionvalue1 {
                            conditionkeyvaluemap0Decoded0?[key1] = conditionvalue1
                        }
                    }
                }
                conditionDecoded0?[key0] = conditionkeyvaluemap0Decoded0
            }
        }
        condition = conditionDecoded0
    }
}

extension CreateResourcePolicyStatementOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResourcePolicyStatementOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateResourcePolicyStatementOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResourcePolicyStatementOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateResourcePolicyStatementOutputResponse(resourceArn: \(String(describing: resourceArn)), revisionId: \(String(describing: revisionId)))"}
}

extension CreateResourcePolicyStatementOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateResourcePolicyStatementOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resourceArn = output.resourceArn
            self.revisionId = output.revisionId
        } else {
            self.resourceArn = nil
            self.revisionId = nil
        }
    }
}

public struct CreateResourcePolicyStatementOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the bot or bot alias that the
    ///          resource policy is attached to.</p>
    public let resourceArn: String?
    /// <p>The current revision of the resource policy. Use the revision ID to
    ///          make sure that you are updating the most current version of a resource
    ///          policy when you add a policy statement to a resource, delete a
    ///          resource, or update a resource.</p>
    public let revisionId: String?

    public init (
        resourceArn: String? = nil,
        revisionId: String? = nil
    )
    {
        self.resourceArn = resourceArn
        self.revisionId = revisionId
    }
}

struct CreateResourcePolicyStatementOutputResponseBody: Equatable {
    public let resourceArn: String?
    public let revisionId: String?
}

extension CreateResourcePolicyStatementOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case revisionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

public struct CreateSlotInputBodyMiddleware: Middleware {
    public let id: String = "CreateSlotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSlotInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSlotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSlotInput>
    public typealias MOutput = OperationOutput<CreateSlotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSlotOutputError>
}

extension CreateSlotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSlotInput(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), description: \(String(describing: description)), intentId: \(String(describing: intentId)), localeId: \(String(describing: localeId)), obfuscationSetting: \(String(describing: obfuscationSetting)), slotName: \(String(describing: slotName)), slotTypeId: \(String(describing: slotTypeId)), valueElicitationSetting: \(String(describing: valueElicitationSetting)))"}
}

extension CreateSlotInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case obfuscationSetting
        case slotName
        case slotTypeId
        case valueElicitationSetting
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let obfuscationSetting = obfuscationSetting {
            try encodeContainer.encode(obfuscationSetting, forKey: .obfuscationSetting)
        }
        if let slotName = slotName {
            try encodeContainer.encode(slotName, forKey: .slotName)
        }
        if let slotTypeId = slotTypeId {
            try encodeContainer.encode(slotTypeId, forKey: .slotTypeId)
        }
        if let valueElicitationSetting = valueElicitationSetting {
            try encodeContainer.encode(valueElicitationSetting, forKey: .valueElicitationSetting)
        }
    }
}

public struct CreateSlotInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSlotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSlotInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSlotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSlotInput>
    public typealias MOutput = OperationOutput<CreateSlotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSlotOutputError>
}

public struct CreateSlotInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSlotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSlotInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSlotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSlotInput>
    public typealias MOutput = OperationOutput<CreateSlotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSlotOutputError>
}

public struct CreateSlotInput: Equatable {
    /// <p>The identifier of the bot associated with the slot.</p>
    public let botId: String?
    /// <p>The version of the bot associated with the slot.</p>
    public let botVersion: String?
    /// <p>A description of the slot. Use this to help identify the slot in
    ///          lists.</p>
    public let description: String?
    /// <p>The identifier of the intent that contains the slot.</p>
    public let intentId: String?
    /// <p>The identifier of the language and locale that the slot will be used
    ///          in. The string must match one of the supported locales. All of the
    ///          bots, intents, slot types used by the slot must have the same locale.
    ///          For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
    public let localeId: String?
    /// <p>Determines how slot values are used in Amazon CloudWatch logs. If the value of
    ///          the <code>obfuscationSetting</code> parameter is
    ///             <code>DefaultObfuscation</code>, slot values are obfuscated in the
    ///          log output. If the value is <code>None</code>, the actual value is
    ///          present in the log output.</p>
    ///          <p>The default is to obfuscate values in the CloudWatch logs.</p>
    public let obfuscationSetting: ObfuscationSetting?
    /// <p>The name of the slot. Slot names must be unique within the bot that
    ///          contains the slot.</p>
    public let slotName: String?
    /// <p>The unique identifier for the slot type associated with this slot.
    ///          The slot type determines the values that can be entered into the
    ///          slot.</p>
    public let slotTypeId: String?
    /// <p>Specifies prompts that Amazon Lex sends to the user to elicit a response
    ///          that provides the value for the slot. </p>
    public let valueElicitationSetting: SlotValueElicitationSetting?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        description: String? = nil,
        intentId: String? = nil,
        localeId: String? = nil,
        obfuscationSetting: ObfuscationSetting? = nil,
        slotName: String? = nil,
        slotTypeId: String? = nil,
        valueElicitationSetting: SlotValueElicitationSetting? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.description = description
        self.intentId = intentId
        self.localeId = localeId
        self.obfuscationSetting = obfuscationSetting
        self.slotName = slotName
        self.slotTypeId = slotTypeId
        self.valueElicitationSetting = valueElicitationSetting
    }
}

struct CreateSlotInputBody: Equatable {
    public let slotName: String?
    public let description: String?
    public let slotTypeId: String?
    public let valueElicitationSetting: SlotValueElicitationSetting?
    public let obfuscationSetting: ObfuscationSetting?
}

extension CreateSlotInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case obfuscationSetting
        case slotName
        case slotTypeId
        case valueElicitationSetting
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotName)
        slotName = slotNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let slotTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotTypeId)
        slotTypeId = slotTypeIdDecoded
        let valueElicitationSettingDecoded = try containerValues.decodeIfPresent(SlotValueElicitationSetting.self, forKey: .valueElicitationSetting)
        valueElicitationSetting = valueElicitationSettingDecoded
        let obfuscationSettingDecoded = try containerValues.decodeIfPresent(ObfuscationSetting.self, forKey: .obfuscationSetting)
        obfuscationSetting = obfuscationSettingDecoded
    }
}

extension CreateSlotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSlotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSlotOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case preconditionFailedException(PreconditionFailedException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSlotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSlotOutputResponse(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), creationDateTime: \(String(describing: creationDateTime)), description: \(String(describing: description)), intentId: \(String(describing: intentId)), localeId: \(String(describing: localeId)), obfuscationSetting: \(String(describing: obfuscationSetting)), slotId: \(String(describing: slotId)), slotName: \(String(describing: slotName)), slotTypeId: \(String(describing: slotTypeId)), valueElicitationSetting: \(String(describing: valueElicitationSetting)))"}
}

extension CreateSlotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSlotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.intentId = output.intentId
            self.localeId = output.localeId
            self.obfuscationSetting = output.obfuscationSetting
            self.slotId = output.slotId
            self.slotName = output.slotName
            self.slotTypeId = output.slotTypeId
            self.valueElicitationSetting = output.valueElicitationSetting
        } else {
            self.botId = nil
            self.botVersion = nil
            self.creationDateTime = nil
            self.description = nil
            self.intentId = nil
            self.localeId = nil
            self.obfuscationSetting = nil
            self.slotId = nil
            self.slotName = nil
            self.slotTypeId = nil
            self.valueElicitationSetting = nil
        }
    }
}

public struct CreateSlotOutputResponse: Equatable {
    /// <p>The unique identifier of the bot associated with the slot.</p>
    public let botId: String?
    /// <p>The version of the bot associated with the slot.</p>
    public let botVersion: String?
    /// <p>The timestamp of the date and time that the slot was created.</p>
    public let creationDateTime: Date?
    /// <p>The description associated with the slot.</p>
    public let description: String?
    /// <p>The unique identifier of the intent associated with the slot.</p>
    public let intentId: String?
    /// <p>The language and local specified for the slot.</p>
    public let localeId: String?
    /// <p>Indicates whether the slot is configured to obfuscate values in Amazon CloudWatch
    ///          logs.</p>
    public let obfuscationSetting: ObfuscationSetting?
    /// <p>The unique identifier associated with the slot. Use this to identify
    ///          the slot when you update or delete it.</p>
    public let slotId: String?
    /// <p>The name specified for the slot.</p>
    public let slotName: String?
    /// <p>The unique identifier of the slot type associated with this
    ///          slot.</p>
    public let slotTypeId: String?
    /// <p>The value elicitation settings specified for the slot.</p>
    public let valueElicitationSetting: SlotValueElicitationSetting?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        creationDateTime: Date? = nil,
        description: String? = nil,
        intentId: String? = nil,
        localeId: String? = nil,
        obfuscationSetting: ObfuscationSetting? = nil,
        slotId: String? = nil,
        slotName: String? = nil,
        slotTypeId: String? = nil,
        valueElicitationSetting: SlotValueElicitationSetting? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.creationDateTime = creationDateTime
        self.description = description
        self.intentId = intentId
        self.localeId = localeId
        self.obfuscationSetting = obfuscationSetting
        self.slotId = slotId
        self.slotName = slotName
        self.slotTypeId = slotTypeId
        self.valueElicitationSetting = valueElicitationSetting
    }
}

struct CreateSlotOutputResponseBody: Equatable {
    public let slotId: String?
    public let slotName: String?
    public let description: String?
    public let slotTypeId: String?
    public let valueElicitationSetting: SlotValueElicitationSetting?
    public let obfuscationSetting: ObfuscationSetting?
    public let botId: String?
    public let botVersion: String?
    public let localeId: String?
    public let intentId: String?
    public let creationDateTime: Date?
}

extension CreateSlotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botId
        case botVersion
        case creationDateTime
        case description
        case intentId
        case localeId
        case obfuscationSetting
        case slotId
        case slotName
        case slotTypeId
        case valueElicitationSetting
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotId)
        slotId = slotIdDecoded
        let slotNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotName)
        slotName = slotNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let slotTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotTypeId)
        slotTypeId = slotTypeIdDecoded
        let valueElicitationSettingDecoded = try containerValues.decodeIfPresent(SlotValueElicitationSetting.self, forKey: .valueElicitationSetting)
        valueElicitationSetting = valueElicitationSettingDecoded
        let obfuscationSettingDecoded = try containerValues.decodeIfPresent(ObfuscationSetting.self, forKey: .obfuscationSetting)
        obfuscationSetting = obfuscationSettingDecoded
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let intentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .intentId)
        intentId = intentIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
    }
}

public struct CreateSlotTypeInputBodyMiddleware: Middleware {
    public let id: String = "CreateSlotTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSlotTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSlotTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSlotTypeInput>
    public typealias MOutput = OperationOutput<CreateSlotTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSlotTypeOutputError>
}

extension CreateSlotTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSlotTypeInput(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), description: \(String(describing: description)), localeId: \(String(describing: localeId)), parentSlotTypeSignature: \(String(describing: parentSlotTypeSignature)), slotTypeName: \(String(describing: slotTypeName)), slotTypeValues: \(String(describing: slotTypeValues)), valueSelectionSetting: \(String(describing: valueSelectionSetting)))"}
}

extension CreateSlotTypeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case parentSlotTypeSignature
        case slotTypeName
        case slotTypeValues
        case valueSelectionSetting
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let parentSlotTypeSignature = parentSlotTypeSignature {
            try encodeContainer.encode(parentSlotTypeSignature, forKey: .parentSlotTypeSignature)
        }
        if let slotTypeName = slotTypeName {
            try encodeContainer.encode(slotTypeName, forKey: .slotTypeName)
        }
        if let slotTypeValues = slotTypeValues {
            var slotTypeValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .slotTypeValues)
            for slottypevalues0 in slotTypeValues {
                try slotTypeValuesContainer.encode(slottypevalues0)
            }
        }
        if let valueSelectionSetting = valueSelectionSetting {
            try encodeContainer.encode(valueSelectionSetting, forKey: .valueSelectionSetting)
        }
    }
}

public struct CreateSlotTypeInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSlotTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSlotTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSlotTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSlotTypeInput>
    public typealias MOutput = OperationOutput<CreateSlotTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSlotTypeOutputError>
}

public struct CreateSlotTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSlotTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSlotTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSlotTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSlotTypeInput>
    public typealias MOutput = OperationOutput<CreateSlotTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSlotTypeOutputError>
}

public struct CreateSlotTypeInput: Equatable {
    /// <p>The identifier of the bot associated with this slot type.</p>
    public let botId: String?
    /// <p>The identifier of the bot version associated with this slot
    ///          type.</p>
    public let botVersion: String?
    /// <p>A description of the slot type. Use the description to help identify
    ///          the slot type in lists.</p>
    public let description: String?
    /// <p>The identifier of the language and locale that the slot type will be
    ///          used in. The string must match one of the supported locales. All of the
    ///          bots, intents, and slots used by the slot type must have the same
    ///          locale. For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
    public let localeId: String?
    /// <p>The built-in slot type used as a parent of this slot type. When you
    ///          define a parent slot type, the new slot type has the configuration of
    ///          the parent slot type.</p>
    ///          <p>Only <code>AMAZON.AlphaNumeric</code> is supported.</p>
    public let parentSlotTypeSignature: String?
    /// <p>The name for the slot. A slot type name must be unique within the
    ///          account.</p>
    public let slotTypeName: String?
    /// <p>A list of <code>SlotTypeValue</code> objects that defines the values
    ///          that the slot type can take. Each value can have a list of synonyms,
    ///          additional values that help train the machine learning model about the
    ///          values that it resolves for a slot.</p>
    public let slotTypeValues: [SlotTypeValue]?
    /// <p>Determines the strategy that Amazon Lex uses to select a value from the
    ///          list of possible values. The field can be set to one of the following
    ///          values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>OriginalValue</code> - Returns the value entered by the
    ///                user, if the user value is similar to the slot value.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TopResolution</code> - If there is a resolution list for
    ///                the slot, return the first value in the resolution list. If there
    ///                is no resolution list, return null.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If you don't specify the <code>valueSelectionSetting</code>
    ///          parameter, the default is <code>OriginalValue</code>.</p>
    public let valueSelectionSetting: SlotValueSelectionSetting?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        description: String? = nil,
        localeId: String? = nil,
        parentSlotTypeSignature: String? = nil,
        slotTypeName: String? = nil,
        slotTypeValues: [SlotTypeValue]? = nil,
        valueSelectionSetting: SlotValueSelectionSetting? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.description = description
        self.localeId = localeId
        self.parentSlotTypeSignature = parentSlotTypeSignature
        self.slotTypeName = slotTypeName
        self.slotTypeValues = slotTypeValues
        self.valueSelectionSetting = valueSelectionSetting
    }
}

struct CreateSlotTypeInputBody: Equatable {
    public let slotTypeName: String?
    public let description: String?
    public let slotTypeValues: [SlotTypeValue]?
    public let valueSelectionSetting: SlotValueSelectionSetting?
    public let parentSlotTypeSignature: String?
}

extension CreateSlotTypeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case parentSlotTypeSignature
        case slotTypeName
        case slotTypeValues
        case valueSelectionSetting
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotTypeName)
        slotTypeName = slotTypeNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let slotTypeValuesContainer = try containerValues.decodeIfPresent([SlotTypeValue?].self, forKey: .slotTypeValues)
        var slotTypeValuesDecoded0:[SlotTypeValue]? = nil
        if let slotTypeValuesContainer = slotTypeValuesContainer {
            slotTypeValuesDecoded0 = [SlotTypeValue]()
            for structure0 in slotTypeValuesContainer {
                if let structure0 = structure0 {
                    slotTypeValuesDecoded0?.append(structure0)
                }
            }
        }
        slotTypeValues = slotTypeValuesDecoded0
        let valueSelectionSettingDecoded = try containerValues.decodeIfPresent(SlotValueSelectionSetting.self, forKey: .valueSelectionSetting)
        valueSelectionSetting = valueSelectionSettingDecoded
        let parentSlotTypeSignatureDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentSlotTypeSignature)
        parentSlotTypeSignature = parentSlotTypeSignatureDecoded
    }
}

extension CreateSlotTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSlotTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSlotTypeOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case preconditionFailedException(PreconditionFailedException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSlotTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSlotTypeOutputResponse(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), creationDateTime: \(String(describing: creationDateTime)), description: \(String(describing: description)), localeId: \(String(describing: localeId)), parentSlotTypeSignature: \(String(describing: parentSlotTypeSignature)), slotTypeId: \(String(describing: slotTypeId)), slotTypeName: \(String(describing: slotTypeName)), slotTypeValues: \(String(describing: slotTypeValues)), valueSelectionSetting: \(String(describing: valueSelectionSetting)))"}
}

extension CreateSlotTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSlotTypeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.localeId = output.localeId
            self.parentSlotTypeSignature = output.parentSlotTypeSignature
            self.slotTypeId = output.slotTypeId
            self.slotTypeName = output.slotTypeName
            self.slotTypeValues = output.slotTypeValues
            self.valueSelectionSetting = output.valueSelectionSetting
        } else {
            self.botId = nil
            self.botVersion = nil
            self.creationDateTime = nil
            self.description = nil
            self.localeId = nil
            self.parentSlotTypeSignature = nil
            self.slotTypeId = nil
            self.slotTypeName = nil
            self.slotTypeValues = nil
            self.valueSelectionSetting = nil
        }
    }
}

public struct CreateSlotTypeOutputResponse: Equatable {
    /// <p>The identifier for the bot associated with the slot type.</p>
    public let botId: String?
    /// <p>The version of the bot associated with the slot type.</p>
    public let botVersion: String?
    /// <p>A timestamp of the date and time that the slot type was
    ///          created.</p>
    public let creationDateTime: Date?
    /// <p>The description specified for the slot type.</p>
    public let description: String?
    /// <p>The specified language and local specified for the slot type.</p>
    public let localeId: String?
    /// <p>The signature of the base slot type specified for the slot
    ///          type.</p>
    public let parentSlotTypeSignature: String?
    /// <p>The unique identifier assigned to the slot type. Use this to
    ///          identify the slot type in the <code>UpdateSlotType</code> and
    ///             <code>DeleteSlotType</code> operations.</p>
    public let slotTypeId: String?
    /// <p>The name specified for the slot type.</p>
    public let slotTypeName: String?
    /// <p>The list of values that the slot type can assume.</p>
    public let slotTypeValues: [SlotTypeValue]?
    /// <p>The strategy that Amazon Lex uses to select a value from the list of
    ///          possible values.</p>
    public let valueSelectionSetting: SlotValueSelectionSetting?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        creationDateTime: Date? = nil,
        description: String? = nil,
        localeId: String? = nil,
        parentSlotTypeSignature: String? = nil,
        slotTypeId: String? = nil,
        slotTypeName: String? = nil,
        slotTypeValues: [SlotTypeValue]? = nil,
        valueSelectionSetting: SlotValueSelectionSetting? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.creationDateTime = creationDateTime
        self.description = description
        self.localeId = localeId
        self.parentSlotTypeSignature = parentSlotTypeSignature
        self.slotTypeId = slotTypeId
        self.slotTypeName = slotTypeName
        self.slotTypeValues = slotTypeValues
        self.valueSelectionSetting = valueSelectionSetting
    }
}

struct CreateSlotTypeOutputResponseBody: Equatable {
    public let slotTypeId: String?
    public let slotTypeName: String?
    public let description: String?
    public let slotTypeValues: [SlotTypeValue]?
    public let valueSelectionSetting: SlotValueSelectionSetting?
    public let parentSlotTypeSignature: String?
    public let botId: String?
    public let botVersion: String?
    public let localeId: String?
    public let creationDateTime: Date?
}

extension CreateSlotTypeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botId
        case botVersion
        case creationDateTime
        case description
        case localeId
        case parentSlotTypeSignature
        case slotTypeId
        case slotTypeName
        case slotTypeValues
        case valueSelectionSetting
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotTypeId)
        slotTypeId = slotTypeIdDecoded
        let slotTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotTypeName)
        slotTypeName = slotTypeNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let slotTypeValuesContainer = try containerValues.decodeIfPresent([SlotTypeValue?].self, forKey: .slotTypeValues)
        var slotTypeValuesDecoded0:[SlotTypeValue]? = nil
        if let slotTypeValuesContainer = slotTypeValuesContainer {
            slotTypeValuesDecoded0 = [SlotTypeValue]()
            for structure0 in slotTypeValuesContainer {
                if let structure0 = structure0 {
                    slotTypeValuesDecoded0?.append(structure0)
                }
            }
        }
        slotTypeValues = slotTypeValuesDecoded0
        let valueSelectionSettingDecoded = try containerValues.decodeIfPresent(SlotValueSelectionSetting.self, forKey: .valueSelectionSetting)
        valueSelectionSetting = valueSelectionSettingDecoded
        let parentSlotTypeSignatureDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentSlotTypeSignature)
        parentSlotTypeSignature = parentSlotTypeSignatureDecoded
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
    }
}

extension CreateUploadUrlInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUploadUrlInput()"}
}

extension CreateUploadUrlInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CreateUploadUrlInputHeadersMiddleware: Middleware {
    public let id: String = "CreateUploadUrlInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUploadUrlInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUploadUrlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUploadUrlInput>
    public typealias MOutput = OperationOutput<CreateUploadUrlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUploadUrlOutputError>
}

public struct CreateUploadUrlInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateUploadUrlInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUploadUrlInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUploadUrlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUploadUrlInput>
    public typealias MOutput = OperationOutput<CreateUploadUrlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUploadUrlOutputError>
}

public struct CreateUploadUrlInput: Equatable {

    public init() {}
}

struct CreateUploadUrlInputBody: Equatable {
}

extension CreateUploadUrlInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CreateUploadUrlOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUploadUrlOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUploadUrlOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUploadUrlOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUploadUrlOutputResponse(importId: \(String(describing: importId)), uploadUrl: \(String(describing: uploadUrl)))"}
}

extension CreateUploadUrlOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateUploadUrlOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.importId = output.importId
            self.uploadUrl = output.uploadUrl
        } else {
            self.importId = nil
            self.uploadUrl = nil
        }
    }
}

public struct CreateUploadUrlOutputResponse: Equatable {
    /// <p>An identifier for a unique import job. Use it when you call the
    ///              operation.</p>
    public let importId: String?
    /// <p>A pre-signed S3 write URL. Upload the zip archive file that contains
    ///          the definition of your bot or bot locale.</p>
    public let uploadUrl: String?

    public init (
        importId: String? = nil,
        uploadUrl: String? = nil
    )
    {
        self.importId = importId
        self.uploadUrl = uploadUrl
    }
}

struct CreateUploadUrlOutputResponseBody: Equatable {
    public let importId: String?
    public let uploadUrl: String?
}

extension CreateUploadUrlOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case importId
        case uploadUrl
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .importId)
        importId = importIdDecoded
        let uploadUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uploadUrl)
        uploadUrl = uploadUrlDecoded
    }
}

extension CustomPayload: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CustomPayload: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomPayload(value: \(String(describing: value)))"}
}

/// <p>A custom response string that Amazon Lex sends to your application. You
///          define the content and structure the string.</p>
public struct CustomPayload: Equatable {
    /// <p>The string that is sent to your application.</p>
    public let value: String?

    public init (
        value: String? = nil
    )
    {
        self.value = value
    }
}

extension DataPrivacy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case childDirected
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if childDirected != false {
            try encodeContainer.encode(childDirected, forKey: .childDirected)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let childDirectedDecoded = try containerValues.decode(Bool.self, forKey: .childDirected)
        childDirected = childDirectedDecoded
    }
}

extension DataPrivacy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataPrivacy(childDirected: \(String(describing: childDirected)))"}
}

/// <p>By default, data stored by Amazon Lex is encrypted. The
///             <code>DataPrivacy</code> structure provides settings that determine
///          how Amazon Lex handles special cases of securing the data for your bot.
///       </p>
public struct DataPrivacy: Equatable {
    /// <p>For each Amazon Lex bot created with the Amazon Lex Model Building Service,
    ///          you must specify whether your use of Amazon Lex is related to a website,
    ///          program, or other application that is directed or targeted, in whole or
    ///          in part, to children under age 13 and subject to the Children's Online
    ///          Privacy Protection Act (COPPA) by specifying <code>true</code> or
    ///             <code>false</code> in the <code>childDirected</code> field. By
    ///          specifying <code>true</code> in the <code>childDirected</code> field,
    ///          you confirm that your use of Amazon Lex <b>is</b>
    ///          related to a website, program, or other application that is directed or
    ///          targeted, in whole or in part, to children under age 13 and subject to
    ///          COPPA. By specifying <code>false</code> in the
    ///             <code>childDirected</code> field, you confirm that your use of Amazon Lex
    ///             <b>is not</b> related to a website,
    ///          program, or other application that is directed or targeted, in whole or
    ///          in part, to children under age 13 and subject to COPPA. You may not
    ///          specify a default value for the <code>childDirected</code> field that
    ///          does not accurately reflect whether your use of Amazon Lex is related to a
    ///          website, program, or other application that is directed or targeted, in
    ///          whole or in part, to children under age 13 and subject to COPPA. If
    ///          your use of Amazon Lex relates to a website, program, or other application
    ///          that is directed in whole or in part, to children under age 13, you
    ///          must obtain any required verifiable parental consent under COPPA. For
    ///          information regarding the use of Amazon Lex in connection with websites,
    ///          programs, or other applications that are directed or targeted, in whole
    ///          or in part, to children under age 13, see the <a href="https://aws.amazon.com/lex/faqs#data-security">Amazon Lex
    ///             FAQ</a>.</p>
    public let childDirected: Bool

    public init (
        childDirected: Bool = false
    )
    {
        self.childDirected = childDirected
    }
}

extension DeleteBotAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBotAliasInput(botAliasId: \(String(describing: botAliasId)), botId: \(String(describing: botId)), skipResourceInUseCheck: \(String(describing: skipResourceInUseCheck)))"}
}

extension DeleteBotAliasInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBotAliasInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBotAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBotAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBotAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBotAliasInput>
    public typealias MOutput = OperationOutput<DeleteBotAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBotAliasOutputError>
}

public struct DeleteBotAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBotAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBotAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBotAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let skipResourceInUseCheckQueryItem = URLQueryItem(name: "skipResourceInUseCheck".urlPercentEncoding(), value: String(input.operationInput.skipResourceInUseCheck).urlPercentEncoding())
        input.builder.withQueryItem(skipResourceInUseCheckQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBotAliasInput>
    public typealias MOutput = OperationOutput<DeleteBotAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBotAliasOutputError>
}

public struct DeleteBotAliasInput: Equatable {
    /// <p>The unique identifier of the bot alias to delete.</p>
    public let botAliasId: String?
    /// <p>The unique identifier of the bot associated with the alias to
    ///          delete.</p>
    public let botId: String?
    /// <p>When this parameter is true, Amazon Lex doesn't check to see if any other
    ///          resource is using the alias before it is deleted.</p>
    public let skipResourceInUseCheck: Bool

    public init (
        botAliasId: String? = nil,
        botId: String? = nil,
        skipResourceInUseCheck: Bool = false
    )
    {
        self.botAliasId = botAliasId
        self.botId = botId
        self.skipResourceInUseCheck = skipResourceInUseCheck
    }
}

struct DeleteBotAliasInputBody: Equatable {
}

extension DeleteBotAliasInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBotAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBotAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBotAliasOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case preconditionFailedException(PreconditionFailedException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBotAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBotAliasOutputResponse(botAliasId: \(String(describing: botAliasId)), botAliasStatus: \(String(describing: botAliasStatus)), botId: \(String(describing: botId)))"}
}

extension DeleteBotAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteBotAliasOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botAliasId = output.botAliasId
            self.botAliasStatus = output.botAliasStatus
            self.botId = output.botId
        } else {
            self.botAliasId = nil
            self.botAliasStatus = nil
            self.botId = nil
        }
    }
}

public struct DeleteBotAliasOutputResponse: Equatable {
    /// <p>The unique identifier of the bot alias to delete.</p>
    public let botAliasId: String?
    /// <p>The current status of the alias. The status is <code>Deleting</code>
    ///          while the alias is in the process of being deleted. Once the alias is
    ///          deleted, it will no longer appear in the list of aliases returned by
    ///          the <code>ListBotAliases</code> operation.</p>
    public let botAliasStatus: BotAliasStatus?
    /// <p>The unique identifier of the bot that contains the alias to
    ///          delete.</p>
    public let botId: String?

    public init (
        botAliasId: String? = nil,
        botAliasStatus: BotAliasStatus? = nil,
        botId: String? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botAliasStatus = botAliasStatus
        self.botId = botId
    }
}

struct DeleteBotAliasOutputResponseBody: Equatable {
    public let botAliasId: String?
    public let botId: String?
    public let botAliasStatus: BotAliasStatus?
}

extension DeleteBotAliasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botAliasId
        case botAliasStatus
        case botId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botAliasIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botAliasId)
        botAliasId = botAliasIdDecoded
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botAliasStatusDecoded = try containerValues.decodeIfPresent(BotAliasStatus.self, forKey: .botAliasStatus)
        botAliasStatus = botAliasStatusDecoded
    }
}

extension DeleteBotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBotInput(botId: \(String(describing: botId)), skipResourceInUseCheck: \(String(describing: skipResourceInUseCheck)))"}
}

extension DeleteBotInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBotInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBotInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBotInput>
    public typealias MOutput = OperationOutput<DeleteBotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBotOutputError>
}

public struct DeleteBotInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBotInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let skipResourceInUseCheckQueryItem = URLQueryItem(name: "skipResourceInUseCheck".urlPercentEncoding(), value: String(input.operationInput.skipResourceInUseCheck).urlPercentEncoding())
        input.builder.withQueryItem(skipResourceInUseCheckQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBotInput>
    public typealias MOutput = OperationOutput<DeleteBotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBotOutputError>
}

public struct DeleteBotInput: Equatable {
    /// <p>The identifier of the bot to delete. </p>
    public let botId: String?
    /// <p>When <code>true</code>, Amazon Lex doesn't check to see if another
    ///          resource, such as an alias, is using the bot before it is
    ///          deleted.</p>
    public let skipResourceInUseCheck: Bool

    public init (
        botId: String? = nil,
        skipResourceInUseCheck: Bool = false
    )
    {
        self.botId = botId
        self.skipResourceInUseCheck = skipResourceInUseCheck
    }
}

struct DeleteBotInputBody: Equatable {
}

extension DeleteBotInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBotLocaleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBotLocaleInput(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), localeId: \(String(describing: localeId)))"}
}

extension DeleteBotLocaleInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBotLocaleInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBotLocaleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBotLocaleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBotLocaleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBotLocaleInput>
    public typealias MOutput = OperationOutput<DeleteBotLocaleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBotLocaleOutputError>
}

public struct DeleteBotLocaleInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBotLocaleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBotLocaleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBotLocaleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBotLocaleInput>
    public typealias MOutput = OperationOutput<DeleteBotLocaleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBotLocaleOutputError>
}

public struct DeleteBotLocaleInput: Equatable {
    /// <p>The unique identifier of the bot that contains the locale.</p>
    public let botId: String?
    /// <p>The version of the bot that contains the locale. </p>
    public let botVersion: String?
    /// <p>The identifier of the language and locale that will be deleted. The
    ///          string must match one of the supported locales. For more information,
    ///          see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
    public let localeId: String?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        localeId: String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.localeId = localeId
    }
}

struct DeleteBotLocaleInputBody: Equatable {
}

extension DeleteBotLocaleInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBotLocaleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBotLocaleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBotLocaleOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case preconditionFailedException(PreconditionFailedException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBotLocaleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBotLocaleOutputResponse(botId: \(String(describing: botId)), botLocaleStatus: \(String(describing: botLocaleStatus)), botVersion: \(String(describing: botVersion)), localeId: \(String(describing: localeId)))"}
}

extension DeleteBotLocaleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteBotLocaleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botId = output.botId
            self.botLocaleStatus = output.botLocaleStatus
            self.botVersion = output.botVersion
            self.localeId = output.localeId
        } else {
            self.botId = nil
            self.botLocaleStatus = nil
            self.botVersion = nil
            self.localeId = nil
        }
    }
}

public struct DeleteBotLocaleOutputResponse: Equatable {
    /// <p>The identifier of the bot that contained the deleted locale.</p>
    public let botId: String?
    /// <p>The status of deleting the bot locale. The locale first enters the
    ///             <code>Deleting</code> status. Once the locale is deleted it no
    ///          longer appears in the list of locales for the bot.</p>
    public let botLocaleStatus: BotLocaleStatus?
    /// <p>The version of the bot that contained the deleted locale.</p>
    public let botVersion: String?
    /// <p>The language and locale of the deleted locale.</p>
    public let localeId: String?

    public init (
        botId: String? = nil,
        botLocaleStatus: BotLocaleStatus? = nil,
        botVersion: String? = nil,
        localeId: String? = nil
    )
    {
        self.botId = botId
        self.botLocaleStatus = botLocaleStatus
        self.botVersion = botVersion
        self.localeId = localeId
    }
}

struct DeleteBotLocaleOutputResponseBody: Equatable {
    public let botId: String?
    public let botVersion: String?
    public let localeId: String?
    public let botLocaleStatus: BotLocaleStatus?
}

extension DeleteBotLocaleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botId
        case botLocaleStatus
        case botVersion
        case localeId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let botLocaleStatusDecoded = try containerValues.decodeIfPresent(BotLocaleStatus.self, forKey: .botLocaleStatus)
        botLocaleStatus = botLocaleStatusDecoded
    }
}

extension DeleteBotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBotOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case preconditionFailedException(PreconditionFailedException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBotOutputResponse(botId: \(String(describing: botId)), botStatus: \(String(describing: botStatus)))"}
}

extension DeleteBotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteBotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botId = output.botId
            self.botStatus = output.botStatus
        } else {
            self.botId = nil
            self.botStatus = nil
        }
    }
}

public struct DeleteBotOutputResponse: Equatable {
    /// <p>The unique identifier of the bot that Amazon Lex is deleting.</p>
    public let botId: String?
    /// <p>The current status of the bot. The status is <code>Deleting</code>
    ///          while the bot and its associated resources are being deleted.</p>
    public let botStatus: BotStatus?

    public init (
        botId: String? = nil,
        botStatus: BotStatus? = nil
    )
    {
        self.botId = botId
        self.botStatus = botStatus
    }
}

struct DeleteBotOutputResponseBody: Equatable {
    public let botId: String?
    public let botStatus: BotStatus?
}

extension DeleteBotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botId
        case botStatus
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botStatusDecoded = try containerValues.decodeIfPresent(BotStatus.self, forKey: .botStatus)
        botStatus = botStatusDecoded
    }
}

extension DeleteBotVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBotVersionInput(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), skipResourceInUseCheck: \(String(describing: skipResourceInUseCheck)))"}
}

extension DeleteBotVersionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBotVersionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBotVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBotVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBotVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBotVersionInput>
    public typealias MOutput = OperationOutput<DeleteBotVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBotVersionOutputError>
}

public struct DeleteBotVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBotVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBotVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBotVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let skipResourceInUseCheckQueryItem = URLQueryItem(name: "skipResourceInUseCheck".urlPercentEncoding(), value: String(input.operationInput.skipResourceInUseCheck).urlPercentEncoding())
        input.builder.withQueryItem(skipResourceInUseCheckQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBotVersionInput>
    public typealias MOutput = OperationOutput<DeleteBotVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBotVersionOutputError>
}

public struct DeleteBotVersionInput: Equatable {
    /// <p>The identifier of the bot that contains the version.</p>
    public let botId: String?
    /// <p>The version of the bot to delete.</p>
    public let botVersion: String?
    /// <p>By default, the <code>DeleteBotVersion</code> operations throws a
    ///             <code>ResourceInUseException</code> exception if you try to delete a
    ///          bot version that has an alias pointing at it. Set the
    ///             <code>skipResourceInUseCheck</code> parameter to <code>true</code>
    ///          to skip this check and remove the version even if an alias points to
    ///          it.</p>
    public let skipResourceInUseCheck: Bool

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        skipResourceInUseCheck: Bool = false
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.skipResourceInUseCheck = skipResourceInUseCheck
    }
}

struct DeleteBotVersionInputBody: Equatable {
}

extension DeleteBotVersionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBotVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBotVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBotVersionOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case preconditionFailedException(PreconditionFailedException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBotVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBotVersionOutputResponse(botId: \(String(describing: botId)), botStatus: \(String(describing: botStatus)), botVersion: \(String(describing: botVersion)))"}
}

extension DeleteBotVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteBotVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botId = output.botId
            self.botStatus = output.botStatus
            self.botVersion = output.botVersion
        } else {
            self.botId = nil
            self.botStatus = nil
            self.botVersion = nil
        }
    }
}

public struct DeleteBotVersionOutputResponse: Equatable {
    /// <p>The identifier of the bot that is being deleted.</p>
    public let botId: String?
    /// <p>The current status of the bot. </p>
    public let botStatus: BotStatus?
    /// <p>The version of the bot that is being deleted.</p>
    public let botVersion: String?

    public init (
        botId: String? = nil,
        botStatus: BotStatus? = nil,
        botVersion: String? = nil
    )
    {
        self.botId = botId
        self.botStatus = botStatus
        self.botVersion = botVersion
    }
}

struct DeleteBotVersionOutputResponseBody: Equatable {
    public let botId: String?
    public let botVersion: String?
    public let botStatus: BotStatus?
}

extension DeleteBotVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botId
        case botStatus
        case botVersion
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let botStatusDecoded = try containerValues.decodeIfPresent(BotStatus.self, forKey: .botStatus)
        botStatus = botStatusDecoded
    }
}

extension DeleteExportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteExportInput(exportId: \(String(describing: exportId)))"}
}

extension DeleteExportInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteExportInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteExportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteExportInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteExportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteExportInput>
    public typealias MOutput = OperationOutput<DeleteExportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteExportOutputError>
}

public struct DeleteExportInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteExportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteExportInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteExportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteExportInput>
    public typealias MOutput = OperationOutput<DeleteExportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteExportOutputError>
}

public struct DeleteExportInput: Equatable {
    /// <p>The unique identifier of the export to delete.</p>
    public let exportId: String?

    public init (
        exportId: String? = nil
    )
    {
        self.exportId = exportId
    }
}

struct DeleteExportInputBody: Equatable {
}

extension DeleteExportInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteExportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteExportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteExportOutputError: Equatable {
    case internalServerException(InternalServerException)
    case preconditionFailedException(PreconditionFailedException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteExportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteExportOutputResponse(exportId: \(String(describing: exportId)), exportStatus: \(String(describing: exportStatus)))"}
}

extension DeleteExportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteExportOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.exportId = output.exportId
            self.exportStatus = output.exportStatus
        } else {
            self.exportId = nil
            self.exportStatus = nil
        }
    }
}

public struct DeleteExportOutputResponse: Equatable {
    /// <p>The unique identifier of the deleted export.</p>
    public let exportId: String?
    /// <p>The current status of the deletion. When the deletion is complete,
    ///          the export will no longer be returned by the  operation and calls to the  with the export identifier will
    ///          fail.</p>
    public let exportStatus: ExportStatus?

    public init (
        exportId: String? = nil,
        exportStatus: ExportStatus? = nil
    )
    {
        self.exportId = exportId
        self.exportStatus = exportStatus
    }
}

struct DeleteExportOutputResponseBody: Equatable {
    public let exportId: String?
    public let exportStatus: ExportStatus?
}

extension DeleteExportOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exportId
        case exportStatus
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exportId)
        exportId = exportIdDecoded
        let exportStatusDecoded = try containerValues.decodeIfPresent(ExportStatus.self, forKey: .exportStatus)
        exportStatus = exportStatusDecoded
    }
}

extension DeleteImportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteImportInput(importId: \(String(describing: importId)))"}
}

extension DeleteImportInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteImportInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteImportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteImportInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteImportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteImportInput>
    public typealias MOutput = OperationOutput<DeleteImportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteImportOutputError>
}

public struct DeleteImportInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteImportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteImportInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteImportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteImportInput>
    public typealias MOutput = OperationOutput<DeleteImportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteImportOutputError>
}

public struct DeleteImportInput: Equatable {
    /// <p>The unique identifier of the import to delete.</p>
    public let importId: String?

    public init (
        importId: String? = nil
    )
    {
        self.importId = importId
    }
}

struct DeleteImportInputBody: Equatable {
}

extension DeleteImportInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteImportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteImportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteImportOutputError: Equatable {
    case internalServerException(InternalServerException)
    case preconditionFailedException(PreconditionFailedException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteImportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteImportOutputResponse(importId: \(String(describing: importId)), importStatus: \(String(describing: importStatus)))"}
}

extension DeleteImportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteImportOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.importId = output.importId
            self.importStatus = output.importStatus
        } else {
            self.importId = nil
            self.importStatus = nil
        }
    }
}

public struct DeleteImportOutputResponse: Equatable {
    /// <p>The unique identifier of the deleted import.</p>
    public let importId: String?
    /// <p>The current status of the deletion. When the deletion is complete,
    ///          the import will no longer be returned by the  operation and calls to the  with the import identifier will
    ///          fail.</p>
    public let importStatus: ImportStatus?

    public init (
        importId: String? = nil,
        importStatus: ImportStatus? = nil
    )
    {
        self.importId = importId
        self.importStatus = importStatus
    }
}

struct DeleteImportOutputResponseBody: Equatable {
    public let importId: String?
    public let importStatus: ImportStatus?
}

extension DeleteImportOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case importId
        case importStatus
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .importId)
        importId = importIdDecoded
        let importStatusDecoded = try containerValues.decodeIfPresent(ImportStatus.self, forKey: .importStatus)
        importStatus = importStatusDecoded
    }
}

extension DeleteIntentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIntentInput(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), intentId: \(String(describing: intentId)), localeId: \(String(describing: localeId)))"}
}

extension DeleteIntentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteIntentInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteIntentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIntentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIntentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIntentInput>
    public typealias MOutput = OperationOutput<DeleteIntentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIntentOutputError>
}

public struct DeleteIntentInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteIntentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIntentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIntentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIntentInput>
    public typealias MOutput = OperationOutput<DeleteIntentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIntentOutputError>
}

public struct DeleteIntentInput: Equatable {
    /// <p>The identifier of the bot associated with the intent.</p>
    public let botId: String?
    /// <p>The version of the bot associated with the intent.</p>
    public let botVersion: String?
    /// <p>The unique identifier of the intent to delete.</p>
    public let intentId: String?
    /// <p>The identifier of the language and locale where the bot will be
    ///          deleted. The string must match one of the supported locales. For more
    ///          information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
    public let localeId: String?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        intentId: String? = nil,
        localeId: String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.intentId = intentId
        self.localeId = localeId
    }
}

struct DeleteIntentInputBody: Equatable {
}

extension DeleteIntentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteIntentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIntentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIntentOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case preconditionFailedException(PreconditionFailedException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIntentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIntentOutputResponse()"}
}

extension DeleteIntentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteIntentOutputResponse: Equatable {

    public init() {}
}

struct DeleteIntentOutputResponseBody: Equatable {
}

extension DeleteIntentOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteResourcePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourcePolicyInput(expectedRevisionId: \(String(describing: expectedRevisionId)), resourceArn: \(String(describing: resourceArn)))"}
}

extension DeleteResourcePolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteResourcePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourcePolicyInput>
    public typealias MOutput = OperationOutput<DeleteResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourcePolicyOutputError>
}

public struct DeleteResourcePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedRevisionId = input.operationInput.expectedRevisionId {
            let expectedRevisionIdQueryItem = URLQueryItem(name: "expectedRevisionId".urlPercentEncoding(), value: String(expectedRevisionId).urlPercentEncoding())
            input.builder.withQueryItem(expectedRevisionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourcePolicyInput>
    public typealias MOutput = OperationOutput<DeleteResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourcePolicyOutputError>
}

public struct DeleteResourcePolicyInput: Equatable {
    /// <p>The identifier of the revision to edit. If this ID doesn't match the
    ///          current revision number, Amazon Lex returns an exception</p>
    ///          <p>If you don't specify a revision ID, Amazon Lex will delete the current
    ///          policy.</p>
    public let expectedRevisionId: String?
    /// <p>The Amazon Resource Name (ARN) of the bot or bot alias that has the
    ///          resource policy attached.</p>
    public let resourceArn: String?

    public init (
        expectedRevisionId: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.expectedRevisionId = expectedRevisionId
        self.resourceArn = resourceArn
    }
}

struct DeleteResourcePolicyInputBody: Equatable {
}

extension DeleteResourcePolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteResourcePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourcePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResourcePolicyOutputError: Equatable {
    case internalServerException(InternalServerException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourcePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourcePolicyOutputResponse(resourceArn: \(String(describing: resourceArn)), revisionId: \(String(describing: revisionId)))"}
}

extension DeleteResourcePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resourceArn = output.resourceArn
            self.revisionId = output.revisionId
        } else {
            self.resourceArn = nil
            self.revisionId = nil
        }
    }
}

public struct DeleteResourcePolicyOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the bot or bot alias that the
    ///          resource policy was deleted from.</p>
    public let resourceArn: String?
    /// <p>The current revision of the resource policy. Use the revision ID to
    ///          make sure that you are updating the most current version of a resource
    ///          policy when you add a policy statement to a resource, delete a
    ///          resource, or update a resource.</p>
    public let revisionId: String?

    public init (
        resourceArn: String? = nil,
        revisionId: String? = nil
    )
    {
        self.resourceArn = resourceArn
        self.revisionId = revisionId
    }
}

struct DeleteResourcePolicyOutputResponseBody: Equatable {
    public let resourceArn: String?
    public let revisionId: String?
}

extension DeleteResourcePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case revisionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension DeleteResourcePolicyStatementInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourcePolicyStatementInput(expectedRevisionId: \(String(describing: expectedRevisionId)), resourceArn: \(String(describing: resourceArn)), statementId: \(String(describing: statementId)))"}
}

extension DeleteResourcePolicyStatementInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteResourcePolicyStatementInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteResourcePolicyStatementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourcePolicyStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourcePolicyStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourcePolicyStatementInput>
    public typealias MOutput = OperationOutput<DeleteResourcePolicyStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourcePolicyStatementOutputError>
}

public struct DeleteResourcePolicyStatementInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteResourcePolicyStatementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourcePolicyStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourcePolicyStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedRevisionId = input.operationInput.expectedRevisionId {
            let expectedRevisionIdQueryItem = URLQueryItem(name: "expectedRevisionId".urlPercentEncoding(), value: String(expectedRevisionId).urlPercentEncoding())
            input.builder.withQueryItem(expectedRevisionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourcePolicyStatementInput>
    public typealias MOutput = OperationOutput<DeleteResourcePolicyStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourcePolicyStatementOutputError>
}

public struct DeleteResourcePolicyStatementInput: Equatable {
    /// <p>The identifier of the revision of the policy to delete the statement
    ///          from. If this revision ID doesn't match the current revision ID, Amazon Lex
    ///          throws an exception.</p>
    ///          <p>If you don't specify a revision, Amazon Lex removes the current contents
    ///          of the statement. </p>
    public let expectedRevisionId: String?
    /// <p>The Amazon Resource Name (ARN) of the bot or bot alias that the
    ///          resource policy is attached to.</p>
    public let resourceArn: String?
    /// <p>The name of the statement (SID) to delete from the policy.</p>
    public let statementId: String?

    public init (
        expectedRevisionId: String? = nil,
        resourceArn: String? = nil,
        statementId: String? = nil
    )
    {
        self.expectedRevisionId = expectedRevisionId
        self.resourceArn = resourceArn
        self.statementId = statementId
    }
}

struct DeleteResourcePolicyStatementInputBody: Equatable {
}

extension DeleteResourcePolicyStatementInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteResourcePolicyStatementOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourcePolicyStatementOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResourcePolicyStatementOutputError: Equatable {
    case internalServerException(InternalServerException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourcePolicyStatementOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourcePolicyStatementOutputResponse(resourceArn: \(String(describing: resourceArn)), revisionId: \(String(describing: revisionId)))"}
}

extension DeleteResourcePolicyStatementOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteResourcePolicyStatementOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resourceArn = output.resourceArn
            self.revisionId = output.revisionId
        } else {
            self.resourceArn = nil
            self.revisionId = nil
        }
    }
}

public struct DeleteResourcePolicyStatementOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the bot or bot alias that the
    ///          resource policy statement was removed from.</p>
    public let resourceArn: String?
    /// <p>The current revision of the resource policy. Use the revision ID to
    ///          make sure that you are updating the most current version of a resource
    ///          policy when you add a policy statement to a resource, delete a
    ///          resource, or update a resource.</p>
    public let revisionId: String?

    public init (
        resourceArn: String? = nil,
        revisionId: String? = nil
    )
    {
        self.resourceArn = resourceArn
        self.revisionId = revisionId
    }
}

struct DeleteResourcePolicyStatementOutputResponseBody: Equatable {
    public let resourceArn: String?
    public let revisionId: String?
}

extension DeleteResourcePolicyStatementOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case revisionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension DeleteSlotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSlotInput(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), intentId: \(String(describing: intentId)), localeId: \(String(describing: localeId)), slotId: \(String(describing: slotId)))"}
}

extension DeleteSlotInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteSlotInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSlotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSlotInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSlotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSlotInput>
    public typealias MOutput = OperationOutput<DeleteSlotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSlotOutputError>
}

public struct DeleteSlotInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSlotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSlotInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSlotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSlotInput>
    public typealias MOutput = OperationOutput<DeleteSlotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSlotOutputError>
}

public struct DeleteSlotInput: Equatable {
    /// <p>The identifier of the bot associated with the slot to delete.</p>
    public let botId: String?
    /// <p>The version of the bot associated with the slot to delete.</p>
    public let botVersion: String?
    /// <p>The identifier of the intent associated with the slot.</p>
    public let intentId: String?
    /// <p>The identifier of the language and locale that the slot will be
    ///          deleted from. The string must match one of the supported locales. For
    ///          more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
    public let localeId: String?
    /// <p>The identifier of the slot to delete. </p>
    public let slotId: String?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        intentId: String? = nil,
        localeId: String? = nil,
        slotId: String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.intentId = intentId
        self.localeId = localeId
        self.slotId = slotId
    }
}

struct DeleteSlotInputBody: Equatable {
}

extension DeleteSlotInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteSlotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSlotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSlotOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case preconditionFailedException(PreconditionFailedException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSlotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSlotOutputResponse()"}
}

extension DeleteSlotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSlotOutputResponse: Equatable {

    public init() {}
}

struct DeleteSlotOutputResponseBody: Equatable {
}

extension DeleteSlotOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteSlotTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSlotTypeInput(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), localeId: \(String(describing: localeId)), skipResourceInUseCheck: \(String(describing: skipResourceInUseCheck)), slotTypeId: \(String(describing: slotTypeId)))"}
}

extension DeleteSlotTypeInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteSlotTypeInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSlotTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSlotTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSlotTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSlotTypeInput>
    public typealias MOutput = OperationOutput<DeleteSlotTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSlotTypeOutputError>
}

public struct DeleteSlotTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSlotTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSlotTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSlotTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let skipResourceInUseCheckQueryItem = URLQueryItem(name: "skipResourceInUseCheck".urlPercentEncoding(), value: String(input.operationInput.skipResourceInUseCheck).urlPercentEncoding())
        input.builder.withQueryItem(skipResourceInUseCheckQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSlotTypeInput>
    public typealias MOutput = OperationOutput<DeleteSlotTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSlotTypeOutputError>
}

public struct DeleteSlotTypeInput: Equatable {
    /// <p>The identifier of the bot associated with the slot type.</p>
    public let botId: String?
    /// <p>The version of the bot associated with the slot type.</p>
    public let botVersion: String?
    /// <p>The identifier of the language and locale that the slot type will be
    ///          deleted from. The string must match one of the supported locales. For
    ///          more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
    public let localeId: String?
    /// <p>By default, the <code>DeleteSlotType</code> operations throws a
    ///             <code>ResourceInUseException</code> exception if you try to delete a
    ///          slot type used by a slot. Set the <code>skipResourceInUseCheck</code>
    ///          parameter to <code>true</code> to skip this check and remove the slot
    ///          type even if a slot uses it.</p>
    public let skipResourceInUseCheck: Bool
    /// <p>The identifier of the slot type to delete.</p>
    public let slotTypeId: String?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        localeId: String? = nil,
        skipResourceInUseCheck: Bool = false,
        slotTypeId: String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.localeId = localeId
        self.skipResourceInUseCheck = skipResourceInUseCheck
        self.slotTypeId = slotTypeId
    }
}

struct DeleteSlotTypeInputBody: Equatable {
}

extension DeleteSlotTypeInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteSlotTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSlotTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSlotTypeOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case preconditionFailedException(PreconditionFailedException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSlotTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSlotTypeOutputResponse()"}
}

extension DeleteSlotTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSlotTypeOutputResponse: Equatable {

    public init() {}
}

struct DeleteSlotTypeOutputResponseBody: Equatable {
}

extension DeleteSlotTypeOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeBotAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBotAliasInput(botAliasId: \(String(describing: botAliasId)), botId: \(String(describing: botId)))"}
}

extension DescribeBotAliasInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeBotAliasInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeBotAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBotAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBotAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBotAliasInput>
    public typealias MOutput = OperationOutput<DescribeBotAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBotAliasOutputError>
}

public struct DescribeBotAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeBotAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBotAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBotAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBotAliasInput>
    public typealias MOutput = OperationOutput<DescribeBotAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBotAliasOutputError>
}

public struct DescribeBotAliasInput: Equatable {
    /// <p>The identifier of the bot alias to describe.</p>
    public let botAliasId: String?
    /// <p>The identifier of the bot associated with the bot alias to
    ///          describe.</p>
    public let botId: String?

    public init (
        botAliasId: String? = nil,
        botId: String? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botId = botId
    }
}

struct DescribeBotAliasInputBody: Equatable {
}

extension DescribeBotAliasInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeBotAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBotAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBotAliasOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBotAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBotAliasOutputResponse(botAliasHistoryEvents: \(String(describing: botAliasHistoryEvents)), botAliasId: \(String(describing: botAliasId)), botAliasLocaleSettings: \(String(describing: botAliasLocaleSettings)), botAliasName: \(String(describing: botAliasName)), botAliasStatus: \(String(describing: botAliasStatus)), botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), conversationLogSettings: \(String(describing: conversationLogSettings)), creationDateTime: \(String(describing: creationDateTime)), description: \(String(describing: description)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), sentimentAnalysisSettings: \(String(describing: sentimentAnalysisSettings)))"}
}

extension DescribeBotAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeBotAliasOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botAliasHistoryEvents = output.botAliasHistoryEvents
            self.botAliasId = output.botAliasId
            self.botAliasLocaleSettings = output.botAliasLocaleSettings
            self.botAliasName = output.botAliasName
            self.botAliasStatus = output.botAliasStatus
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.conversationLogSettings = output.conversationLogSettings
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.sentimentAnalysisSettings = output.sentimentAnalysisSettings
        } else {
            self.botAliasHistoryEvents = nil
            self.botAliasId = nil
            self.botAliasLocaleSettings = nil
            self.botAliasName = nil
            self.botAliasStatus = nil
            self.botId = nil
            self.botVersion = nil
            self.conversationLogSettings = nil
            self.creationDateTime = nil
            self.description = nil
            self.lastUpdatedDateTime = nil
            self.sentimentAnalysisSettings = nil
        }
    }
}

public struct DescribeBotAliasOutputResponse: Equatable {
    /// <p>A list of events that affect a bot alias. For example, an event is
    ///          recorded when the version that the alias points to changes.</p>
    public let botAliasHistoryEvents: [BotAliasHistoryEvent]?
    /// <p>The identifier of the bot alias.</p>
    public let botAliasId: String?
    /// <p>The locale settings that are unique to the alias.</p>
    public let botAliasLocaleSettings: [String:BotAliasLocaleSettings]?
    /// <p>The name of the bot alias.</p>
    public let botAliasName: String?
    /// <p>The current status of the alias. When the alias is
    ///             <code>Available</code>, the alias is ready for use with your
    ///          bot.</p>
    public let botAliasStatus: BotAliasStatus?
    /// <p>The identifier of the bot associated with the bot alias.</p>
    public let botId: String?
    /// <p>The version of the bot associated with the bot alias.</p>
    public let botVersion: String?
    /// <p>Specifics of how Amazon Lex logs text and audio conversations with the
    ///          bot associated with the alias.</p>
    public let conversationLogSettings: ConversationLogSettings?
    /// <p>A timestamp of the date and time that the alias was created.</p>
    public let creationDateTime: Date?
    /// <p>The description of the bot alias.</p>
    public let description: String?
    /// <p>A timestamp of the date and time that the alias was last
    ///          updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of
    ///          user utterances.</p>
    public let sentimentAnalysisSettings: SentimentAnalysisSettings?

    public init (
        botAliasHistoryEvents: [BotAliasHistoryEvent]? = nil,
        botAliasId: String? = nil,
        botAliasLocaleSettings: [String:BotAliasLocaleSettings]? = nil,
        botAliasName: String? = nil,
        botAliasStatus: BotAliasStatus? = nil,
        botId: String? = nil,
        botVersion: String? = nil,
        conversationLogSettings: ConversationLogSettings? = nil,
        creationDateTime: Date? = nil,
        description: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        sentimentAnalysisSettings: SentimentAnalysisSettings? = nil
    )
    {
        self.botAliasHistoryEvents = botAliasHistoryEvents
        self.botAliasId = botAliasId
        self.botAliasLocaleSettings = botAliasLocaleSettings
        self.botAliasName = botAliasName
        self.botAliasStatus = botAliasStatus
        self.botId = botId
        self.botVersion = botVersion
        self.conversationLogSettings = conversationLogSettings
        self.creationDateTime = creationDateTime
        self.description = description
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.sentimentAnalysisSettings = sentimentAnalysisSettings
    }
}

struct DescribeBotAliasOutputResponseBody: Equatable {
    public let botAliasId: String?
    public let botAliasName: String?
    public let description: String?
    public let botVersion: String?
    public let botAliasLocaleSettings: [String:BotAliasLocaleSettings]?
    public let conversationLogSettings: ConversationLogSettings?
    public let sentimentAnalysisSettings: SentimentAnalysisSettings?
    public let botAliasHistoryEvents: [BotAliasHistoryEvent]?
    public let botAliasStatus: BotAliasStatus?
    public let botId: String?
    public let creationDateTime: Date?
    public let lastUpdatedDateTime: Date?
}

extension DescribeBotAliasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botAliasHistoryEvents
        case botAliasId
        case botAliasLocaleSettings
        case botAliasName
        case botAliasStatus
        case botId
        case botVersion
        case conversationLogSettings
        case creationDateTime
        case description
        case lastUpdatedDateTime
        case sentimentAnalysisSettings
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botAliasIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botAliasId)
        botAliasId = botAliasIdDecoded
        let botAliasNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botAliasName)
        botAliasName = botAliasNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let botAliasLocaleSettingsContainer = try containerValues.decodeIfPresent([String: BotAliasLocaleSettings?].self, forKey: .botAliasLocaleSettings)
        var botAliasLocaleSettingsDecoded0: [String:BotAliasLocaleSettings]? = nil
        if let botAliasLocaleSettingsContainer = botAliasLocaleSettingsContainer {
            botAliasLocaleSettingsDecoded0 = [String:BotAliasLocaleSettings]()
            for (key0, botaliaslocalesettings0) in botAliasLocaleSettingsContainer {
                if let botaliaslocalesettings0 = botaliaslocalesettings0 {
                    botAliasLocaleSettingsDecoded0?[key0] = botaliaslocalesettings0
                }
            }
        }
        botAliasLocaleSettings = botAliasLocaleSettingsDecoded0
        let conversationLogSettingsDecoded = try containerValues.decodeIfPresent(ConversationLogSettings.self, forKey: .conversationLogSettings)
        conversationLogSettings = conversationLogSettingsDecoded
        let sentimentAnalysisSettingsDecoded = try containerValues.decodeIfPresent(SentimentAnalysisSettings.self, forKey: .sentimentAnalysisSettings)
        sentimentAnalysisSettings = sentimentAnalysisSettingsDecoded
        let botAliasHistoryEventsContainer = try containerValues.decodeIfPresent([BotAliasHistoryEvent?].self, forKey: .botAliasHistoryEvents)
        var botAliasHistoryEventsDecoded0:[BotAliasHistoryEvent]? = nil
        if let botAliasHistoryEventsContainer = botAliasHistoryEventsContainer {
            botAliasHistoryEventsDecoded0 = [BotAliasHistoryEvent]()
            for structure0 in botAliasHistoryEventsContainer {
                if let structure0 = structure0 {
                    botAliasHistoryEventsDecoded0?.append(structure0)
                }
            }
        }
        botAliasHistoryEvents = botAliasHistoryEventsDecoded0
        let botAliasStatusDecoded = try containerValues.decodeIfPresent(BotAliasStatus.self, forKey: .botAliasStatus)
        botAliasStatus = botAliasStatusDecoded
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension DescribeBotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBotInput(botId: \(String(describing: botId)))"}
}

extension DescribeBotInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeBotInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeBotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBotInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBotInput>
    public typealias MOutput = OperationOutput<DescribeBotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBotOutputError>
}

public struct DescribeBotInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeBotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBotInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBotInput>
    public typealias MOutput = OperationOutput<DescribeBotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBotOutputError>
}

public struct DescribeBotInput: Equatable {
    /// <p>The unique identifier of the bot to describe.</p>
    public let botId: String?

    public init (
        botId: String? = nil
    )
    {
        self.botId = botId
    }
}

struct DescribeBotInputBody: Equatable {
}

extension DescribeBotInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeBotLocaleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBotLocaleInput(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), localeId: \(String(describing: localeId)))"}
}

extension DescribeBotLocaleInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeBotLocaleInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeBotLocaleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBotLocaleInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBotLocaleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBotLocaleInput>
    public typealias MOutput = OperationOutput<DescribeBotLocaleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBotLocaleOutputError>
}

public struct DescribeBotLocaleInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeBotLocaleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBotLocaleInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBotLocaleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBotLocaleInput>
    public typealias MOutput = OperationOutput<DescribeBotLocaleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBotLocaleOutputError>
}

public struct DescribeBotLocaleInput: Equatable {
    /// <p>The identifier of the bot associated with the locale.</p>
    public let botId: String?
    /// <p>The identifier of the version of the bot associated with the
    ///          locale.</p>
    public let botVersion: String?
    /// <p>The unique identifier of the locale to describe. The string must
    ///          match one of the supported locales. For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>. </p>
    public let localeId: String?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        localeId: String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.localeId = localeId
    }
}

struct DescribeBotLocaleInputBody: Equatable {
}

extension DescribeBotLocaleInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeBotLocaleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBotLocaleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBotLocaleOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBotLocaleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBotLocaleOutputResponse(botId: \(String(describing: botId)), botLocaleHistoryEvents: \(String(describing: botLocaleHistoryEvents)), botLocaleStatus: \(String(describing: botLocaleStatus)), botVersion: \(String(describing: botVersion)), creationDateTime: \(String(describing: creationDateTime)), description: \(String(describing: description)), failureReasons: \(String(describing: failureReasons)), intentsCount: \(String(describing: intentsCount)), lastBuildSubmittedDateTime: \(String(describing: lastBuildSubmittedDateTime)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), localeId: \(String(describing: localeId)), localeName: \(String(describing: localeName)), nluIntentConfidenceThreshold: \(String(describing: nluIntentConfidenceThreshold)), slotTypesCount: \(String(describing: slotTypesCount)), voiceSettings: \(String(describing: voiceSettings)))"}
}

extension DescribeBotLocaleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeBotLocaleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botId = output.botId
            self.botLocaleHistoryEvents = output.botLocaleHistoryEvents
            self.botLocaleStatus = output.botLocaleStatus
            self.botVersion = output.botVersion
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.failureReasons = output.failureReasons
            self.intentsCount = output.intentsCount
            self.lastBuildSubmittedDateTime = output.lastBuildSubmittedDateTime
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.localeId = output.localeId
            self.localeName = output.localeName
            self.nluIntentConfidenceThreshold = output.nluIntentConfidenceThreshold
            self.slotTypesCount = output.slotTypesCount
            self.voiceSettings = output.voiceSettings
        } else {
            self.botId = nil
            self.botLocaleHistoryEvents = nil
            self.botLocaleStatus = nil
            self.botVersion = nil
            self.creationDateTime = nil
            self.description = nil
            self.failureReasons = nil
            self.intentsCount = nil
            self.lastBuildSubmittedDateTime = nil
            self.lastUpdatedDateTime = nil
            self.localeId = nil
            self.localeName = nil
            self.nluIntentConfidenceThreshold = nil
            self.slotTypesCount = nil
            self.voiceSettings = nil
        }
    }
}

public struct DescribeBotLocaleOutputResponse: Equatable {
    /// <p>The identifier of the bot associated with the locale.</p>
    public let botId: String?
    /// <p>History of changes, such as when a locale is used in an alias, that
    ///          have taken place for the locale.</p>
    public let botLocaleHistoryEvents: [BotLocaleHistoryEvent]?
    /// <p>The status of the bot. If the status is <code>Failed</code>, the
    ///          reasons for the failure are listed in the <code>failureReasons</code>
    ///          field.</p>
    public let botLocaleStatus: BotLocaleStatus?
    /// <p>The identifier of the version of the bot associated with the
    ///          locale.</p>
    public let botVersion: String?
    /// <p>The date and time that the locale was created.</p>
    public let creationDateTime: Date?
    /// <p>The description of the locale.</p>
    public let description: String?
    /// <p>if <code>botLocaleStatus</code> is <code>Failed</code>, Amazon Lex
    ///          explains why it failed to build the bot.</p>
    public let failureReasons: [String]?
    /// <p>The number of intents defined for the locale.</p>
    public let intentsCount: Int?
    /// <p>The date and time that the locale was last submitted for
    ///          building.</p>
    public let lastBuildSubmittedDateTime: Date?
    /// <p>The date and time that the locale was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The unique identifier of the described locale.</p>
    public let localeId: String?
    /// <p>The name of the locale.</p>
    public let localeName: String?
    /// <p>The confidence threshold where Amazon Lex inserts the
    ///             <code>AMAZON.FallbackIntent</code> and
    ///             <code>AMAZON.KendraSearchIntent</code> intents in the list of
    ///          possible intents for an utterance.</p>
    public let nluIntentConfidenceThreshold: Double?
    /// <p>The number of slot types defined for the locale.</p>
    public let slotTypesCount: Int?
    /// <p>The Amazon Polly voice Amazon Lex uses for voice interaction with the
    ///          user.</p>
    public let voiceSettings: VoiceSettings?

    public init (
        botId: String? = nil,
        botLocaleHistoryEvents: [BotLocaleHistoryEvent]? = nil,
        botLocaleStatus: BotLocaleStatus? = nil,
        botVersion: String? = nil,
        creationDateTime: Date? = nil,
        description: String? = nil,
        failureReasons: [String]? = nil,
        intentsCount: Int? = nil,
        lastBuildSubmittedDateTime: Date? = nil,
        lastUpdatedDateTime: Date? = nil,
        localeId: String? = nil,
        localeName: String? = nil,
        nluIntentConfidenceThreshold: Double? = nil,
        slotTypesCount: Int? = nil,
        voiceSettings: VoiceSettings? = nil
    )
    {
        self.botId = botId
        self.botLocaleHistoryEvents = botLocaleHistoryEvents
        self.botLocaleStatus = botLocaleStatus
        self.botVersion = botVersion
        self.creationDateTime = creationDateTime
        self.description = description
        self.failureReasons = failureReasons
        self.intentsCount = intentsCount
        self.lastBuildSubmittedDateTime = lastBuildSubmittedDateTime
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.localeId = localeId
        self.localeName = localeName
        self.nluIntentConfidenceThreshold = nluIntentConfidenceThreshold
        self.slotTypesCount = slotTypesCount
        self.voiceSettings = voiceSettings
    }
}

struct DescribeBotLocaleOutputResponseBody: Equatable {
    public let botId: String?
    public let botVersion: String?
    public let localeId: String?
    public let localeName: String?
    public let description: String?
    public let nluIntentConfidenceThreshold: Double?
    public let voiceSettings: VoiceSettings?
    public let intentsCount: Int?
    public let slotTypesCount: Int?
    public let botLocaleStatus: BotLocaleStatus?
    public let failureReasons: [String]?
    public let creationDateTime: Date?
    public let lastUpdatedDateTime: Date?
    public let lastBuildSubmittedDateTime: Date?
    public let botLocaleHistoryEvents: [BotLocaleHistoryEvent]?
}

extension DescribeBotLocaleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botId
        case botLocaleHistoryEvents
        case botLocaleStatus
        case botVersion
        case creationDateTime
        case description
        case failureReasons
        case intentsCount
        case lastBuildSubmittedDateTime
        case lastUpdatedDateTime
        case localeId
        case localeName
        case nluIntentConfidenceThreshold
        case slotTypesCount
        case voiceSettings
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let localeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localeName)
        localeName = localeNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let nluIntentConfidenceThresholdDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .nluIntentConfidenceThreshold)
        nluIntentConfidenceThreshold = nluIntentConfidenceThresholdDecoded
        let voiceSettingsDecoded = try containerValues.decodeIfPresent(VoiceSettings.self, forKey: .voiceSettings)
        voiceSettings = voiceSettingsDecoded
        let intentsCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .intentsCount)
        intentsCount = intentsCountDecoded
        let slotTypesCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .slotTypesCount)
        slotTypesCount = slotTypesCountDecoded
        let botLocaleStatusDecoded = try containerValues.decodeIfPresent(BotLocaleStatus.self, forKey: .botLocaleStatus)
        botLocaleStatus = botLocaleStatusDecoded
        let failureReasonsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .failureReasons)
        var failureReasonsDecoded0:[String]? = nil
        if let failureReasonsContainer = failureReasonsContainer {
            failureReasonsDecoded0 = [String]()
            for string0 in failureReasonsContainer {
                if let string0 = string0 {
                    failureReasonsDecoded0?.append(string0)
                }
            }
        }
        failureReasons = failureReasonsDecoded0
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let lastBuildSubmittedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastBuildSubmittedDateTime)
        lastBuildSubmittedDateTime = lastBuildSubmittedDateTimeDecoded
        let botLocaleHistoryEventsContainer = try containerValues.decodeIfPresent([BotLocaleHistoryEvent?].self, forKey: .botLocaleHistoryEvents)
        var botLocaleHistoryEventsDecoded0:[BotLocaleHistoryEvent]? = nil
        if let botLocaleHistoryEventsContainer = botLocaleHistoryEventsContainer {
            botLocaleHistoryEventsDecoded0 = [BotLocaleHistoryEvent]()
            for structure0 in botLocaleHistoryEventsContainer {
                if let structure0 = structure0 {
                    botLocaleHistoryEventsDecoded0?.append(structure0)
                }
            }
        }
        botLocaleHistoryEvents = botLocaleHistoryEventsDecoded0
    }
}

extension DescribeBotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBotOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBotOutputResponse(botId: \(String(describing: botId)), botName: \(String(describing: botName)), botStatus: \(String(describing: botStatus)), creationDateTime: \(String(describing: creationDateTime)), dataPrivacy: \(String(describing: dataPrivacy)), description: \(String(describing: description)), idleSessionTTLInSeconds: \(String(describing: idleSessionTTLInSeconds)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), roleArn: \(String(describing: roleArn)))"}
}

extension DescribeBotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeBotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botId = output.botId
            self.botName = output.botName
            self.botStatus = output.botStatus
            self.creationDateTime = output.creationDateTime
            self.dataPrivacy = output.dataPrivacy
            self.description = output.description
            self.idleSessionTTLInSeconds = output.idleSessionTTLInSeconds
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.roleArn = output.roleArn
        } else {
            self.botId = nil
            self.botName = nil
            self.botStatus = nil
            self.creationDateTime = nil
            self.dataPrivacy = nil
            self.description = nil
            self.idleSessionTTLInSeconds = nil
            self.lastUpdatedDateTime = nil
            self.roleArn = nil
        }
    }
}

public struct DescribeBotOutputResponse: Equatable {
    /// <p>The unique identifier of the bot.</p>
    public let botId: String?
    /// <p>The name of the bot.</p>
    public let botName: String?
    /// <p>The current status of the bot. When the status is
    ///             <code>Available</code> the bot is ready to be used in conversations
    ///          with users.</p>
    public let botStatus: BotStatus?
    /// <p>A timestamp of the date and time that the bot was created.</p>
    public let creationDateTime: Date?
    /// <p>Settings for managing data privacy of the bot and its conversations
    ///          with users.</p>
    public let dataPrivacy: DataPrivacy?
    /// <p>The description of the bot. </p>
    public let description: String?
    /// <p>The maximum time in seconds that Amazon Lex retains the data gathered in
    ///          a conversation.</p>
    public let idleSessionTTLInSeconds: Int?
    /// <p>A timestamp of the date and time that the bot was last
    ///          updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The Amazon Resource Name (ARN) of an IAM role that has permission to
    ///          access the bot.</p>
    public let roleArn: String?

    public init (
        botId: String? = nil,
        botName: String? = nil,
        botStatus: BotStatus? = nil,
        creationDateTime: Date? = nil,
        dataPrivacy: DataPrivacy? = nil,
        description: String? = nil,
        idleSessionTTLInSeconds: Int? = nil,
        lastUpdatedDateTime: Date? = nil,
        roleArn: String? = nil
    )
    {
        self.botId = botId
        self.botName = botName
        self.botStatus = botStatus
        self.creationDateTime = creationDateTime
        self.dataPrivacy = dataPrivacy
        self.description = description
        self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.roleArn = roleArn
    }
}

struct DescribeBotOutputResponseBody: Equatable {
    public let botId: String?
    public let botName: String?
    public let description: String?
    public let roleArn: String?
    public let dataPrivacy: DataPrivacy?
    public let idleSessionTTLInSeconds: Int?
    public let botStatus: BotStatus?
    public let creationDateTime: Date?
    public let lastUpdatedDateTime: Date?
}

extension DescribeBotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botId
        case botName
        case botStatus
        case creationDateTime
        case dataPrivacy
        case description
        case idleSessionTTLInSeconds
        case lastUpdatedDateTime
        case roleArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botName)
        botName = botNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let dataPrivacyDecoded = try containerValues.decodeIfPresent(DataPrivacy.self, forKey: .dataPrivacy)
        dataPrivacy = dataPrivacyDecoded
        let idleSessionTTLInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .idleSessionTTLInSeconds)
        idleSessionTTLInSeconds = idleSessionTTLInSecondsDecoded
        let botStatusDecoded = try containerValues.decodeIfPresent(BotStatus.self, forKey: .botStatus)
        botStatus = botStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension DescribeBotVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBotVersionInput(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)))"}
}

extension DescribeBotVersionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeBotVersionInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeBotVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBotVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBotVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBotVersionInput>
    public typealias MOutput = OperationOutput<DescribeBotVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBotVersionOutputError>
}

public struct DescribeBotVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeBotVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBotVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBotVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBotVersionInput>
    public typealias MOutput = OperationOutput<DescribeBotVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBotVersionOutputError>
}

public struct DescribeBotVersionInput: Equatable {
    /// <p>The identifier of the bot containing the version to return metadata
    ///          for.</p>
    public let botId: String?
    /// <p>The version of the bot to return metadata for.</p>
    public let botVersion: String?

    public init (
        botId: String? = nil,
        botVersion: String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
    }
}

struct DescribeBotVersionInputBody: Equatable {
}

extension DescribeBotVersionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeBotVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBotVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBotVersionOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBotVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBotVersionOutputResponse(botId: \(String(describing: botId)), botName: \(String(describing: botName)), botStatus: \(String(describing: botStatus)), botVersion: \(String(describing: botVersion)), creationDateTime: \(String(describing: creationDateTime)), dataPrivacy: \(String(describing: dataPrivacy)), description: \(String(describing: description)), failureReasons: \(String(describing: failureReasons)), idleSessionTTLInSeconds: \(String(describing: idleSessionTTLInSeconds)), roleArn: \(String(describing: roleArn)))"}
}

extension DescribeBotVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeBotVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botId = output.botId
            self.botName = output.botName
            self.botStatus = output.botStatus
            self.botVersion = output.botVersion
            self.creationDateTime = output.creationDateTime
            self.dataPrivacy = output.dataPrivacy
            self.description = output.description
            self.failureReasons = output.failureReasons
            self.idleSessionTTLInSeconds = output.idleSessionTTLInSeconds
            self.roleArn = output.roleArn
        } else {
            self.botId = nil
            self.botName = nil
            self.botStatus = nil
            self.botVersion = nil
            self.creationDateTime = nil
            self.dataPrivacy = nil
            self.description = nil
            self.failureReasons = nil
            self.idleSessionTTLInSeconds = nil
            self.roleArn = nil
        }
    }
}

public struct DescribeBotVersionOutputResponse: Equatable {
    /// <p>The identifier of the bot that contains the version.</p>
    public let botId: String?
    /// <p>The name of the bot that contains the version.</p>
    public let botName: String?
    /// <p>The current status of the bot. When the status is
    ///             <code>Available</code>, the bot version is ready for use.</p>
    public let botStatus: BotStatus?
    /// <p>The version of the bot to describe.</p>
    public let botVersion: String?
    /// <p>A timestamp of the date and time that the bot version was
    ///          created.</p>
    public let creationDateTime: Date?
    /// <p>Data privacy settings for the bot version.</p>
    public let dataPrivacy: DataPrivacy?
    /// <p>The description specified for the bot.</p>
    public let description: String?
    /// <p>If the <code>botStatus</code> is <code>Failed</code>, this contains
    ///          a list of reasons that the version couldn't be built.</p>
    public let failureReasons: [String]?
    /// <p>The number of seconds that a session with the bot remains active
    ///          before it is discarded by Amazon Lex.</p>
    public let idleSessionTTLInSeconds: Int?
    /// <p>The Amazon Resource Name (ARN) of an IAM role that has permission to
    ///          access the bot version.</p>
    public let roleArn: String?

    public init (
        botId: String? = nil,
        botName: String? = nil,
        botStatus: BotStatus? = nil,
        botVersion: String? = nil,
        creationDateTime: Date? = nil,
        dataPrivacy: DataPrivacy? = nil,
        description: String? = nil,
        failureReasons: [String]? = nil,
        idleSessionTTLInSeconds: Int? = nil,
        roleArn: String? = nil
    )
    {
        self.botId = botId
        self.botName = botName
        self.botStatus = botStatus
        self.botVersion = botVersion
        self.creationDateTime = creationDateTime
        self.dataPrivacy = dataPrivacy
        self.description = description
        self.failureReasons = failureReasons
        self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
        self.roleArn = roleArn
    }
}

struct DescribeBotVersionOutputResponseBody: Equatable {
    public let botId: String?
    public let botName: String?
    public let botVersion: String?
    public let description: String?
    public let roleArn: String?
    public let dataPrivacy: DataPrivacy?
    public let idleSessionTTLInSeconds: Int?
    public let botStatus: BotStatus?
    public let failureReasons: [String]?
    public let creationDateTime: Date?
}

extension DescribeBotVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botId
        case botName
        case botStatus
        case botVersion
        case creationDateTime
        case dataPrivacy
        case description
        case failureReasons
        case idleSessionTTLInSeconds
        case roleArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botName)
        botName = botNameDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let dataPrivacyDecoded = try containerValues.decodeIfPresent(DataPrivacy.self, forKey: .dataPrivacy)
        dataPrivacy = dataPrivacyDecoded
        let idleSessionTTLInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .idleSessionTTLInSeconds)
        idleSessionTTLInSeconds = idleSessionTTLInSecondsDecoded
        let botStatusDecoded = try containerValues.decodeIfPresent(BotStatus.self, forKey: .botStatus)
        botStatus = botStatusDecoded
        let failureReasonsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .failureReasons)
        var failureReasonsDecoded0:[String]? = nil
        if let failureReasonsContainer = failureReasonsContainer {
            failureReasonsDecoded0 = [String]()
            for string0 in failureReasonsContainer {
                if let string0 = string0 {
                    failureReasonsDecoded0?.append(string0)
                }
            }
        }
        failureReasons = failureReasonsDecoded0
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
    }
}

extension DescribeExportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeExportInput(exportId: \(String(describing: exportId)))"}
}

extension DescribeExportInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeExportInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeExportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeExportInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeExportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeExportInput>
    public typealias MOutput = OperationOutput<DescribeExportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeExportOutputError>
}

public struct DescribeExportInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeExportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeExportInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeExportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeExportInput>
    public typealias MOutput = OperationOutput<DescribeExportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeExportOutputError>
}

public struct DescribeExportInput: Equatable {
    /// <p>The unique identifier of the export to describe.</p>
    public let exportId: String?

    public init (
        exportId: String? = nil
    )
    {
        self.exportId = exportId
    }
}

struct DescribeExportInputBody: Equatable {
}

extension DescribeExportInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeExportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeExportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeExportOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeExportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeExportOutputResponse(creationDateTime: \(String(describing: creationDateTime)), downloadUrl: \(String(describing: downloadUrl)), exportId: \(String(describing: exportId)), exportStatus: \(String(describing: exportStatus)), failureReasons: \(String(describing: failureReasons)), fileFormat: \(String(describing: fileFormat)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), resourceSpecification: \(String(describing: resourceSpecification)))"}
}

extension DescribeExportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeExportOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.creationDateTime = output.creationDateTime
            self.downloadUrl = output.downloadUrl
            self.exportId = output.exportId
            self.exportStatus = output.exportStatus
            self.failureReasons = output.failureReasons
            self.fileFormat = output.fileFormat
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.resourceSpecification = output.resourceSpecification
        } else {
            self.creationDateTime = nil
            self.downloadUrl = nil
            self.exportId = nil
            self.exportStatus = nil
            self.failureReasons = nil
            self.fileFormat = nil
            self.lastUpdatedDateTime = nil
            self.resourceSpecification = nil
        }
    }
}

public struct DescribeExportOutputResponse: Equatable {
    /// <p>The date and time that the export was created.</p>
    public let creationDateTime: Date?
    /// <p>A pre-signed S3 URL that points to the bot or bot locale archive.
    ///          The URL is only available for 5 minutes after calling the
    ///             <code>DescribeExport</code> operation.</p>
    public let downloadUrl: String?
    /// <p>The unique identifier of the described export.</p>
    public let exportId: String?
    /// <p>The status of the export. When the status is <code>Complete</code>
    ///          the export archive file is available for download.</p>
    public let exportStatus: ExportStatus?
    /// <p>If the <code>exportStatus</code> is failed, contains one or more
    ///          reasons why the export could not be completed.</p>
    public let failureReasons: [String]?
    /// <p>The file format used in the files that describe the bot or bot
    ///          locale.</p>
    public let fileFormat: ImportExportFileFormat?
    /// <p>The last date and time that the export was updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The bot, bot ID, and optional locale ID of the exported bot or bot
    ///          locale.</p>
    public let resourceSpecification: ExportResourceSpecification?

    public init (
        creationDateTime: Date? = nil,
        downloadUrl: String? = nil,
        exportId: String? = nil,
        exportStatus: ExportStatus? = nil,
        failureReasons: [String]? = nil,
        fileFormat: ImportExportFileFormat? = nil,
        lastUpdatedDateTime: Date? = nil,
        resourceSpecification: ExportResourceSpecification? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.downloadUrl = downloadUrl
        self.exportId = exportId
        self.exportStatus = exportStatus
        self.failureReasons = failureReasons
        self.fileFormat = fileFormat
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.resourceSpecification = resourceSpecification
    }
}

struct DescribeExportOutputResponseBody: Equatable {
    public let exportId: String?
    public let resourceSpecification: ExportResourceSpecification?
    public let fileFormat: ImportExportFileFormat?
    public let exportStatus: ExportStatus?
    public let failureReasons: [String]?
    public let downloadUrl: String?
    public let creationDateTime: Date?
    public let lastUpdatedDateTime: Date?
}

extension DescribeExportOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationDateTime
        case downloadUrl
        case exportId
        case exportStatus
        case failureReasons
        case fileFormat
        case lastUpdatedDateTime
        case resourceSpecification
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exportId)
        exportId = exportIdDecoded
        let resourceSpecificationDecoded = try containerValues.decodeIfPresent(ExportResourceSpecification.self, forKey: .resourceSpecification)
        resourceSpecification = resourceSpecificationDecoded
        let fileFormatDecoded = try containerValues.decodeIfPresent(ImportExportFileFormat.self, forKey: .fileFormat)
        fileFormat = fileFormatDecoded
        let exportStatusDecoded = try containerValues.decodeIfPresent(ExportStatus.self, forKey: .exportStatus)
        exportStatus = exportStatusDecoded
        let failureReasonsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .failureReasons)
        var failureReasonsDecoded0:[String]? = nil
        if let failureReasonsContainer = failureReasonsContainer {
            failureReasonsDecoded0 = [String]()
            for string0 in failureReasonsContainer {
                if let string0 = string0 {
                    failureReasonsDecoded0?.append(string0)
                }
            }
        }
        failureReasons = failureReasonsDecoded0
        let downloadUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .downloadUrl)
        downloadUrl = downloadUrlDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension DescribeImportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeImportInput(importId: \(String(describing: importId)))"}
}

extension DescribeImportInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeImportInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeImportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeImportInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeImportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeImportInput>
    public typealias MOutput = OperationOutput<DescribeImportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeImportOutputError>
}

public struct DescribeImportInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeImportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeImportInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeImportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeImportInput>
    public typealias MOutput = OperationOutput<DescribeImportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeImportOutputError>
}

public struct DescribeImportInput: Equatable {
    /// <p>The unique identifier of the import to describe.</p>
    public let importId: String?

    public init (
        importId: String? = nil
    )
    {
        self.importId = importId
    }
}

struct DescribeImportInputBody: Equatable {
}

extension DescribeImportInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeImportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeImportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeImportOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeImportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeImportOutputResponse(creationDateTime: \(String(describing: creationDateTime)), failureReasons: \(String(describing: failureReasons)), importId: \(String(describing: importId)), importStatus: \(String(describing: importStatus)), importedResourceId: \(String(describing: importedResourceId)), importedResourceName: \(String(describing: importedResourceName)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), mergeStrategy: \(String(describing: mergeStrategy)), resourceSpecification: \(String(describing: resourceSpecification)))"}
}

extension DescribeImportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeImportOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.creationDateTime = output.creationDateTime
            self.failureReasons = output.failureReasons
            self.importId = output.importId
            self.importStatus = output.importStatus
            self.importedResourceId = output.importedResourceId
            self.importedResourceName = output.importedResourceName
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.mergeStrategy = output.mergeStrategy
            self.resourceSpecification = output.resourceSpecification
        } else {
            self.creationDateTime = nil
            self.failureReasons = nil
            self.importId = nil
            self.importStatus = nil
            self.importedResourceId = nil
            self.importedResourceName = nil
            self.lastUpdatedDateTime = nil
            self.mergeStrategy = nil
            self.resourceSpecification = nil
        }
    }
}

public struct DescribeImportOutputResponse: Equatable {
    /// <p>The date and time that the import was created.</p>
    public let creationDateTime: Date?
    /// <p>If the <code>importStatus</code> field is <code>Failed</code>, this
    ///          provides one or more reasons for the failture.</p>
    public let failureReasons: [String]?
    /// <p>The unique identifier of the described import.</p>
    public let importId: String?
    /// <p>The status of the import process. When the status is
    ///             <code>Completed</code> the resource is imported and ready for
    ///          use.</p>
    public let importStatus: ImportStatus?
    /// <p>The unique identifier that Amazon Lex assigned to the resource created by
    ///          the import.</p>
    public let importedResourceId: String?
    /// <p>The name of the imported resource.</p>
    public let importedResourceName: String?
    /// <p>The date and time that the import was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The strategy used when there was a name conflict between the
    ///          imported resource and an existing resource. When the merge strategy is
    ///             <code>FailOnConflict</code> existing resources are not overwritten
    ///          and the import fails.</p>
    public let mergeStrategy: MergeStrategy?
    /// <p>The specifications of the imported bot or bot locale.</p>
    public let resourceSpecification: ImportResourceSpecification?

    public init (
        creationDateTime: Date? = nil,
        failureReasons: [String]? = nil,
        importId: String? = nil,
        importStatus: ImportStatus? = nil,
        importedResourceId: String? = nil,
        importedResourceName: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        mergeStrategy: MergeStrategy? = nil,
        resourceSpecification: ImportResourceSpecification? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.failureReasons = failureReasons
        self.importId = importId
        self.importStatus = importStatus
        self.importedResourceId = importedResourceId
        self.importedResourceName = importedResourceName
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.mergeStrategy = mergeStrategy
        self.resourceSpecification = resourceSpecification
    }
}

struct DescribeImportOutputResponseBody: Equatable {
    public let importId: String?
    public let resourceSpecification: ImportResourceSpecification?
    public let importedResourceId: String?
    public let importedResourceName: String?
    public let mergeStrategy: MergeStrategy?
    public let importStatus: ImportStatus?
    public let failureReasons: [String]?
    public let creationDateTime: Date?
    public let lastUpdatedDateTime: Date?
}

extension DescribeImportOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationDateTime
        case failureReasons
        case importId
        case importStatus
        case importedResourceId
        case importedResourceName
        case lastUpdatedDateTime
        case mergeStrategy
        case resourceSpecification
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .importId)
        importId = importIdDecoded
        let resourceSpecificationDecoded = try containerValues.decodeIfPresent(ImportResourceSpecification.self, forKey: .resourceSpecification)
        resourceSpecification = resourceSpecificationDecoded
        let importedResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .importedResourceId)
        importedResourceId = importedResourceIdDecoded
        let importedResourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .importedResourceName)
        importedResourceName = importedResourceNameDecoded
        let mergeStrategyDecoded = try containerValues.decodeIfPresent(MergeStrategy.self, forKey: .mergeStrategy)
        mergeStrategy = mergeStrategyDecoded
        let importStatusDecoded = try containerValues.decodeIfPresent(ImportStatus.self, forKey: .importStatus)
        importStatus = importStatusDecoded
        let failureReasonsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .failureReasons)
        var failureReasonsDecoded0:[String]? = nil
        if let failureReasonsContainer = failureReasonsContainer {
            failureReasonsDecoded0 = [String]()
            for string0 in failureReasonsContainer {
                if let string0 = string0 {
                    failureReasonsDecoded0?.append(string0)
                }
            }
        }
        failureReasons = failureReasonsDecoded0
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension DescribeIntentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeIntentInput(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), intentId: \(String(describing: intentId)), localeId: \(String(describing: localeId)))"}
}

extension DescribeIntentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeIntentInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeIntentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIntentInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIntentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIntentInput>
    public typealias MOutput = OperationOutput<DescribeIntentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIntentOutputError>
}

public struct DescribeIntentInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeIntentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIntentInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIntentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIntentInput>
    public typealias MOutput = OperationOutput<DescribeIntentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIntentOutputError>
}

public struct DescribeIntentInput: Equatable {
    /// <p>The identifier of the bot associated with the intent.</p>
    public let botId: String?
    /// <p>The version of the bot associated with the intent.</p>
    public let botVersion: String?
    /// <p>The identifier of the intent to describe.</p>
    public let intentId: String?
    /// <p>The identifier of the language and locale of the intent to describe.
    ///          The string must match one of the supported locales. For more
    ///          information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
    public let localeId: String?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        intentId: String? = nil,
        localeId: String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.intentId = intentId
        self.localeId = localeId
    }
}

struct DescribeIntentInputBody: Equatable {
}

extension DescribeIntentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeIntentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeIntentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeIntentOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIntentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeIntentOutputResponse(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), creationDateTime: \(String(describing: creationDateTime)), description: \(String(describing: description)), dialogCodeHook: \(String(describing: dialogCodeHook)), fulfillmentCodeHook: \(String(describing: fulfillmentCodeHook)), inputContexts: \(String(describing: inputContexts)), intentClosingSetting: \(String(describing: intentClosingSetting)), intentConfirmationSetting: \(String(describing: intentConfirmationSetting)), intentId: \(String(describing: intentId)), intentName: \(String(describing: intentName)), kendraConfiguration: \(String(describing: kendraConfiguration)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), localeId: \(String(describing: localeId)), outputContexts: \(String(describing: outputContexts)), parentIntentSignature: \(String(describing: parentIntentSignature)), sampleUtterances: \(String(describing: sampleUtterances)), slotPriorities: \(String(describing: slotPriorities)))"}
}

extension DescribeIntentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeIntentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.dialogCodeHook = output.dialogCodeHook
            self.fulfillmentCodeHook = output.fulfillmentCodeHook
            self.inputContexts = output.inputContexts
            self.intentClosingSetting = output.intentClosingSetting
            self.intentConfirmationSetting = output.intentConfirmationSetting
            self.intentId = output.intentId
            self.intentName = output.intentName
            self.kendraConfiguration = output.kendraConfiguration
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.localeId = output.localeId
            self.outputContexts = output.outputContexts
            self.parentIntentSignature = output.parentIntentSignature
            self.sampleUtterances = output.sampleUtterances
            self.slotPriorities = output.slotPriorities
        } else {
            self.botId = nil
            self.botVersion = nil
            self.creationDateTime = nil
            self.description = nil
            self.dialogCodeHook = nil
            self.fulfillmentCodeHook = nil
            self.inputContexts = nil
            self.intentClosingSetting = nil
            self.intentConfirmationSetting = nil
            self.intentId = nil
            self.intentName = nil
            self.kendraConfiguration = nil
            self.lastUpdatedDateTime = nil
            self.localeId = nil
            self.outputContexts = nil
            self.parentIntentSignature = nil
            self.sampleUtterances = nil
            self.slotPriorities = nil
        }
    }
}

public struct DescribeIntentOutputResponse: Equatable {
    /// <p>The identifier of the bot associated with the intent.</p>
    public let botId: String?
    /// <p>The version of the bot associated with the intent.</p>
    public let botVersion: String?
    /// <p>A timestamp of the date and time that the intent was created.</p>
    public let creationDateTime: Date?
    /// <p>The description of the intent.</p>
    public let description: String?
    /// <p>The Lambda function called during each turn of a conversation with
    ///          the intent.</p>
    public let dialogCodeHook: DialogCodeHookSettings?
    /// <p>The Lambda function called when the intent is complete and ready for
    ///          fulfillment.</p>
    public let fulfillmentCodeHook: FulfillmentCodeHookSettings?
    /// <p>A list of contexts that must be active for the intent to be
    ///          considered for sending to the user.</p>
    public let inputContexts: [InputContext]?
    /// <p>The response that Amazon Lex sends to when the intent is closed.</p>
    public let intentClosingSetting: IntentClosingSetting?
    /// <p>Prompts that Amazon Lex sends to the user to confirm completion of an
    ///          intent.</p>
    public let intentConfirmationSetting: IntentConfirmationSetting?
    /// <p>The unique identifier assigned to the intent when it was
    ///          created.</p>
    public let intentId: String?
    /// <p>The name specified for the intent.</p>
    public let intentName: String?
    /// <p>Configuration information required to use the
    ///             <code>AMAZON.KendraSearchIntent</code> intent.</p>
    public let kendraConfiguration: KendraConfiguration?
    /// <p>A timestamp of the date and time that the intent was last
    ///          updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The language and locale specified for the intent.</p>
    public let localeId: String?
    /// <p>A list of contexts that are activated when the intent is
    ///          fulfilled.</p>
    public let outputContexts: [OutputContext]?
    /// <p>The identifier of the built-in intent that this intent is derived
    ///          from, if any.</p>
    public let parentIntentSignature: String?
    /// <p>User utterances that trigger this intent.</p>
    public let sampleUtterances: [SampleUtterance]?
    /// <p>The list that determines the priority that slots should be elicited
    ///          from the user.</p>
    public let slotPriorities: [SlotPriority]?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        creationDateTime: Date? = nil,
        description: String? = nil,
        dialogCodeHook: DialogCodeHookSettings? = nil,
        fulfillmentCodeHook: FulfillmentCodeHookSettings? = nil,
        inputContexts: [InputContext]? = nil,
        intentClosingSetting: IntentClosingSetting? = nil,
        intentConfirmationSetting: IntentConfirmationSetting? = nil,
        intentId: String? = nil,
        intentName: String? = nil,
        kendraConfiguration: KendraConfiguration? = nil,
        lastUpdatedDateTime: Date? = nil,
        localeId: String? = nil,
        outputContexts: [OutputContext]? = nil,
        parentIntentSignature: String? = nil,
        sampleUtterances: [SampleUtterance]? = nil,
        slotPriorities: [SlotPriority]? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.creationDateTime = creationDateTime
        self.description = description
        self.dialogCodeHook = dialogCodeHook
        self.fulfillmentCodeHook = fulfillmentCodeHook
        self.inputContexts = inputContexts
        self.intentClosingSetting = intentClosingSetting
        self.intentConfirmationSetting = intentConfirmationSetting
        self.intentId = intentId
        self.intentName = intentName
        self.kendraConfiguration = kendraConfiguration
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.localeId = localeId
        self.outputContexts = outputContexts
        self.parentIntentSignature = parentIntentSignature
        self.sampleUtterances = sampleUtterances
        self.slotPriorities = slotPriorities
    }
}

struct DescribeIntentOutputResponseBody: Equatable {
    public let intentId: String?
    public let intentName: String?
    public let description: String?
    public let parentIntentSignature: String?
    public let sampleUtterances: [SampleUtterance]?
    public let dialogCodeHook: DialogCodeHookSettings?
    public let fulfillmentCodeHook: FulfillmentCodeHookSettings?
    public let slotPriorities: [SlotPriority]?
    public let intentConfirmationSetting: IntentConfirmationSetting?
    public let intentClosingSetting: IntentClosingSetting?
    public let inputContexts: [InputContext]?
    public let outputContexts: [OutputContext]?
    public let kendraConfiguration: KendraConfiguration?
    public let botId: String?
    public let botVersion: String?
    public let localeId: String?
    public let creationDateTime: Date?
    public let lastUpdatedDateTime: Date?
}

extension DescribeIntentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botId
        case botVersion
        case creationDateTime
        case description
        case dialogCodeHook
        case fulfillmentCodeHook
        case inputContexts
        case intentClosingSetting
        case intentConfirmationSetting
        case intentId
        case intentName
        case kendraConfiguration
        case lastUpdatedDateTime
        case localeId
        case outputContexts
        case parentIntentSignature
        case sampleUtterances
        case slotPriorities
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .intentId)
        intentId = intentIdDecoded
        let intentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .intentName)
        intentName = intentNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let parentIntentSignatureDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentIntentSignature)
        parentIntentSignature = parentIntentSignatureDecoded
        let sampleUtterancesContainer = try containerValues.decodeIfPresent([SampleUtterance?].self, forKey: .sampleUtterances)
        var sampleUtterancesDecoded0:[SampleUtterance]? = nil
        if let sampleUtterancesContainer = sampleUtterancesContainer {
            sampleUtterancesDecoded0 = [SampleUtterance]()
            for structure0 in sampleUtterancesContainer {
                if let structure0 = structure0 {
                    sampleUtterancesDecoded0?.append(structure0)
                }
            }
        }
        sampleUtterances = sampleUtterancesDecoded0
        let dialogCodeHookDecoded = try containerValues.decodeIfPresent(DialogCodeHookSettings.self, forKey: .dialogCodeHook)
        dialogCodeHook = dialogCodeHookDecoded
        let fulfillmentCodeHookDecoded = try containerValues.decodeIfPresent(FulfillmentCodeHookSettings.self, forKey: .fulfillmentCodeHook)
        fulfillmentCodeHook = fulfillmentCodeHookDecoded
        let slotPrioritiesContainer = try containerValues.decodeIfPresent([SlotPriority?].self, forKey: .slotPriorities)
        var slotPrioritiesDecoded0:[SlotPriority]? = nil
        if let slotPrioritiesContainer = slotPrioritiesContainer {
            slotPrioritiesDecoded0 = [SlotPriority]()
            for structure0 in slotPrioritiesContainer {
                if let structure0 = structure0 {
                    slotPrioritiesDecoded0?.append(structure0)
                }
            }
        }
        slotPriorities = slotPrioritiesDecoded0
        let intentConfirmationSettingDecoded = try containerValues.decodeIfPresent(IntentConfirmationSetting.self, forKey: .intentConfirmationSetting)
        intentConfirmationSetting = intentConfirmationSettingDecoded
        let intentClosingSettingDecoded = try containerValues.decodeIfPresent(IntentClosingSetting.self, forKey: .intentClosingSetting)
        intentClosingSetting = intentClosingSettingDecoded
        let inputContextsContainer = try containerValues.decodeIfPresent([InputContext?].self, forKey: .inputContexts)
        var inputContextsDecoded0:[InputContext]? = nil
        if let inputContextsContainer = inputContextsContainer {
            inputContextsDecoded0 = [InputContext]()
            for structure0 in inputContextsContainer {
                if let structure0 = structure0 {
                    inputContextsDecoded0?.append(structure0)
                }
            }
        }
        inputContexts = inputContextsDecoded0
        let outputContextsContainer = try containerValues.decodeIfPresent([OutputContext?].self, forKey: .outputContexts)
        var outputContextsDecoded0:[OutputContext]? = nil
        if let outputContextsContainer = outputContextsContainer {
            outputContextsDecoded0 = [OutputContext]()
            for structure0 in outputContextsContainer {
                if let structure0 = structure0 {
                    outputContextsDecoded0?.append(structure0)
                }
            }
        }
        outputContexts = outputContextsDecoded0
        let kendraConfigurationDecoded = try containerValues.decodeIfPresent(KendraConfiguration.self, forKey: .kendraConfiguration)
        kendraConfiguration = kendraConfigurationDecoded
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension DescribeResourcePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeResourcePolicyInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension DescribeResourcePolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeResourcePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeResourcePolicyInput>
    public typealias MOutput = OperationOutput<DescribeResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeResourcePolicyOutputError>
}

public struct DescribeResourcePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeResourcePolicyInput>
    public typealias MOutput = OperationOutput<DescribeResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeResourcePolicyOutputError>
}

public struct DescribeResourcePolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the bot or bot alias that the
    ///          resource policy is attached to.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DescribeResourcePolicyInputBody: Equatable {
}

extension DescribeResourcePolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeResourcePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeResourcePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeResourcePolicyOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeResourcePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeResourcePolicyOutputResponse(policy: \(String(describing: policy)), resourceArn: \(String(describing: resourceArn)), revisionId: \(String(describing: revisionId)))"}
}

extension DescribeResourcePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
            self.resourceArn = output.resourceArn
            self.revisionId = output.revisionId
        } else {
            self.policy = nil
            self.resourceArn = nil
            self.revisionId = nil
        }
    }
}

public struct DescribeResourcePolicyOutputResponse: Equatable {
    /// <p>The JSON structure that contains the resource policy. For more
    ///          information about the contents of a JSON policy document, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies.html"> IAM JSON policy
    ///             reference </a>.</p>
    public let policy: String?
    /// <p>The Amazon Resource Name (ARN) of the bot or bot alias that the
    ///          resource policy is attached to.</p>
    public let resourceArn: String?
    /// <p>The current revision of the resource policy. Use the revision ID to
    ///          make sure that you are updating the most current version of a resource
    ///          policy when you add a policy statement to a resource, delete a
    ///          resource, or update a resource.</p>
    public let revisionId: String?

    public init (
        policy: String? = nil,
        resourceArn: String? = nil,
        revisionId: String? = nil
    )
    {
        self.policy = policy
        self.resourceArn = resourceArn
        self.revisionId = revisionId
    }
}

struct DescribeResourcePolicyOutputResponseBody: Equatable {
    public let resourceArn: String?
    public let policy: String?
    public let revisionId: String?
}

extension DescribeResourcePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy
        case resourceArn
        case revisionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension DescribeSlotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSlotInput(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), intentId: \(String(describing: intentId)), localeId: \(String(describing: localeId)), slotId: \(String(describing: slotId)))"}
}

extension DescribeSlotInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeSlotInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSlotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSlotInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSlotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSlotInput>
    public typealias MOutput = OperationOutput<DescribeSlotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSlotOutputError>
}

public struct DescribeSlotInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSlotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSlotInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSlotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSlotInput>
    public typealias MOutput = OperationOutput<DescribeSlotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSlotOutputError>
}

public struct DescribeSlotInput: Equatable {
    /// <p>The identifier of the bot associated with the slot.</p>
    public let botId: String?
    /// <p>The version of the bot associated with the slot.</p>
    public let botVersion: String?
    /// <p>The identifier of the intent that contains the slot.</p>
    public let intentId: String?
    /// <p>The identifier of the language and locale of the slot to describe.
    ///          The string must match one of the supported locales. For more
    ///          information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
    public let localeId: String?
    /// <p>The unique identifier for the slot.</p>
    public let slotId: String?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        intentId: String? = nil,
        localeId: String? = nil,
        slotId: String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.intentId = intentId
        self.localeId = localeId
        self.slotId = slotId
    }
}

struct DescribeSlotInputBody: Equatable {
}

extension DescribeSlotInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeSlotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSlotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSlotOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSlotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSlotOutputResponse(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), creationDateTime: \(String(describing: creationDateTime)), description: \(String(describing: description)), intentId: \(String(describing: intentId)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), localeId: \(String(describing: localeId)), obfuscationSetting: \(String(describing: obfuscationSetting)), slotId: \(String(describing: slotId)), slotName: \(String(describing: slotName)), slotTypeId: \(String(describing: slotTypeId)), valueElicitationSetting: \(String(describing: valueElicitationSetting)))"}
}

extension DescribeSlotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSlotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.intentId = output.intentId
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.localeId = output.localeId
            self.obfuscationSetting = output.obfuscationSetting
            self.slotId = output.slotId
            self.slotName = output.slotName
            self.slotTypeId = output.slotTypeId
            self.valueElicitationSetting = output.valueElicitationSetting
        } else {
            self.botId = nil
            self.botVersion = nil
            self.creationDateTime = nil
            self.description = nil
            self.intentId = nil
            self.lastUpdatedDateTime = nil
            self.localeId = nil
            self.obfuscationSetting = nil
            self.slotId = nil
            self.slotName = nil
            self.slotTypeId = nil
            self.valueElicitationSetting = nil
        }
    }
}

public struct DescribeSlotOutputResponse: Equatable {
    /// <p>The identifier of the bot associated with the slot.</p>
    public let botId: String?
    /// <p>The version of the bot associated with the slot.</p>
    public let botVersion: String?
    /// <p>A timestamp of the date and time that the slot was created.</p>
    public let creationDateTime: Date?
    /// <p>The description specified for the slot.</p>
    public let description: String?
    /// <p>The identifier of the intent associated with the slot.</p>
    public let intentId: String?
    /// <p>A timestamp of the date and time that the slot was last
    ///          updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The language and locale specified for the slot.</p>
    public let localeId: String?
    /// <p>Whether slot values are shown in Amazon CloudWatch logs. If the value is
    ///             <code>None</code>, the actual value of the slot is shown in
    ///          logs.</p>
    public let obfuscationSetting: ObfuscationSetting?
    /// <p>The unique identifier generated for the slot.</p>
    public let slotId: String?
    /// <p>The name specified for the slot.</p>
    public let slotName: String?
    /// <p>The identifier of the slot type that determines the values entered
    ///          into the slot.</p>
    public let slotTypeId: String?
    /// <p>Prompts that Amazon Lex uses to elicit a value for the slot.</p>
    public let valueElicitationSetting: SlotValueElicitationSetting?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        creationDateTime: Date? = nil,
        description: String? = nil,
        intentId: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        localeId: String? = nil,
        obfuscationSetting: ObfuscationSetting? = nil,
        slotId: String? = nil,
        slotName: String? = nil,
        slotTypeId: String? = nil,
        valueElicitationSetting: SlotValueElicitationSetting? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.creationDateTime = creationDateTime
        self.description = description
        self.intentId = intentId
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.localeId = localeId
        self.obfuscationSetting = obfuscationSetting
        self.slotId = slotId
        self.slotName = slotName
        self.slotTypeId = slotTypeId
        self.valueElicitationSetting = valueElicitationSetting
    }
}

struct DescribeSlotOutputResponseBody: Equatable {
    public let slotId: String?
    public let slotName: String?
    public let description: String?
    public let slotTypeId: String?
    public let valueElicitationSetting: SlotValueElicitationSetting?
    public let obfuscationSetting: ObfuscationSetting?
    public let botId: String?
    public let botVersion: String?
    public let localeId: String?
    public let intentId: String?
    public let creationDateTime: Date?
    public let lastUpdatedDateTime: Date?
}

extension DescribeSlotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botId
        case botVersion
        case creationDateTime
        case description
        case intentId
        case lastUpdatedDateTime
        case localeId
        case obfuscationSetting
        case slotId
        case slotName
        case slotTypeId
        case valueElicitationSetting
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotId)
        slotId = slotIdDecoded
        let slotNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotName)
        slotName = slotNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let slotTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotTypeId)
        slotTypeId = slotTypeIdDecoded
        let valueElicitationSettingDecoded = try containerValues.decodeIfPresent(SlotValueElicitationSetting.self, forKey: .valueElicitationSetting)
        valueElicitationSetting = valueElicitationSettingDecoded
        let obfuscationSettingDecoded = try containerValues.decodeIfPresent(ObfuscationSetting.self, forKey: .obfuscationSetting)
        obfuscationSetting = obfuscationSettingDecoded
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let intentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .intentId)
        intentId = intentIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension DescribeSlotTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSlotTypeInput(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), localeId: \(String(describing: localeId)), slotTypeId: \(String(describing: slotTypeId)))"}
}

extension DescribeSlotTypeInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeSlotTypeInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSlotTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSlotTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSlotTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSlotTypeInput>
    public typealias MOutput = OperationOutput<DescribeSlotTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSlotTypeOutputError>
}

public struct DescribeSlotTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSlotTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSlotTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSlotTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSlotTypeInput>
    public typealias MOutput = OperationOutput<DescribeSlotTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSlotTypeOutputError>
}

public struct DescribeSlotTypeInput: Equatable {
    /// <p>The identifier of the bot associated with the slot type.</p>
    public let botId: String?
    /// <p>The version of the bot associated with the slot type.</p>
    public let botVersion: String?
    /// <p>The identifier of the language and locale of the slot type to
    ///          describe. The string must match one of the supported locales. For more
    ///          information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
    public let localeId: String?
    /// <p>The identifier of the slot type.</p>
    public let slotTypeId: String?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        localeId: String? = nil,
        slotTypeId: String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.localeId = localeId
        self.slotTypeId = slotTypeId
    }
}

struct DescribeSlotTypeInputBody: Equatable {
}

extension DescribeSlotTypeInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeSlotTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSlotTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSlotTypeOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSlotTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSlotTypeOutputResponse(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), creationDateTime: \(String(describing: creationDateTime)), description: \(String(describing: description)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), localeId: \(String(describing: localeId)), parentSlotTypeSignature: \(String(describing: parentSlotTypeSignature)), slotTypeId: \(String(describing: slotTypeId)), slotTypeName: \(String(describing: slotTypeName)), slotTypeValues: \(String(describing: slotTypeValues)), valueSelectionSetting: \(String(describing: valueSelectionSetting)))"}
}

extension DescribeSlotTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSlotTypeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.localeId = output.localeId
            self.parentSlotTypeSignature = output.parentSlotTypeSignature
            self.slotTypeId = output.slotTypeId
            self.slotTypeName = output.slotTypeName
            self.slotTypeValues = output.slotTypeValues
            self.valueSelectionSetting = output.valueSelectionSetting
        } else {
            self.botId = nil
            self.botVersion = nil
            self.creationDateTime = nil
            self.description = nil
            self.lastUpdatedDateTime = nil
            self.localeId = nil
            self.parentSlotTypeSignature = nil
            self.slotTypeId = nil
            self.slotTypeName = nil
            self.slotTypeValues = nil
            self.valueSelectionSetting = nil
        }
    }
}

public struct DescribeSlotTypeOutputResponse: Equatable {
    /// <p>The identifier of the bot associated with the slot type.</p>
    public let botId: String?
    /// <p>The version of the bot associated with the slot type.</p>
    public let botVersion: String?
    /// <p>A timestamp of the date and time that the slot type was
    ///          created.</p>
    public let creationDateTime: Date?
    /// <p>The description specified for the slot type.</p>
    public let description: String?
    /// <p>A timestamp of the date and time that the slot type was last
    ///          updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The language and locale specified for the slot type.</p>
    public let localeId: String?
    /// <p>The built in slot type used as a parent to this slot type.</p>
    public let parentSlotTypeSignature: String?
    /// <p>The unique identifier for the slot type.</p>
    public let slotTypeId: String?
    /// <p>The name specified for the slot type.</p>
    public let slotTypeName: String?
    /// <p>The values that the slot type can take. Includes any synonyms for
    ///          the slot type values.</p>
    public let slotTypeValues: [SlotTypeValue]?
    /// <p>The strategy that Amazon Lex uses to choose a value from a list of
    ///          possible values.</p>
    public let valueSelectionSetting: SlotValueSelectionSetting?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        creationDateTime: Date? = nil,
        description: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        localeId: String? = nil,
        parentSlotTypeSignature: String? = nil,
        slotTypeId: String? = nil,
        slotTypeName: String? = nil,
        slotTypeValues: [SlotTypeValue]? = nil,
        valueSelectionSetting: SlotValueSelectionSetting? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.creationDateTime = creationDateTime
        self.description = description
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.localeId = localeId
        self.parentSlotTypeSignature = parentSlotTypeSignature
        self.slotTypeId = slotTypeId
        self.slotTypeName = slotTypeName
        self.slotTypeValues = slotTypeValues
        self.valueSelectionSetting = valueSelectionSetting
    }
}

struct DescribeSlotTypeOutputResponseBody: Equatable {
    public let slotTypeId: String?
    public let slotTypeName: String?
    public let description: String?
    public let slotTypeValues: [SlotTypeValue]?
    public let valueSelectionSetting: SlotValueSelectionSetting?
    public let parentSlotTypeSignature: String?
    public let botId: String?
    public let botVersion: String?
    public let localeId: String?
    public let creationDateTime: Date?
    public let lastUpdatedDateTime: Date?
}

extension DescribeSlotTypeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botId
        case botVersion
        case creationDateTime
        case description
        case lastUpdatedDateTime
        case localeId
        case parentSlotTypeSignature
        case slotTypeId
        case slotTypeName
        case slotTypeValues
        case valueSelectionSetting
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotTypeId)
        slotTypeId = slotTypeIdDecoded
        let slotTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotTypeName)
        slotTypeName = slotTypeNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let slotTypeValuesContainer = try containerValues.decodeIfPresent([SlotTypeValue?].self, forKey: .slotTypeValues)
        var slotTypeValuesDecoded0:[SlotTypeValue]? = nil
        if let slotTypeValuesContainer = slotTypeValuesContainer {
            slotTypeValuesDecoded0 = [SlotTypeValue]()
            for structure0 in slotTypeValuesContainer {
                if let structure0 = structure0 {
                    slotTypeValuesDecoded0?.append(structure0)
                }
            }
        }
        slotTypeValues = slotTypeValuesDecoded0
        let valueSelectionSettingDecoded = try containerValues.decodeIfPresent(SlotValueSelectionSetting.self, forKey: .valueSelectionSetting)
        valueSelectionSetting = valueSelectionSettingDecoded
        let parentSlotTypeSignatureDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentSlotTypeSignature)
        parentSlotTypeSignature = parentSlotTypeSignatureDecoded
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension DialogCodeHookSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension DialogCodeHookSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DialogCodeHookSettings(enabled: \(String(describing: enabled)))"}
}

/// <p>Settings that determine the Lambda function that Amazon Lex uses for
///          processing user responses.</p>
public struct DialogCodeHookSettings: Equatable {
    /// <p>Enables the dialog code hook so that it processes user
    ///          requests.</p>
    public let enabled: Bool

    public init (
        enabled: Bool = false
    )
    {
        self.enabled = enabled
    }
}

public enum Effect {
    case allow
    case deny
    case sdkUnknown(String)
}

extension Effect : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Effect] {
        return [
            .allow,
            .deny,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .allow: return "Allow"
        case .deny: return "Deny"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Effect(rawValue: rawValue) ?? Effect.sdkUnknown(rawValue)
    }
}

extension ExportFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ExportFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(ExportFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension ExportFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportFilter(name: \(String(describing: name)), operator: \(String(describing: `operator`)), values: \(String(describing: values)))"}
}

/// <p>Filtes the response form the
///          operation</p>
public struct ExportFilter: Equatable {
    /// <p>The operator to use for the filter. Specify EQ when the
    ///             <code>ListExports</code> operation should return only resource types
    ///          that equal the specified value. Specify CO when the
    ///             <code>ListExports</code> operation should return resource types that
    ///          contain the specified value.</p>
    public let `operator`: ExportFilterOperator?
    /// <p>The name of the field to use for filtering.</p>
    public let name: ExportFilterName?
    /// <p>The values to use to fileter the response.</p>
    public let values: [String]?

    public init (
        `operator`: ExportFilterOperator? = nil,
        name: ExportFilterName? = nil,
        values: [String]? = nil
    )
    {
        self.`operator` = `operator`
        self.name = name
        self.values = values
    }
}

public enum ExportFilterName {
    case exportresourcetype
    case sdkUnknown(String)
}

extension ExportFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExportFilterName] {
        return [
            .exportresourcetype,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .exportresourcetype: return "ExportResourceType"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExportFilterName(rawValue: rawValue) ?? ExportFilterName.sdkUnknown(rawValue)
    }
}

public enum ExportFilterOperator {
    case contains
    case equals
    case sdkUnknown(String)
}

extension ExportFilterOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExportFilterOperator] {
        return [
            .contains,
            .equals,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .contains: return "CO"
        case .equals: return "EQ"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExportFilterOperator(rawValue: rawValue) ?? ExportFilterOperator.sdkUnknown(rawValue)
    }
}

extension ExportResourceSpecification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case botExportSpecification
        case botLocaleExportSpecification
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botExportSpecification = botExportSpecification {
            try encodeContainer.encode(botExportSpecification, forKey: .botExportSpecification)
        }
        if let botLocaleExportSpecification = botLocaleExportSpecification {
            try encodeContainer.encode(botLocaleExportSpecification, forKey: .botLocaleExportSpecification)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botExportSpecificationDecoded = try containerValues.decodeIfPresent(BotExportSpecification.self, forKey: .botExportSpecification)
        botExportSpecification = botExportSpecificationDecoded
        let botLocaleExportSpecificationDecoded = try containerValues.decodeIfPresent(BotLocaleExportSpecification.self, forKey: .botLocaleExportSpecification)
        botLocaleExportSpecification = botLocaleExportSpecificationDecoded
    }
}

extension ExportResourceSpecification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportResourceSpecification(botExportSpecification: \(String(describing: botExportSpecification)), botLocaleExportSpecification: \(String(describing: botLocaleExportSpecification)))"}
}

/// <p>Provides information about the bot or bot locale that you want to
///          export. You can specify the <code>botExportSpecification</code> or the
///             <code>botLocaleExportSpecification</code>, but not both.</p>
public struct ExportResourceSpecification: Equatable {
    /// <p>Parameters for exporting a bot.</p>
    public let botExportSpecification: BotExportSpecification?
    /// <p>Parameters for exporting a bot locale.</p>
    public let botLocaleExportSpecification: BotLocaleExportSpecification?

    public init (
        botExportSpecification: BotExportSpecification? = nil,
        botLocaleExportSpecification: BotLocaleExportSpecification? = nil
    )
    {
        self.botExportSpecification = botExportSpecification
        self.botLocaleExportSpecification = botLocaleExportSpecification
    }
}

public enum ExportSortAttribute {
    case lastupdateddatetime
    case sdkUnknown(String)
}

extension ExportSortAttribute : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExportSortAttribute] {
        return [
            .lastupdateddatetime,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .lastupdateddatetime: return "LastUpdatedDateTime"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExportSortAttribute(rawValue: rawValue) ?? ExportSortAttribute.sdkUnknown(rawValue)
    }
}

extension ExportSortBy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attribute
        case order
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let order = order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(ExportSortAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let orderDecoded = try containerValues.decodeIfPresent(SortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension ExportSortBy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportSortBy(attribute: \(String(describing: attribute)), order: \(String(describing: order)))"}
}

/// <p>Provides information about sorting a list of exports.</p>
public struct ExportSortBy: Equatable {
    /// <p>The export field to use for sorting.</p>
    public let attribute: ExportSortAttribute?
    /// <p>The order to sort the list.</p>
    public let order: SortOrder?

    public init (
        attribute: ExportSortAttribute? = nil,
        order: SortOrder? = nil
    )
    {
        self.attribute = attribute
        self.order = order
    }
}

public enum ExportStatus {
    case completed
    case deleting
    case failed
    case inprogress
    case sdkUnknown(String)
}

extension ExportStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExportStatus] {
        return [
            .completed,
            .deleting,
            .failed,
            .inprogress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "Completed"
        case .deleting: return "Deleting"
        case .failed: return "Failed"
        case .inprogress: return "InProgress"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExportStatus(rawValue: rawValue) ?? ExportStatus.sdkUnknown(rawValue)
    }
}

extension ExportSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDateTime
        case exportId
        case exportStatus
        case fileFormat
        case lastUpdatedDateTime
        case resourceSpecification
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let exportId = exportId {
            try encodeContainer.encode(exportId, forKey: .exportId)
        }
        if let exportStatus = exportStatus {
            try encodeContainer.encode(exportStatus.rawValue, forKey: .exportStatus)
        }
        if let fileFormat = fileFormat {
            try encodeContainer.encode(fileFormat.rawValue, forKey: .fileFormat)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let resourceSpecification = resourceSpecification {
            try encodeContainer.encode(resourceSpecification, forKey: .resourceSpecification)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exportId)
        exportId = exportIdDecoded
        let resourceSpecificationDecoded = try containerValues.decodeIfPresent(ExportResourceSpecification.self, forKey: .resourceSpecification)
        resourceSpecification = resourceSpecificationDecoded
        let fileFormatDecoded = try containerValues.decodeIfPresent(ImportExportFileFormat.self, forKey: .fileFormat)
        fileFormat = fileFormatDecoded
        let exportStatusDecoded = try containerValues.decodeIfPresent(ExportStatus.self, forKey: .exportStatus)
        exportStatus = exportStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension ExportSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportSummary(creationDateTime: \(String(describing: creationDateTime)), exportId: \(String(describing: exportId)), exportStatus: \(String(describing: exportStatus)), fileFormat: \(String(describing: fileFormat)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), resourceSpecification: \(String(describing: resourceSpecification)))"}
}

/// <p>Provides summary information about an export in an export list.
///       </p>
public struct ExportSummary: Equatable {
    /// <p>The date and time that the export was created.</p>
    public let creationDateTime: Date?
    /// <p>The unique identifier that Amazon Lex assigned to the export.</p>
    public let exportId: String?
    /// <p>The status of the export. When the status is <code>Completed</code>
    ///          the export is ready to download.</p>
    public let exportStatus: ExportStatus?
    /// <p>The file format used in the export files.</p>
    public let fileFormat: ImportExportFileFormat?
    /// <p>The date and time that the export was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>Information about the bot or bot locale that was exported.</p>
    public let resourceSpecification: ExportResourceSpecification?

    public init (
        creationDateTime: Date? = nil,
        exportId: String? = nil,
        exportStatus: ExportStatus? = nil,
        fileFormat: ImportExportFileFormat? = nil,
        lastUpdatedDateTime: Date? = nil,
        resourceSpecification: ExportResourceSpecification? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.exportId = exportId
        self.exportStatus = exportStatus
        self.fileFormat = fileFormat
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.resourceSpecification = resourceSpecification
    }
}

extension FulfillmentCodeHookSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension FulfillmentCodeHookSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FulfillmentCodeHookSettings(enabled: \(String(describing: enabled)))"}
}

/// <p>Determines if a Lambda function should be invoked for a specific
///          intent.</p>
public struct FulfillmentCodeHookSettings: Equatable {
    /// <p>Indicates whether a Lambda function should be invoked to fulfill a
    ///          specific intent.</p>
    public let enabled: Bool

    public init (
        enabled: Bool = false
    )
    {
        self.enabled = enabled
    }
}

extension ImageResponseCard: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case buttons
        case imageUrl
        case subtitle
        case title
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let buttons = buttons {
            var buttonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .buttons)
            for buttonslist0 in buttons {
                try buttonsContainer.encode(buttonslist0)
            }
        }
        if let imageUrl = imageUrl {
            try encodeContainer.encode(imageUrl, forKey: .imageUrl)
        }
        if let subtitle = subtitle {
            try encodeContainer.encode(subtitle, forKey: .subtitle)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let subtitleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subtitle)
        subtitle = subtitleDecoded
        let imageUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageUrl)
        imageUrl = imageUrlDecoded
        let buttonsContainer = try containerValues.decodeIfPresent([Button?].self, forKey: .buttons)
        var buttonsDecoded0:[Button]? = nil
        if let buttonsContainer = buttonsContainer {
            buttonsDecoded0 = [Button]()
            for structure0 in buttonsContainer {
                if let structure0 = structure0 {
                    buttonsDecoded0?.append(structure0)
                }
            }
        }
        buttons = buttonsDecoded0
    }
}

extension ImageResponseCard: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageResponseCard(buttons: \(String(describing: buttons)), imageUrl: \(String(describing: imageUrl)), subtitle: \(String(describing: subtitle)), title: \(String(describing: title)))"}
}

/// <p>A card that is shown to the user by a messaging platform. You define
///          the contents of the card, the card is displayed by the platform. </p>
///          <p>When you use a response card, the response from the user is
///          constrained to the text associated with a button on the card.</p>
public struct ImageResponseCard: Equatable {
    /// <p>A list of buttons that should be displayed on the response card. The
    ///          arrangement of the buttons is determined by the platform that displays
    ///          the button.</p>
    public let buttons: [Button]?
    /// <p>The URL of an image to display on the response card. The image URL
    ///          must be publicly available so that the platform displaying the response
    ///          card has access to the image.</p>
    public let imageUrl: String?
    /// <p>The subtitle to display on the response card. The format of the
    ///          subtitle is determined by the platform displaying the response
    ///          card.</p>
    public let subtitle: String?
    /// <p>The title to display on the response card. The format of the title
    ///          is determined by the platform displaying the response card.</p>
    public let title: String?

    public init (
        buttons: [Button]? = nil,
        imageUrl: String? = nil,
        subtitle: String? = nil,
        title: String? = nil
    )
    {
        self.buttons = buttons
        self.imageUrl = imageUrl
        self.subtitle = subtitle
        self.title = title
    }
}

public enum ImportExportFileFormat {
    case lexjson
    case sdkUnknown(String)
}

extension ImportExportFileFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ImportExportFileFormat] {
        return [
            .lexjson,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .lexjson: return "LexJson"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ImportExportFileFormat(rawValue: rawValue) ?? ImportExportFileFormat.sdkUnknown(rawValue)
    }
}

extension ImportFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ImportFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(ImportFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension ImportFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportFilter(name: \(String(describing: name)), operator: \(String(describing: `operator`)), values: \(String(describing: values)))"}
}

/// <p>Filters the response from the
///          operation.</p>
public struct ImportFilter: Equatable {
    /// <p>The operator to use for the filter. Specify EQ when the
    ///             <code>ListImports</code> operation should return only resource types
    ///          that equal the specified value. Specify CO when the
    ///             <code>ListImports</code> operation should return resource types that
    ///          contain the specified value.</p>
    public let `operator`: ImportFilterOperator?
    /// <p>The name of the field to use for filtering.</p>
    public let name: ImportFilterName?
    /// <p>The values to use to filter the response.</p>
    public let values: [String]?

    public init (
        `operator`: ImportFilterOperator? = nil,
        name: ImportFilterName? = nil,
        values: [String]? = nil
    )
    {
        self.`operator` = `operator`
        self.name = name
        self.values = values
    }
}

public enum ImportFilterName {
    case importresourcetype
    case sdkUnknown(String)
}

extension ImportFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ImportFilterName] {
        return [
            .importresourcetype,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .importresourcetype: return "ImportResourceType"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ImportFilterName(rawValue: rawValue) ?? ImportFilterName.sdkUnknown(rawValue)
    }
}

public enum ImportFilterOperator {
    case contains
    case equals
    case sdkUnknown(String)
}

extension ImportFilterOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ImportFilterOperator] {
        return [
            .contains,
            .equals,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .contains: return "CO"
        case .equals: return "EQ"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ImportFilterOperator(rawValue: rawValue) ?? ImportFilterOperator.sdkUnknown(rawValue)
    }
}

extension ImportResourceSpecification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case botImportSpecification
        case botLocaleImportSpecification
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botImportSpecification = botImportSpecification {
            try encodeContainer.encode(botImportSpecification, forKey: .botImportSpecification)
        }
        if let botLocaleImportSpecification = botLocaleImportSpecification {
            try encodeContainer.encode(botLocaleImportSpecification, forKey: .botLocaleImportSpecification)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botImportSpecificationDecoded = try containerValues.decodeIfPresent(BotImportSpecification.self, forKey: .botImportSpecification)
        botImportSpecification = botImportSpecificationDecoded
        let botLocaleImportSpecificationDecoded = try containerValues.decodeIfPresent(BotLocaleImportSpecification.self, forKey: .botLocaleImportSpecification)
        botLocaleImportSpecification = botLocaleImportSpecificationDecoded
    }
}

extension ImportResourceSpecification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportResourceSpecification(botImportSpecification: \(String(describing: botImportSpecification)), botLocaleImportSpecification: \(String(describing: botLocaleImportSpecification)))"}
}

/// <p>Provides information about the bot or bot locale that you want to
///          import. You can sepcifiy the <code>botImportSpecification</code> or the
///             <code>botLocaleImportSpecification</code>, but not both.</p>
public struct ImportResourceSpecification: Equatable {
    /// <p>Parameters for importing a bot.</p>
    public let botImportSpecification: BotImportSpecification?
    /// <p>Parameters for importing a bot locale.</p>
    public let botLocaleImportSpecification: BotLocaleImportSpecification?

    public init (
        botImportSpecification: BotImportSpecification? = nil,
        botLocaleImportSpecification: BotLocaleImportSpecification? = nil
    )
    {
        self.botImportSpecification = botImportSpecification
        self.botLocaleImportSpecification = botLocaleImportSpecification
    }
}

public enum ImportSortAttribute {
    case lastupdateddatetime
    case sdkUnknown(String)
}

extension ImportSortAttribute : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ImportSortAttribute] {
        return [
            .lastupdateddatetime,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .lastupdateddatetime: return "LastUpdatedDateTime"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ImportSortAttribute(rawValue: rawValue) ?? ImportSortAttribute.sdkUnknown(rawValue)
    }
}

extension ImportSortBy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attribute
        case order
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let order = order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(ImportSortAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let orderDecoded = try containerValues.decodeIfPresent(SortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension ImportSortBy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportSortBy(attribute: \(String(describing: attribute)), order: \(String(describing: order)))"}
}

/// <p>Provides information for sorting a list of imports.</p>
public struct ImportSortBy: Equatable {
    /// <p>The export field to use for sorting.</p>
    public let attribute: ImportSortAttribute?
    /// <p>The order to sort the list.</p>
    public let order: SortOrder?

    public init (
        attribute: ImportSortAttribute? = nil,
        order: SortOrder? = nil
    )
    {
        self.attribute = attribute
        self.order = order
    }
}

public enum ImportStatus {
    case completed
    case deleting
    case failed
    case inprogress
    case sdkUnknown(String)
}

extension ImportStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ImportStatus] {
        return [
            .completed,
            .deleting,
            .failed,
            .inprogress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "Completed"
        case .deleting: return "Deleting"
        case .failed: return "Failed"
        case .inprogress: return "InProgress"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ImportStatus(rawValue: rawValue) ?? ImportStatus.sdkUnknown(rawValue)
    }
}

extension ImportSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDateTime
        case importId
        case importStatus
        case importedResourceId
        case importedResourceName
        case lastUpdatedDateTime
        case mergeStrategy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let importId = importId {
            try encodeContainer.encode(importId, forKey: .importId)
        }
        if let importStatus = importStatus {
            try encodeContainer.encode(importStatus.rawValue, forKey: .importStatus)
        }
        if let importedResourceId = importedResourceId {
            try encodeContainer.encode(importedResourceId, forKey: .importedResourceId)
        }
        if let importedResourceName = importedResourceName {
            try encodeContainer.encode(importedResourceName, forKey: .importedResourceName)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let mergeStrategy = mergeStrategy {
            try encodeContainer.encode(mergeStrategy.rawValue, forKey: .mergeStrategy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .importId)
        importId = importIdDecoded
        let importedResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .importedResourceId)
        importedResourceId = importedResourceIdDecoded
        let importedResourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .importedResourceName)
        importedResourceName = importedResourceNameDecoded
        let importStatusDecoded = try containerValues.decodeIfPresent(ImportStatus.self, forKey: .importStatus)
        importStatus = importStatusDecoded
        let mergeStrategyDecoded = try containerValues.decodeIfPresent(MergeStrategy.self, forKey: .mergeStrategy)
        mergeStrategy = mergeStrategyDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension ImportSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportSummary(creationDateTime: \(String(describing: creationDateTime)), importId: \(String(describing: importId)), importStatus: \(String(describing: importStatus)), importedResourceId: \(String(describing: importedResourceId)), importedResourceName: \(String(describing: importedResourceName)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), mergeStrategy: \(String(describing: mergeStrategy)))"}
}

/// <p>Provides summary information about an import in an import
///          list.</p>
public struct ImportSummary: Equatable {
    /// <p>The date and time that the import was created.</p>
    public let creationDateTime: Date?
    /// <p>The unique identifier that Amazon Lex assigned to the import.</p>
    public let importId: String?
    /// <p>The status of the resource. When the status is
    ///             <code>Completed</code> the resource is ready to build.</p>
    public let importStatus: ImportStatus?
    /// <p>The unique identifier that Amazon Lex assigned to the imported
    ///          resource.</p>
    public let importedResourceId: String?
    /// <p>The name that you gave the imported resource.</p>
    public let importedResourceName: String?
    /// <p>The date and time that the import was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The strategy used to merge existing bot or bot locale definitions
    ///          with the imported definition.</p>
    public let mergeStrategy: MergeStrategy?

    public init (
        creationDateTime: Date? = nil,
        importId: String? = nil,
        importStatus: ImportStatus? = nil,
        importedResourceId: String? = nil,
        importedResourceName: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        mergeStrategy: MergeStrategy? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.importId = importId
        self.importStatus = importStatus
        self.importedResourceId = importedResourceId
        self.importedResourceName = importedResourceName
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.mergeStrategy = mergeStrategy
    }
}

extension InputContext: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension InputContext: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputContext(name: \(String(describing: name)))"}
}

/// <p>The name of a context that must be active for an intent to be
///          selected by Amazon Lex.</p>
public struct InputContext: Equatable {
    /// <p>The name of the context.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

extension IntentClosingSetting: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case closingResponse
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let closingResponse = closingResponse {
            try encodeContainer.encode(closingResponse, forKey: .closingResponse)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let closingResponseDecoded = try containerValues.decodeIfPresent(ResponseSpecification.self, forKey: .closingResponse)
        closingResponse = closingResponseDecoded
    }
}

extension IntentClosingSetting: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IntentClosingSetting(closingResponse: \(String(describing: closingResponse)))"}
}

/// <p>Provides a statement the Amazon Lex conveys to the user when the intent
///          is successfully fulfilled.</p>
public struct IntentClosingSetting: Equatable {
    /// <p>The response that Amazon Lex sends to the user when the intent is
    ///          complete.</p>
    public let closingResponse: ResponseSpecification?

    public init (
        closingResponse: ResponseSpecification? = nil
    )
    {
        self.closingResponse = closingResponse
    }
}

extension IntentConfirmationSetting: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case declinationResponse
        case promptSpecification
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let declinationResponse = declinationResponse {
            try encodeContainer.encode(declinationResponse, forKey: .declinationResponse)
        }
        if let promptSpecification = promptSpecification {
            try encodeContainer.encode(promptSpecification, forKey: .promptSpecification)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let promptSpecificationDecoded = try containerValues.decodeIfPresent(PromptSpecification.self, forKey: .promptSpecification)
        promptSpecification = promptSpecificationDecoded
        let declinationResponseDecoded = try containerValues.decodeIfPresent(ResponseSpecification.self, forKey: .declinationResponse)
        declinationResponse = declinationResponseDecoded
    }
}

extension IntentConfirmationSetting: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IntentConfirmationSetting(declinationResponse: \(String(describing: declinationResponse)), promptSpecification: \(String(describing: promptSpecification)))"}
}

/// <p>Provides a prompt for making sure that the user is ready for the
///          intent to be fulfilled.</p>
public struct IntentConfirmationSetting: Equatable {
    /// <p>When the user answers "no" to the question defined in
    ///             <code>promptSpecification</code>, Amazon Lex responds with this response
    ///          to acknowledge that the intent was canceled. </p>
    public let declinationResponse: ResponseSpecification?
    /// <p>Prompts the user to confirm the intent. This question should have a
    ///          yes or no answer.</p>
    ///          <p>Amazon Lex uses this prompt to ensure that the user acknowledges that the
    ///          intent is ready for fulfillment. For example, with the
    ///             <code>OrderPizza</code> intent, you might want to confirm that the
    ///          order is correct before placing it. For other intents, such as intents
    ///          that simply respond to user questions, you might not need to ask the
    ///          user for confirmation before providing the information. </p>
    public let promptSpecification: PromptSpecification?

    public init (
        declinationResponse: ResponseSpecification? = nil,
        promptSpecification: PromptSpecification? = nil
    )
    {
        self.declinationResponse = declinationResponse
        self.promptSpecification = promptSpecification
    }
}

extension IntentFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(IntentFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(IntentFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension IntentFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IntentFilter(name: \(String(describing: name)), operator: \(String(describing: `operator`)), values: \(String(describing: values)))"}
}

/// <p>Filters the response from the <code>ListIntents</code>
///          operation.</p>
public struct IntentFilter: Equatable {
    /// <p>The operator to use for the filter. Specify <code>EQ</code> when the
    ///             <code>ListIntents</code> operation should return only aliases that
    ///          equal the specified value. Specify <code>CO</code> when the
    ///             <code>ListIntents</code> operation should return aliases that
    ///          contain the specified value.</p>
    public let `operator`: IntentFilterOperator?
    /// <p>The name of the field to use for the filter.</p>
    public let name: IntentFilterName?
    /// <p>The value to use for the filter.</p>
    public let values: [String]?

    public init (
        `operator`: IntentFilterOperator? = nil,
        name: IntentFilterName? = nil,
        values: [String]? = nil
    )
    {
        self.`operator` = `operator`
        self.name = name
        self.values = values
    }
}

public enum IntentFilterName {
    case intentname
    case sdkUnknown(String)
}

extension IntentFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IntentFilterName] {
        return [
            .intentname,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .intentname: return "IntentName"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IntentFilterName(rawValue: rawValue) ?? IntentFilterName.sdkUnknown(rawValue)
    }
}

public enum IntentFilterOperator {
    case contains
    case equals
    case sdkUnknown(String)
}

extension IntentFilterOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IntentFilterOperator] {
        return [
            .contains,
            .equals,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .contains: return "CO"
        case .equals: return "EQ"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IntentFilterOperator(rawValue: rawValue) ?? IntentFilterOperator.sdkUnknown(rawValue)
    }
}

public enum IntentSortAttribute {
    case intentname
    case lastupdateddatetime
    case sdkUnknown(String)
}

extension IntentSortAttribute : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IntentSortAttribute] {
        return [
            .intentname,
            .lastupdateddatetime,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .intentname: return "IntentName"
        case .lastupdateddatetime: return "LastUpdatedDateTime"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IntentSortAttribute(rawValue: rawValue) ?? IntentSortAttribute.sdkUnknown(rawValue)
    }
}

extension IntentSortBy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attribute
        case order
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let order = order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(IntentSortAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let orderDecoded = try containerValues.decodeIfPresent(SortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension IntentSortBy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IntentSortBy(attribute: \(String(describing: attribute)), order: \(String(describing: order)))"}
}

/// <p>Specifies attributes for sorting a list of intents.</p>
public struct IntentSortBy: Equatable {
    /// <p>The attribute to use to sort the list of intents.</p>
    public let attribute: IntentSortAttribute?
    /// <p>The order to sort the list. You can choose ascending or
    ///          descending.</p>
    public let order: SortOrder?

    public init (
        attribute: IntentSortAttribute? = nil,
        order: SortOrder? = nil
    )
    {
        self.attribute = attribute
        self.order = order
    }
}

extension IntentSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case inputContexts
        case intentId
        case intentName
        case lastUpdatedDateTime
        case outputContexts
        case parentIntentSignature
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let inputContexts = inputContexts {
            var inputContextsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputContexts)
            for inputcontextslist0 in inputContexts {
                try inputContextsContainer.encode(inputcontextslist0)
            }
        }
        if let intentId = intentId {
            try encodeContainer.encode(intentId, forKey: .intentId)
        }
        if let intentName = intentName {
            try encodeContainer.encode(intentName, forKey: .intentName)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let outputContexts = outputContexts {
            var outputContextsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputContexts)
            for outputcontextslist0 in outputContexts {
                try outputContextsContainer.encode(outputcontextslist0)
            }
        }
        if let parentIntentSignature = parentIntentSignature {
            try encodeContainer.encode(parentIntentSignature, forKey: .parentIntentSignature)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .intentId)
        intentId = intentIdDecoded
        let intentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .intentName)
        intentName = intentNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let parentIntentSignatureDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentIntentSignature)
        parentIntentSignature = parentIntentSignatureDecoded
        let inputContextsContainer = try containerValues.decodeIfPresent([InputContext?].self, forKey: .inputContexts)
        var inputContextsDecoded0:[InputContext]? = nil
        if let inputContextsContainer = inputContextsContainer {
            inputContextsDecoded0 = [InputContext]()
            for structure0 in inputContextsContainer {
                if let structure0 = structure0 {
                    inputContextsDecoded0?.append(structure0)
                }
            }
        }
        inputContexts = inputContextsDecoded0
        let outputContextsContainer = try containerValues.decodeIfPresent([OutputContext?].self, forKey: .outputContexts)
        var outputContextsDecoded0:[OutputContext]? = nil
        if let outputContextsContainer = outputContextsContainer {
            outputContextsDecoded0 = [OutputContext]()
            for structure0 in outputContextsContainer {
                if let structure0 = structure0 {
                    outputContextsDecoded0?.append(structure0)
                }
            }
        }
        outputContexts = outputContextsDecoded0
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension IntentSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IntentSummary(description: \(String(describing: description)), inputContexts: \(String(describing: inputContexts)), intentId: \(String(describing: intentId)), intentName: \(String(describing: intentName)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), outputContexts: \(String(describing: outputContexts)), parentIntentSignature: \(String(describing: parentIntentSignature)))"}
}

/// <p>Summary information about an intent returned by the
///             <code>ListIntents</code> operation.</p>
public struct IntentSummary: Equatable {
    /// <p>The description of the intent.</p>
    public let description: String?
    /// <p>The input contexts that must be active for this intent to be
    ///          considered for recognition.</p>
    public let inputContexts: [InputContext]?
    /// <p>The unique identifier assigned to the intent. Use this ID to get
    ///          detailed information about the intent with the
    ///             <code>DescribeIntent</code> operation.</p>
    public let intentId: String?
    /// <p>The name of the intent.</p>
    public let intentName: String?
    /// <p>The timestamp of the date and time that the intent was last
    ///          updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The output contexts that are activated when this intent is
    ///          fulfilled.</p>
    public let outputContexts: [OutputContext]?
    /// <p>If this intent is derived from a built-in intent, the name of the
    ///          parent intent.</p>
    public let parentIntentSignature: String?

    public init (
        description: String? = nil,
        inputContexts: [InputContext]? = nil,
        intentId: String? = nil,
        intentName: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        outputContexts: [OutputContext]? = nil,
        parentIntentSignature: String? = nil
    )
    {
        self.description = description
        self.inputContexts = inputContexts
        self.intentId = intentId
        self.intentName = intentName
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.outputContexts = outputContexts
        self.parentIntentSignature = parentIntentSignature
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KendraConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case kendraIndex
        case queryFilterString
        case queryFilterStringEnabled
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kendraIndex = kendraIndex {
            try encodeContainer.encode(kendraIndex, forKey: .kendraIndex)
        }
        if let queryFilterString = queryFilterString {
            try encodeContainer.encode(queryFilterString, forKey: .queryFilterString)
        }
        if queryFilterStringEnabled != false {
            try encodeContainer.encode(queryFilterStringEnabled, forKey: .queryFilterStringEnabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kendraIndexDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kendraIndex)
        kendraIndex = kendraIndexDecoded
        let queryFilterStringEnabledDecoded = try containerValues.decode(Bool.self, forKey: .queryFilterStringEnabled)
        queryFilterStringEnabled = queryFilterStringEnabledDecoded
        let queryFilterStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryFilterString)
        queryFilterString = queryFilterStringDecoded
    }
}

extension KendraConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KendraConfiguration(kendraIndex: \(String(describing: kendraIndex)), queryFilterString: \(String(describing: queryFilterString)), queryFilterStringEnabled: \(String(describing: queryFilterStringEnabled)))"}
}

/// <p>Provides configuration information for the AMAZON.KendraSearchIntent
///          intent. When you use this intent, Amazon Lex searches the specified Amazon Kendra
///          index and returns documents from the index that match the user's
///          utterance.</p>
public struct KendraConfiguration: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Amazon Kendra index that you want the
    ///          AMAZON.KendraSearchIntent intent to search. The index must be in the
    ///          same account and Region as the Amazon Lex bot.</p>
    public let kendraIndex: String?
    /// <p>A query filter that Amazon Lex sends to Amazon Kendra to filter the response from
    ///          a query. The filter is in the format defined by Amazon Kendra. For more
    ///          information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/filtering.html">Filtering
    ///          queries</a>.</p>
    public let queryFilterString: String?
    /// <p>Determines whether the AMAZON.KendraSearchIntent intent uses a
    ///          custom query string to query the Amazon Kendra index.</p>
    public let queryFilterStringEnabled: Bool

    public init (
        kendraIndex: String? = nil,
        queryFilterString: String? = nil,
        queryFilterStringEnabled: Bool = false
    )
    {
        self.kendraIndex = kendraIndex
        self.queryFilterString = queryFilterString
        self.queryFilterStringEnabled = queryFilterStringEnabled
    }
}

extension LambdaCodeHook: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case codeHookInterfaceVersion
        case lambdaARN
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeHookInterfaceVersion = codeHookInterfaceVersion {
            try encodeContainer.encode(codeHookInterfaceVersion, forKey: .codeHookInterfaceVersion)
        }
        if let lambdaARN = lambdaARN {
            try encodeContainer.encode(lambdaARN, forKey: .lambdaARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lambdaARN)
        lambdaARN = lambdaARNDecoded
        let codeHookInterfaceVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .codeHookInterfaceVersion)
        codeHookInterfaceVersion = codeHookInterfaceVersionDecoded
    }
}

extension LambdaCodeHook: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaCodeHook(codeHookInterfaceVersion: \(String(describing: codeHookInterfaceVersion)), lambdaARN: \(String(describing: lambdaARN)))"}
}

/// <p>Specifies a Lambda function that verifies requests to a bot or
///          fulfilles the user's request to a bot.</p>
public struct LambdaCodeHook: Equatable {
    /// <p>The version of the request-response that you want Amazon Lex to use to
    ///          invoke your Lambda function.</p>
    public let codeHookInterfaceVersion: String?
    /// <p>The Amazon Resource Name (ARN) of the Lambda function.</p>
    public let lambdaARN: String?

    public init (
        codeHookInterfaceVersion: String? = nil,
        lambdaARN: String? = nil
    )
    {
        self.codeHookInterfaceVersion = codeHookInterfaceVersion
        self.lambdaARN = lambdaARN
    }
}

public struct ListBotAliasesInputBodyMiddleware: Middleware {
    public let id: String = "ListBotAliasesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBotAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBotAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBotAliasesInput>
    public typealias MOutput = OperationOutput<ListBotAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBotAliasesOutputError>
}

extension ListBotAliasesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBotAliasesInput(botId: \(String(describing: botId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBotAliasesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListBotAliasesInputHeadersMiddleware: Middleware {
    public let id: String = "ListBotAliasesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBotAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBotAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBotAliasesInput>
    public typealias MOutput = OperationOutput<ListBotAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBotAliasesOutputError>
}

public struct ListBotAliasesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBotAliasesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBotAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBotAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBotAliasesInput>
    public typealias MOutput = OperationOutput<ListBotAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBotAliasesOutputError>
}

public struct ListBotAliasesInput: Equatable {
    /// <p>The identifier of the bot to list aliases for.</p>
    public let botId: String?
    /// <p>The maximum number of aliases to return in each page of results. If
    ///          there are fewer results than the max page size, only the actual number
    ///          of results are returned.</p>
    public let maxResults: Int?
    /// <p>If the response from the <code>ListBotAliases</code> operation
    ///          contains more results than specified in the <code>maxResults</code>
    ///          parameter, a token is returned in the response. Use that token in the
    ///             <code>nextToken</code> parameter to return the next page of
    ///          results.</p>
    public let nextToken: String?

    public init (
        botId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.botId = botId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBotAliasesInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListBotAliasesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBotAliasesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBotAliasesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBotAliasesOutputError: Equatable {
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBotAliasesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBotAliasesOutputResponse(botAliasSummaries: \(String(describing: botAliasSummaries)), botId: \(String(describing: botId)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBotAliasesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBotAliasesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botAliasSummaries = output.botAliasSummaries
            self.botId = output.botId
            self.nextToken = output.nextToken
        } else {
            self.botAliasSummaries = nil
            self.botId = nil
            self.nextToken = nil
        }
    }
}

public struct ListBotAliasesOutputResponse: Equatable {
    /// <p>Summary information for the bot aliases that meet the filter
    ///          criteria specified in the request. The length of the list is specified
    ///          in the <code>maxResults</code> parameter of the request. If there are
    ///          more aliases available, the <code>nextToken</code> field contains a
    ///          token to get the next page of results.</p>
    public let botAliasSummaries: [BotAliasSummary]?
    /// <p>The identifier of the bot associated with the aliases.</p>
    public let botId: String?
    /// <p>A token that indicates whether there are more results to return in a
    ///          response to the <code>ListBotAliases</code> operation. If the
    ///             <code>nextToken</code> field is present, you send the contents as
    ///          the <code>nextToken</code> parameter of a <code>ListBotAliases</code>
    ///          operation request to get the next page of results.</p>
    public let nextToken: String?

    public init (
        botAliasSummaries: [BotAliasSummary]? = nil,
        botId: String? = nil,
        nextToken: String? = nil
    )
    {
        self.botAliasSummaries = botAliasSummaries
        self.botId = botId
        self.nextToken = nextToken
    }
}

struct ListBotAliasesOutputResponseBody: Equatable {
    public let botAliasSummaries: [BotAliasSummary]?
    public let nextToken: String?
    public let botId: String?
}

extension ListBotAliasesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botAliasSummaries
        case botId
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botAliasSummariesContainer = try containerValues.decodeIfPresent([BotAliasSummary?].self, forKey: .botAliasSummaries)
        var botAliasSummariesDecoded0:[BotAliasSummary]? = nil
        if let botAliasSummariesContainer = botAliasSummariesContainer {
            botAliasSummariesDecoded0 = [BotAliasSummary]()
            for structure0 in botAliasSummariesContainer {
                if let structure0 = structure0 {
                    botAliasSummariesDecoded0?.append(structure0)
                }
            }
        }
        botAliasSummaries = botAliasSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
    }
}

public struct ListBotLocalesInputBodyMiddleware: Middleware {
    public let id: String = "ListBotLocalesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBotLocalesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBotLocalesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBotLocalesInput>
    public typealias MOutput = OperationOutput<ListBotLocalesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBotLocalesOutputError>
}

extension ListBotLocalesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBotLocalesInput(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortBy: \(String(describing: sortBy)))"}
}

extension ListBotLocalesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
        case sortBy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for botlocalefilters0 in filters {
                try filtersContainer.encode(botlocalefilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
    }
}

public struct ListBotLocalesInputHeadersMiddleware: Middleware {
    public let id: String = "ListBotLocalesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBotLocalesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBotLocalesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBotLocalesInput>
    public typealias MOutput = OperationOutput<ListBotLocalesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBotLocalesOutputError>
}

public struct ListBotLocalesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBotLocalesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBotLocalesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBotLocalesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBotLocalesInput>
    public typealias MOutput = OperationOutput<ListBotLocalesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBotLocalesOutputError>
}

public struct ListBotLocalesInput: Equatable {
    /// <p>The identifier of the bot to list locales for.</p>
    public let botId: String?
    /// <p>The version of the bot to list locales for.</p>
    public let botVersion: String?
    /// <p>Provides the specification for a filter used to limit the response
    ///          to only those locales that match the filter specification. You can only
    ///          specify one filter and one value to filter on.</p>
    public let filters: [BotLocaleFilter]?
    /// <p>The maximum number of aliases to return in each page of results. If
    ///          there are fewer results than the max page size, only the actual number
    ///          of results are returned.</p>
    public let maxResults: Int?
    /// <p>If the response from the <code>ListBotLocales</code> operation
    ///          contains more results than specified in the <code>maxResults</code>
    ///          parameter, a token is returned in the response. Use that token as the
    ///             <code>nextToken</code> parameter to return the next page of results.
    ///       </p>
    public let nextToken: String?
    /// <p>Specifies sorting parameters for the list of locales. You can sort
    ///          by locale name in ascending or descending order.</p>
    public let sortBy: BotLocaleSortBy?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        filters: [BotLocaleFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: BotLocaleSortBy? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
    }
}

struct ListBotLocalesInputBody: Equatable {
    public let sortBy: BotLocaleSortBy?
    public let filters: [BotLocaleFilter]?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListBotLocalesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
        case sortBy
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(BotLocaleSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let filtersContainer = try containerValues.decodeIfPresent([BotLocaleFilter?].self, forKey: .filters)
        var filtersDecoded0:[BotLocaleFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [BotLocaleFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBotLocalesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBotLocalesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBotLocalesOutputError: Equatable {
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBotLocalesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBotLocalesOutputResponse(botId: \(String(describing: botId)), botLocaleSummaries: \(String(describing: botLocaleSummaries)), botVersion: \(String(describing: botVersion)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBotLocalesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBotLocalesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botId = output.botId
            self.botLocaleSummaries = output.botLocaleSummaries
            self.botVersion = output.botVersion
            self.nextToken = output.nextToken
        } else {
            self.botId = nil
            self.botLocaleSummaries = nil
            self.botVersion = nil
            self.nextToken = nil
        }
    }
}

public struct ListBotLocalesOutputResponse: Equatable {
    /// <p>The identifier of the bot to list locales for.</p>
    public let botId: String?
    /// <p>Summary information for the locales that meet the filter criteria
    ///          specified in the request. The length of the list is specified in the
    ///             <code>maxResults</code> parameter of the request. If there are more
    ///          locales available, the <code>nextToken</code> field contains a token to
    ///          get the next page of results.</p>
    public let botLocaleSummaries: [BotLocaleSummary]?
    /// <p>The version of the bot.</p>
    public let botVersion: String?
    /// <p>A token that indicates whether there are more results to return in a
    ///          response to the <code>ListBotLocales</code> operation. If the
    ///             <code>nextToken</code> field is present, you send the contents as
    ///          the <code>nextToken</code> parameter of a <code>ListBotLocales</code>
    ///          operation request to get the next page of results.</p>
    public let nextToken: String?

    public init (
        botId: String? = nil,
        botLocaleSummaries: [BotLocaleSummary]? = nil,
        botVersion: String? = nil,
        nextToken: String? = nil
    )
    {
        self.botId = botId
        self.botLocaleSummaries = botLocaleSummaries
        self.botVersion = botVersion
        self.nextToken = nextToken
    }
}

struct ListBotLocalesOutputResponseBody: Equatable {
    public let botId: String?
    public let botVersion: String?
    public let nextToken: String?
    public let botLocaleSummaries: [BotLocaleSummary]?
}

extension ListBotLocalesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botId
        case botLocaleSummaries
        case botVersion
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let botLocaleSummariesContainer = try containerValues.decodeIfPresent([BotLocaleSummary?].self, forKey: .botLocaleSummaries)
        var botLocaleSummariesDecoded0:[BotLocaleSummary]? = nil
        if let botLocaleSummariesContainer = botLocaleSummariesContainer {
            botLocaleSummariesDecoded0 = [BotLocaleSummary]()
            for structure0 in botLocaleSummariesContainer {
                if let structure0 = structure0 {
                    botLocaleSummariesDecoded0?.append(structure0)
                }
            }
        }
        botLocaleSummaries = botLocaleSummariesDecoded0
    }
}

public struct ListBotVersionsInputBodyMiddleware: Middleware {
    public let id: String = "ListBotVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBotVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBotVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBotVersionsInput>
    public typealias MOutput = OperationOutput<ListBotVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBotVersionsOutputError>
}

extension ListBotVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBotVersionsInput(botId: \(String(describing: botId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortBy: \(String(describing: sortBy)))"}
}

extension ListBotVersionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case sortBy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
    }
}

public struct ListBotVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListBotVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBotVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBotVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBotVersionsInput>
    public typealias MOutput = OperationOutput<ListBotVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBotVersionsOutputError>
}

public struct ListBotVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBotVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBotVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBotVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBotVersionsInput>
    public typealias MOutput = OperationOutput<ListBotVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBotVersionsOutputError>
}

public struct ListBotVersionsInput: Equatable {
    /// <p>The identifier of the bot to list versions for.</p>
    public let botId: String?
    /// <p>The maximum number of versions to return in each page of results. If
    ///          there are fewer results than the max page size, only the actual number
    ///          of results are returned.</p>
    public let maxResults: Int?
    /// <p>If the response to the <code>ListBotVersion</code> operation
    ///          contains more results than specified in the <code>maxResults</code>
    ///          parameter, a token is returned in the response. Use that token in the
    ///             <code>nextToken</code> parameter to return the next page of
    ///          results.</p>
    public let nextToken: String?
    /// <p>Specifies sorting parameters for the list of versions. You can
    ///          specify that the list be sorted by version name in either ascending or
    ///          descending order.</p>
    public let sortBy: BotVersionSortBy?

    public init (
        botId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: BotVersionSortBy? = nil
    )
    {
        self.botId = botId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
    }
}

struct ListBotVersionsInputBody: Equatable {
    public let sortBy: BotVersionSortBy?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListBotVersionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case sortBy
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(BotVersionSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBotVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBotVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBotVersionsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBotVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBotVersionsOutputResponse(botId: \(String(describing: botId)), botVersionSummaries: \(String(describing: botVersionSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBotVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBotVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botId = output.botId
            self.botVersionSummaries = output.botVersionSummaries
            self.nextToken = output.nextToken
        } else {
            self.botId = nil
            self.botVersionSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListBotVersionsOutputResponse: Equatable {
    /// <p>The identifier of the bot to list versions for.</p>
    public let botId: String?
    /// <p>Summary information for the bot versions that meet the filter
    ///          criteria specified in the request. The length of the list is specified
    ///          in the <code>maxResults</code> parameter of the request. If there are
    ///          more versions available, the <code>nextToken</code> field contains a
    ///          token to get the next page of results.</p>
    public let botVersionSummaries: [BotVersionSummary]?
    /// <p>A token that indicates whether there are more results to return in a
    ///          response to the <code>ListBotVersions</code> operation. If the
    ///             <code>nextToken</code> field is present, you send the contents as
    ///          the <code>nextToken</code> parameter of a <code>ListBotAliases</code>
    ///          operation request to get the next page of results.</p>
    public let nextToken: String?

    public init (
        botId: String? = nil,
        botVersionSummaries: [BotVersionSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.botId = botId
        self.botVersionSummaries = botVersionSummaries
        self.nextToken = nextToken
    }
}

struct ListBotVersionsOutputResponseBody: Equatable {
    public let botId: String?
    public let botVersionSummaries: [BotVersionSummary]?
    public let nextToken: String?
}

extension ListBotVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botId
        case botVersionSummaries
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionSummariesContainer = try containerValues.decodeIfPresent([BotVersionSummary?].self, forKey: .botVersionSummaries)
        var botVersionSummariesDecoded0:[BotVersionSummary]? = nil
        if let botVersionSummariesContainer = botVersionSummariesContainer {
            botVersionSummariesDecoded0 = [BotVersionSummary]()
            for structure0 in botVersionSummariesContainer {
                if let structure0 = structure0 {
                    botVersionSummariesDecoded0?.append(structure0)
                }
            }
        }
        botVersionSummaries = botVersionSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListBotsInputBodyMiddleware: Middleware {
    public let id: String = "ListBotsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBotsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBotsInput>
    public typealias MOutput = OperationOutput<ListBotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBotsOutputError>
}

extension ListBotsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBotsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortBy: \(String(describing: sortBy)))"}
}

extension ListBotsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
        case sortBy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for botfilters0 in filters {
                try filtersContainer.encode(botfilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
    }
}

public struct ListBotsInputHeadersMiddleware: Middleware {
    public let id: String = "ListBotsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBotsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBotsInput>
    public typealias MOutput = OperationOutput<ListBotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBotsOutputError>
}

public struct ListBotsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBotsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBotsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBotsInput>
    public typealias MOutput = OperationOutput<ListBotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBotsOutputError>
}

public struct ListBotsInput: Equatable {
    /// <p>Provides the specification of a filter used to limit the bots in the
    ///          response to only those that match the filter specification. You can
    ///          only specify one filter and one string to filter on.</p>
    public let filters: [BotFilter]?
    /// <p>The maximum number of bots to return in each page of results. If
    ///          there are fewer results than the maximum page size, only the actual
    ///          number of results are returned.</p>
    public let maxResults: Int?
    /// <p>If the response from the <code>ListBots</code> operation contains
    ///          more results than specified in the <code>maxResults</code> parameter, a
    ///          token is returned in the response. Use that token in the
    ///             <code>nextToken</code> parameter to return the next page of
    ///          results.</p>
    public let nextToken: String?
    /// <p>Specifies sorting parameters for the list of bots. You can specify
    ///          that the list be sorted by bot name in ascending or descending
    ///          order.</p>
    public let sortBy: BotSortBy?

    public init (
        filters: [BotFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: BotSortBy? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
    }
}

struct ListBotsInputBody: Equatable {
    public let sortBy: BotSortBy?
    public let filters: [BotFilter]?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListBotsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
        case sortBy
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(BotSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let filtersContainer = try containerValues.decodeIfPresent([BotFilter?].self, forKey: .filters)
        var filtersDecoded0:[BotFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [BotFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBotsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBotsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBotsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBotsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBotsOutputResponse(botSummaries: \(String(describing: botSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBotsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBotsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botSummaries = output.botSummaries
            self.nextToken = output.nextToken
        } else {
            self.botSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListBotsOutputResponse: Equatable {
    /// <p>Summary information for the bots that meet the filter criteria
    ///          specified in the request. The length of the list is specified in the
    ///             <code>maxResults</code> parameter of the request. If there are more
    ///          bots available, the <code>nextToken</code> field contains a token to
    ///          the next page of results.</p>
    public let botSummaries: [BotSummary]?
    /// <p>A token that indicates whether there are more results to return in a
    ///          response to the <code>ListBots</code> operation. If the
    ///             <code>nextToken</code> field is present, you send the contents as
    ///          the <code>nextToken</code> parameter of a <code>ListBots</code>
    ///          operation request to get the next page of results.</p>
    public let nextToken: String?

    public init (
        botSummaries: [BotSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.botSummaries = botSummaries
        self.nextToken = nextToken
    }
}

struct ListBotsOutputResponseBody: Equatable {
    public let botSummaries: [BotSummary]?
    public let nextToken: String?
}

extension ListBotsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botSummaries
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botSummariesContainer = try containerValues.decodeIfPresent([BotSummary?].self, forKey: .botSummaries)
        var botSummariesDecoded0:[BotSummary]? = nil
        if let botSummariesContainer = botSummariesContainer {
            botSummariesDecoded0 = [BotSummary]()
            for structure0 in botSummariesContainer {
                if let structure0 = structure0 {
                    botSummariesDecoded0?.append(structure0)
                }
            }
        }
        botSummaries = botSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListBuiltInIntentsInputBodyMiddleware: Middleware {
    public let id: String = "ListBuiltInIntentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBuiltInIntentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBuiltInIntentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBuiltInIntentsInput>
    public typealias MOutput = OperationOutput<ListBuiltInIntentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBuiltInIntentsOutputError>
}

extension ListBuiltInIntentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBuiltInIntentsInput(localeId: \(String(describing: localeId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortBy: \(String(describing: sortBy)))"}
}

extension ListBuiltInIntentsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case sortBy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
    }
}

public struct ListBuiltInIntentsInputHeadersMiddleware: Middleware {
    public let id: String = "ListBuiltInIntentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBuiltInIntentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBuiltInIntentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBuiltInIntentsInput>
    public typealias MOutput = OperationOutput<ListBuiltInIntentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBuiltInIntentsOutputError>
}

public struct ListBuiltInIntentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBuiltInIntentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBuiltInIntentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBuiltInIntentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBuiltInIntentsInput>
    public typealias MOutput = OperationOutput<ListBuiltInIntentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBuiltInIntentsOutputError>
}

public struct ListBuiltInIntentsInput: Equatable {
    /// <p>The identifier of the language and locale of the intents to list.
    ///          The string must match one of the supported locales. For more
    ///          information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
    public let localeId: String?
    /// <p>The maximum number of built-in intents to return in each page of
    ///          results. If there are fewer results than the max page size, only the
    ///          actual number of results are returned.</p>
    public let maxResults: Int?
    /// <p>If the response from the <code>ListBuiltInIntents</code> operation
    ///          contains more results than specified in the <code>maxResults</code>
    ///          parameter, a token is returned in the response. Use that token in the
    ///             <code>nextToken</code> parameter to return the next page of
    ///          results.</p>
    public let nextToken: String?
    /// <p>Specifies sorting parameters for the list of built-in intents. You
    ///          can specify that the list be sorted by the built-in intent signature in
    ///          either ascending or descending order.</p>
    public let sortBy: BuiltInIntentSortBy?

    public init (
        localeId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: BuiltInIntentSortBy? = nil
    )
    {
        self.localeId = localeId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
    }
}

struct ListBuiltInIntentsInputBody: Equatable {
    public let sortBy: BuiltInIntentSortBy?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListBuiltInIntentsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case sortBy
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(BuiltInIntentSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBuiltInIntentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBuiltInIntentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBuiltInIntentsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBuiltInIntentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBuiltInIntentsOutputResponse(builtInIntentSummaries: \(String(describing: builtInIntentSummaries)), localeId: \(String(describing: localeId)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBuiltInIntentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBuiltInIntentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.builtInIntentSummaries = output.builtInIntentSummaries
            self.localeId = output.localeId
            self.nextToken = output.nextToken
        } else {
            self.builtInIntentSummaries = nil
            self.localeId = nil
            self.nextToken = nil
        }
    }
}

public struct ListBuiltInIntentsOutputResponse: Equatable {
    /// <p>Summary information for the built-in intents that meet the filter
    ///          criteria specified in the request. The length of the list is specified
    ///          in the <code>maxResults</code> parameter of the request. If there are
    ///          more intents available, the <code>nextToken</code> field contains a
    ///          token to get the next page of results.</p>
    public let builtInIntentSummaries: [BuiltInIntentSummary]?
    /// <p>The language and locale of the intents in the list.</p>
    public let localeId: String?
    /// <p>A token that indicates whether there are more results to return in a
    ///          response to the <code>ListBuiltInIntents</code> operation. If the
    ///             <code>nextToken</code> field is present, you send the contents as
    ///          the <code>nextToken</code> parameter of a <code>ListBotAliases</code>
    ///          operation request to get the next page of results.</p>
    public let nextToken: String?

    public init (
        builtInIntentSummaries: [BuiltInIntentSummary]? = nil,
        localeId: String? = nil,
        nextToken: String? = nil
    )
    {
        self.builtInIntentSummaries = builtInIntentSummaries
        self.localeId = localeId
        self.nextToken = nextToken
    }
}

struct ListBuiltInIntentsOutputResponseBody: Equatable {
    public let builtInIntentSummaries: [BuiltInIntentSummary]?
    public let nextToken: String?
    public let localeId: String?
}

extension ListBuiltInIntentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case builtInIntentSummaries
        case localeId
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let builtInIntentSummariesContainer = try containerValues.decodeIfPresent([BuiltInIntentSummary?].self, forKey: .builtInIntentSummaries)
        var builtInIntentSummariesDecoded0:[BuiltInIntentSummary]? = nil
        if let builtInIntentSummariesContainer = builtInIntentSummariesContainer {
            builtInIntentSummariesDecoded0 = [BuiltInIntentSummary]()
            for structure0 in builtInIntentSummariesContainer {
                if let structure0 = structure0 {
                    builtInIntentSummariesDecoded0?.append(structure0)
                }
            }
        }
        builtInIntentSummaries = builtInIntentSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localeId)
        localeId = localeIdDecoded
    }
}

public struct ListBuiltInSlotTypesInputBodyMiddleware: Middleware {
    public let id: String = "ListBuiltInSlotTypesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBuiltInSlotTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBuiltInSlotTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBuiltInSlotTypesInput>
    public typealias MOutput = OperationOutput<ListBuiltInSlotTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBuiltInSlotTypesOutputError>
}

extension ListBuiltInSlotTypesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBuiltInSlotTypesInput(localeId: \(String(describing: localeId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortBy: \(String(describing: sortBy)))"}
}

extension ListBuiltInSlotTypesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case sortBy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
    }
}

public struct ListBuiltInSlotTypesInputHeadersMiddleware: Middleware {
    public let id: String = "ListBuiltInSlotTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBuiltInSlotTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBuiltInSlotTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBuiltInSlotTypesInput>
    public typealias MOutput = OperationOutput<ListBuiltInSlotTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBuiltInSlotTypesOutputError>
}

public struct ListBuiltInSlotTypesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBuiltInSlotTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBuiltInSlotTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBuiltInSlotTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBuiltInSlotTypesInput>
    public typealias MOutput = OperationOutput<ListBuiltInSlotTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBuiltInSlotTypesOutputError>
}

public struct ListBuiltInSlotTypesInput: Equatable {
    /// <p>The identifier of the language and locale of the slot types to list.
    ///          The string must match one of the supported locales. For more
    ///          information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
    public let localeId: String?
    /// <p>The maximum number of built-in slot types to return in each page of
    ///          results. If there are fewer results than the max page size, only the
    ///          actual number of results are returned.</p>
    public let maxResults: Int?
    /// <p>If the response from the <code>ListBuiltInSlotTypes</code> operation
    ///          contains more results than specified in the <code>maxResults</code>
    ///          parameter, a token is returned in the response. Use that token in the
    ///             <code>nextToken</code> parameter to return the next page of
    ///          results.</p>
    public let nextToken: String?
    /// <p>Determines the sort order for the response from the
    ///             <code>ListBuiltInSlotTypes</code> operation. You can choose to sort
    ///          by the slot type signature in either ascending or descending
    ///          order.</p>
    public let sortBy: BuiltInSlotTypeSortBy?

    public init (
        localeId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: BuiltInSlotTypeSortBy? = nil
    )
    {
        self.localeId = localeId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
    }
}

struct ListBuiltInSlotTypesInputBody: Equatable {
    public let sortBy: BuiltInSlotTypeSortBy?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListBuiltInSlotTypesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case sortBy
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(BuiltInSlotTypeSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBuiltInSlotTypesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBuiltInSlotTypesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBuiltInSlotTypesOutputError: Equatable {
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBuiltInSlotTypesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBuiltInSlotTypesOutputResponse(builtInSlotTypeSummaries: \(String(describing: builtInSlotTypeSummaries)), localeId: \(String(describing: localeId)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBuiltInSlotTypesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBuiltInSlotTypesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.builtInSlotTypeSummaries = output.builtInSlotTypeSummaries
            self.localeId = output.localeId
            self.nextToken = output.nextToken
        } else {
            self.builtInSlotTypeSummaries = nil
            self.localeId = nil
            self.nextToken = nil
        }
    }
}

public struct ListBuiltInSlotTypesOutputResponse: Equatable {
    /// <p>Summary information for the built-in slot types that meet the filter
    ///          criteria specified in the request. The length of the list is specified
    ///          in the <code>maxResults</code> parameter of the request. If there are
    ///          more slot types available, the <code>nextToken</code> field contains a
    ///          token to get the next page of results.</p>
    public let builtInSlotTypeSummaries: [BuiltInSlotTypeSummary]?
    /// <p>The language and locale of the slot types in the list.</p>
    public let localeId: String?
    /// <p>A token that indicates whether there are more results to return in a
    ///          response to the <code>ListBuiltInSlotTypes</code> operation. If the
    ///             <code>nextToken</code> field is present, you send the contents as
    ///          the <code>nextToken</code> parameter of a
    ///             <code>LIstBuiltInSlotTypes</code> operation request to get the next
    ///          page of results.</p>
    public let nextToken: String?

    public init (
        builtInSlotTypeSummaries: [BuiltInSlotTypeSummary]? = nil,
        localeId: String? = nil,
        nextToken: String? = nil
    )
    {
        self.builtInSlotTypeSummaries = builtInSlotTypeSummaries
        self.localeId = localeId
        self.nextToken = nextToken
    }
}

struct ListBuiltInSlotTypesOutputResponseBody: Equatable {
    public let builtInSlotTypeSummaries: [BuiltInSlotTypeSummary]?
    public let nextToken: String?
    public let localeId: String?
}

extension ListBuiltInSlotTypesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case builtInSlotTypeSummaries
        case localeId
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let builtInSlotTypeSummariesContainer = try containerValues.decodeIfPresent([BuiltInSlotTypeSummary?].self, forKey: .builtInSlotTypeSummaries)
        var builtInSlotTypeSummariesDecoded0:[BuiltInSlotTypeSummary]? = nil
        if let builtInSlotTypeSummariesContainer = builtInSlotTypeSummariesContainer {
            builtInSlotTypeSummariesDecoded0 = [BuiltInSlotTypeSummary]()
            for structure0 in builtInSlotTypeSummariesContainer {
                if let structure0 = structure0 {
                    builtInSlotTypeSummariesDecoded0?.append(structure0)
                }
            }
        }
        builtInSlotTypeSummaries = builtInSlotTypeSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localeId)
        localeId = localeIdDecoded
    }
}

public struct ListExportsInputBodyMiddleware: Middleware {
    public let id: String = "ListExportsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListExportsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListExportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListExportsInput>
    public typealias MOutput = OperationOutput<ListExportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListExportsOutputError>
}

extension ListExportsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListExportsInput(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortBy: \(String(describing: sortBy)))"}
}

extension ListExportsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case botId
        case botVersion
        case filters
        case maxResults
        case nextToken
        case sortBy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botId = botId {
            try encodeContainer.encode(botId, forKey: .botId)
        }
        if let botVersion = botVersion {
            try encodeContainer.encode(botVersion, forKey: .botVersion)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for exportfilters0 in filters {
                try filtersContainer.encode(exportfilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
    }
}

public struct ListExportsInputHeadersMiddleware: Middleware {
    public let id: String = "ListExportsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListExportsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListExportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListExportsInput>
    public typealias MOutput = OperationOutput<ListExportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListExportsOutputError>
}

public struct ListExportsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListExportsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListExportsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListExportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListExportsInput>
    public typealias MOutput = OperationOutput<ListExportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListExportsOutputError>
}

public struct ListExportsInput: Equatable {
    /// <p>The unique identifier that Amazon Lex assigned to the bot.</p>
    public let botId: String?
    /// <p>The version of the bot to list exports for. </p>
    public let botVersion: String?
    /// <p>Provides the specification of a filter used to limit the exports in
    ///          the response to only those that match the filter specification. You can
    ///          only specify one filter and one string to filter on.</p>
    public let filters: [ExportFilter]?
    /// <p>The maximum number of exports to return in each page of results. If
    ///          there are fewer results than the max page size, only the actual number
    ///          of results are returned.</p>
    public let maxResults: Int?
    /// <p>If the response from the <code>ListExports</code> operation contans
    ///          more results that specified in the <code>maxResults</code> parameter, a
    ///          token is returned in the response. Use that token in the
    ///             <code>nextToken</code> parameter to return the next page of
    ///          results.</p>
    public let nextToken: String?
    /// <p>Determines the field that the list of exports is sorted by. You can
    ///          sort by the <code>LastUpdatedDateTime</code> field in ascending or
    ///          descending order.</p>
    public let sortBy: ExportSortBy?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        filters: [ExportFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: ExportSortBy? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
    }
}

struct ListExportsInputBody: Equatable {
    public let botId: String?
    public let botVersion: String?
    public let sortBy: ExportSortBy?
    public let filters: [ExportFilter]?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListExportsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botId
        case botVersion
        case filters
        case maxResults
        case nextToken
        case sortBy
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(ExportSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ExportFilter?].self, forKey: .filters)
        var filtersDecoded0:[ExportFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ExportFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListExportsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListExportsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListExportsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListExportsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListExportsOutputResponse(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), exportSummaries: \(String(describing: exportSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListExportsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListExportsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.exportSummaries = output.exportSummaries
            self.nextToken = output.nextToken
        } else {
            self.botId = nil
            self.botVersion = nil
            self.exportSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListExportsOutputResponse: Equatable {
    /// <p>The unique identifier assigned to the bot by Amazon Lex.</p>
    public let botId: String?
    /// <p>The version of the bot that was exported.</p>
    public let botVersion: String?
    /// <p>Summary information for the exports that meet the filter criteria
    ///          specified in the request. The length of the list is specified in the
    ///             <code>maxResults</code> parameter. If there are more exports
    ///          available, the <code>nextToken</code> field contains a token to get the
    ///          next page of results.</p>
    public let exportSummaries: [ExportSummary]?
    /// <p>A token that indicates whether there are more results to return in a
    ///          response to the <code>ListExports</code> operation. If the
    ///             <code>nextToken</code> field is present, you send the contents as
    ///          the <code>nextToken</code> parameter of a <code>ListExports</code>
    ///          operation request to get the next page of results.</p>
    public let nextToken: String?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        exportSummaries: [ExportSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.exportSummaries = exportSummaries
        self.nextToken = nextToken
    }
}

struct ListExportsOutputResponseBody: Equatable {
    public let botId: String?
    public let botVersion: String?
    public let exportSummaries: [ExportSummary]?
    public let nextToken: String?
}

extension ListExportsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botId
        case botVersion
        case exportSummaries
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let exportSummariesContainer = try containerValues.decodeIfPresent([ExportSummary?].self, forKey: .exportSummaries)
        var exportSummariesDecoded0:[ExportSummary]? = nil
        if let exportSummariesContainer = exportSummariesContainer {
            exportSummariesDecoded0 = [ExportSummary]()
            for structure0 in exportSummariesContainer {
                if let structure0 = structure0 {
                    exportSummariesDecoded0?.append(structure0)
                }
            }
        }
        exportSummaries = exportSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListImportsInputBodyMiddleware: Middleware {
    public let id: String = "ListImportsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListImportsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListImportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListImportsInput>
    public typealias MOutput = OperationOutput<ListImportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListImportsOutputError>
}

extension ListImportsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListImportsInput(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortBy: \(String(describing: sortBy)))"}
}

extension ListImportsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case botId
        case botVersion
        case filters
        case maxResults
        case nextToken
        case sortBy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botId = botId {
            try encodeContainer.encode(botId, forKey: .botId)
        }
        if let botVersion = botVersion {
            try encodeContainer.encode(botVersion, forKey: .botVersion)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for importfilters0 in filters {
                try filtersContainer.encode(importfilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
    }
}

public struct ListImportsInputHeadersMiddleware: Middleware {
    public let id: String = "ListImportsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListImportsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListImportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListImportsInput>
    public typealias MOutput = OperationOutput<ListImportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListImportsOutputError>
}

public struct ListImportsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListImportsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListImportsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListImportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListImportsInput>
    public typealias MOutput = OperationOutput<ListImportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListImportsOutputError>
}

public struct ListImportsInput: Equatable {
    /// <p>The unique identifier that Amazon Lex assigned to the bot.</p>
    public let botId: String?
    /// <p>The version of the bot to list imports for.</p>
    public let botVersion: String?
    /// <p>Provides the specification of a filter used to limit the bots in the
    ///          response to only those that match the filter specification. You can
    ///          only specify one filter and one string to filter on.</p>
    public let filters: [ImportFilter]?
    /// <p>The maximum number of imports to return in each page of results. If
    ///          there are fewer results than the max page size, only the actual number
    ///          of results are returned.</p>
    public let maxResults: Int?
    /// <p>If the response from the <code>ListImports</code> operation contains
    ///          more results than specified in the <code>maxResults</code> parameter, a
    ///          token is returned in the response. Use that token in the
    ///             <code>nextToken</code> parameter to return the next page of
    ///          results.</p>
    public let nextToken: String?
    /// <p>Determines the field that the list of imports is sorted by. You can
    ///          sort by the <code>LastUpdatedDateTime</code> field in ascending or
    ///          descending order.</p>
    public let sortBy: ImportSortBy?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        filters: [ImportFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: ImportSortBy? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
    }
}

struct ListImportsInputBody: Equatable {
    public let botId: String?
    public let botVersion: String?
    public let sortBy: ImportSortBy?
    public let filters: [ImportFilter]?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListImportsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botId
        case botVersion
        case filters
        case maxResults
        case nextToken
        case sortBy
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(ImportSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ImportFilter?].self, forKey: .filters)
        var filtersDecoded0:[ImportFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ImportFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImportsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListImportsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListImportsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListImportsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListImportsOutputResponse(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), importSummaries: \(String(describing: importSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListImportsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListImportsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.importSummaries = output.importSummaries
            self.nextToken = output.nextToken
        } else {
            self.botId = nil
            self.botVersion = nil
            self.importSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListImportsOutputResponse: Equatable {
    /// <p>The unique identifier assigned by Amazon Lex to the bot.</p>
    public let botId: String?
    /// <p>The version of the bot that was imported. It will always be
    ///             <code>DRAFT</code>.</p>
    public let botVersion: String?
    /// <p>Summary information for the imports that meet the filter criteria
    ///          specified in the request. The length of the list is specified in the
    ///             <code>maxResults</code> parameter. If there are more imports
    ///          available, the <code>nextToken</code> field contains a token to get the
    ///          next page of results.</p>
    public let importSummaries: [ImportSummary]?
    /// <p>A token that indicates whether there are more results to return in a
    ///          response to the <code>ListImports</code> operation. If the
    ///             <code>nextToken</code> field is present, you send the contents as
    ///          the <code>nextToken</code> parameter of a <code>ListImports</code>
    ///          operation request to get the next page of results.</p>
    public let nextToken: String?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        importSummaries: [ImportSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.importSummaries = importSummaries
        self.nextToken = nextToken
    }
}

struct ListImportsOutputResponseBody: Equatable {
    public let botId: String?
    public let botVersion: String?
    public let importSummaries: [ImportSummary]?
    public let nextToken: String?
}

extension ListImportsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botId
        case botVersion
        case importSummaries
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let importSummariesContainer = try containerValues.decodeIfPresent([ImportSummary?].self, forKey: .importSummaries)
        var importSummariesDecoded0:[ImportSummary]? = nil
        if let importSummariesContainer = importSummariesContainer {
            importSummariesDecoded0 = [ImportSummary]()
            for structure0 in importSummariesContainer {
                if let structure0 = structure0 {
                    importSummariesDecoded0?.append(structure0)
                }
            }
        }
        importSummaries = importSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListIntentsInputBodyMiddleware: Middleware {
    public let id: String = "ListIntentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIntentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIntentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIntentsInput>
    public typealias MOutput = OperationOutput<ListIntentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIntentsOutputError>
}

extension ListIntentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIntentsInput(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), filters: \(String(describing: filters)), localeId: \(String(describing: localeId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortBy: \(String(describing: sortBy)))"}
}

extension ListIntentsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
        case sortBy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for intentfilters0 in filters {
                try filtersContainer.encode(intentfilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
    }
}

public struct ListIntentsInputHeadersMiddleware: Middleware {
    public let id: String = "ListIntentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIntentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIntentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIntentsInput>
    public typealias MOutput = OperationOutput<ListIntentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIntentsOutputError>
}

public struct ListIntentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListIntentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIntentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIntentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIntentsInput>
    public typealias MOutput = OperationOutput<ListIntentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIntentsOutputError>
}

public struct ListIntentsInput: Equatable {
    /// <p>The unique identifier of the bot that contains the intent.</p>
    public let botId: String?
    /// <p>The version of the bot that contains the intent.</p>
    public let botVersion: String?
    /// <p>Provides the specification of a filter used to limit the intents in
    ///          the response to only those that match the filter specification. You can
    ///          only specify one filter and only one string to filter on.</p>
    public let filters: [IntentFilter]?
    /// <p>The identifier of the language and locale of the intents to list.
    ///          The string must match one of the supported locales. For more
    ///          information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
    public let localeId: String?
    /// <p>The maximum number of intents to return in each page of results. If
    ///          there are fewer results than the max page size, only the actual number
    ///          of results are returned.</p>
    public let maxResults: Int?
    /// <p>If the response from the <code>ListIntents</code> operation contains
    ///          more results than specified in the <code>maxResults</code> parameter, a
    ///          token is returned in the response. Use that token in the
    ///             <code>nextToken</code> parameter to return the next page of
    ///          results.</p>
    public let nextToken: String?
    /// <p>Determines the sort order for the response from the
    ///             <code>ListIntents</code> operation. You can choose to sort by the
    ///          intent name or last updated date in either ascending or descending
    ///          order.</p>
    public let sortBy: IntentSortBy?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        filters: [IntentFilter]? = nil,
        localeId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: IntentSortBy? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.filters = filters
        self.localeId = localeId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
    }
}

struct ListIntentsInputBody: Equatable {
    public let sortBy: IntentSortBy?
    public let filters: [IntentFilter]?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListIntentsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
        case sortBy
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(IntentSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let filtersContainer = try containerValues.decodeIfPresent([IntentFilter?].self, forKey: .filters)
        var filtersDecoded0:[IntentFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [IntentFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListIntentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIntentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIntentsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIntentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIntentsOutputResponse(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), intentSummaries: \(String(describing: intentSummaries)), localeId: \(String(describing: localeId)), nextToken: \(String(describing: nextToken)))"}
}

extension ListIntentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListIntentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.intentSummaries = output.intentSummaries
            self.localeId = output.localeId
            self.nextToken = output.nextToken
        } else {
            self.botId = nil
            self.botVersion = nil
            self.intentSummaries = nil
            self.localeId = nil
            self.nextToken = nil
        }
    }
}

public struct ListIntentsOutputResponse: Equatable {
    /// <p>The identifier of the bot that contains the intent.</p>
    public let botId: String?
    /// <p>The version of the bot that contains the intent.</p>
    public let botVersion: String?
    /// <p>Summary information for the intents that meet the filter criteria
    ///          specified in the request. The length of the list is specified in the
    ///             <code>maxResults</code> parameter of the request. If there are more
    ///          intents available, the <code>nextToken</code> field contains a token to
    ///          get the next page of results.</p>
    public let intentSummaries: [IntentSummary]?
    /// <p>The language and locale of the intents in the list.</p>
    public let localeId: String?
    /// <p>A token that indicates whether there are more results to return in a
    ///          response to the <code>ListIntents</code> operation. If the
    ///             <code>nextToken</code> field is present, you send the contents as
    ///          the <code>nextToken</code> parameter of a <code>ListIntents</code>
    ///          operation request to get the next page of results.</p>
    public let nextToken: String?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        intentSummaries: [IntentSummary]? = nil,
        localeId: String? = nil,
        nextToken: String? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.intentSummaries = intentSummaries
        self.localeId = localeId
        self.nextToken = nextToken
    }
}

struct ListIntentsOutputResponseBody: Equatable {
    public let botId: String?
    public let botVersion: String?
    public let localeId: String?
    public let intentSummaries: [IntentSummary]?
    public let nextToken: String?
}

extension ListIntentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botId
        case botVersion
        case intentSummaries
        case localeId
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let intentSummariesContainer = try containerValues.decodeIfPresent([IntentSummary?].self, forKey: .intentSummaries)
        var intentSummariesDecoded0:[IntentSummary]? = nil
        if let intentSummariesContainer = intentSummariesContainer {
            intentSummariesDecoded0 = [IntentSummary]()
            for structure0 in intentSummariesContainer {
                if let structure0 = structure0 {
                    intentSummariesDecoded0?.append(structure0)
                }
            }
        }
        intentSummaries = intentSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSlotTypesInputBodyMiddleware: Middleware {
    public let id: String = "ListSlotTypesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSlotTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSlotTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSlotTypesInput>
    public typealias MOutput = OperationOutput<ListSlotTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSlotTypesOutputError>
}

extension ListSlotTypesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSlotTypesInput(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), filters: \(String(describing: filters)), localeId: \(String(describing: localeId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortBy: \(String(describing: sortBy)))"}
}

extension ListSlotTypesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
        case sortBy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for slottypefilters0 in filters {
                try filtersContainer.encode(slottypefilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
    }
}

public struct ListSlotTypesInputHeadersMiddleware: Middleware {
    public let id: String = "ListSlotTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSlotTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSlotTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSlotTypesInput>
    public typealias MOutput = OperationOutput<ListSlotTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSlotTypesOutputError>
}

public struct ListSlotTypesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSlotTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSlotTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSlotTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSlotTypesInput>
    public typealias MOutput = OperationOutput<ListSlotTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSlotTypesOutputError>
}

public struct ListSlotTypesInput: Equatable {
    /// <p>The unique identifier of the bot that contains the slot
    ///          types.</p>
    public let botId: String?
    /// <p>The version of the bot that contains the slot type.</p>
    public let botVersion: String?
    /// <p>Provides the specification of a filter used to limit the slot types
    ///          in the response to only those that match the filter specification. You
    ///          can only specify one filter and only one string to filter on.</p>
    public let filters: [SlotTypeFilter]?
    /// <p>The identifier of the language and locale of the slot types to list.
    ///          The string must match one of the supported locales. For more
    ///          information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
    public let localeId: String?
    /// <p>The maximum number of slot types to return in each page of results.
    ///          If there are fewer results than the max page size, only the actual
    ///          number of results are returned.</p>
    public let maxResults: Int?
    /// <p>If the response from the <code>ListSlotTypes</code> operation
    ///          contains more results than specified in the <code>maxResults</code>
    ///          parameter, a token is returned in the response. Use that token in the
    ///             <code>nextToken</code> parameter to return the next page of
    ///          results.</p>
    public let nextToken: String?
    /// <p>Determines the sort order for the response from the
    ///             <code>ListSlotTypes</code> operation. You can choose to sort by the
    ///          slot type name or last updated date in either ascending or descending
    ///          order.</p>
    public let sortBy: SlotTypeSortBy?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        filters: [SlotTypeFilter]? = nil,
        localeId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: SlotTypeSortBy? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.filters = filters
        self.localeId = localeId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
    }
}

struct ListSlotTypesInputBody: Equatable {
    public let sortBy: SlotTypeSortBy?
    public let filters: [SlotTypeFilter]?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListSlotTypesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
        case sortBy
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(SlotTypeSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SlotTypeFilter?].self, forKey: .filters)
        var filtersDecoded0:[SlotTypeFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SlotTypeFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSlotTypesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSlotTypesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSlotTypesOutputError: Equatable {
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSlotTypesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSlotTypesOutputResponse(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), localeId: \(String(describing: localeId)), nextToken: \(String(describing: nextToken)), slotTypeSummaries: \(String(describing: slotTypeSummaries)))"}
}

extension ListSlotTypesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSlotTypesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.localeId = output.localeId
            self.nextToken = output.nextToken
            self.slotTypeSummaries = output.slotTypeSummaries
        } else {
            self.botId = nil
            self.botVersion = nil
            self.localeId = nil
            self.nextToken = nil
            self.slotTypeSummaries = nil
        }
    }
}

public struct ListSlotTypesOutputResponse: Equatable {
    /// <p>The identifier of the bot that contains the slot types.</p>
    public let botId: String?
    /// <p>The version of the bot that contains the slot types.</p>
    public let botVersion: String?
    /// <p>The language and local of the slot types in the list.</p>
    public let localeId: String?
    /// <p>A token that indicates whether there are more results to return in a
    ///          response to the <code>ListSlotTypes</code> operation. If the
    ///             <code>nextToken</code> field is present, you send the contents as
    ///          the <code>nextToken</code> parameter of a <code>ListSlotTypes</code>
    ///          operation request to get the next page of results.</p>
    public let nextToken: String?
    /// <p>Summary information for the slot types that meet the filter criteria
    ///          specified in the request. The length of the list is specified in the
    ///             <code>maxResults</code> parameter of the request. If there are more
    ///          slot types available, the <code>nextToken</code> field contains a token
    ///          to get the next page of results.</p>
    public let slotTypeSummaries: [SlotTypeSummary]?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        localeId: String? = nil,
        nextToken: String? = nil,
        slotTypeSummaries: [SlotTypeSummary]? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.localeId = localeId
        self.nextToken = nextToken
        self.slotTypeSummaries = slotTypeSummaries
    }
}

struct ListSlotTypesOutputResponseBody: Equatable {
    public let botId: String?
    public let botVersion: String?
    public let localeId: String?
    public let slotTypeSummaries: [SlotTypeSummary]?
    public let nextToken: String?
}

extension ListSlotTypesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botId
        case botVersion
        case localeId
        case nextToken
        case slotTypeSummaries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let slotTypeSummariesContainer = try containerValues.decodeIfPresent([SlotTypeSummary?].self, forKey: .slotTypeSummaries)
        var slotTypeSummariesDecoded0:[SlotTypeSummary]? = nil
        if let slotTypeSummariesContainer = slotTypeSummariesContainer {
            slotTypeSummariesDecoded0 = [SlotTypeSummary]()
            for structure0 in slotTypeSummariesContainer {
                if let structure0 = structure0 {
                    slotTypeSummariesDecoded0?.append(structure0)
                }
            }
        }
        slotTypeSummaries = slotTypeSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSlotsInputBodyMiddleware: Middleware {
    public let id: String = "ListSlotsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSlotsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSlotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSlotsInput>
    public typealias MOutput = OperationOutput<ListSlotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSlotsOutputError>
}

extension ListSlotsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSlotsInput(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), filters: \(String(describing: filters)), intentId: \(String(describing: intentId)), localeId: \(String(describing: localeId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortBy: \(String(describing: sortBy)))"}
}

extension ListSlotsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
        case sortBy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for slotfilters0 in filters {
                try filtersContainer.encode(slotfilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
    }
}

public struct ListSlotsInputHeadersMiddleware: Middleware {
    public let id: String = "ListSlotsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSlotsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSlotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSlotsInput>
    public typealias MOutput = OperationOutput<ListSlotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSlotsOutputError>
}

public struct ListSlotsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSlotsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSlotsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSlotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSlotsInput>
    public typealias MOutput = OperationOutput<ListSlotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSlotsOutputError>
}

public struct ListSlotsInput: Equatable {
    /// <p>The identifier of the bot that contains the slot.</p>
    public let botId: String?
    /// <p>The version of the bot that contains the slot.</p>
    public let botVersion: String?
    /// <p>Provides the specification of a filter used to limit the slots in
    ///          the response to only those that match the filter specification. You can
    ///          only specify one filter and only one string to filter on.</p>
    public let filters: [SlotFilter]?
    /// <p>The unique identifier of the intent that contains the slot.</p>
    public let intentId: String?
    /// <p>The identifier of the language and locale of the slots to list. The
    ///          string must match one of the supported locales. For more information,
    ///          see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
    public let localeId: String?
    /// <p>The maximum number of slots to return in each page of results. If
    ///          there are fewer results than the max page size, only the actual number
    ///          of results are returned.</p>
    public let maxResults: Int?
    /// <p>If the response from the <code>ListSlots</code> operation contains
    ///          more results than specified in the <code>maxResults</code> parameter, a
    ///          token is returned in the response. Use that token in the
    ///             <code>nextToken</code> parameter to return the next page of
    ///          results.</p>
    public let nextToken: String?
    /// <p>Determines the sort order for the response from the
    ///             <code>ListSlots</code> operation. You can choose to sort by the slot
    ///          name or last updated date in either ascending or descending
    ///          order.</p>
    public let sortBy: SlotSortBy?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        filters: [SlotFilter]? = nil,
        intentId: String? = nil,
        localeId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: SlotSortBy? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.filters = filters
        self.intentId = intentId
        self.localeId = localeId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
    }
}

struct ListSlotsInputBody: Equatable {
    public let sortBy: SlotSortBy?
    public let filters: [SlotFilter]?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListSlotsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
        case sortBy
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(SlotSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SlotFilter?].self, forKey: .filters)
        var filtersDecoded0:[SlotFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SlotFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSlotsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSlotsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSlotsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSlotsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSlotsOutputResponse(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), intentId: \(String(describing: intentId)), localeId: \(String(describing: localeId)), nextToken: \(String(describing: nextToken)), slotSummaries: \(String(describing: slotSummaries)))"}
}

extension ListSlotsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSlotsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.intentId = output.intentId
            self.localeId = output.localeId
            self.nextToken = output.nextToken
            self.slotSummaries = output.slotSummaries
        } else {
            self.botId = nil
            self.botVersion = nil
            self.intentId = nil
            self.localeId = nil
            self.nextToken = nil
            self.slotSummaries = nil
        }
    }
}

public struct ListSlotsOutputResponse: Equatable {
    /// <p>The identifier of the bot that contains the slots.</p>
    public let botId: String?
    /// <p>The version of the bot that contains the slots.</p>
    public let botVersion: String?
    /// <p>The identifier of the intent that contains the slots.</p>
    public let intentId: String?
    /// <p>The language and locale of the slots in the list.</p>
    public let localeId: String?
    /// <p>A token that indicates whether there are more results to return in a
    ///          response to the <code>ListSlots</code> operation. If the
    ///             <code>nextToken</code> field is present, you send the contents as
    ///          the <code>nextToken</code> parameter of a <code>ListSlots</code>
    ///          operation request to get the next page of results.</p>
    public let nextToken: String?
    /// <p>Summary information for the slots that meet the filter criteria
    ///          specified in the request. The length of the list is specified in the
    ///             <code>maxResults</code> parameter of the request. If there are more
    ///          slots available, the <code>nextToken</code> field contains a token to
    ///          get the next page of results.</p>
    public let slotSummaries: [SlotSummary]?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        intentId: String? = nil,
        localeId: String? = nil,
        nextToken: String? = nil,
        slotSummaries: [SlotSummary]? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.intentId = intentId
        self.localeId = localeId
        self.nextToken = nextToken
        self.slotSummaries = slotSummaries
    }
}

struct ListSlotsOutputResponseBody: Equatable {
    public let botId: String?
    public let botVersion: String?
    public let localeId: String?
    public let intentId: String?
    public let slotSummaries: [SlotSummary]?
    public let nextToken: String?
}

extension ListSlotsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botId
        case botVersion
        case intentId
        case localeId
        case nextToken
        case slotSummaries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let intentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .intentId)
        intentId = intentIdDecoded
        let slotSummariesContainer = try containerValues.decodeIfPresent([SlotSummary?].self, forKey: .slotSummaries)
        var slotSummariesDecoded0:[SlotSummary]? = nil
        if let slotSummariesContainer = slotSummariesContainer {
            slotSummariesDecoded0 = [SlotSummary]()
            for structure0 in slotSummariesContainer {
                if let structure0 = structure0 {
                    slotSummariesDecoded0?.append(structure0)
                }
            }
        }
        slotSummaries = slotSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceARN: \(String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource to get a list of tags
    ///          for.</p>
    public let resourceARN: String?

    public init (
        resourceARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The tags associated with a resource.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum MergeStrategy {
    case failonconflict
    case overwrite
    case sdkUnknown(String)
}

extension MergeStrategy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MergeStrategy] {
        return [
            .failonconflict,
            .overwrite,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failonconflict: return "FailOnConflict"
        case .overwrite: return "Overwrite"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MergeStrategy(rawValue: rawValue) ?? MergeStrategy.sdkUnknown(rawValue)
    }
}

extension Message: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customPayload
        case imageResponseCard
        case plainTextMessage
        case ssmlMessage
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customPayload = customPayload {
            try encodeContainer.encode(customPayload, forKey: .customPayload)
        }
        if let imageResponseCard = imageResponseCard {
            try encodeContainer.encode(imageResponseCard, forKey: .imageResponseCard)
        }
        if let plainTextMessage = plainTextMessage {
            try encodeContainer.encode(plainTextMessage, forKey: .plainTextMessage)
        }
        if let ssmlMessage = ssmlMessage {
            try encodeContainer.encode(ssmlMessage, forKey: .ssmlMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let plainTextMessageDecoded = try containerValues.decodeIfPresent(PlainTextMessage.self, forKey: .plainTextMessage)
        plainTextMessage = plainTextMessageDecoded
        let customPayloadDecoded = try containerValues.decodeIfPresent(CustomPayload.self, forKey: .customPayload)
        customPayload = customPayloadDecoded
        let ssmlMessageDecoded = try containerValues.decodeIfPresent(SSMLMessage.self, forKey: .ssmlMessage)
        ssmlMessage = ssmlMessageDecoded
        let imageResponseCardDecoded = try containerValues.decodeIfPresent(ImageResponseCard.self, forKey: .imageResponseCard)
        imageResponseCard = imageResponseCardDecoded
    }
}

extension Message: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Message(customPayload: \(String(describing: customPayload)), imageResponseCard: \(String(describing: imageResponseCard)), plainTextMessage: \(String(describing: plainTextMessage)), ssmlMessage: \(String(describing: ssmlMessage)))"}
}

/// <p>The object that provides message text and it's type.</p>
public struct Message: Equatable {
    /// <p>A message in a custom format defined by the client
    ///          application.</p>
    public let customPayload: CustomPayload?
    /// <p>A message that defines a response card that the client application
    ///          can show to the user.</p>
    public let imageResponseCard: ImageResponseCard?
    /// <p>A message in plain text format.</p>
    public let plainTextMessage: PlainTextMessage?
    /// <p>A message in Speech Synthesis Markup Language (SSML).</p>
    public let ssmlMessage: SSMLMessage?

    public init (
        customPayload: CustomPayload? = nil,
        imageResponseCard: ImageResponseCard? = nil,
        plainTextMessage: PlainTextMessage? = nil,
        ssmlMessage: SSMLMessage? = nil
    )
    {
        self.customPayload = customPayload
        self.imageResponseCard = imageResponseCard
        self.plainTextMessage = plainTextMessage
        self.ssmlMessage = ssmlMessage
    }
}

extension MessageGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message
        case variations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let variations = variations {
            var variationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variations)
            for messagevariationslist0 in variations {
                try variationsContainer.encode(messagevariationslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Message.self, forKey: .message)
        message = messageDecoded
        let variationsContainer = try containerValues.decodeIfPresent([Message?].self, forKey: .variations)
        var variationsDecoded0:[Message]? = nil
        if let variationsContainer = variationsContainer {
            variationsDecoded0 = [Message]()
            for structure0 in variationsContainer {
                if let structure0 = structure0 {
                    variationsDecoded0?.append(structure0)
                }
            }
        }
        variations = variationsDecoded0
    }
}

extension MessageGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MessageGroup(message: \(String(describing: message)), variations: \(String(describing: variations)))"}
}

/// <p>Provides one or more messages that Amazon Lex should send to the
///          user.</p>
public struct MessageGroup: Equatable {
    /// <p>The primary message that Amazon Lex should send to the user.</p>
    public let message: Message?
    /// <p>Message variations to send to the user. When variations are defined,
    ///          Amazon Lex chooses the primary message or one of the variations to send to
    ///          the user.</p>
    public let variations: [Message]?

    public init (
        message: Message? = nil,
        variations: [Message]? = nil
    )
    {
        self.message = message
        self.variations = variations
    }
}

extension ObfuscationSetting: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case obfuscationSettingType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let obfuscationSettingType = obfuscationSettingType {
            try encodeContainer.encode(obfuscationSettingType.rawValue, forKey: .obfuscationSettingType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let obfuscationSettingTypeDecoded = try containerValues.decodeIfPresent(ObfuscationSettingType.self, forKey: .obfuscationSettingType)
        obfuscationSettingType = obfuscationSettingTypeDecoded
    }
}

extension ObfuscationSetting: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ObfuscationSetting(obfuscationSettingType: \(String(describing: obfuscationSettingType)))"}
}

/// <p>Determines whether Amazon Lex obscures slot values in conversation logs.
///       </p>
public struct ObfuscationSetting: Equatable {
    /// <p>Value that determines whether Amazon Lex obscures slot values in
    ///          conversation logs. The default is to obscure the values.</p>
    public let obfuscationSettingType: ObfuscationSettingType?

    public init (
        obfuscationSettingType: ObfuscationSettingType? = nil
    )
    {
        self.obfuscationSettingType = obfuscationSettingType
    }
}

public enum ObfuscationSettingType {
    case defaultobfuscation
    case `none`
    case sdkUnknown(String)
}

extension ObfuscationSettingType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ObfuscationSettingType] {
        return [
            .defaultobfuscation,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .defaultobfuscation: return "DefaultObfuscation"
        case .none: return "None"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ObfuscationSettingType(rawValue: rawValue) ?? ObfuscationSettingType.sdkUnknown(rawValue)
    }
}

extension OutputContext: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case timeToLiveInSeconds
        case turnsToLive
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let timeToLiveInSeconds = timeToLiveInSeconds {
            try encodeContainer.encode(timeToLiveInSeconds, forKey: .timeToLiveInSeconds)
        }
        if let turnsToLive = turnsToLive {
            try encodeContainer.encode(turnsToLive, forKey: .turnsToLive)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let timeToLiveInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeToLiveInSeconds)
        timeToLiveInSeconds = timeToLiveInSecondsDecoded
        let turnsToLiveDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .turnsToLive)
        turnsToLive = turnsToLiveDecoded
    }
}

extension OutputContext: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OutputContext(name: \(String(describing: name)), timeToLiveInSeconds: \(String(describing: timeToLiveInSeconds)), turnsToLive: \(String(describing: turnsToLive)))"}
}

/// <p>Describes a session context that is activated when an intent is
///          fulfilled.</p>
public struct OutputContext: Equatable {
    /// <p>The name of the output context.</p>
    public let name: String?
    /// <p>The amount of time, in seconds, that the output context should
    ///          remain active. The time is figured from the first time the context is
    ///          sent to the user.</p>
    public let timeToLiveInSeconds: Int?
    /// <p>The number of conversation turns that the output context should
    ///          remain active. The number of turns is counted from the first time that
    ///          the context is sent to the user.</p>
    public let turnsToLive: Int?

    public init (
        name: String? = nil,
        timeToLiveInSeconds: Int? = nil,
        turnsToLive: Int? = nil
    )
    {
        self.name = name
        self.timeToLiveInSeconds = timeToLiveInSeconds
        self.turnsToLive = turnsToLive
    }
}

extension PlainTextMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension PlainTextMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PlainTextMessage(value: \(String(describing: value)))"}
}

/// <p>Defines an ASCII text message to send to the user.</p>
public struct PlainTextMessage: Equatable {
    /// <p>The message to send to the user.</p>
    public let value: String?

    public init (
        value: String? = nil
    )
    {
        self.value = value
    }
}

extension PreconditionFailedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PreconditionFailedException(message: \(String(describing: message)))"}
}

extension PreconditionFailedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PreconditionFailedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct PreconditionFailedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PreconditionFailedExceptionBody: Equatable {
    public let message: String?
}

extension PreconditionFailedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Principal: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case service
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let service = service {
            try encodeContainer.encode(service, forKey: .service)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .service)
        service = serviceDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension Principal: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Principal(arn: \(String(describing: arn)), service: \(String(describing: service)))"}
}

/// <p>The IAM principal that you allowing or denying access to an Amazon Lex
///          action. You must provide a <code>service</code> or an <code>arn</code>,
///          but not both in the same statement. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_principal.html"> AWS JSON policy elements: Principal </a>.</p>
public struct Principal: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the principal.</p>
    public let arn: String?
    /// <p>The name of the AWS service that should allowed or denied access to
    ///          an Amazon Lex action.</p>
    public let service: String?

    public init (
        arn: String? = nil,
        service: String? = nil
    )
    {
        self.arn = arn
        self.service = service
    }
}

extension PromptSpecification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowInterrupt
        case maxRetries
        case messageGroups
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowInterrupt = allowInterrupt {
            try encodeContainer.encode(allowInterrupt, forKey: .allowInterrupt)
        }
        if let maxRetries = maxRetries {
            try encodeContainer.encode(maxRetries, forKey: .maxRetries)
        }
        if let messageGroups = messageGroups {
            var messageGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .messageGroups)
            for messagegroupslist0 in messageGroups {
                try messageGroupsContainer.encode(messagegroupslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageGroupsContainer = try containerValues.decodeIfPresent([MessageGroup?].self, forKey: .messageGroups)
        var messageGroupsDecoded0:[MessageGroup]? = nil
        if let messageGroupsContainer = messageGroupsContainer {
            messageGroupsDecoded0 = [MessageGroup]()
            for structure0 in messageGroupsContainer {
                if let structure0 = structure0 {
                    messageGroupsDecoded0?.append(structure0)
                }
            }
        }
        messageGroups = messageGroupsDecoded0
        let maxRetriesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxRetries)
        maxRetries = maxRetriesDecoded
        let allowInterruptDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowInterrupt)
        allowInterrupt = allowInterruptDecoded
    }
}

extension PromptSpecification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PromptSpecification(allowInterrupt: \(String(describing: allowInterrupt)), maxRetries: \(String(describing: maxRetries)), messageGroups: \(String(describing: messageGroups)))"}
}

/// <p>Specifies a list of message groups that Amazon Lex sends to a user to
///          elicit a response.</p>
public struct PromptSpecification: Equatable {
    /// <p>Indicates whether the user can interrupt a speech prompt from the
    ///          bot.</p>
    public let allowInterrupt: Bool?
    /// <p>The maximum number of times the bot tries to elicit a resonse from
    ///          the user using this prompt.</p>
    public let maxRetries: Int?
    /// <p>A collection of messages that Amazon Lex can send to the user. Amazon Lex
    ///          chooses the actual message to send at runtime.</p>
    public let messageGroups: [MessageGroup]?

    public init (
        allowInterrupt: Bool? = nil,
        maxRetries: Int? = nil,
        messageGroups: [MessageGroup]? = nil
    )
    {
        self.allowInterrupt = allowInterrupt
        self.maxRetries = maxRetries
        self.messageGroups = messageGroups
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResponseSpecification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowInterrupt
        case messageGroups
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowInterrupt = allowInterrupt {
            try encodeContainer.encode(allowInterrupt, forKey: .allowInterrupt)
        }
        if let messageGroups = messageGroups {
            var messageGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .messageGroups)
            for messagegroupslist0 in messageGroups {
                try messageGroupsContainer.encode(messagegroupslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageGroupsContainer = try containerValues.decodeIfPresent([MessageGroup?].self, forKey: .messageGroups)
        var messageGroupsDecoded0:[MessageGroup]? = nil
        if let messageGroupsContainer = messageGroupsContainer {
            messageGroupsDecoded0 = [MessageGroup]()
            for structure0 in messageGroupsContainer {
                if let structure0 = structure0 {
                    messageGroupsDecoded0?.append(structure0)
                }
            }
        }
        messageGroups = messageGroupsDecoded0
        let allowInterruptDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowInterrupt)
        allowInterrupt = allowInterruptDecoded
    }
}

extension ResponseSpecification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResponseSpecification(allowInterrupt: \(String(describing: allowInterrupt)), messageGroups: \(String(describing: messageGroups)))"}
}

/// <p>Specifies a list of message groups that Amazon Lex uses to respond the
///          user input.</p>
public struct ResponseSpecification: Equatable {
    /// <p>Indicates whether the user can interrupt a speech response from
    ///          Amazon Lex.</p>
    public let allowInterrupt: Bool?
    /// <p>A collection of responses that Amazon Lex can send to the user. Amazon Lex
    ///          chooses the actual response to send at runtime.</p>
    public let messageGroups: [MessageGroup]?

    public init (
        allowInterrupt: Bool? = nil,
        messageGroups: [MessageGroup]? = nil
    )
    {
        self.allowInterrupt = allowInterrupt
        self.messageGroups = messageGroups
    }
}

extension S3BucketLogDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case kmsKeyArn
        case logPrefix
        case s3BucketArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyArn = kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let logPrefix = logPrefix {
            try encodeContainer.encode(logPrefix, forKey: .logPrefix)
        }
        if let s3BucketArn = s3BucketArn {
            try encodeContainer.encode(s3BucketArn, forKey: .s3BucketArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let s3BucketArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketArn)
        s3BucketArn = s3BucketArnDecoded
        let logPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logPrefix)
        logPrefix = logPrefixDecoded
    }
}

extension S3BucketLogDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3BucketLogDestination(kmsKeyArn: \(String(describing: kmsKeyArn)), logPrefix: \(String(describing: logPrefix)), s3BucketArn: \(String(describing: s3BucketArn)))"}
}

/// <p>Specifies an Amazon S3 bucket for logging audio conversations</p>
public struct S3BucketLogDestination: Equatable {
    /// <p>The Amazon Resource Name (ARN) of an AWS Key Management Service
    ///          (KMS) key for encrypting audio log files stored in an S3 bucket.</p>
    public let kmsKeyArn: String?
    /// <p>The S3 prefix to assign to audio log files.</p>
    public let logPrefix: String?
    /// <p>The Amazon Resource Name (ARN) of an Amazon S3 bucket where audio
    ///          log files are stored.</p>
    public let s3BucketArn: String?

    public init (
        kmsKeyArn: String? = nil,
        logPrefix: String? = nil,
        s3BucketArn: String? = nil
    )
    {
        self.kmsKeyArn = kmsKeyArn
        self.logPrefix = logPrefix
        self.s3BucketArn = s3BucketArn
    }
}

extension SSMLMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SSMLMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SSMLMessage(value: \(String(describing: value)))"}
}

/// <p>Defines a Speech Synthesis Markup Language (SSML) prompt.</p>
public struct SSMLMessage: Equatable {
    /// <p>The SSML text that defines the prompt.</p>
    public let value: String?

    public init (
        value: String? = nil
    )
    {
        self.value = value
    }
}

extension SampleUtterance: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case utterance
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let utterance = utterance {
            try encodeContainer.encode(utterance, forKey: .utterance)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let utteranceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .utterance)
        utterance = utteranceDecoded
    }
}

extension SampleUtterance: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SampleUtterance(utterance: \(String(describing: utterance)))"}
}

/// <p>A sample utterance that invokes an intent or respond to a slot
///          elicitation prompt.</p>
public struct SampleUtterance: Equatable {
    /// <p>The sample utterance that Amazon Lex uses to build its machine-learning
    ///          model to recognize intents.</p>
    public let utterance: String?

    public init (
        utterance: String? = nil
    )
    {
        self.utterance = utterance
    }
}

extension SampleValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SampleValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SampleValue(value: \(String(describing: value)))"}
}

/// <p>Defines one of the values for a slot type.</p>
public struct SampleValue: Equatable {
    /// <p>The value that can be used for a slot type.</p>
    public let value: String?

    public init (
        value: String? = nil
    )
    {
        self.value = value
    }
}

extension SentimentAnalysisSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detectSentiment
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if detectSentiment != false {
            try encodeContainer.encode(detectSentiment, forKey: .detectSentiment)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectSentimentDecoded = try containerValues.decode(Bool.self, forKey: .detectSentiment)
        detectSentiment = detectSentimentDecoded
    }
}

extension SentimentAnalysisSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SentimentAnalysisSettings(detectSentiment: \(String(describing: detectSentiment)))"}
}

/// <p>Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of
///          user utterances.</p>
public struct SentimentAnalysisSettings: Equatable {
    /// <p>Sets whether Amazon Lex uses Amazon Comprehend to detect the sentiment of user
    ///          utterances.</p>
    public let detectSentiment: Bool

    public init (
        detectSentiment: Bool = false
    )
    {
        self.detectSentiment = detectSentiment
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum SlotConstraint {
    case `optional`
    case `required`
    case sdkUnknown(String)
}

extension SlotConstraint : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SlotConstraint] {
        return [
            .optional,
            .required,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .optional: return "Optional"
        case .required: return "Required"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SlotConstraint(rawValue: rawValue) ?? SlotConstraint.sdkUnknown(rawValue)
    }
}

extension SlotDefaultValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultValue
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension SlotDefaultValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SlotDefaultValue(defaultValue: \(String(describing: defaultValue)))"}
}

/// <p>Specifies the default value to use when a user doesn't provide a
///          value for a slot.</p>
public struct SlotDefaultValue: Equatable {
    /// <p>The default value to use when a user doesn't provide a value for a
    ///          slot.</p>
    public let defaultValue: String?

    public init (
        defaultValue: String? = nil
    )
    {
        self.defaultValue = defaultValue
    }
}

extension SlotDefaultValueSpecification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultValueList
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValueList = defaultValueList {
            var defaultValueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .defaultValueList)
            for slotdefaultvaluelist0 in defaultValueList {
                try defaultValueListContainer.encode(slotdefaultvaluelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueListContainer = try containerValues.decodeIfPresent([SlotDefaultValue?].self, forKey: .defaultValueList)
        var defaultValueListDecoded0:[SlotDefaultValue]? = nil
        if let defaultValueListContainer = defaultValueListContainer {
            defaultValueListDecoded0 = [SlotDefaultValue]()
            for structure0 in defaultValueListContainer {
                if let structure0 = structure0 {
                    defaultValueListDecoded0?.append(structure0)
                }
            }
        }
        defaultValueList = defaultValueListDecoded0
    }
}

extension SlotDefaultValueSpecification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SlotDefaultValueSpecification(defaultValueList: \(String(describing: defaultValueList)))"}
}

/// <p>Defines a list of values that Amazon Lex should use as the default value
///          for a slot.</p>
public struct SlotDefaultValueSpecification: Equatable {
    /// <p>A list of default values. Amazon Lex chooses the default value to use in
    ///          the order that they are presented in the list.</p>
    public let defaultValueList: [SlotDefaultValue]?

    public init (
        defaultValueList: [SlotDefaultValue]? = nil
    )
    {
        self.defaultValueList = defaultValueList
    }
}

extension SlotFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(SlotFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(SlotFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension SlotFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SlotFilter(name: \(String(describing: name)), operator: \(String(describing: `operator`)), values: \(String(describing: values)))"}
}

/// <p>Filters the response from the <code>ListSlots</code>
///          operation.</p>
public struct SlotFilter: Equatable {
    /// <p>The operator to use for the filter. Specify <code>EQ</code> when the
    ///             <code>ListSlots</code> operation should return only aliases that
    ///          equal the specified value. Specify <code>CO</code> when the
    ///             <code>ListSlots</code> operation should return aliases that contain
    ///          the specified value.</p>
    public let `operator`: SlotFilterOperator?
    /// <p>The name of the field to use for filtering.</p>
    public let name: SlotFilterName?
    /// <p>The value to use to filter the response.</p>
    public let values: [String]?

    public init (
        `operator`: SlotFilterOperator? = nil,
        name: SlotFilterName? = nil,
        values: [String]? = nil
    )
    {
        self.`operator` = `operator`
        self.name = name
        self.values = values
    }
}

public enum SlotFilterName {
    case slotname
    case sdkUnknown(String)
}

extension SlotFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SlotFilterName] {
        return [
            .slotname,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .slotname: return "SlotName"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SlotFilterName(rawValue: rawValue) ?? SlotFilterName.sdkUnknown(rawValue)
    }
}

public enum SlotFilterOperator {
    case contains
    case equals
    case sdkUnknown(String)
}

extension SlotFilterOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SlotFilterOperator] {
        return [
            .contains,
            .equals,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .contains: return "CO"
        case .equals: return "EQ"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SlotFilterOperator(rawValue: rawValue) ?? SlotFilterOperator.sdkUnknown(rawValue)
    }
}

extension SlotPriority: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case priority
        case slotId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let slotId = slotId {
            try encodeContainer.encode(slotId, forKey: .slotId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let priorityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .priority)
        priority = priorityDecoded
        let slotIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotId)
        slotId = slotIdDecoded
    }
}

extension SlotPriority: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SlotPriority(priority: \(String(describing: priority)), slotId: \(String(describing: slotId)))"}
}

/// <p>Sets the priority that Amazon Lex should use when eliciting slot values
///          from a user.</p>
public struct SlotPriority: Equatable {
    /// <p>The priority that a slot should be elicited.</p>
    public let priority: Int?
    /// <p>The unique identifier of the slot.</p>
    public let slotId: String?

    public init (
        priority: Int? = nil,
        slotId: String? = nil
    )
    {
        self.priority = priority
        self.slotId = slotId
    }
}

public enum SlotSortAttribute {
    case lastupdateddatetime
    case slotname
    case sdkUnknown(String)
}

extension SlotSortAttribute : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SlotSortAttribute] {
        return [
            .lastupdateddatetime,
            .slotname,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .lastupdateddatetime: return "LastUpdatedDateTime"
        case .slotname: return "SlotName"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SlotSortAttribute(rawValue: rawValue) ?? SlotSortAttribute.sdkUnknown(rawValue)
    }
}

extension SlotSortBy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attribute
        case order
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let order = order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(SlotSortAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let orderDecoded = try containerValues.decodeIfPresent(SortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension SlotSortBy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SlotSortBy(attribute: \(String(describing: attribute)), order: \(String(describing: order)))"}
}

/// <p>Specifies attributes for sorting a list of bots.</p>
public struct SlotSortBy: Equatable {
    /// <p>The attribute to use to sort the list.</p>
    public let attribute: SlotSortAttribute?
    /// <p>The order to sort the list. You can choose ascending or
    ///          descending.</p>
    public let order: SortOrder?

    public init (
        attribute: SlotSortAttribute? = nil,
        order: SortOrder? = nil
    )
    {
        self.attribute = attribute
        self.order = order
    }
}

extension SlotSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case lastUpdatedDateTime
        case slotConstraint
        case slotId
        case slotName
        case slotTypeId
        case valueElicitationPromptSpecification
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let slotConstraint = slotConstraint {
            try encodeContainer.encode(slotConstraint.rawValue, forKey: .slotConstraint)
        }
        if let slotId = slotId {
            try encodeContainer.encode(slotId, forKey: .slotId)
        }
        if let slotName = slotName {
            try encodeContainer.encode(slotName, forKey: .slotName)
        }
        if let slotTypeId = slotTypeId {
            try encodeContainer.encode(slotTypeId, forKey: .slotTypeId)
        }
        if let valueElicitationPromptSpecification = valueElicitationPromptSpecification {
            try encodeContainer.encode(valueElicitationPromptSpecification, forKey: .valueElicitationPromptSpecification)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotId)
        slotId = slotIdDecoded
        let slotNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotName)
        slotName = slotNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let slotConstraintDecoded = try containerValues.decodeIfPresent(SlotConstraint.self, forKey: .slotConstraint)
        slotConstraint = slotConstraintDecoded
        let slotTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotTypeId)
        slotTypeId = slotTypeIdDecoded
        let valueElicitationPromptSpecificationDecoded = try containerValues.decodeIfPresent(PromptSpecification.self, forKey: .valueElicitationPromptSpecification)
        valueElicitationPromptSpecification = valueElicitationPromptSpecificationDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension SlotSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SlotSummary(description: \(String(describing: description)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), slotConstraint: \(String(describing: slotConstraint)), slotId: \(String(describing: slotId)), slotName: \(String(describing: slotName)), slotTypeId: \(String(describing: slotTypeId)), valueElicitationPromptSpecification: \(String(describing: valueElicitationPromptSpecification)))"}
}

/// <p>Summary information about a slot, a value that the bot elicits from
///          the user.</p>
public struct SlotSummary: Equatable {
    /// <p>The description of the slot.</p>
    public let description: String?
    /// <p>The timestamp of the last date and time that the slot was
    ///          updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>Whether the slot is required or optional. An intent is complete when
    ///          all required slots are filled.</p>
    public let slotConstraint: SlotConstraint?
    /// <p>The unique identifier of the slot.</p>
    public let slotId: String?
    /// <p>The name given to the slot.</p>
    public let slotName: String?
    /// <p>The unique identifier for the slot type that defines the values for
    ///          the slot.</p>
    public let slotTypeId: String?
    /// <p>Prompts that are sent to the user to elicit a value for the
    ///          slot.</p>
    public let valueElicitationPromptSpecification: PromptSpecification?

    public init (
        description: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        slotConstraint: SlotConstraint? = nil,
        slotId: String? = nil,
        slotName: String? = nil,
        slotTypeId: String? = nil,
        valueElicitationPromptSpecification: PromptSpecification? = nil
    )
    {
        self.description = description
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.slotConstraint = slotConstraint
        self.slotId = slotId
        self.slotName = slotName
        self.slotTypeId = slotTypeId
        self.valueElicitationPromptSpecification = valueElicitationPromptSpecification
    }
}

extension SlotTypeFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(SlotTypeFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(SlotTypeFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension SlotTypeFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SlotTypeFilter(name: \(String(describing: name)), operator: \(String(describing: `operator`)), values: \(String(describing: values)))"}
}

/// <p>Filters the response from the <code>ListSlotTypes</code>
///          operation.</p>
public struct SlotTypeFilter: Equatable {
    /// <p>The operator to use for the filter. Specify <code>EQ</code> when the
    ///             <code>ListSlotTypes</code> operation should return only aliases that
    ///          equal the specified value. Specify <code>CO</code> when the
    ///             <code>ListSlotTypes</code> operation should return aliases that
    ///          contain the specified value.</p>
    public let `operator`: SlotTypeFilterOperator?
    /// <p>The name of the field to use for filtering.</p>
    public let name: SlotTypeFilterName?
    /// <p>The value to use to filter the response.</p>
    public let values: [String]?

    public init (
        `operator`: SlotTypeFilterOperator? = nil,
        name: SlotTypeFilterName? = nil,
        values: [String]? = nil
    )
    {
        self.`operator` = `operator`
        self.name = name
        self.values = values
    }
}

public enum SlotTypeFilterName {
    case slottypename
    case sdkUnknown(String)
}

extension SlotTypeFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SlotTypeFilterName] {
        return [
            .slottypename,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .slottypename: return "SlotTypeName"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SlotTypeFilterName(rawValue: rawValue) ?? SlotTypeFilterName.sdkUnknown(rawValue)
    }
}

public enum SlotTypeFilterOperator {
    case contains
    case equals
    case sdkUnknown(String)
}

extension SlotTypeFilterOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SlotTypeFilterOperator] {
        return [
            .contains,
            .equals,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .contains: return "CO"
        case .equals: return "EQ"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SlotTypeFilterOperator(rawValue: rawValue) ?? SlotTypeFilterOperator.sdkUnknown(rawValue)
    }
}

public enum SlotTypeSortAttribute {
    case lastupdateddatetime
    case slottypename
    case sdkUnknown(String)
}

extension SlotTypeSortAttribute : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SlotTypeSortAttribute] {
        return [
            .lastupdateddatetime,
            .slottypename,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .lastupdateddatetime: return "LastUpdatedDateTime"
        case .slottypename: return "SlotTypeName"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SlotTypeSortAttribute(rawValue: rawValue) ?? SlotTypeSortAttribute.sdkUnknown(rawValue)
    }
}

extension SlotTypeSortBy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attribute
        case order
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let order = order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(SlotTypeSortAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let orderDecoded = try containerValues.decodeIfPresent(SortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension SlotTypeSortBy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SlotTypeSortBy(attribute: \(String(describing: attribute)), order: \(String(describing: order)))"}
}

/// <p>Specifies attributes for sorting a list of slot types.</p>
public struct SlotTypeSortBy: Equatable {
    /// <p>The attribute to use to sort the list of slot types.</p>
    public let attribute: SlotTypeSortAttribute?
    /// <p>The order to sort the list. You can say ascending or
    ///          descending.</p>
    public let order: SortOrder?

    public init (
        attribute: SlotTypeSortAttribute? = nil,
        order: SortOrder? = nil
    )
    {
        self.attribute = attribute
        self.order = order
    }
}

extension SlotTypeSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case lastUpdatedDateTime
        case parentSlotTypeSignature
        case slotTypeId
        case slotTypeName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let parentSlotTypeSignature = parentSlotTypeSignature {
            try encodeContainer.encode(parentSlotTypeSignature, forKey: .parentSlotTypeSignature)
        }
        if let slotTypeId = slotTypeId {
            try encodeContainer.encode(slotTypeId, forKey: .slotTypeId)
        }
        if let slotTypeName = slotTypeName {
            try encodeContainer.encode(slotTypeName, forKey: .slotTypeName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotTypeId)
        slotTypeId = slotTypeIdDecoded
        let slotTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotTypeName)
        slotTypeName = slotTypeNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let parentSlotTypeSignatureDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentSlotTypeSignature)
        parentSlotTypeSignature = parentSlotTypeSignatureDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension SlotTypeSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SlotTypeSummary(description: \(String(describing: description)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), parentSlotTypeSignature: \(String(describing: parentSlotTypeSignature)), slotTypeId: \(String(describing: slotTypeId)), slotTypeName: \(String(describing: slotTypeName)))"}
}

/// <p>Provides summary information about a slot type.</p>
public struct SlotTypeSummary: Equatable {
    /// <p>The description of the slot type.</p>
    public let description: String?
    /// <p>A timestamp of the date and time that the slot type was last
    ///          updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>If the slot type is derived from a built-on slot type, the name of
    ///          the parent slot type.</p>
    public let parentSlotTypeSignature: String?
    /// <p>The unique identifier assigned to the slot type.</p>
    public let slotTypeId: String?
    /// <p>The name of the slot type.</p>
    public let slotTypeName: String?

    public init (
        description: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        parentSlotTypeSignature: String? = nil,
        slotTypeId: String? = nil,
        slotTypeName: String? = nil
    )
    {
        self.description = description
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.parentSlotTypeSignature = parentSlotTypeSignature
        self.slotTypeId = slotTypeId
        self.slotTypeName = slotTypeName
    }
}

extension SlotTypeValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sampleValue
        case synonyms
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sampleValue = sampleValue {
            try encodeContainer.encode(sampleValue, forKey: .sampleValue)
        }
        if let synonyms = synonyms {
            var synonymsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .synonyms)
            for synonymlist0 in synonyms {
                try synonymsContainer.encode(synonymlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sampleValueDecoded = try containerValues.decodeIfPresent(SampleValue.self, forKey: .sampleValue)
        sampleValue = sampleValueDecoded
        let synonymsContainer = try containerValues.decodeIfPresent([SampleValue?].self, forKey: .synonyms)
        var synonymsDecoded0:[SampleValue]? = nil
        if let synonymsContainer = synonymsContainer {
            synonymsDecoded0 = [SampleValue]()
            for structure0 in synonymsContainer {
                if let structure0 = structure0 {
                    synonymsDecoded0?.append(structure0)
                }
            }
        }
        synonyms = synonymsDecoded0
    }
}

extension SlotTypeValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SlotTypeValue(sampleValue: \(String(describing: sampleValue)), synonyms: \(String(describing: synonyms)))"}
}

/// <p>Each slot type can have a set of values. Each
///             <code>SlotTypeValue</code> represents a value that the slot type can
///          take.</p>
public struct SlotTypeValue: Equatable {
    /// <p>The value of the slot type entry.</p>
    public let sampleValue: SampleValue?
    /// <p>Additional values releated to the slot type entry.</p>
    public let synonyms: [SampleValue]?

    public init (
        sampleValue: SampleValue? = nil,
        synonyms: [SampleValue]? = nil
    )
    {
        self.sampleValue = sampleValue
        self.synonyms = synonyms
    }
}

extension SlotValueElicitationSetting: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultValueSpecification
        case promptSpecification
        case sampleUtterances
        case slotConstraint
        case waitAndContinueSpecification
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValueSpecification = defaultValueSpecification {
            try encodeContainer.encode(defaultValueSpecification, forKey: .defaultValueSpecification)
        }
        if let promptSpecification = promptSpecification {
            try encodeContainer.encode(promptSpecification, forKey: .promptSpecification)
        }
        if let sampleUtterances = sampleUtterances {
            var sampleUtterancesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sampleUtterances)
            for sampleutteranceslist0 in sampleUtterances {
                try sampleUtterancesContainer.encode(sampleutteranceslist0)
            }
        }
        if let slotConstraint = slotConstraint {
            try encodeContainer.encode(slotConstraint.rawValue, forKey: .slotConstraint)
        }
        if let waitAndContinueSpecification = waitAndContinueSpecification {
            try encodeContainer.encode(waitAndContinueSpecification, forKey: .waitAndContinueSpecification)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueSpecificationDecoded = try containerValues.decodeIfPresent(SlotDefaultValueSpecification.self, forKey: .defaultValueSpecification)
        defaultValueSpecification = defaultValueSpecificationDecoded
        let slotConstraintDecoded = try containerValues.decodeIfPresent(SlotConstraint.self, forKey: .slotConstraint)
        slotConstraint = slotConstraintDecoded
        let promptSpecificationDecoded = try containerValues.decodeIfPresent(PromptSpecification.self, forKey: .promptSpecification)
        promptSpecification = promptSpecificationDecoded
        let sampleUtterancesContainer = try containerValues.decodeIfPresent([SampleUtterance?].self, forKey: .sampleUtterances)
        var sampleUtterancesDecoded0:[SampleUtterance]? = nil
        if let sampleUtterancesContainer = sampleUtterancesContainer {
            sampleUtterancesDecoded0 = [SampleUtterance]()
            for structure0 in sampleUtterancesContainer {
                if let structure0 = structure0 {
                    sampleUtterancesDecoded0?.append(structure0)
                }
            }
        }
        sampleUtterances = sampleUtterancesDecoded0
        let waitAndContinueSpecificationDecoded = try containerValues.decodeIfPresent(WaitAndContinueSpecification.self, forKey: .waitAndContinueSpecification)
        waitAndContinueSpecification = waitAndContinueSpecificationDecoded
    }
}

extension SlotValueElicitationSetting: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SlotValueElicitationSetting(defaultValueSpecification: \(String(describing: defaultValueSpecification)), promptSpecification: \(String(describing: promptSpecification)), sampleUtterances: \(String(describing: sampleUtterances)), slotConstraint: \(String(describing: slotConstraint)), waitAndContinueSpecification: \(String(describing: waitAndContinueSpecification)))"}
}

/// <p>Settings that you can use for eliciting a slot value.</p>
public struct SlotValueElicitationSetting: Equatable {
    /// <p>A list of default values for a slot. Default values are used when
    ///          Amazon Lex hasn't determined a value for a slot. You can specify default
    ///          values from context variables, sesion attributes, and defined
    ///          values.</p>
    public let defaultValueSpecification: SlotDefaultValueSpecification?
    /// <p>The prompt that Amazon Lex uses to elicit the slot value from the
    ///          user.</p>
    public let promptSpecification: PromptSpecification?
    /// <p>If you know a specific pattern that users might respond to an Amazon Lex
    ///          request for a slot value, you can provide those utterances to improve
    ///          accuracy. This is optional. In most cases, Amazon Lex is capable of
    ///          understanding user utterances.</p>
    public let sampleUtterances: [SampleUtterance]?
    /// <p>Specifies whether the slot is required or optional.</p>
    public let slotConstraint: SlotConstraint?
    /// <p>Specifies the prompts that Amazon Lex uses while a bot is waiting for
    ///          customer input. </p>
    public let waitAndContinueSpecification: WaitAndContinueSpecification?

    public init (
        defaultValueSpecification: SlotDefaultValueSpecification? = nil,
        promptSpecification: PromptSpecification? = nil,
        sampleUtterances: [SampleUtterance]? = nil,
        slotConstraint: SlotConstraint? = nil,
        waitAndContinueSpecification: WaitAndContinueSpecification? = nil
    )
    {
        self.defaultValueSpecification = defaultValueSpecification
        self.promptSpecification = promptSpecification
        self.sampleUtterances = sampleUtterances
        self.slotConstraint = slotConstraint
        self.waitAndContinueSpecification = waitAndContinueSpecification
    }
}

extension SlotValueRegexFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pattern
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pattern = pattern {
            try encodeContainer.encode(pattern, forKey: .pattern)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pattern)
        pattern = patternDecoded
    }
}

extension SlotValueRegexFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SlotValueRegexFilter(pattern: \(String(describing: pattern)))"}
}

/// <p>Provides a regular expression used to validate the value of a
///          slot.</p>
public struct SlotValueRegexFilter: Equatable {
    /// <p>A regular expression used to validate the value of a slot.</p>
    ///          <p> Use a standard regular expression. Amazon Lex supports the
    ///          following characters in the regular expression: </p>
    ///          <ul>
    ///             <li>
    ///                <p>A-Z, a-z</p>
    ///             </li>
    ///             <li>
    ///                <p>0-9</p>
    ///             </li>
    ///             <li>
    ///                <p>Unicode characters ("\ u<Unicode>")</p>
    ///             </li>
    ///          </ul>
    ///          <p> Represent Unicode characters with four digits, for example "\u0041"
    ///          or "\u005A". </p>
    ///          <p> The following regular expression operators are not supported: </p>
    ///          <ul>
    ///             <li>
    ///                <p>Infinite repeaters: *, +, or {x,} with no upper bound.</p>
    ///             </li>
    ///             <li>
    ///                <p>Wild card (.)</p>
    ///             </li>
    ///          </ul>
    public let pattern: String?

    public init (
        pattern: String? = nil
    )
    {
        self.pattern = pattern
    }
}

public enum SlotValueResolutionStrategy {
    case originalvalue
    case topresolution
    case sdkUnknown(String)
}

extension SlotValueResolutionStrategy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SlotValueResolutionStrategy] {
        return [
            .originalvalue,
            .topresolution,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .originalvalue: return "OriginalValue"
        case .topresolution: return "TopResolution"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SlotValueResolutionStrategy(rawValue: rawValue) ?? SlotValueResolutionStrategy.sdkUnknown(rawValue)
    }
}

extension SlotValueSelectionSetting: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case regexFilter
        case resolutionStrategy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let regexFilter = regexFilter {
            try encodeContainer.encode(regexFilter, forKey: .regexFilter)
        }
        if let resolutionStrategy = resolutionStrategy {
            try encodeContainer.encode(resolutionStrategy.rawValue, forKey: .resolutionStrategy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolutionStrategyDecoded = try containerValues.decodeIfPresent(SlotValueResolutionStrategy.self, forKey: .resolutionStrategy)
        resolutionStrategy = resolutionStrategyDecoded
        let regexFilterDecoded = try containerValues.decodeIfPresent(SlotValueRegexFilter.self, forKey: .regexFilter)
        regexFilter = regexFilterDecoded
    }
}

extension SlotValueSelectionSetting: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SlotValueSelectionSetting(regexFilter: \(String(describing: regexFilter)), resolutionStrategy: \(String(describing: resolutionStrategy)))"}
}

/// <p>Contains settings used by Amazon Lex to select a slot value.</p>
public struct SlotValueSelectionSetting: Equatable {
    /// <p>A regular expression used to validate the value of a slot.</p>
    public let regexFilter: SlotValueRegexFilter?
    /// <p>Determines the slot resolution strategy that Amazon Lex uses to
    ///          return slot type values. The field can be set to one of the following
    ///          values:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>OriginalValue - Returns the value entered by the user, if the
    ///                user value is similar to the slot value.</p>
    ///             </li>
    ///             <li>
    ///                <p>TopResolution - If there is a resolution list for the slot,
    ///                return the first value in the resolution list as the slot type
    ///                value. If there is no resolution list, null is returned.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>If you don't specify the valueSelectionStrategy, the default is
    ///          OriginalValue. </p>
    public let resolutionStrategy: SlotValueResolutionStrategy?

    public init (
        regexFilter: SlotValueRegexFilter? = nil,
        resolutionStrategy: SlotValueResolutionStrategy? = nil
    )
    {
        self.regexFilter = regexFilter
        self.resolutionStrategy = resolutionStrategy
    }
}

public enum SortOrder {
    case ascending
    case descending
    case sdkUnknown(String)
}

extension SortOrder : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SortOrder] {
        return [
            .ascending,
            .descending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ascending: return "Ascending"
        case .descending: return "Descending"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
    }
}

public struct StartImportInputBodyMiddleware: Middleware {
    public let id: String = "StartImportInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartImportInput>,
                  next: H) -> Swift.Result<OperationOutput<StartImportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartImportInput>
    public typealias MOutput = OperationOutput<StartImportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartImportOutputError>
}

extension StartImportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartImportInput(filePassword: \(String(describing: filePassword)), importId: \(String(describing: importId)), mergeStrategy: \(String(describing: mergeStrategy)), resourceSpecification: \(String(describing: resourceSpecification)))"}
}

extension StartImportInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filePassword
        case importId
        case mergeStrategy
        case resourceSpecification
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filePassword = filePassword {
            try encodeContainer.encode(filePassword, forKey: .filePassword)
        }
        if let importId = importId {
            try encodeContainer.encode(importId, forKey: .importId)
        }
        if let mergeStrategy = mergeStrategy {
            try encodeContainer.encode(mergeStrategy.rawValue, forKey: .mergeStrategy)
        }
        if let resourceSpecification = resourceSpecification {
            try encodeContainer.encode(resourceSpecification, forKey: .resourceSpecification)
        }
    }
}

public struct StartImportInputHeadersMiddleware: Middleware {
    public let id: String = "StartImportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartImportInput>,
                  next: H) -> Swift.Result<OperationOutput<StartImportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartImportInput>
    public typealias MOutput = OperationOutput<StartImportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartImportOutputError>
}

public struct StartImportInputQueryItemMiddleware: Middleware {
    public let id: String = "StartImportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartImportInput>,
                  next: H) -> Swift.Result<OperationOutput<StartImportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartImportInput>
    public typealias MOutput = OperationOutput<StartImportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartImportOutputError>
}

public struct StartImportInput: Equatable {
    /// <p>The password used to encrypt the zip archive that contains the bot
    ///          or bot locale definition. You should always encrypt the zip archive to
    ///          protect it during transit between your site and Amazon Lex.</p>
    public let filePassword: String?
    /// <p>The unique identifier for the import. It is included in the response
    ///          from the  operation.</p>
    public let importId: String?
    /// <p>The strategy to use when there is a name conflict between the
    ///          imported resource and an existing resource. When the merge strategy is
    ///             <code>FailOnConflict</code> existing resources are not overwritten
    ///          and the import fails.</p>
    public let mergeStrategy: MergeStrategy?
    /// <p>Parameters for creating the bot or bot locale.</p>
    public let resourceSpecification: ImportResourceSpecification?

    public init (
        filePassword: String? = nil,
        importId: String? = nil,
        mergeStrategy: MergeStrategy? = nil,
        resourceSpecification: ImportResourceSpecification? = nil
    )
    {
        self.filePassword = filePassword
        self.importId = importId
        self.mergeStrategy = mergeStrategy
        self.resourceSpecification = resourceSpecification
    }
}

struct StartImportInputBody: Equatable {
    public let importId: String?
    public let resourceSpecification: ImportResourceSpecification?
    public let mergeStrategy: MergeStrategy?
    public let filePassword: String?
}

extension StartImportInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filePassword
        case importId
        case mergeStrategy
        case resourceSpecification
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .importId)
        importId = importIdDecoded
        let resourceSpecificationDecoded = try containerValues.decodeIfPresent(ImportResourceSpecification.self, forKey: .resourceSpecification)
        resourceSpecification = resourceSpecificationDecoded
        let mergeStrategyDecoded = try containerValues.decodeIfPresent(MergeStrategy.self, forKey: .mergeStrategy)
        mergeStrategy = mergeStrategyDecoded
        let filePasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filePassword)
        filePassword = filePasswordDecoded
    }
}

extension StartImportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartImportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartImportOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartImportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartImportOutputResponse(creationDateTime: \(String(describing: creationDateTime)), importId: \(String(describing: importId)), importStatus: \(String(describing: importStatus)), mergeStrategy: \(String(describing: mergeStrategy)), resourceSpecification: \(String(describing: resourceSpecification)))"}
}

extension StartImportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartImportOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.creationDateTime = output.creationDateTime
            self.importId = output.importId
            self.importStatus = output.importStatus
            self.mergeStrategy = output.mergeStrategy
            self.resourceSpecification = output.resourceSpecification
        } else {
            self.creationDateTime = nil
            self.importId = nil
            self.importStatus = nil
            self.mergeStrategy = nil
            self.resourceSpecification = nil
        }
    }
}

public struct StartImportOutputResponse: Equatable {
    /// <p>The date and time that the import request was created.</p>
    public let creationDateTime: Date?
    /// <p>A unique identifier for the import.</p>
    public let importId: String?
    /// <p>The current status of the import. When the status is
    ///             <code>Complete</code> the bot or bot alias is ready to use.</p>
    public let importStatus: ImportStatus?
    /// <p>The strategy used when there was a name conflict between the
    ///          imported resource and an existing resource. When the merge strategy is
    ///             <code>FailOnConflict</code> existing resources are not overwritten
    ///          and the import fails.</p>
    public let mergeStrategy: MergeStrategy?
    /// <p>The parameters used when importing the bot or bot locale.</p>
    public let resourceSpecification: ImportResourceSpecification?

    public init (
        creationDateTime: Date? = nil,
        importId: String? = nil,
        importStatus: ImportStatus? = nil,
        mergeStrategy: MergeStrategy? = nil,
        resourceSpecification: ImportResourceSpecification? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.importId = importId
        self.importStatus = importStatus
        self.mergeStrategy = mergeStrategy
        self.resourceSpecification = resourceSpecification
    }
}

struct StartImportOutputResponseBody: Equatable {
    public let importId: String?
    public let resourceSpecification: ImportResourceSpecification?
    public let mergeStrategy: MergeStrategy?
    public let importStatus: ImportStatus?
    public let creationDateTime: Date?
}

extension StartImportOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationDateTime
        case importId
        case importStatus
        case mergeStrategy
        case resourceSpecification
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .importId)
        importId = importIdDecoded
        let resourceSpecificationDecoded = try containerValues.decodeIfPresent(ImportResourceSpecification.self, forKey: .resourceSpecification)
        resourceSpecification = resourceSpecificationDecoded
        let mergeStrategyDecoded = try containerValues.decodeIfPresent(MergeStrategy.self, forKey: .mergeStrategy)
        mergeStrategy = mergeStrategyDecoded
        let importStatusDecoded = try containerValues.decodeIfPresent(ImportStatus.self, forKey: .importStatus)
        importStatus = importStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
    }
}

extension StillWaitingResponseSpecification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowInterrupt
        case frequencyInSeconds
        case messageGroups
        case timeoutInSeconds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowInterrupt = allowInterrupt {
            try encodeContainer.encode(allowInterrupt, forKey: .allowInterrupt)
        }
        if let frequencyInSeconds = frequencyInSeconds {
            try encodeContainer.encode(frequencyInSeconds, forKey: .frequencyInSeconds)
        }
        if let messageGroups = messageGroups {
            var messageGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .messageGroups)
            for messagegroupslist0 in messageGroups {
                try messageGroupsContainer.encode(messagegroupslist0)
            }
        }
        if let timeoutInSeconds = timeoutInSeconds {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageGroupsContainer = try containerValues.decodeIfPresent([MessageGroup?].self, forKey: .messageGroups)
        var messageGroupsDecoded0:[MessageGroup]? = nil
        if let messageGroupsContainer = messageGroupsContainer {
            messageGroupsDecoded0 = [MessageGroup]()
            for structure0 in messageGroupsContainer {
                if let structure0 = structure0 {
                    messageGroupsDecoded0?.append(structure0)
                }
            }
        }
        messageGroups = messageGroupsDecoded0
        let frequencyInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .frequencyInSeconds)
        frequencyInSeconds = frequencyInSecondsDecoded
        let timeoutInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
        let allowInterruptDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowInterrupt)
        allowInterrupt = allowInterruptDecoded
    }
}

extension StillWaitingResponseSpecification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StillWaitingResponseSpecification(allowInterrupt: \(String(describing: allowInterrupt)), frequencyInSeconds: \(String(describing: frequencyInSeconds)), messageGroups: \(String(describing: messageGroups)), timeoutInSeconds: \(String(describing: timeoutInSeconds)))"}
}

/// <p>Defines the messages that Amazon Lex sends to a user to remind them that
///          the bot is waiting for a response.</p>
public struct StillWaitingResponseSpecification: Equatable {
    /// <p>Indicates that the user can interrupt the response by speaking while
    ///          the message is being played.</p>
    public let allowInterrupt: Bool?
    /// <p>How often a message should be sent to the user. Minimum of 1 second,
    ///          maximum of 5 minutes.</p>
    public let frequencyInSeconds: Int?
    /// <p>One or more message groups, each containing one or more messages,
    ///          that define the prompts that Amazon Lex sends to the user.</p>
    public let messageGroups: [MessageGroup]?
    /// <p>If Amazon Lex waits longer than this length of time for a response, it
    ///          will stop sending messages.</p>
    public let timeoutInSeconds: Int?

    public init (
        allowInterrupt: Bool? = nil,
        frequencyInSeconds: Int? = nil,
        messageGroups: [MessageGroup]? = nil,
        timeoutInSeconds: Int? = nil
    )
    {
        self.allowInterrupt = allowInterrupt
        self.frequencyInSeconds = frequencyInSeconds
        self.messageGroups = messageGroups
        self.timeoutInSeconds = timeoutInSeconds
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceARN: \(String(describing: resourceARN)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the bot, bot alias, or bot channel
    ///          to tag.</p>
    public let resourceARN: String?
    /// <p>A list of tag keys to add to the resource. If a tag key already
    ///          exists, the existing value is replaced with the new value.</p>
    public let tags: [String:String]?

    public init (
        resourceARN: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TextLogDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatch
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatch = cloudWatch {
            try encodeContainer.encode(cloudWatch, forKey: .cloudWatch)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchDecoded = try containerValues.decodeIfPresent(CloudWatchLogGroupLogDestination.self, forKey: .cloudWatch)
        cloudWatch = cloudWatchDecoded
    }
}

extension TextLogDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TextLogDestination(cloudWatch: \(String(describing: cloudWatch)))"}
}

/// <p>Defines the Amazon CloudWatch Logs destination log group for
///          conversation text logs.</p>
public struct TextLogDestination: Equatable {
    /// <p>Defines the Amazon CloudWatch Logs log group where text and metadata logs are
    ///          delivered.</p>
    public let cloudWatch: CloudWatchLogGroupLogDestination?

    public init (
        cloudWatch: CloudWatchLogGroupLogDestination? = nil
    )
    {
        self.cloudWatch = cloudWatch
    }
}

extension TextLogSetting: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destination
        case enabled
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(TextLogDestination.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension TextLogSetting: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TextLogSetting(destination: \(String(describing: destination)), enabled: \(String(describing: enabled)))"}
}

/// <p>Defines settings to enable text conversation logs.</p>
public struct TextLogSetting: Equatable {
    /// <p>Defines the Amazon CloudWatch Logs destination log group for
    ///          conversation text logs.</p>
    public let destination: TextLogDestination?
    /// <p>Determines whether conversation logs should be stored for an
    ///          alias.</p>
    public let enabled: Bool

    public init (
        destination: TextLogDestination? = nil,
        enabled: Bool = false
    )
    {
        self.destination = destination
        self.enabled = enabled
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)), retryAfterSeconds: \(String(describing: retryAfterSeconds)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var retryAfterSeconds: Int

    public init (
        message: String? = nil,
        retryAfterSeconds: Int = 0
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceARN: \(String(describing: resourceARN)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource to remove the tags
    ///          from.</p>
    public let resourceARN: String?
    /// <p>A list of tag keys to remove from the resource. If a tag key does
    ///          not exist on the resource, it is ignored.</p>
    public let tagKeys: [String]?

    public init (
        resourceARN: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateBotAliasInputBodyMiddleware: Middleware {
    public let id: String = "UpdateBotAliasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBotAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBotAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBotAliasInput>
    public typealias MOutput = OperationOutput<UpdateBotAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBotAliasOutputError>
}

extension UpdateBotAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBotAliasInput(botAliasId: \(String(describing: botAliasId)), botAliasLocaleSettings: \(String(describing: botAliasLocaleSettings)), botAliasName: \(String(describing: botAliasName)), botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), conversationLogSettings: \(String(describing: conversationLogSettings)), description: \(String(describing: description)), sentimentAnalysisSettings: \(String(describing: sentimentAnalysisSettings)))"}
}

extension UpdateBotAliasInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case botAliasLocaleSettings
        case botAliasName
        case botVersion
        case conversationLogSettings
        case description
        case sentimentAnalysisSettings
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botAliasLocaleSettings = botAliasLocaleSettings {
            var botAliasLocaleSettingsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .botAliasLocaleSettings)
            for (dictKey0, botaliaslocalesettingsmap0) in botAliasLocaleSettings {
                try botAliasLocaleSettingsContainer.encode(botaliaslocalesettingsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let botAliasName = botAliasName {
            try encodeContainer.encode(botAliasName, forKey: .botAliasName)
        }
        if let botVersion = botVersion {
            try encodeContainer.encode(botVersion, forKey: .botVersion)
        }
        if let conversationLogSettings = conversationLogSettings {
            try encodeContainer.encode(conversationLogSettings, forKey: .conversationLogSettings)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let sentimentAnalysisSettings = sentimentAnalysisSettings {
            try encodeContainer.encode(sentimentAnalysisSettings, forKey: .sentimentAnalysisSettings)
        }
    }
}

public struct UpdateBotAliasInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateBotAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBotAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBotAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBotAliasInput>
    public typealias MOutput = OperationOutput<UpdateBotAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBotAliasOutputError>
}

public struct UpdateBotAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateBotAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBotAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBotAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBotAliasInput>
    public typealias MOutput = OperationOutput<UpdateBotAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBotAliasOutputError>
}

public struct UpdateBotAliasInput: Equatable {
    /// <p>The unique identifier of the bot alias.</p>
    public let botAliasId: String?
    /// <p>The new Lambda functions to use in each locale for the bot
    ///          alias.</p>
    public let botAliasLocaleSettings: [String:BotAliasLocaleSettings]?
    /// <p>The new name to assign to the bot alias.</p>
    public let botAliasName: String?
    /// <p>The identifier of the bot with the updated alias.</p>
    public let botId: String?
    /// <p>The new bot version to assign to the bot alias.</p>
    public let botVersion: String?
    /// <p>The new settings for storing conversation logs in Amazon CloudWatch Logs and
    ///          Amazon S3 buckets.</p>
    public let conversationLogSettings: ConversationLogSettings?
    /// <p>The new description to assign to the bot alias.</p>
    public let description: String?
    /// <p>Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of
    ///          user utterances.</p>
    public let sentimentAnalysisSettings: SentimentAnalysisSettings?

    public init (
        botAliasId: String? = nil,
        botAliasLocaleSettings: [String:BotAliasLocaleSettings]? = nil,
        botAliasName: String? = nil,
        botId: String? = nil,
        botVersion: String? = nil,
        conversationLogSettings: ConversationLogSettings? = nil,
        description: String? = nil,
        sentimentAnalysisSettings: SentimentAnalysisSettings? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botAliasLocaleSettings = botAliasLocaleSettings
        self.botAliasName = botAliasName
        self.botId = botId
        self.botVersion = botVersion
        self.conversationLogSettings = conversationLogSettings
        self.description = description
        self.sentimentAnalysisSettings = sentimentAnalysisSettings
    }
}

struct UpdateBotAliasInputBody: Equatable {
    public let botAliasName: String?
    public let description: String?
    public let botVersion: String?
    public let botAliasLocaleSettings: [String:BotAliasLocaleSettings]?
    public let conversationLogSettings: ConversationLogSettings?
    public let sentimentAnalysisSettings: SentimentAnalysisSettings?
}

extension UpdateBotAliasInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botAliasLocaleSettings
        case botAliasName
        case botVersion
        case conversationLogSettings
        case description
        case sentimentAnalysisSettings
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botAliasNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botAliasName)
        botAliasName = botAliasNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let botAliasLocaleSettingsContainer = try containerValues.decodeIfPresent([String: BotAliasLocaleSettings?].self, forKey: .botAliasLocaleSettings)
        var botAliasLocaleSettingsDecoded0: [String:BotAliasLocaleSettings]? = nil
        if let botAliasLocaleSettingsContainer = botAliasLocaleSettingsContainer {
            botAliasLocaleSettingsDecoded0 = [String:BotAliasLocaleSettings]()
            for (key0, botaliaslocalesettings0) in botAliasLocaleSettingsContainer {
                if let botaliaslocalesettings0 = botaliaslocalesettings0 {
                    botAliasLocaleSettingsDecoded0?[key0] = botaliaslocalesettings0
                }
            }
        }
        botAliasLocaleSettings = botAliasLocaleSettingsDecoded0
        let conversationLogSettingsDecoded = try containerValues.decodeIfPresent(ConversationLogSettings.self, forKey: .conversationLogSettings)
        conversationLogSettings = conversationLogSettingsDecoded
        let sentimentAnalysisSettingsDecoded = try containerValues.decodeIfPresent(SentimentAnalysisSettings.self, forKey: .sentimentAnalysisSettings)
        sentimentAnalysisSettings = sentimentAnalysisSettingsDecoded
    }
}

extension UpdateBotAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBotAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBotAliasOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case preconditionFailedException(PreconditionFailedException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBotAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBotAliasOutputResponse(botAliasId: \(String(describing: botAliasId)), botAliasLocaleSettings: \(String(describing: botAliasLocaleSettings)), botAliasName: \(String(describing: botAliasName)), botAliasStatus: \(String(describing: botAliasStatus)), botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), conversationLogSettings: \(String(describing: conversationLogSettings)), creationDateTime: \(String(describing: creationDateTime)), description: \(String(describing: description)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), sentimentAnalysisSettings: \(String(describing: sentimentAnalysisSettings)))"}
}

extension UpdateBotAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateBotAliasOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botAliasId = output.botAliasId
            self.botAliasLocaleSettings = output.botAliasLocaleSettings
            self.botAliasName = output.botAliasName
            self.botAliasStatus = output.botAliasStatus
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.conversationLogSettings = output.conversationLogSettings
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.sentimentAnalysisSettings = output.sentimentAnalysisSettings
        } else {
            self.botAliasId = nil
            self.botAliasLocaleSettings = nil
            self.botAliasName = nil
            self.botAliasStatus = nil
            self.botId = nil
            self.botVersion = nil
            self.conversationLogSettings = nil
            self.creationDateTime = nil
            self.description = nil
            self.lastUpdatedDateTime = nil
            self.sentimentAnalysisSettings = nil
        }
    }
}

public struct UpdateBotAliasOutputResponse: Equatable {
    /// <p>The identifier of the updated bot alias.</p>
    public let botAliasId: String?
    /// <p>The updated Lambda functions to use in each locale for the bot
    ///          alias.</p>
    public let botAliasLocaleSettings: [String:BotAliasLocaleSettings]?
    /// <p>The updated name of the bot alias.</p>
    public let botAliasName: String?
    /// <p>The current status of the bot alias. When the status is
    ///             <code>Available</code> the alias is ready for use.</p>
    public let botAliasStatus: BotAliasStatus?
    /// <p>The identifier of the bot with the updated alias.</p>
    public let botId: String?
    /// <p>The updated version of the bot that the alias points to.</p>
    public let botVersion: String?
    /// <p>The updated settings for storing conversation logs in Amazon CloudWatch Logs and
    ///          Amazon S3 buckets.</p>
    public let conversationLogSettings: ConversationLogSettings?
    /// <p>A timestamp of the date and time that the bot was created.</p>
    public let creationDateTime: Date?
    /// <p>The updated description of the bot alias.</p>
    public let description: String?
    /// <p>A timestamp of the date and time that the bot was last
    ///          updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of
    ///          user utterances.</p>
    public let sentimentAnalysisSettings: SentimentAnalysisSettings?

    public init (
        botAliasId: String? = nil,
        botAliasLocaleSettings: [String:BotAliasLocaleSettings]? = nil,
        botAliasName: String? = nil,
        botAliasStatus: BotAliasStatus? = nil,
        botId: String? = nil,
        botVersion: String? = nil,
        conversationLogSettings: ConversationLogSettings? = nil,
        creationDateTime: Date? = nil,
        description: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        sentimentAnalysisSettings: SentimentAnalysisSettings? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botAliasLocaleSettings = botAliasLocaleSettings
        self.botAliasName = botAliasName
        self.botAliasStatus = botAliasStatus
        self.botId = botId
        self.botVersion = botVersion
        self.conversationLogSettings = conversationLogSettings
        self.creationDateTime = creationDateTime
        self.description = description
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.sentimentAnalysisSettings = sentimentAnalysisSettings
    }
}

struct UpdateBotAliasOutputResponseBody: Equatable {
    public let botAliasId: String?
    public let botAliasName: String?
    public let description: String?
    public let botVersion: String?
    public let botAliasLocaleSettings: [String:BotAliasLocaleSettings]?
    public let conversationLogSettings: ConversationLogSettings?
    public let sentimentAnalysisSettings: SentimentAnalysisSettings?
    public let botAliasStatus: BotAliasStatus?
    public let botId: String?
    public let creationDateTime: Date?
    public let lastUpdatedDateTime: Date?
}

extension UpdateBotAliasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botAliasId
        case botAliasLocaleSettings
        case botAliasName
        case botAliasStatus
        case botId
        case botVersion
        case conversationLogSettings
        case creationDateTime
        case description
        case lastUpdatedDateTime
        case sentimentAnalysisSettings
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botAliasIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botAliasId)
        botAliasId = botAliasIdDecoded
        let botAliasNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botAliasName)
        botAliasName = botAliasNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let botAliasLocaleSettingsContainer = try containerValues.decodeIfPresent([String: BotAliasLocaleSettings?].self, forKey: .botAliasLocaleSettings)
        var botAliasLocaleSettingsDecoded0: [String:BotAliasLocaleSettings]? = nil
        if let botAliasLocaleSettingsContainer = botAliasLocaleSettingsContainer {
            botAliasLocaleSettingsDecoded0 = [String:BotAliasLocaleSettings]()
            for (key0, botaliaslocalesettings0) in botAliasLocaleSettingsContainer {
                if let botaliaslocalesettings0 = botaliaslocalesettings0 {
                    botAliasLocaleSettingsDecoded0?[key0] = botaliaslocalesettings0
                }
            }
        }
        botAliasLocaleSettings = botAliasLocaleSettingsDecoded0
        let conversationLogSettingsDecoded = try containerValues.decodeIfPresent(ConversationLogSettings.self, forKey: .conversationLogSettings)
        conversationLogSettings = conversationLogSettingsDecoded
        let sentimentAnalysisSettingsDecoded = try containerValues.decodeIfPresent(SentimentAnalysisSettings.self, forKey: .sentimentAnalysisSettings)
        sentimentAnalysisSettings = sentimentAnalysisSettingsDecoded
        let botAliasStatusDecoded = try containerValues.decodeIfPresent(BotAliasStatus.self, forKey: .botAliasStatus)
        botAliasStatus = botAliasStatusDecoded
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

public struct UpdateBotInputBodyMiddleware: Middleware {
    public let id: String = "UpdateBotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBotInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBotInput>
    public typealias MOutput = OperationOutput<UpdateBotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBotOutputError>
}

extension UpdateBotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBotInput(botId: \(String(describing: botId)), botName: \(String(describing: botName)), dataPrivacy: \(String(describing: dataPrivacy)), description: \(String(describing: description)), idleSessionTTLInSeconds: \(String(describing: idleSessionTTLInSeconds)), roleArn: \(String(describing: roleArn)))"}
}

extension UpdateBotInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case botName
        case dataPrivacy
        case description
        case idleSessionTTLInSeconds
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botName = botName {
            try encodeContainer.encode(botName, forKey: .botName)
        }
        if let dataPrivacy = dataPrivacy {
            try encodeContainer.encode(dataPrivacy, forKey: .dataPrivacy)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let idleSessionTTLInSeconds = idleSessionTTLInSeconds {
            try encodeContainer.encode(idleSessionTTLInSeconds, forKey: .idleSessionTTLInSeconds)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

public struct UpdateBotInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateBotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBotInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBotInput>
    public typealias MOutput = OperationOutput<UpdateBotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBotOutputError>
}

public struct UpdateBotInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateBotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBotInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBotInput>
    public typealias MOutput = OperationOutput<UpdateBotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBotOutputError>
}

public struct UpdateBotInput: Equatable {
    /// <p>The unique identifier of the bot to update. This identifier is
    ///          returned by the <a>CreateBot</a> operation.</p>
    public let botId: String?
    /// <p>The new name of the bot. The name must be unique in the account that
    ///          creates the bot.</p>
    public let botName: String?
    /// <p>Provides information on additional privacy protections Amazon Lex should
    ///          use with the bot's data.</p>
    public let dataPrivacy: DataPrivacy?
    /// <p>A description of the bot.</p>
    public let description: String?
    /// <p>The time, in seconds, that Amazon Lex should keep information about a
    ///          user's conversation with the bot.</p>
    ///          <p>A user interaction remains active for the amount of time specified.
    ///          If no conversation occurs during this time, the session expires and
    ///          Amazon Lex deletes any data provided before the timeout.</p>
    ///          <p>You can specify between 60 (1 minute) and 86,400 (24 hours)
    ///          seconds.</p>
    public let idleSessionTTLInSeconds: Int?
    /// <p>The Amazon Resource Name (ARN) of an IAM role that has permissions
    ///          to access the bot.</p>
    public let roleArn: String?

    public init (
        botId: String? = nil,
        botName: String? = nil,
        dataPrivacy: DataPrivacy? = nil,
        description: String? = nil,
        idleSessionTTLInSeconds: Int? = nil,
        roleArn: String? = nil
    )
    {
        self.botId = botId
        self.botName = botName
        self.dataPrivacy = dataPrivacy
        self.description = description
        self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
        self.roleArn = roleArn
    }
}

struct UpdateBotInputBody: Equatable {
    public let botName: String?
    public let description: String?
    public let roleArn: String?
    public let dataPrivacy: DataPrivacy?
    public let idleSessionTTLInSeconds: Int?
}

extension UpdateBotInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botName
        case dataPrivacy
        case description
        case idleSessionTTLInSeconds
        case roleArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botName)
        botName = botNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let dataPrivacyDecoded = try containerValues.decodeIfPresent(DataPrivacy.self, forKey: .dataPrivacy)
        dataPrivacy = dataPrivacyDecoded
        let idleSessionTTLInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .idleSessionTTLInSeconds)
        idleSessionTTLInSeconds = idleSessionTTLInSecondsDecoded
    }
}

public struct UpdateBotLocaleInputBodyMiddleware: Middleware {
    public let id: String = "UpdateBotLocaleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBotLocaleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBotLocaleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBotLocaleInput>
    public typealias MOutput = OperationOutput<UpdateBotLocaleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBotLocaleOutputError>
}

extension UpdateBotLocaleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBotLocaleInput(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), description: \(String(describing: description)), localeId: \(String(describing: localeId)), nluIntentConfidenceThreshold: \(String(describing: nluIntentConfidenceThreshold)), voiceSettings: \(String(describing: voiceSettings)))"}
}

extension UpdateBotLocaleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case nluIntentConfidenceThreshold
        case voiceSettings
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let nluIntentConfidenceThreshold = nluIntentConfidenceThreshold {
            try encodeContainer.encode(nluIntentConfidenceThreshold, forKey: .nluIntentConfidenceThreshold)
        }
        if let voiceSettings = voiceSettings {
            try encodeContainer.encode(voiceSettings, forKey: .voiceSettings)
        }
    }
}

public struct UpdateBotLocaleInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateBotLocaleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBotLocaleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBotLocaleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBotLocaleInput>
    public typealias MOutput = OperationOutput<UpdateBotLocaleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBotLocaleOutputError>
}

public struct UpdateBotLocaleInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateBotLocaleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBotLocaleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBotLocaleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBotLocaleInput>
    public typealias MOutput = OperationOutput<UpdateBotLocaleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBotLocaleOutputError>
}

public struct UpdateBotLocaleInput: Equatable {
    /// <p>The unique identifier of the bot that contains the locale.</p>
    public let botId: String?
    /// <p>The version of the bot that contains the locale to be updated. The
    ///          version can only be the <code>DRAFT</code> version.</p>
    public let botVersion: String?
    /// <p>The new description of the locale.</p>
    public let description: String?
    /// <p>The identifier of the language and locale to update. The string must
    ///          match one of the supported locales. For more information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
    public let localeId: String?
    /// <p>The new confidence threshold where Amazon Lex inserts the
    ///             <code>AMAZON.FallbackIntent</code> and
    ///             <code>AMAZON.KendraSearchIntent</code> intents in the list of
    ///          possible intents for an utterance.</p>
    public let nluIntentConfidenceThreshold: Double?
    /// <p>The new Amazon Polly voice Amazon Lex should use for voice interaction with the
    ///          user.</p>
    public let voiceSettings: VoiceSettings?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        description: String? = nil,
        localeId: String? = nil,
        nluIntentConfidenceThreshold: Double? = nil,
        voiceSettings: VoiceSettings? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.description = description
        self.localeId = localeId
        self.nluIntentConfidenceThreshold = nluIntentConfidenceThreshold
        self.voiceSettings = voiceSettings
    }
}

struct UpdateBotLocaleInputBody: Equatable {
    public let description: String?
    public let nluIntentConfidenceThreshold: Double?
    public let voiceSettings: VoiceSettings?
}

extension UpdateBotLocaleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case nluIntentConfidenceThreshold
        case voiceSettings
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let nluIntentConfidenceThresholdDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .nluIntentConfidenceThreshold)
        nluIntentConfidenceThreshold = nluIntentConfidenceThresholdDecoded
        let voiceSettingsDecoded = try containerValues.decodeIfPresent(VoiceSettings.self, forKey: .voiceSettings)
        voiceSettings = voiceSettingsDecoded
    }
}

extension UpdateBotLocaleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBotLocaleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBotLocaleOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case preconditionFailedException(PreconditionFailedException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBotLocaleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBotLocaleOutputResponse(botId: \(String(describing: botId)), botLocaleStatus: \(String(describing: botLocaleStatus)), botVersion: \(String(describing: botVersion)), creationDateTime: \(String(describing: creationDateTime)), description: \(String(describing: description)), failureReasons: \(String(describing: failureReasons)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), localeId: \(String(describing: localeId)), localeName: \(String(describing: localeName)), nluIntentConfidenceThreshold: \(String(describing: nluIntentConfidenceThreshold)), voiceSettings: \(String(describing: voiceSettings)))"}
}

extension UpdateBotLocaleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateBotLocaleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botId = output.botId
            self.botLocaleStatus = output.botLocaleStatus
            self.botVersion = output.botVersion
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.failureReasons = output.failureReasons
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.localeId = output.localeId
            self.localeName = output.localeName
            self.nluIntentConfidenceThreshold = output.nluIntentConfidenceThreshold
            self.voiceSettings = output.voiceSettings
        } else {
            self.botId = nil
            self.botLocaleStatus = nil
            self.botVersion = nil
            self.creationDateTime = nil
            self.description = nil
            self.failureReasons = nil
            self.lastUpdatedDateTime = nil
            self.localeId = nil
            self.localeName = nil
            self.nluIntentConfidenceThreshold = nil
            self.voiceSettings = nil
        }
    }
}

public struct UpdateBotLocaleOutputResponse: Equatable {
    /// <p>The identifier of the bot that contains the updated locale.</p>
    public let botId: String?
    /// <p>The current status of the locale. When the bot status is
    ///             <code>Built</code> the locale is ready for use.</p>
    public let botLocaleStatus: BotLocaleStatus?
    /// <p>The version of the bot that contains the updated locale.</p>
    public let botVersion: String?
    /// <p>A timestamp of the date and time that the locale was created.</p>
    public let creationDateTime: Date?
    /// <p>The updated description of the locale.</p>
    public let description: String?
    /// <p>If the <code>botLocaleStatus</code> is <code>Failed</code>, the
    ///             <code>failureReasons</code> field lists the errors that occurred
    ///          while building the bot.</p>
    public let failureReasons: [String]?
    /// <p>A timestamp of the date and time that the locale was last
    ///          updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The language and locale of the updated bot locale.</p>
    public let localeId: String?
    /// <p>The updated locale name for the locale.</p>
    public let localeName: String?
    /// <p>The updated confidence threshold for inserting the
    ///             <code>AMAZON.FallbackIntent</code> and
    ///             <code>AMAZON.KendraSearchIntent</code> intents in the list of
    ///          possible intents for an utterance.</p>
    public let nluIntentConfidenceThreshold: Double?
    /// <p>The updated Amazon Polly voice to use for voice interaction with the
    ///          user.</p>
    public let voiceSettings: VoiceSettings?

    public init (
        botId: String? = nil,
        botLocaleStatus: BotLocaleStatus? = nil,
        botVersion: String? = nil,
        creationDateTime: Date? = nil,
        description: String? = nil,
        failureReasons: [String]? = nil,
        lastUpdatedDateTime: Date? = nil,
        localeId: String? = nil,
        localeName: String? = nil,
        nluIntentConfidenceThreshold: Double? = nil,
        voiceSettings: VoiceSettings? = nil
    )
    {
        self.botId = botId
        self.botLocaleStatus = botLocaleStatus
        self.botVersion = botVersion
        self.creationDateTime = creationDateTime
        self.description = description
        self.failureReasons = failureReasons
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.localeId = localeId
        self.localeName = localeName
        self.nluIntentConfidenceThreshold = nluIntentConfidenceThreshold
        self.voiceSettings = voiceSettings
    }
}

struct UpdateBotLocaleOutputResponseBody: Equatable {
    public let botId: String?
    public let botVersion: String?
    public let localeId: String?
    public let localeName: String?
    public let description: String?
    public let nluIntentConfidenceThreshold: Double?
    public let voiceSettings: VoiceSettings?
    public let botLocaleStatus: BotLocaleStatus?
    public let failureReasons: [String]?
    public let creationDateTime: Date?
    public let lastUpdatedDateTime: Date?
}

extension UpdateBotLocaleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botId
        case botLocaleStatus
        case botVersion
        case creationDateTime
        case description
        case failureReasons
        case lastUpdatedDateTime
        case localeId
        case localeName
        case nluIntentConfidenceThreshold
        case voiceSettings
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let localeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localeName)
        localeName = localeNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let nluIntentConfidenceThresholdDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .nluIntentConfidenceThreshold)
        nluIntentConfidenceThreshold = nluIntentConfidenceThresholdDecoded
        let voiceSettingsDecoded = try containerValues.decodeIfPresent(VoiceSettings.self, forKey: .voiceSettings)
        voiceSettings = voiceSettingsDecoded
        let botLocaleStatusDecoded = try containerValues.decodeIfPresent(BotLocaleStatus.self, forKey: .botLocaleStatus)
        botLocaleStatus = botLocaleStatusDecoded
        let failureReasonsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .failureReasons)
        var failureReasonsDecoded0:[String]? = nil
        if let failureReasonsContainer = failureReasonsContainer {
            failureReasonsDecoded0 = [String]()
            for string0 in failureReasonsContainer {
                if let string0 = string0 {
                    failureReasonsDecoded0?.append(string0)
                }
            }
        }
        failureReasons = failureReasonsDecoded0
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension UpdateBotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBotOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case preconditionFailedException(PreconditionFailedException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBotOutputResponse(botId: \(String(describing: botId)), botName: \(String(describing: botName)), botStatus: \(String(describing: botStatus)), creationDateTime: \(String(describing: creationDateTime)), dataPrivacy: \(String(describing: dataPrivacy)), description: \(String(describing: description)), idleSessionTTLInSeconds: \(String(describing: idleSessionTTLInSeconds)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), roleArn: \(String(describing: roleArn)))"}
}

extension UpdateBotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateBotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botId = output.botId
            self.botName = output.botName
            self.botStatus = output.botStatus
            self.creationDateTime = output.creationDateTime
            self.dataPrivacy = output.dataPrivacy
            self.description = output.description
            self.idleSessionTTLInSeconds = output.idleSessionTTLInSeconds
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.roleArn = output.roleArn
        } else {
            self.botId = nil
            self.botName = nil
            self.botStatus = nil
            self.creationDateTime = nil
            self.dataPrivacy = nil
            self.description = nil
            self.idleSessionTTLInSeconds = nil
            self.lastUpdatedDateTime = nil
            self.roleArn = nil
        }
    }
}

public struct UpdateBotOutputResponse: Equatable {
    /// <p>The unique identifier of the bot that was updated.</p>
    public let botId: String?
    /// <p>The name of the bot after the update.</p>
    public let botName: String?
    /// <p>Shows the current status of the bot. The bot is first in the
    ///             <code>Creating</code> status. Once the bot is read for use, it
    ///          changes to the <code>Available</code> status. After the bot is created,
    ///          you can use the <code>DRAFT</code> version of the bot.</p>
    public let botStatus: BotStatus?
    /// <p>A timestamp of the date and time that the bot was created.</p>
    public let creationDateTime: Date?
    /// <p>The data privacy settings for the bot after the update.</p>
    public let dataPrivacy: DataPrivacy?
    /// <p>The description of the bot after the update.</p>
    public let description: String?
    /// <p>The session timeout, in seconds, for the bot after the
    ///          update.</p>
    public let idleSessionTTLInSeconds: Int?
    /// <p>A timestamp of the date and time that the bot was last
    ///          updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the IAM role used by the bot after
    ///          the update.</p>
    public let roleArn: String?

    public init (
        botId: String? = nil,
        botName: String? = nil,
        botStatus: BotStatus? = nil,
        creationDateTime: Date? = nil,
        dataPrivacy: DataPrivacy? = nil,
        description: String? = nil,
        idleSessionTTLInSeconds: Int? = nil,
        lastUpdatedDateTime: Date? = nil,
        roleArn: String? = nil
    )
    {
        self.botId = botId
        self.botName = botName
        self.botStatus = botStatus
        self.creationDateTime = creationDateTime
        self.dataPrivacy = dataPrivacy
        self.description = description
        self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.roleArn = roleArn
    }
}

struct UpdateBotOutputResponseBody: Equatable {
    public let botId: String?
    public let botName: String?
    public let description: String?
    public let roleArn: String?
    public let dataPrivacy: DataPrivacy?
    public let idleSessionTTLInSeconds: Int?
    public let botStatus: BotStatus?
    public let creationDateTime: Date?
    public let lastUpdatedDateTime: Date?
}

extension UpdateBotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botId
        case botName
        case botStatus
        case creationDateTime
        case dataPrivacy
        case description
        case idleSessionTTLInSeconds
        case lastUpdatedDateTime
        case roleArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botName)
        botName = botNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let dataPrivacyDecoded = try containerValues.decodeIfPresent(DataPrivacy.self, forKey: .dataPrivacy)
        dataPrivacy = dataPrivacyDecoded
        let idleSessionTTLInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .idleSessionTTLInSeconds)
        idleSessionTTLInSeconds = idleSessionTTLInSecondsDecoded
        let botStatusDecoded = try containerValues.decodeIfPresent(BotStatus.self, forKey: .botStatus)
        botStatus = botStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

public struct UpdateExportInputBodyMiddleware: Middleware {
    public let id: String = "UpdateExportInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateExportInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateExportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateExportInput>
    public typealias MOutput = OperationOutput<UpdateExportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateExportOutputError>
}

extension UpdateExportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateExportInput(exportId: \(String(describing: exportId)), filePassword: \(String(describing: filePassword)))"}
}

extension UpdateExportInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filePassword
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filePassword = filePassword {
            try encodeContainer.encode(filePassword, forKey: .filePassword)
        }
    }
}

public struct UpdateExportInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateExportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateExportInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateExportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateExportInput>
    public typealias MOutput = OperationOutput<UpdateExportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateExportOutputError>
}

public struct UpdateExportInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateExportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateExportInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateExportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateExportInput>
    public typealias MOutput = OperationOutput<UpdateExportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateExportOutputError>
}

public struct UpdateExportInput: Equatable {
    /// <p>The unique identifier Amazon Lex assigned to the export.</p>
    public let exportId: String?
    /// <p>The new password to use to encrypt the export zip archive.</p>
    public let filePassword: String?

    public init (
        exportId: String? = nil,
        filePassword: String? = nil
    )
    {
        self.exportId = exportId
        self.filePassword = filePassword
    }
}

struct UpdateExportInputBody: Equatable {
    public let filePassword: String?
}

extension UpdateExportInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filePassword
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filePassword)
        filePassword = filePasswordDecoded
    }
}

extension UpdateExportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateExportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateExportOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateExportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateExportOutputResponse(creationDateTime: \(String(describing: creationDateTime)), exportId: \(String(describing: exportId)), exportStatus: \(String(describing: exportStatus)), fileFormat: \(String(describing: fileFormat)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), resourceSpecification: \(String(describing: resourceSpecification)))"}
}

extension UpdateExportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateExportOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.creationDateTime = output.creationDateTime
            self.exportId = output.exportId
            self.exportStatus = output.exportStatus
            self.fileFormat = output.fileFormat
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.resourceSpecification = output.resourceSpecification
        } else {
            self.creationDateTime = nil
            self.exportId = nil
            self.exportStatus = nil
            self.fileFormat = nil
            self.lastUpdatedDateTime = nil
            self.resourceSpecification = nil
        }
    }
}

public struct UpdateExportOutputResponse: Equatable {
    /// <p>The date and time that the export was created.</p>
    public let creationDateTime: Date?
    /// <p>The unique identifier Amazon Lex assigned to the export.</p>
    public let exportId: String?
    /// <p>The status of the export. When the status is <code>Completed</code>
    ///          the export archive is available for download.</p>
    public let exportStatus: ExportStatus?
    /// <p>The file format used for the files that define the resource.</p>
    public let fileFormat: ImportExportFileFormat?
    /// <p>The date and time that the export was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>A description of the type of resource that was exported, either a
    ///          bot or a bot locale.</p>
    public let resourceSpecification: ExportResourceSpecification?

    public init (
        creationDateTime: Date? = nil,
        exportId: String? = nil,
        exportStatus: ExportStatus? = nil,
        fileFormat: ImportExportFileFormat? = nil,
        lastUpdatedDateTime: Date? = nil,
        resourceSpecification: ExportResourceSpecification? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.exportId = exportId
        self.exportStatus = exportStatus
        self.fileFormat = fileFormat
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.resourceSpecification = resourceSpecification
    }
}

struct UpdateExportOutputResponseBody: Equatable {
    public let exportId: String?
    public let resourceSpecification: ExportResourceSpecification?
    public let fileFormat: ImportExportFileFormat?
    public let exportStatus: ExportStatus?
    public let creationDateTime: Date?
    public let lastUpdatedDateTime: Date?
}

extension UpdateExportOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationDateTime
        case exportId
        case exportStatus
        case fileFormat
        case lastUpdatedDateTime
        case resourceSpecification
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exportId)
        exportId = exportIdDecoded
        let resourceSpecificationDecoded = try containerValues.decodeIfPresent(ExportResourceSpecification.self, forKey: .resourceSpecification)
        resourceSpecification = resourceSpecificationDecoded
        let fileFormatDecoded = try containerValues.decodeIfPresent(ImportExportFileFormat.self, forKey: .fileFormat)
        fileFormat = fileFormatDecoded
        let exportStatusDecoded = try containerValues.decodeIfPresent(ExportStatus.self, forKey: .exportStatus)
        exportStatus = exportStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

public struct UpdateIntentInputBodyMiddleware: Middleware {
    public let id: String = "UpdateIntentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIntentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIntentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIntentInput>
    public typealias MOutput = OperationOutput<UpdateIntentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIntentOutputError>
}

extension UpdateIntentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateIntentInput(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), description: \(String(describing: description)), dialogCodeHook: \(String(describing: dialogCodeHook)), fulfillmentCodeHook: \(String(describing: fulfillmentCodeHook)), inputContexts: \(String(describing: inputContexts)), intentClosingSetting: \(String(describing: intentClosingSetting)), intentConfirmationSetting: \(String(describing: intentConfirmationSetting)), intentId: \(String(describing: intentId)), intentName: \(String(describing: intentName)), kendraConfiguration: \(String(describing: kendraConfiguration)), localeId: \(String(describing: localeId)), outputContexts: \(String(describing: outputContexts)), parentIntentSignature: \(String(describing: parentIntentSignature)), sampleUtterances: \(String(describing: sampleUtterances)), slotPriorities: \(String(describing: slotPriorities)))"}
}

extension UpdateIntentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case dialogCodeHook
        case fulfillmentCodeHook
        case inputContexts
        case intentClosingSetting
        case intentConfirmationSetting
        case intentName
        case kendraConfiguration
        case outputContexts
        case parentIntentSignature
        case sampleUtterances
        case slotPriorities
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dialogCodeHook = dialogCodeHook {
            try encodeContainer.encode(dialogCodeHook, forKey: .dialogCodeHook)
        }
        if let fulfillmentCodeHook = fulfillmentCodeHook {
            try encodeContainer.encode(fulfillmentCodeHook, forKey: .fulfillmentCodeHook)
        }
        if let inputContexts = inputContexts {
            var inputContextsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputContexts)
            for inputcontextslist0 in inputContexts {
                try inputContextsContainer.encode(inputcontextslist0)
            }
        }
        if let intentClosingSetting = intentClosingSetting {
            try encodeContainer.encode(intentClosingSetting, forKey: .intentClosingSetting)
        }
        if let intentConfirmationSetting = intentConfirmationSetting {
            try encodeContainer.encode(intentConfirmationSetting, forKey: .intentConfirmationSetting)
        }
        if let intentName = intentName {
            try encodeContainer.encode(intentName, forKey: .intentName)
        }
        if let kendraConfiguration = kendraConfiguration {
            try encodeContainer.encode(kendraConfiguration, forKey: .kendraConfiguration)
        }
        if let outputContexts = outputContexts {
            var outputContextsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputContexts)
            for outputcontextslist0 in outputContexts {
                try outputContextsContainer.encode(outputcontextslist0)
            }
        }
        if let parentIntentSignature = parentIntentSignature {
            try encodeContainer.encode(parentIntentSignature, forKey: .parentIntentSignature)
        }
        if let sampleUtterances = sampleUtterances {
            var sampleUtterancesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sampleUtterances)
            for sampleutteranceslist0 in sampleUtterances {
                try sampleUtterancesContainer.encode(sampleutteranceslist0)
            }
        }
        if let slotPriorities = slotPriorities {
            var slotPrioritiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .slotPriorities)
            for slotprioritieslist0 in slotPriorities {
                try slotPrioritiesContainer.encode(slotprioritieslist0)
            }
        }
    }
}

public struct UpdateIntentInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateIntentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIntentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIntentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIntentInput>
    public typealias MOutput = OperationOutput<UpdateIntentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIntentOutputError>
}

public struct UpdateIntentInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateIntentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIntentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIntentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIntentInput>
    public typealias MOutput = OperationOutput<UpdateIntentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIntentOutputError>
}

public struct UpdateIntentInput: Equatable {
    /// <p>The identifier of the bot that contains the intent.</p>
    public let botId: String?
    /// <p>The version of the bot that contains the intent. Must be
    ///             <code>DRAFT</code>.</p>
    public let botVersion: String?
    /// <p>The new description of the intent.</p>
    public let description: String?
    /// <p>The new Lambda function to use between each turn of the conversation
    ///          with the bot.</p>
    public let dialogCodeHook: DialogCodeHookSettings?
    /// <p>The new Lambda function to call when all of the intents required
    ///          slots are provided and the intent is ready for fulfillment.</p>
    public let fulfillmentCodeHook: FulfillmentCodeHookSettings?
    /// <p>A new list of contexts that must be active in order for Amazon Lex to
    ///          consider the intent.</p>
    public let inputContexts: [InputContext]?
    /// <p>The new response that Amazon Lex sends the user when the intent is
    ///          closed.</p>
    public let intentClosingSetting: IntentClosingSetting?
    /// <p>New prompts that Amazon Lex sends to the user to confirm the completion
    ///          of an intent.</p>
    public let intentConfirmationSetting: IntentConfirmationSetting?
    /// <p>The unique identifier of the intent to update.</p>
    public let intentId: String?
    /// <p>The new name for the intent.</p>
    public let intentName: String?
    /// <p>New configuration settings for connecting to an Amazon Kendra index.</p>
    public let kendraConfiguration: KendraConfiguration?
    /// <p>The identifier of the language and locale where this intent is used.
    ///          The string must match one of the supported locales. For more
    ///          information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
    public let localeId: String?
    /// <p>A new list of contexts that Amazon Lex activates when the intent is
    ///          fulfilled.</p>
    public let outputContexts: [OutputContext]?
    /// <p>The signature of the new built-in intent to use as the parent of
    ///          this intent.</p>
    public let parentIntentSignature: String?
    /// <p>New utterances used to invoke the intent.</p>
    public let sampleUtterances: [SampleUtterance]?
    /// <p>A new list of slots and their priorities that are contained by the
    ///          intent.</p>
    public let slotPriorities: [SlotPriority]?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        description: String? = nil,
        dialogCodeHook: DialogCodeHookSettings? = nil,
        fulfillmentCodeHook: FulfillmentCodeHookSettings? = nil,
        inputContexts: [InputContext]? = nil,
        intentClosingSetting: IntentClosingSetting? = nil,
        intentConfirmationSetting: IntentConfirmationSetting? = nil,
        intentId: String? = nil,
        intentName: String? = nil,
        kendraConfiguration: KendraConfiguration? = nil,
        localeId: String? = nil,
        outputContexts: [OutputContext]? = nil,
        parentIntentSignature: String? = nil,
        sampleUtterances: [SampleUtterance]? = nil,
        slotPriorities: [SlotPriority]? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.description = description
        self.dialogCodeHook = dialogCodeHook
        self.fulfillmentCodeHook = fulfillmentCodeHook
        self.inputContexts = inputContexts
        self.intentClosingSetting = intentClosingSetting
        self.intentConfirmationSetting = intentConfirmationSetting
        self.intentId = intentId
        self.intentName = intentName
        self.kendraConfiguration = kendraConfiguration
        self.localeId = localeId
        self.outputContexts = outputContexts
        self.parentIntentSignature = parentIntentSignature
        self.sampleUtterances = sampleUtterances
        self.slotPriorities = slotPriorities
    }
}

struct UpdateIntentInputBody: Equatable {
    public let intentName: String?
    public let description: String?
    public let parentIntentSignature: String?
    public let sampleUtterances: [SampleUtterance]?
    public let dialogCodeHook: DialogCodeHookSettings?
    public let fulfillmentCodeHook: FulfillmentCodeHookSettings?
    public let slotPriorities: [SlotPriority]?
    public let intentConfirmationSetting: IntentConfirmationSetting?
    public let intentClosingSetting: IntentClosingSetting?
    public let inputContexts: [InputContext]?
    public let outputContexts: [OutputContext]?
    public let kendraConfiguration: KendraConfiguration?
}

extension UpdateIntentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case dialogCodeHook
        case fulfillmentCodeHook
        case inputContexts
        case intentClosingSetting
        case intentConfirmationSetting
        case intentName
        case kendraConfiguration
        case outputContexts
        case parentIntentSignature
        case sampleUtterances
        case slotPriorities
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .intentName)
        intentName = intentNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let parentIntentSignatureDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentIntentSignature)
        parentIntentSignature = parentIntentSignatureDecoded
        let sampleUtterancesContainer = try containerValues.decodeIfPresent([SampleUtterance?].self, forKey: .sampleUtterances)
        var sampleUtterancesDecoded0:[SampleUtterance]? = nil
        if let sampleUtterancesContainer = sampleUtterancesContainer {
            sampleUtterancesDecoded0 = [SampleUtterance]()
            for structure0 in sampleUtterancesContainer {
                if let structure0 = structure0 {
                    sampleUtterancesDecoded0?.append(structure0)
                }
            }
        }
        sampleUtterances = sampleUtterancesDecoded0
        let dialogCodeHookDecoded = try containerValues.decodeIfPresent(DialogCodeHookSettings.self, forKey: .dialogCodeHook)
        dialogCodeHook = dialogCodeHookDecoded
        let fulfillmentCodeHookDecoded = try containerValues.decodeIfPresent(FulfillmentCodeHookSettings.self, forKey: .fulfillmentCodeHook)
        fulfillmentCodeHook = fulfillmentCodeHookDecoded
        let slotPrioritiesContainer = try containerValues.decodeIfPresent([SlotPriority?].self, forKey: .slotPriorities)
        var slotPrioritiesDecoded0:[SlotPriority]? = nil
        if let slotPrioritiesContainer = slotPrioritiesContainer {
            slotPrioritiesDecoded0 = [SlotPriority]()
            for structure0 in slotPrioritiesContainer {
                if let structure0 = structure0 {
                    slotPrioritiesDecoded0?.append(structure0)
                }
            }
        }
        slotPriorities = slotPrioritiesDecoded0
        let intentConfirmationSettingDecoded = try containerValues.decodeIfPresent(IntentConfirmationSetting.self, forKey: .intentConfirmationSetting)
        intentConfirmationSetting = intentConfirmationSettingDecoded
        let intentClosingSettingDecoded = try containerValues.decodeIfPresent(IntentClosingSetting.self, forKey: .intentClosingSetting)
        intentClosingSetting = intentClosingSettingDecoded
        let inputContextsContainer = try containerValues.decodeIfPresent([InputContext?].self, forKey: .inputContexts)
        var inputContextsDecoded0:[InputContext]? = nil
        if let inputContextsContainer = inputContextsContainer {
            inputContextsDecoded0 = [InputContext]()
            for structure0 in inputContextsContainer {
                if let structure0 = structure0 {
                    inputContextsDecoded0?.append(structure0)
                }
            }
        }
        inputContexts = inputContextsDecoded0
        let outputContextsContainer = try containerValues.decodeIfPresent([OutputContext?].self, forKey: .outputContexts)
        var outputContextsDecoded0:[OutputContext]? = nil
        if let outputContextsContainer = outputContextsContainer {
            outputContextsDecoded0 = [OutputContext]()
            for structure0 in outputContextsContainer {
                if let structure0 = structure0 {
                    outputContextsDecoded0?.append(structure0)
                }
            }
        }
        outputContexts = outputContextsDecoded0
        let kendraConfigurationDecoded = try containerValues.decodeIfPresent(KendraConfiguration.self, forKey: .kendraConfiguration)
        kendraConfiguration = kendraConfigurationDecoded
    }
}

extension UpdateIntentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIntentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateIntentOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case preconditionFailedException(PreconditionFailedException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIntentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateIntentOutputResponse(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), creationDateTime: \(String(describing: creationDateTime)), description: \(String(describing: description)), dialogCodeHook: \(String(describing: dialogCodeHook)), fulfillmentCodeHook: \(String(describing: fulfillmentCodeHook)), inputContexts: \(String(describing: inputContexts)), intentClosingSetting: \(String(describing: intentClosingSetting)), intentConfirmationSetting: \(String(describing: intentConfirmationSetting)), intentId: \(String(describing: intentId)), intentName: \(String(describing: intentName)), kendraConfiguration: \(String(describing: kendraConfiguration)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), localeId: \(String(describing: localeId)), outputContexts: \(String(describing: outputContexts)), parentIntentSignature: \(String(describing: parentIntentSignature)), sampleUtterances: \(String(describing: sampleUtterances)), slotPriorities: \(String(describing: slotPriorities)))"}
}

extension UpdateIntentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateIntentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.dialogCodeHook = output.dialogCodeHook
            self.fulfillmentCodeHook = output.fulfillmentCodeHook
            self.inputContexts = output.inputContexts
            self.intentClosingSetting = output.intentClosingSetting
            self.intentConfirmationSetting = output.intentConfirmationSetting
            self.intentId = output.intentId
            self.intentName = output.intentName
            self.kendraConfiguration = output.kendraConfiguration
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.localeId = output.localeId
            self.outputContexts = output.outputContexts
            self.parentIntentSignature = output.parentIntentSignature
            self.sampleUtterances = output.sampleUtterances
            self.slotPriorities = output.slotPriorities
        } else {
            self.botId = nil
            self.botVersion = nil
            self.creationDateTime = nil
            self.description = nil
            self.dialogCodeHook = nil
            self.fulfillmentCodeHook = nil
            self.inputContexts = nil
            self.intentClosingSetting = nil
            self.intentConfirmationSetting = nil
            self.intentId = nil
            self.intentName = nil
            self.kendraConfiguration = nil
            self.lastUpdatedDateTime = nil
            self.localeId = nil
            self.outputContexts = nil
            self.parentIntentSignature = nil
            self.sampleUtterances = nil
            self.slotPriorities = nil
        }
    }
}

public struct UpdateIntentOutputResponse: Equatable {
    /// <p>The identifier of the bot that contains the intent.</p>
    public let botId: String?
    /// <p>The version of the bot that contains the intent. Will always be
    ///             <code>DRAFT</code>.</p>
    public let botVersion: String?
    /// <p>A timestamp of when the intent was created.</p>
    public let creationDateTime: Date?
    /// <p>The updated description of the intent.</p>
    public let description: String?
    /// <p>The updated Lambda function called during each turn of the
    ///          conversation with the user.</p>
    public let dialogCodeHook: DialogCodeHookSettings?
    /// <p>The updated Lambda function called when the intent is ready for
    ///          fulfillment.</p>
    public let fulfillmentCodeHook: FulfillmentCodeHookSettings?
    /// <p>The updated list of contexts that must be active for the intent to
    ///          be considered by Amazon Lex.</p>
    public let inputContexts: [InputContext]?
    /// <p>The updated response that Amazon Lex sends the user when the intent is
    ///          closed.</p>
    public let intentClosingSetting: IntentClosingSetting?
    /// <p>The updated prompts that Amazon Lex sends to the user to confirm the
    ///          completion of an intent.</p>
    public let intentConfirmationSetting: IntentConfirmationSetting?
    /// <p>The identifier of the intent that was updated.</p>
    public let intentId: String?
    /// <p>The updated name of the intent.</p>
    public let intentName: String?
    /// <p>The updated configuration for connecting to an Amazon Kendra index with the
    ///             <code>AMAZON.KendraSearchIntent</code> intent.</p>
    public let kendraConfiguration: KendraConfiguration?
    /// <p>A timestamp of the last time that the intent was modified.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The updated language and locale of the intent.</p>
    public let localeId: String?
    /// <p>The updated list of contexts that Amazon Lex activates when the intent is
    ///          fulfilled.</p>
    public let outputContexts: [OutputContext]?
    /// <p>The updated built-in intent that is the parent of this
    ///          intent.</p>
    public let parentIntentSignature: String?
    /// <p>The updated list of sample utterances for the intent.</p>
    public let sampleUtterances: [SampleUtterance]?
    /// <p>The updated list of slots and their priorities that are elicited
    ///          from the user for the intent.</p>
    public let slotPriorities: [SlotPriority]?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        creationDateTime: Date? = nil,
        description: String? = nil,
        dialogCodeHook: DialogCodeHookSettings? = nil,
        fulfillmentCodeHook: FulfillmentCodeHookSettings? = nil,
        inputContexts: [InputContext]? = nil,
        intentClosingSetting: IntentClosingSetting? = nil,
        intentConfirmationSetting: IntentConfirmationSetting? = nil,
        intentId: String? = nil,
        intentName: String? = nil,
        kendraConfiguration: KendraConfiguration? = nil,
        lastUpdatedDateTime: Date? = nil,
        localeId: String? = nil,
        outputContexts: [OutputContext]? = nil,
        parentIntentSignature: String? = nil,
        sampleUtterances: [SampleUtterance]? = nil,
        slotPriorities: [SlotPriority]? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.creationDateTime = creationDateTime
        self.description = description
        self.dialogCodeHook = dialogCodeHook
        self.fulfillmentCodeHook = fulfillmentCodeHook
        self.inputContexts = inputContexts
        self.intentClosingSetting = intentClosingSetting
        self.intentConfirmationSetting = intentConfirmationSetting
        self.intentId = intentId
        self.intentName = intentName
        self.kendraConfiguration = kendraConfiguration
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.localeId = localeId
        self.outputContexts = outputContexts
        self.parentIntentSignature = parentIntentSignature
        self.sampleUtterances = sampleUtterances
        self.slotPriorities = slotPriorities
    }
}

struct UpdateIntentOutputResponseBody: Equatable {
    public let intentId: String?
    public let intentName: String?
    public let description: String?
    public let parentIntentSignature: String?
    public let sampleUtterances: [SampleUtterance]?
    public let dialogCodeHook: DialogCodeHookSettings?
    public let fulfillmentCodeHook: FulfillmentCodeHookSettings?
    public let slotPriorities: [SlotPriority]?
    public let intentConfirmationSetting: IntentConfirmationSetting?
    public let intentClosingSetting: IntentClosingSetting?
    public let inputContexts: [InputContext]?
    public let outputContexts: [OutputContext]?
    public let kendraConfiguration: KendraConfiguration?
    public let botId: String?
    public let botVersion: String?
    public let localeId: String?
    public let creationDateTime: Date?
    public let lastUpdatedDateTime: Date?
}

extension UpdateIntentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botId
        case botVersion
        case creationDateTime
        case description
        case dialogCodeHook
        case fulfillmentCodeHook
        case inputContexts
        case intentClosingSetting
        case intentConfirmationSetting
        case intentId
        case intentName
        case kendraConfiguration
        case lastUpdatedDateTime
        case localeId
        case outputContexts
        case parentIntentSignature
        case sampleUtterances
        case slotPriorities
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .intentId)
        intentId = intentIdDecoded
        let intentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .intentName)
        intentName = intentNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let parentIntentSignatureDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentIntentSignature)
        parentIntentSignature = parentIntentSignatureDecoded
        let sampleUtterancesContainer = try containerValues.decodeIfPresent([SampleUtterance?].self, forKey: .sampleUtterances)
        var sampleUtterancesDecoded0:[SampleUtterance]? = nil
        if let sampleUtterancesContainer = sampleUtterancesContainer {
            sampleUtterancesDecoded0 = [SampleUtterance]()
            for structure0 in sampleUtterancesContainer {
                if let structure0 = structure0 {
                    sampleUtterancesDecoded0?.append(structure0)
                }
            }
        }
        sampleUtterances = sampleUtterancesDecoded0
        let dialogCodeHookDecoded = try containerValues.decodeIfPresent(DialogCodeHookSettings.self, forKey: .dialogCodeHook)
        dialogCodeHook = dialogCodeHookDecoded
        let fulfillmentCodeHookDecoded = try containerValues.decodeIfPresent(FulfillmentCodeHookSettings.self, forKey: .fulfillmentCodeHook)
        fulfillmentCodeHook = fulfillmentCodeHookDecoded
        let slotPrioritiesContainer = try containerValues.decodeIfPresent([SlotPriority?].self, forKey: .slotPriorities)
        var slotPrioritiesDecoded0:[SlotPriority]? = nil
        if let slotPrioritiesContainer = slotPrioritiesContainer {
            slotPrioritiesDecoded0 = [SlotPriority]()
            for structure0 in slotPrioritiesContainer {
                if let structure0 = structure0 {
                    slotPrioritiesDecoded0?.append(structure0)
                }
            }
        }
        slotPriorities = slotPrioritiesDecoded0
        let intentConfirmationSettingDecoded = try containerValues.decodeIfPresent(IntentConfirmationSetting.self, forKey: .intentConfirmationSetting)
        intentConfirmationSetting = intentConfirmationSettingDecoded
        let intentClosingSettingDecoded = try containerValues.decodeIfPresent(IntentClosingSetting.self, forKey: .intentClosingSetting)
        intentClosingSetting = intentClosingSettingDecoded
        let inputContextsContainer = try containerValues.decodeIfPresent([InputContext?].self, forKey: .inputContexts)
        var inputContextsDecoded0:[InputContext]? = nil
        if let inputContextsContainer = inputContextsContainer {
            inputContextsDecoded0 = [InputContext]()
            for structure0 in inputContextsContainer {
                if let structure0 = structure0 {
                    inputContextsDecoded0?.append(structure0)
                }
            }
        }
        inputContexts = inputContextsDecoded0
        let outputContextsContainer = try containerValues.decodeIfPresent([OutputContext?].self, forKey: .outputContexts)
        var outputContextsDecoded0:[OutputContext]? = nil
        if let outputContextsContainer = outputContextsContainer {
            outputContextsDecoded0 = [OutputContext]()
            for structure0 in outputContextsContainer {
                if let structure0 = structure0 {
                    outputContextsDecoded0?.append(structure0)
                }
            }
        }
        outputContexts = outputContextsDecoded0
        let kendraConfigurationDecoded = try containerValues.decodeIfPresent(KendraConfiguration.self, forKey: .kendraConfiguration)
        kendraConfiguration = kendraConfigurationDecoded
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

public struct UpdateResourcePolicyInputBodyMiddleware: Middleware {
    public let id: String = "UpdateResourcePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResourcePolicyInput>
    public typealias MOutput = OperationOutput<UpdateResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResourcePolicyOutputError>
}

extension UpdateResourcePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateResourcePolicyInput(expectedRevisionId: \(String(describing: expectedRevisionId)), policy: \(String(describing: policy)), resourceArn: \(String(describing: resourceArn)))"}
}

extension UpdateResourcePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

public struct UpdateResourcePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResourcePolicyInput>
    public typealias MOutput = OperationOutput<UpdateResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResourcePolicyOutputError>
}

public struct UpdateResourcePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedRevisionId = input.operationInput.expectedRevisionId {
            let expectedRevisionIdQueryItem = URLQueryItem(name: "expectedRevisionId".urlPercentEncoding(), value: String(expectedRevisionId).urlPercentEncoding())
            input.builder.withQueryItem(expectedRevisionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResourcePolicyInput>
    public typealias MOutput = OperationOutput<UpdateResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResourcePolicyOutputError>
}

public struct UpdateResourcePolicyInput: Equatable {
    /// <p>The identifier of the revision of the policy to update. If this
    ///          revision ID doesn't match the current revision ID, Amazon Lex throws an
    ///          exception.</p>
    ///          <p>If you don't specify a revision, Amazon Lex overwrites the contents of
    ///          the policy with the new values.</p>
    public let expectedRevisionId: String?
    /// <p>A resource policy to add to the resource. The policy is a JSON
    ///          structure that contains one or more statements that define the policy.
    ///          The policy must follow the IAM syntax. For more information about the
    ///          contents of a JSON policy document, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies.html"> IAM JSON policy
    ///             reference </a>. </p>
    ///          <p>If the policy isn't valid, Amazon Lex returns a validation
    ///          exception.</p>
    public let policy: String?
    /// <p>The Amazon Resource Name (ARN) of the bot or bot alias that the
    ///          resource policy is attached to.</p>
    public let resourceArn: String?

    public init (
        expectedRevisionId: String? = nil,
        policy: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.expectedRevisionId = expectedRevisionId
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

struct UpdateResourcePolicyInputBody: Equatable {
    public let policy: String?
}

extension UpdateResourcePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension UpdateResourcePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResourcePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResourcePolicyOutputError: Equatable {
    case internalServerException(InternalServerException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResourcePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateResourcePolicyOutputResponse(resourceArn: \(String(describing: resourceArn)), revisionId: \(String(describing: revisionId)))"}
}

extension UpdateResourcePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resourceArn = output.resourceArn
            self.revisionId = output.revisionId
        } else {
            self.resourceArn = nil
            self.revisionId = nil
        }
    }
}

public struct UpdateResourcePolicyOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the bot or bot alias that the
    ///          resource policy is attached to.</p>
    public let resourceArn: String?
    /// <p>The current revision of the resource policy. Use the revision ID to
    ///          make sure that you are updating the most current version of a resource
    ///          policy when you add a policy statement to a resource, delete a
    ///          resource, or update a resource.</p>
    public let revisionId: String?

    public init (
        resourceArn: String? = nil,
        revisionId: String? = nil
    )
    {
        self.resourceArn = resourceArn
        self.revisionId = revisionId
    }
}

struct UpdateResourcePolicyOutputResponseBody: Equatable {
    public let resourceArn: String?
    public let revisionId: String?
}

extension UpdateResourcePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case revisionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

public struct UpdateSlotInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSlotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSlotInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSlotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSlotInput>
    public typealias MOutput = OperationOutput<UpdateSlotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSlotOutputError>
}

extension UpdateSlotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSlotInput(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), description: \(String(describing: description)), intentId: \(String(describing: intentId)), localeId: \(String(describing: localeId)), obfuscationSetting: \(String(describing: obfuscationSetting)), slotId: \(String(describing: slotId)), slotName: \(String(describing: slotName)), slotTypeId: \(String(describing: slotTypeId)), valueElicitationSetting: \(String(describing: valueElicitationSetting)))"}
}

extension UpdateSlotInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case obfuscationSetting
        case slotName
        case slotTypeId
        case valueElicitationSetting
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let obfuscationSetting = obfuscationSetting {
            try encodeContainer.encode(obfuscationSetting, forKey: .obfuscationSetting)
        }
        if let slotName = slotName {
            try encodeContainer.encode(slotName, forKey: .slotName)
        }
        if let slotTypeId = slotTypeId {
            try encodeContainer.encode(slotTypeId, forKey: .slotTypeId)
        }
        if let valueElicitationSetting = valueElicitationSetting {
            try encodeContainer.encode(valueElicitationSetting, forKey: .valueElicitationSetting)
        }
    }
}

public struct UpdateSlotInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSlotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSlotInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSlotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSlotInput>
    public typealias MOutput = OperationOutput<UpdateSlotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSlotOutputError>
}

public struct UpdateSlotInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSlotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSlotInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSlotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSlotInput>
    public typealias MOutput = OperationOutput<UpdateSlotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSlotOutputError>
}

public struct UpdateSlotInput: Equatable {
    /// <p>The unique identifier of the bot that contains the slot.</p>
    public let botId: String?
    /// <p>The version of the bot that contains the slot. Must always be
    ///             <code>DRAFT</code>.</p>
    public let botVersion: String?
    /// <p>The new description for the slot.</p>
    public let description: String?
    /// <p>The identifier of the intent that contains the slot.</p>
    public let intentId: String?
    /// <p>The identifier of the language and locale that contains the slot.
    ///          The string must match one of the supported locales. For more
    ///          information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
    public let localeId: String?
    /// <p>New settings that determine how slot values are formatted in Amazon CloudWatch
    ///          logs. </p>
    public let obfuscationSetting: ObfuscationSetting?
    /// <p>The unique identifier for the slot to update.</p>
    public let slotId: String?
    /// <p>The new name for the slot.</p>
    public let slotName: String?
    /// <p>The unique identifier of the new slot type to associate with this
    ///          slot. </p>
    public let slotTypeId: String?
    /// <p>A new set of prompts that Amazon Lex sends to the user to elicit a
    ///          response the provides a value for the slot.</p>
    public let valueElicitationSetting: SlotValueElicitationSetting?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        description: String? = nil,
        intentId: String? = nil,
        localeId: String? = nil,
        obfuscationSetting: ObfuscationSetting? = nil,
        slotId: String? = nil,
        slotName: String? = nil,
        slotTypeId: String? = nil,
        valueElicitationSetting: SlotValueElicitationSetting? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.description = description
        self.intentId = intentId
        self.localeId = localeId
        self.obfuscationSetting = obfuscationSetting
        self.slotId = slotId
        self.slotName = slotName
        self.slotTypeId = slotTypeId
        self.valueElicitationSetting = valueElicitationSetting
    }
}

struct UpdateSlotInputBody: Equatable {
    public let slotName: String?
    public let description: String?
    public let slotTypeId: String?
    public let valueElicitationSetting: SlotValueElicitationSetting?
    public let obfuscationSetting: ObfuscationSetting?
}

extension UpdateSlotInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case obfuscationSetting
        case slotName
        case slotTypeId
        case valueElicitationSetting
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotName)
        slotName = slotNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let slotTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotTypeId)
        slotTypeId = slotTypeIdDecoded
        let valueElicitationSettingDecoded = try containerValues.decodeIfPresent(SlotValueElicitationSetting.self, forKey: .valueElicitationSetting)
        valueElicitationSetting = valueElicitationSettingDecoded
        let obfuscationSettingDecoded = try containerValues.decodeIfPresent(ObfuscationSetting.self, forKey: .obfuscationSetting)
        obfuscationSetting = obfuscationSettingDecoded
    }
}

extension UpdateSlotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSlotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSlotOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case preconditionFailedException(PreconditionFailedException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSlotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSlotOutputResponse(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), creationDateTime: \(String(describing: creationDateTime)), description: \(String(describing: description)), intentId: \(String(describing: intentId)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), localeId: \(String(describing: localeId)), obfuscationSetting: \(String(describing: obfuscationSetting)), slotId: \(String(describing: slotId)), slotName: \(String(describing: slotName)), slotTypeId: \(String(describing: slotTypeId)), valueElicitationSetting: \(String(describing: valueElicitationSetting)))"}
}

extension UpdateSlotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateSlotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.intentId = output.intentId
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.localeId = output.localeId
            self.obfuscationSetting = output.obfuscationSetting
            self.slotId = output.slotId
            self.slotName = output.slotName
            self.slotTypeId = output.slotTypeId
            self.valueElicitationSetting = output.valueElicitationSetting
        } else {
            self.botId = nil
            self.botVersion = nil
            self.creationDateTime = nil
            self.description = nil
            self.intentId = nil
            self.lastUpdatedDateTime = nil
            self.localeId = nil
            self.obfuscationSetting = nil
            self.slotId = nil
            self.slotName = nil
            self.slotTypeId = nil
            self.valueElicitationSetting = nil
        }
    }
}

public struct UpdateSlotOutputResponse: Equatable {
    /// <p>The identifier of the bot that contains the slot.</p>
    public let botId: String?
    /// <p>The identifier of the slot version that contains the slot. Will
    ///          always be <code>DRAFT</code>.</p>
    public let botVersion: String?
    /// <p>The timestamp of the date and time that the slot was created.</p>
    public let creationDateTime: Date?
    /// <p>The updated description of the bot.</p>
    public let description: String?
    /// <p>The intent that contains the slot.</p>
    public let intentId: String?
    /// <p>The timestamp of the date and time that the slot was last
    ///          updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The locale that contains the slot.</p>
    public let localeId: String?
    /// <p>The updated setting that determines whether the slot value is
    ///          obfuscated in the Amazon CloudWatch logs.</p>
    public let obfuscationSetting: ObfuscationSetting?
    /// <p>The unique identifier of the slot that was updated.</p>
    public let slotId: String?
    /// <p>The updated name of the slot.</p>
    public let slotName: String?
    /// <p>The updated identifier of the slot type that provides values for the
    ///          slot.</p>
    public let slotTypeId: String?
    /// <p>The updated prompts that Amazon Lex sends to the user to elicit a
    ///          response that provides a value for the slot.</p>
    public let valueElicitationSetting: SlotValueElicitationSetting?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        creationDateTime: Date? = nil,
        description: String? = nil,
        intentId: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        localeId: String? = nil,
        obfuscationSetting: ObfuscationSetting? = nil,
        slotId: String? = nil,
        slotName: String? = nil,
        slotTypeId: String? = nil,
        valueElicitationSetting: SlotValueElicitationSetting? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.creationDateTime = creationDateTime
        self.description = description
        self.intentId = intentId
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.localeId = localeId
        self.obfuscationSetting = obfuscationSetting
        self.slotId = slotId
        self.slotName = slotName
        self.slotTypeId = slotTypeId
        self.valueElicitationSetting = valueElicitationSetting
    }
}

struct UpdateSlotOutputResponseBody: Equatable {
    public let slotId: String?
    public let slotName: String?
    public let description: String?
    public let slotTypeId: String?
    public let valueElicitationSetting: SlotValueElicitationSetting?
    public let obfuscationSetting: ObfuscationSetting?
    public let botId: String?
    public let botVersion: String?
    public let localeId: String?
    public let intentId: String?
    public let creationDateTime: Date?
    public let lastUpdatedDateTime: Date?
}

extension UpdateSlotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botId
        case botVersion
        case creationDateTime
        case description
        case intentId
        case lastUpdatedDateTime
        case localeId
        case obfuscationSetting
        case slotId
        case slotName
        case slotTypeId
        case valueElicitationSetting
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotId)
        slotId = slotIdDecoded
        let slotNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotName)
        slotName = slotNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let slotTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotTypeId)
        slotTypeId = slotTypeIdDecoded
        let valueElicitationSettingDecoded = try containerValues.decodeIfPresent(SlotValueElicitationSetting.self, forKey: .valueElicitationSetting)
        valueElicitationSetting = valueElicitationSettingDecoded
        let obfuscationSettingDecoded = try containerValues.decodeIfPresent(ObfuscationSetting.self, forKey: .obfuscationSetting)
        obfuscationSetting = obfuscationSettingDecoded
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let intentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .intentId)
        intentId = intentIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

public struct UpdateSlotTypeInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSlotTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSlotTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSlotTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSlotTypeInput>
    public typealias MOutput = OperationOutput<UpdateSlotTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSlotTypeOutputError>
}

extension UpdateSlotTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSlotTypeInput(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), description: \(String(describing: description)), localeId: \(String(describing: localeId)), parentSlotTypeSignature: \(String(describing: parentSlotTypeSignature)), slotTypeId: \(String(describing: slotTypeId)), slotTypeName: \(String(describing: slotTypeName)), slotTypeValues: \(String(describing: slotTypeValues)), valueSelectionSetting: \(String(describing: valueSelectionSetting)))"}
}

extension UpdateSlotTypeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case parentSlotTypeSignature
        case slotTypeName
        case slotTypeValues
        case valueSelectionSetting
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let parentSlotTypeSignature = parentSlotTypeSignature {
            try encodeContainer.encode(parentSlotTypeSignature, forKey: .parentSlotTypeSignature)
        }
        if let slotTypeName = slotTypeName {
            try encodeContainer.encode(slotTypeName, forKey: .slotTypeName)
        }
        if let slotTypeValues = slotTypeValues {
            var slotTypeValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .slotTypeValues)
            for slottypevalues0 in slotTypeValues {
                try slotTypeValuesContainer.encode(slottypevalues0)
            }
        }
        if let valueSelectionSetting = valueSelectionSetting {
            try encodeContainer.encode(valueSelectionSetting, forKey: .valueSelectionSetting)
        }
    }
}

public struct UpdateSlotTypeInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSlotTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSlotTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSlotTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSlotTypeInput>
    public typealias MOutput = OperationOutput<UpdateSlotTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSlotTypeOutputError>
}

public struct UpdateSlotTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSlotTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSlotTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSlotTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSlotTypeInput>
    public typealias MOutput = OperationOutput<UpdateSlotTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSlotTypeOutputError>
}

public struct UpdateSlotTypeInput: Equatable {
    /// <p>The identifier of the bot that contains the slot type.</p>
    public let botId: String?
    /// <p>The version of the bot that contains the slot type. Must be
    ///             <code>DRAFT</code>.</p>
    public let botVersion: String?
    /// <p>The new description of the slot type.</p>
    public let description: String?
    /// <p>The identifier of the language and locale that contains the slot
    ///          type. The string must match one of the supported locales. For more
    ///          information, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html">Supported languages</a>.</p>
    public let localeId: String?
    /// <p>The new built-in slot type that should be used as the parent of this
    ///          slot type.</p>
    public let parentSlotTypeSignature: String?
    /// <p>The unique identifier of the slot type to update.</p>
    public let slotTypeId: String?
    /// <p>The new name of the slot type.</p>
    public let slotTypeName: String?
    /// <p>A new list of values and their optional synonyms that define the
    ///          values that the slot type can take.</p>
    public let slotTypeValues: [SlotTypeValue]?
    /// <p>The strategy that Amazon Lex should use when deciding on a value from the
    ///          list of slot type values.</p>
    public let valueSelectionSetting: SlotValueSelectionSetting?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        description: String? = nil,
        localeId: String? = nil,
        parentSlotTypeSignature: String? = nil,
        slotTypeId: String? = nil,
        slotTypeName: String? = nil,
        slotTypeValues: [SlotTypeValue]? = nil,
        valueSelectionSetting: SlotValueSelectionSetting? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.description = description
        self.localeId = localeId
        self.parentSlotTypeSignature = parentSlotTypeSignature
        self.slotTypeId = slotTypeId
        self.slotTypeName = slotTypeName
        self.slotTypeValues = slotTypeValues
        self.valueSelectionSetting = valueSelectionSetting
    }
}

struct UpdateSlotTypeInputBody: Equatable {
    public let slotTypeName: String?
    public let description: String?
    public let slotTypeValues: [SlotTypeValue]?
    public let valueSelectionSetting: SlotValueSelectionSetting?
    public let parentSlotTypeSignature: String?
}

extension UpdateSlotTypeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case parentSlotTypeSignature
        case slotTypeName
        case slotTypeValues
        case valueSelectionSetting
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotTypeName)
        slotTypeName = slotTypeNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let slotTypeValuesContainer = try containerValues.decodeIfPresent([SlotTypeValue?].self, forKey: .slotTypeValues)
        var slotTypeValuesDecoded0:[SlotTypeValue]? = nil
        if let slotTypeValuesContainer = slotTypeValuesContainer {
            slotTypeValuesDecoded0 = [SlotTypeValue]()
            for structure0 in slotTypeValuesContainer {
                if let structure0 = structure0 {
                    slotTypeValuesDecoded0?.append(structure0)
                }
            }
        }
        slotTypeValues = slotTypeValuesDecoded0
        let valueSelectionSettingDecoded = try containerValues.decodeIfPresent(SlotValueSelectionSetting.self, forKey: .valueSelectionSetting)
        valueSelectionSetting = valueSelectionSettingDecoded
        let parentSlotTypeSignatureDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentSlotTypeSignature)
        parentSlotTypeSignature = parentSlotTypeSignatureDecoded
    }
}

extension UpdateSlotTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSlotTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSlotTypeOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case preconditionFailedException(PreconditionFailedException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSlotTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSlotTypeOutputResponse(botId: \(String(describing: botId)), botVersion: \(String(describing: botVersion)), creationDateTime: \(String(describing: creationDateTime)), description: \(String(describing: description)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), localeId: \(String(describing: localeId)), parentSlotTypeSignature: \(String(describing: parentSlotTypeSignature)), slotTypeId: \(String(describing: slotTypeId)), slotTypeName: \(String(describing: slotTypeName)), slotTypeValues: \(String(describing: slotTypeValues)), valueSelectionSetting: \(String(describing: valueSelectionSetting)))"}
}

extension UpdateSlotTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateSlotTypeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botId = output.botId
            self.botVersion = output.botVersion
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.lastUpdatedDateTime = output.lastUpdatedDateTime
            self.localeId = output.localeId
            self.parentSlotTypeSignature = output.parentSlotTypeSignature
            self.slotTypeId = output.slotTypeId
            self.slotTypeName = output.slotTypeName
            self.slotTypeValues = output.slotTypeValues
            self.valueSelectionSetting = output.valueSelectionSetting
        } else {
            self.botId = nil
            self.botVersion = nil
            self.creationDateTime = nil
            self.description = nil
            self.lastUpdatedDateTime = nil
            self.localeId = nil
            self.parentSlotTypeSignature = nil
            self.slotTypeId = nil
            self.slotTypeName = nil
            self.slotTypeValues = nil
            self.valueSelectionSetting = nil
        }
    }
}

public struct UpdateSlotTypeOutputResponse: Equatable {
    /// <p>The identifier of the bot that contains the slot type.</p>
    public let botId: String?
    /// <p>The version of the bot that contains the slot type. This is always
    ///             <code>DRAFT</code>.</p>
    public let botVersion: String?
    /// <p>The timestamp of the date and time that the slot type was
    ///          created.</p>
    public let creationDateTime: Date?
    /// <p>The updated description of the slot type.</p>
    public let description: String?
    /// <p>A timestamp of the date and time that the slot type was last
    ///          updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The language and locale of the updated slot type.</p>
    public let localeId: String?
    /// <p>The updated signature of the built-in slot type that is the parent
    ///          of this slot type.</p>
    public let parentSlotTypeSignature: String?
    /// <p>The unique identifier of the updated slot type.</p>
    public let slotTypeId: String?
    /// <p>The updated name of the slot type.</p>
    public let slotTypeName: String?
    /// <p>The updated values that the slot type provides.</p>
    public let slotTypeValues: [SlotTypeValue]?
    /// <p>The updated strategy that Amazon Lex uses to determine which value to
    ///          select from the slot type.</p>
    public let valueSelectionSetting: SlotValueSelectionSetting?

    public init (
        botId: String? = nil,
        botVersion: String? = nil,
        creationDateTime: Date? = nil,
        description: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        localeId: String? = nil,
        parentSlotTypeSignature: String? = nil,
        slotTypeId: String? = nil,
        slotTypeName: String? = nil,
        slotTypeValues: [SlotTypeValue]? = nil,
        valueSelectionSetting: SlotValueSelectionSetting? = nil
    )
    {
        self.botId = botId
        self.botVersion = botVersion
        self.creationDateTime = creationDateTime
        self.description = description
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.localeId = localeId
        self.parentSlotTypeSignature = parentSlotTypeSignature
        self.slotTypeId = slotTypeId
        self.slotTypeName = slotTypeName
        self.slotTypeValues = slotTypeValues
        self.valueSelectionSetting = valueSelectionSetting
    }
}

struct UpdateSlotTypeOutputResponseBody: Equatable {
    public let slotTypeId: String?
    public let slotTypeName: String?
    public let description: String?
    public let slotTypeValues: [SlotTypeValue]?
    public let valueSelectionSetting: SlotValueSelectionSetting?
    public let parentSlotTypeSignature: String?
    public let botId: String?
    public let botVersion: String?
    public let localeId: String?
    public let creationDateTime: Date?
    public let lastUpdatedDateTime: Date?
}

extension UpdateSlotTypeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botId
        case botVersion
        case creationDateTime
        case description
        case lastUpdatedDateTime
        case localeId
        case parentSlotTypeSignature
        case slotTypeId
        case slotTypeName
        case slotTypeValues
        case valueSelectionSetting
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotTypeId)
        slotTypeId = slotTypeIdDecoded
        let slotTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotTypeName)
        slotTypeName = slotTypeNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let slotTypeValuesContainer = try containerValues.decodeIfPresent([SlotTypeValue?].self, forKey: .slotTypeValues)
        var slotTypeValuesDecoded0:[SlotTypeValue]? = nil
        if let slotTypeValuesContainer = slotTypeValuesContainer {
            slotTypeValuesDecoded0 = [SlotTypeValue]()
            for structure0 in slotTypeValuesContainer {
                if let structure0 = structure0 {
                    slotTypeValuesDecoded0?.append(structure0)
                }
            }
        }
        slotTypeValues = slotTypeValuesDecoded0
        let valueSelectionSettingDecoded = try containerValues.decodeIfPresent(SlotValueSelectionSetting.self, forKey: .valueSelectionSetting)
        valueSelectionSetting = valueSelectionSettingDecoded
        let parentSlotTypeSignatureDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentSlotTypeSignature)
        parentSlotTypeSignature = parentSlotTypeSignatureDecoded
        let botIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botId)
        botId = botIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VoiceSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case voiceId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let voiceId = voiceId {
            try encodeContainer.encode(voiceId, forKey: .voiceId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .voiceId)
        voiceId = voiceIdDecoded
    }
}

extension VoiceSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VoiceSettings(voiceId: \(String(describing: voiceId)))"}
}

/// <p>Defines settings for using an Amazon Polly voice to communicate with a
///          user.</p>
public struct VoiceSettings: Equatable {
    /// <p>The identifier of the Amazon Polly voice to use.</p>
    public let voiceId: String?

    public init (
        voiceId: String? = nil
    )
    {
        self.voiceId = voiceId
    }
}

extension WaitAndContinueSpecification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case continueResponse
        case stillWaitingResponse
        case waitingResponse
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let continueResponse = continueResponse {
            try encodeContainer.encode(continueResponse, forKey: .continueResponse)
        }
        if let stillWaitingResponse = stillWaitingResponse {
            try encodeContainer.encode(stillWaitingResponse, forKey: .stillWaitingResponse)
        }
        if let waitingResponse = waitingResponse {
            try encodeContainer.encode(waitingResponse, forKey: .waitingResponse)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waitingResponseDecoded = try containerValues.decodeIfPresent(ResponseSpecification.self, forKey: .waitingResponse)
        waitingResponse = waitingResponseDecoded
        let continueResponseDecoded = try containerValues.decodeIfPresent(ResponseSpecification.self, forKey: .continueResponse)
        continueResponse = continueResponseDecoded
        let stillWaitingResponseDecoded = try containerValues.decodeIfPresent(StillWaitingResponseSpecification.self, forKey: .stillWaitingResponse)
        stillWaitingResponse = stillWaitingResponseDecoded
    }
}

extension WaitAndContinueSpecification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WaitAndContinueSpecification(continueResponse: \(String(describing: continueResponse)), stillWaitingResponse: \(String(describing: stillWaitingResponse)), waitingResponse: \(String(describing: waitingResponse)))"}
}

/// <p>Specifies the prompts that Amazon Lex uses while a bot is waiting for
///          customer input. </p>
public struct WaitAndContinueSpecification: Equatable {
    /// <p>The response that Amazon Lex sends to indicate that the bot is ready to
    ///          continue the conversation.</p>
    public let continueResponse: ResponseSpecification?
    /// <p>A response that Amazon Lex sends periodically to the user to indicate
    ///          that the bot is still waiting for input from the user.</p>
    public let stillWaitingResponse: StillWaitingResponseSpecification?
    /// <p>The response that Amazon Lex sends to indicate that the bot is waiting
    ///          for the conversation to continue.</p>
    public let waitingResponse: ResponseSpecification?

    public init (
        continueResponse: ResponseSpecification? = nil,
        stillWaitingResponse: StillWaitingResponseSpecification? = nil,
        waitingResponse: ResponseSpecification? = nil
    )
    {
        self.continueResponse = continueResponse
        self.stillWaitingResponse = stillWaitingResponse
        self.waitingResponse = waitingResponse
    }
}
