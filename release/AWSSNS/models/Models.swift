// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AddPermissionInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let aWSAccountId = aWSAccountId {
            var aWSAccountIdContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AWSAccountId"))
            for (index0, delegate0) in aWSAccountId.enumerated() {
                try aWSAccountIdContainer.encode(delegate0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let actionName = actionName {
            var actionNameContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ActionName"))
            for (index0, action0) in actionName.enumerated() {
                try actionNameContainer.encode(action0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let label = label {
            try container.encode(label, forKey: ClientRuntime.Key("Label"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
        try container.encode("AddPermission", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension AddPermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AddPermissionInput: Swift.Equatable {
    /// The Amazon Web Services account IDs of the users (principals) who will be given access to the specified actions. The users must have Amazon Web Services account, but do not need to be signed up for this service.
    /// This member is required.
    public var aWSAccountId: [Swift.String]?
    /// The action you want to allow for the specified principal(s). Valid values: Any Amazon SNS action name, for example Publish.
    /// This member is required.
    public var actionName: [Swift.String]?
    /// A unique identifier for the new policy statement.
    /// This member is required.
    public var label: Swift.String?
    /// The ARN of the topic whose access control policy you wish to modify.
    /// This member is required.
    public var topicArn: Swift.String?

    public init (
        aWSAccountId: [Swift.String]? = nil,
        actionName: [Swift.String]? = nil,
        label: Swift.String? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.aWSAccountId = aWSAccountId
        self.actionName = actionName
        self.label = label
        self.topicArn = topicArn
    }
}

struct AddPermissionInputBody: Swift.Equatable {
    let topicArn: Swift.String?
    let label: Swift.String?
    let aWSAccountId: [Swift.String]?
    let actionName: [Swift.String]?
}

extension AddPermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aWSAccountId = "AWSAccountId"
        case actionName = "ActionName"
        case label = "Label"
        case topicArn = "TopicArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        if containerValues.contains(.aWSAccountId) {
            struct KeyVal0{struct member{}}
            let aWSAccountIdWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .aWSAccountId)
            if let aWSAccountIdWrappedContainer = aWSAccountIdWrappedContainer {
                let aWSAccountIdContainer = try aWSAccountIdWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var aWSAccountIdBuffer:[Swift.String]? = nil
                if let aWSAccountIdContainer = aWSAccountIdContainer {
                    aWSAccountIdBuffer = [Swift.String]()
                    for stringContainer0 in aWSAccountIdContainer {
                        aWSAccountIdBuffer?.append(stringContainer0)
                    }
                }
                aWSAccountId = aWSAccountIdBuffer
            } else {
                aWSAccountId = []
            }
        } else {
            aWSAccountId = nil
        }
        if containerValues.contains(.actionName) {
            struct KeyVal0{struct member{}}
            let actionNameWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .actionName)
            if let actionNameWrappedContainer = actionNameWrappedContainer {
                let actionNameContainer = try actionNameWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var actionNameBuffer:[Swift.String]? = nil
                if let actionNameContainer = actionNameContainer {
                    actionNameBuffer = [Swift.String]()
                    for stringContainer0 in actionNameContainer {
                        actionNameBuffer?.append(stringContainer0)
                    }
                }
                actionName = actionNameBuffer
            } else {
                actionName = []
            }
        } else {
            actionName = nil
        }
    }
}

extension AddPermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddPermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFound" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddPermissionOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddPermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AddPermissionOutputResponse: Swift.Equatable {

}

extension AuthorizationErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<AuthorizationErrorExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that the user has been denied access to the requested resource.
public struct AuthorizationErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AuthorizationErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AuthorizationErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BatchEntryIdsNotDistinctException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<BatchEntryIdsNotDistinctExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Two or more batch entries in the request have the same Id.
public struct BatchEntryIdsNotDistinctException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BatchEntryIdsNotDistinctExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BatchEntryIdsNotDistinctExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BatchRequestTooLongException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<BatchRequestTooLongExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The length of all the batch messages put together is more than the limit.
public struct BatchRequestTooLongException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BatchRequestTooLongExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BatchRequestTooLongExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnsClientTypes.BatchResultErrorEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case id = "Id"
        case message = "Message"
        case senderFault = "SenderFault"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let code = code {
            try container.encode(code, forKey: ClientRuntime.Key("Code"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let message = message {
            try container.encode(message, forKey: ClientRuntime.Key("Message"))
        }
        if senderFault != false {
            try container.encode(senderFault, forKey: ClientRuntime.Key("SenderFault"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let senderFaultDecoded = try containerValues.decode(Swift.Bool.self, forKey: .senderFault)
        senderFault = senderFaultDecoded
    }
}

extension SnsClientTypes {
    /// Gives a detailed description of failed messages in the batch.
    public struct BatchResultErrorEntry: Swift.Equatable {
        /// An error code representing why the action failed on this entry.
        /// This member is required.
        public var code: Swift.String?
        /// The Id of an entry in a batch request
        /// This member is required.
        public var id: Swift.String?
        /// A message explaining why the action failed on this entry.
        public var message: Swift.String?
        /// Specifies whether the error happened due to the caller of the batch API action.
        /// This member is required.
        public var senderFault: Swift.Bool

        public init (
            code: Swift.String? = nil,
            id: Swift.String? = nil,
            message: Swift.String? = nil,
            senderFault: Swift.Bool = false
        )
        {
            self.code = code
            self.id = id
            self.message = message
            self.senderFault = senderFault
        }
    }

}

extension CheckIfPhoneNumberIsOptedOutInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: ClientRuntime.Key("phoneNumber"))
        }
        try container.encode("CheckIfPhoneNumberIsOptedOut", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CheckIfPhoneNumberIsOptedOutInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The input for the CheckIfPhoneNumberIsOptedOut action.
public struct CheckIfPhoneNumberIsOptedOutInput: Swift.Equatable {
    /// The phone number for which you want to check the opt out status.
    /// This member is required.
    public var phoneNumber: Swift.String?

    public init (
        phoneNumber: Swift.String? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

struct CheckIfPhoneNumberIsOptedOutInputBody: Swift.Equatable {
    let phoneNumber: Swift.String?
}

extension CheckIfPhoneNumberIsOptedOutInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
    }
}

extension CheckIfPhoneNumberIsOptedOutOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CheckIfPhoneNumberIsOptedOutOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Throttled" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CheckIfPhoneNumberIsOptedOutOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CheckIfPhoneNumberIsOptedOutOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CheckIfPhoneNumberIsOptedOutOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.isOptedOut = output.isOptedOut
        } else {
            self.isOptedOut = false
        }
    }
}

/// The response from the CheckIfPhoneNumberIsOptedOut action.
public struct CheckIfPhoneNumberIsOptedOutOutputResponse: Swift.Equatable {
    /// Indicates whether the phone number is opted out:
    ///
    /// * true – The phone number is opted out, meaning you cannot publish SMS messages to it.
    ///
    /// * false – The phone number is opted in, meaning you can publish SMS messages to it.
    public var isOptedOut: Swift.Bool

    public init (
        isOptedOut: Swift.Bool = false
    )
    {
        self.isOptedOut = isOptedOut
    }
}

struct CheckIfPhoneNumberIsOptedOutOutputResponseBody: Swift.Equatable {
    let isOptedOut: Swift.Bool
}

extension CheckIfPhoneNumberIsOptedOutOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isOptedOut
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CheckIfPhoneNumberIsOptedOutResult"))
        let isOptedOutDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isOptedOut)
        isOptedOut = isOptedOutDecoded
    }
}

extension ConcurrentAccessException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<ConcurrentAccessExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Can't perform multiple operations on a tag simultaneously. Perform the operations sequentially.
public struct ConcurrentAccessException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentAccessExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConcurrentAccessExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConfirmSubscriptionInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let authenticateOnUnsubscribe = authenticateOnUnsubscribe {
            try container.encode(authenticateOnUnsubscribe, forKey: ClientRuntime.Key("AuthenticateOnUnsubscribe"))
        }
        if let token = token {
            try container.encode(token, forKey: ClientRuntime.Key("Token"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
        try container.encode("ConfirmSubscription", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ConfirmSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input for ConfirmSubscription action.
public struct ConfirmSubscriptionInput: Swift.Equatable {
    /// Disallows unauthenticated unsubscribes of the subscription. If the value of this parameter is true and the request has an Amazon Web Services signature, then only the topic owner and the subscription owner can unsubscribe the endpoint. The unsubscribe action requires Amazon Web Services authentication.
    public var authenticateOnUnsubscribe: Swift.String?
    /// Short-lived token sent to an endpoint during the Subscribe action.
    /// This member is required.
    public var token: Swift.String?
    /// The ARN of the topic for which you wish to confirm a subscription.
    /// This member is required.
    public var topicArn: Swift.String?

    public init (
        authenticateOnUnsubscribe: Swift.String? = nil,
        token: Swift.String? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.authenticateOnUnsubscribe = authenticateOnUnsubscribe
        self.token = token
        self.topicArn = topicArn
    }
}

struct ConfirmSubscriptionInputBody: Swift.Equatable {
    let topicArn: Swift.String?
    let token: Swift.String?
    let authenticateOnUnsubscribe: Swift.String?
}

extension ConfirmSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticateOnUnsubscribe = "AuthenticateOnUnsubscribe"
        case token = "Token"
        case topicArn = "TopicArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
        let authenticateOnUnsubscribeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authenticateOnUnsubscribe)
        authenticateOnUnsubscribe = authenticateOnUnsubscribeDecoded
    }
}

extension ConfirmSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ConfirmSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FilterPolicyLimitExceeded" : self = .filterPolicyLimitExceededException(try FilterPolicyLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFound" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionLimitExceeded" : self = .subscriptionLimitExceededException(try SubscriptionLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ConfirmSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case filterPolicyLimitExceededException(FilterPolicyLimitExceededException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case subscriptionLimitExceededException(SubscriptionLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ConfirmSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConfirmSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.subscriptionArn = output.subscriptionArn
        } else {
            self.subscriptionArn = nil
        }
    }
}

/// Response for ConfirmSubscriptions action.
public struct ConfirmSubscriptionOutputResponse: Swift.Equatable {
    /// The ARN of the created subscription.
    public var subscriptionArn: Swift.String?

    public init (
        subscriptionArn: Swift.String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

struct ConfirmSubscriptionOutputResponseBody: Swift.Equatable {
    let subscriptionArn: Swift.String?
}

extension ConfirmSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriptionArn = "SubscriptionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ConfirmSubscriptionResult"))
        let subscriptionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionArn)
        subscriptionArn = subscriptionArnDecoded
    }
}

extension CreatePlatformApplicationInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let stringValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(stringKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(stringValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let platform = platform {
            try container.encode(platform, forKey: ClientRuntime.Key("Platform"))
        }
        try container.encode("CreatePlatformApplication", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreatePlatformApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input for CreatePlatformApplication action.
public struct CreatePlatformApplicationInput: Swift.Equatable {
    /// For a list of attributes, see [SetPlatformApplicationAttributes](https://docs.aws.amazon.com/sns/latest/api/API_SetPlatformApplicationAttributes.html).
    /// This member is required.
    public var attributes: [Swift.String:Swift.String]?
    /// Application names must be made up of only uppercase and lowercase ASCII letters, numbers, underscores, hyphens, and periods, and must be between 1 and 256 characters long.
    /// This member is required.
    public var name: Swift.String?
    /// The following platforms are supported: ADM (Amazon Device Messaging), APNS (Apple Push Notification Service), APNS_SANDBOX, and GCM (Firebase Cloud Messaging).
    /// This member is required.
    public var platform: Swift.String?

    public init (
        attributes: [Swift.String:Swift.String]? = nil,
        name: Swift.String? = nil,
        platform: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.name = name
        self.platform = platform
    }
}

struct CreatePlatformApplicationInputBody: Swift.Equatable {
    let name: Swift.String?
    let platform: Swift.String?
    let attributes: [Swift.String:Swift.String]?
}

extension CreatePlatformApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case name = "Name"
        case platform = "Platform"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platform)
        platform = platformDecoded
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var attributesBuffer: [Swift.String:Swift.String]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in attributesContainer {
                        attributesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = [:]
            }
        } else {
            attributes = nil
        }
    }
}

extension CreatePlatformApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreatePlatformApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePlatformApplicationOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePlatformApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePlatformApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.platformApplicationArn = output.platformApplicationArn
        } else {
            self.platformApplicationArn = nil
        }
    }
}

/// Response from CreatePlatformApplication action.
public struct CreatePlatformApplicationOutputResponse: Swift.Equatable {
    /// PlatformApplicationArn is returned.
    public var platformApplicationArn: Swift.String?

    public init (
        platformApplicationArn: Swift.String? = nil
    )
    {
        self.platformApplicationArn = platformApplicationArn
    }
}

struct CreatePlatformApplicationOutputResponseBody: Swift.Equatable {
    let platformApplicationArn: Swift.String?
}

extension CreatePlatformApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case platformApplicationArn = "PlatformApplicationArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreatePlatformApplicationResult"))
        let platformApplicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformApplicationArn)
        platformApplicationArn = platformApplicationArnDecoded
    }
}

extension CreatePlatformEndpointInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let stringValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(stringKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(stringValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let customUserData = customUserData {
            try container.encode(customUserData, forKey: ClientRuntime.Key("CustomUserData"))
        }
        if let platformApplicationArn = platformApplicationArn {
            try container.encode(platformApplicationArn, forKey: ClientRuntime.Key("PlatformApplicationArn"))
        }
        if let token = token {
            try container.encode(token, forKey: ClientRuntime.Key("Token"))
        }
        try container.encode("CreatePlatformEndpoint", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreatePlatformEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input for CreatePlatformEndpoint action.
public struct CreatePlatformEndpointInput: Swift.Equatable {
    /// For a list of attributes, see [SetEndpointAttributes](https://docs.aws.amazon.com/sns/latest/api/API_SetEndpointAttributes.html).
    public var attributes: [Swift.String:Swift.String]?
    /// Arbitrary user data to associate with the endpoint. Amazon SNS does not use this data. The data must be in UTF-8 format and less than 2KB.
    public var customUserData: Swift.String?
    /// PlatformApplicationArn returned from CreatePlatformApplication is used to create a an endpoint.
    /// This member is required.
    public var platformApplicationArn: Swift.String?
    /// Unique identifier created by the notification service for an app on a device. The specific name for Token will vary, depending on which notification service is being used. For example, when using APNS as the notification service, you need the device token. Alternatively, when using GCM (Firebase Cloud Messaging) or ADM, the device token equivalent is called the registration ID.
    /// This member is required.
    public var token: Swift.String?

    public init (
        attributes: [Swift.String:Swift.String]? = nil,
        customUserData: Swift.String? = nil,
        platformApplicationArn: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.customUserData = customUserData
        self.platformApplicationArn = platformApplicationArn
        self.token = token
    }
}

struct CreatePlatformEndpointInputBody: Swift.Equatable {
    let platformApplicationArn: Swift.String?
    let token: Swift.String?
    let customUserData: Swift.String?
    let attributes: [Swift.String:Swift.String]?
}

extension CreatePlatformEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case customUserData = "CustomUserData"
        case platformApplicationArn = "PlatformApplicationArn"
        case token = "Token"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let platformApplicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformApplicationArn)
        platformApplicationArn = platformApplicationArnDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
        let customUserDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customUserData)
        customUserData = customUserDataDecoded
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var attributesBuffer: [Swift.String:Swift.String]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in attributesContainer {
                        attributesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = [:]
            }
        } else {
            attributes = nil
        }
    }
}

extension CreatePlatformEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreatePlatformEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFound" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePlatformEndpointOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePlatformEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePlatformEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpointArn = output.endpointArn
        } else {
            self.endpointArn = nil
        }
    }
}

/// Response from CreateEndpoint action.
public struct CreatePlatformEndpointOutputResponse: Swift.Equatable {
    /// EndpointArn returned from CreateEndpoint action.
    public var endpointArn: Swift.String?

    public init (
        endpointArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

struct CreatePlatformEndpointOutputResponseBody: Swift.Equatable {
    let endpointArn: Swift.String?
}

extension CreatePlatformEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreatePlatformEndpointResult"))
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
    }
}

extension CreateSMSSandboxPhoneNumberInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let languageCode = languageCode {
            try container.encode(languageCode, forKey: ClientRuntime.Key("LanguageCode"))
        }
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: ClientRuntime.Key("PhoneNumber"))
        }
        try container.encode("CreateSMSSandboxPhoneNumber", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateSMSSandboxPhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateSMSSandboxPhoneNumberInput: Swift.Equatable {
    /// The language to use for sending the OTP. The default value is en-US.
    public var languageCode: SnsClientTypes.LanguageCodeString?
    /// The destination phone number to verify. On verification, Amazon SNS adds this phone number to the list of verified phone numbers that you can send SMS messages to.
    /// This member is required.
    public var phoneNumber: Swift.String?

    public init (
        languageCode: SnsClientTypes.LanguageCodeString? = nil,
        phoneNumber: Swift.String? = nil
    )
    {
        self.languageCode = languageCode
        self.phoneNumber = phoneNumber
    }
}

struct CreateSMSSandboxPhoneNumberInputBody: Swift.Equatable {
    let phoneNumber: Swift.String?
    let languageCode: SnsClientTypes.LanguageCodeString?
}

extension CreateSMSSandboxPhoneNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case languageCode = "LanguageCode"
        case phoneNumber = "PhoneNumber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(SnsClientTypes.LanguageCodeString.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension CreateSMSSandboxPhoneNumberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateSMSSandboxPhoneNumberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptedOut" : self = .optedOutException(try OptedOutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Throttled" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserError" : self = .userErrorException(try UserErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSMSSandboxPhoneNumberOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case optedOutException(OptedOutException)
    case throttledException(ThrottledException)
    case userErrorException(UserErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSMSSandboxPhoneNumberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateSMSSandboxPhoneNumberOutputResponse: Swift.Equatable {

}

extension CreateTopicInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let attributenameKey0 = element0.key
                let attributevalueValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(attributenameKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(attributevalueValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateTopic", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateTopicInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input for CreateTopic action.
public struct CreateTopicInput: Swift.Equatable {
    /// A map of attributes with their corresponding values. The following lists the names, descriptions, and values of the special request parameters that the CreateTopic action uses:
    ///
    /// * DeliveryPolicy – The policy that defines how Amazon SNS retries failed deliveries to HTTP/S endpoints.
    ///
    /// * DisplayName – The display name to use for a topic with SMS subscriptions.
    ///
    /// * FifoTopic – Set to true to create a FIFO topic.
    ///
    /// * Policy – The policy that defines who can access your topic. By default, only the topic owner can publish or subscribe to the topic.
    ///
    ///
    /// The following attribute applies only to [server-side encryption](https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html):
    ///
    /// * KmsMasterKeyId – The ID of an Amazon Web Services managed customer master key (CMK) for Amazon SNS or a custom CMK. For more information, see [Key Terms](https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html#sse-key-terms). For more examples, see [KeyId](https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters) in the Key Management Service API Reference.
    ///
    ///
    /// The following attributes apply only to [FIFO topics](https://docs.aws.amazon.com/sns/latest/dg/sns-fifo-topics.html):
    ///
    /// * FifoTopic – When this is set to true, a FIFO topic is created.
    ///
    /// * ContentBasedDeduplication – Enables content-based deduplication for FIFO topics.
    ///
    /// * By default, ContentBasedDeduplication is set to false. If you create a FIFO topic and this attribute is false, you must specify a value for the MessageDeduplicationId parameter for the [Publish](https://docs.aws.amazon.com/sns/latest/api/API_Publish.html) action.
    ///
    /// * When you set ContentBasedDeduplication to true, Amazon SNS uses a SHA-256 hash to generate the MessageDeduplicationId using the body of the message (but not the attributes of the message). (Optional) To override the generated value, you can specify a value for the MessageDeduplicationId parameter for the Publish action.
    public var attributes: [Swift.String:Swift.String]?
    /// The name of the topic you want to create. Constraints: Topic names must be made up of only uppercase and lowercase ASCII letters, numbers, underscores, and hyphens, and must be between 1 and 256 characters long. For a FIFO (first-in-first-out) topic, the name must end with the .fifo suffix.
    /// This member is required.
    public var name: Swift.String?
    /// The list of tags to add to a new topic. To be able to tag a topic on creation, you must have the sns:CreateTopic and sns:TagResource permissions.
    public var tags: [SnsClientTypes.Tag]?

    public init (
        attributes: [Swift.String:Swift.String]? = nil,
        name: Swift.String? = nil,
        tags: [SnsClientTypes.Tag]? = nil
    )
    {
        self.attributes = attributes
        self.name = name
        self.tags = tags
    }
}

struct CreateTopicInputBody: Swift.Equatable {
    let name: Swift.String?
    let attributes: [Swift.String:Swift.String]?
    let tags: [SnsClientTypes.Tag]?
}

extension CreateTopicInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var attributesBuffer: [Swift.String:Swift.String]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in attributesContainer {
                        attributesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = [:]
            }
        } else {
            attributes = nil
        }
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([SnsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[SnsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [SnsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateTopicOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateTopicOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentAccess" : self = .concurrentAccessException(try ConcurrentAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecurity" : self = .invalidSecurityException(try InvalidSecurityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StaleTag" : self = .staleTagException(try StaleTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceeded" : self = .tagLimitExceededException(try TagLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicy" : self = .tagPolicyException(try TagPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TopicLimitExceeded" : self = .topicLimitExceededException(try TopicLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTopicOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case concurrentAccessException(ConcurrentAccessException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidSecurityException(InvalidSecurityException)
    case staleTagException(StaleTagException)
    case tagLimitExceededException(TagLimitExceededException)
    case tagPolicyException(TagPolicyException)
    case topicLimitExceededException(TopicLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTopicOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateTopicOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.topicArn = output.topicArn
        } else {
            self.topicArn = nil
        }
    }
}

/// Response from CreateTopic action.
public struct CreateTopicOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) assigned to the created topic.
    public var topicArn: Swift.String?

    public init (
        topicArn: Swift.String? = nil
    )
    {
        self.topicArn = topicArn
    }
}

struct CreateTopicOutputResponseBody: Swift.Equatable {
    let topicArn: Swift.String?
}

extension CreateTopicOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topicArn = "TopicArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateTopicResult"))
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

extension DeleteEndpointInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let endpointArn = endpointArn {
            try container.encode(endpointArn, forKey: ClientRuntime.Key("EndpointArn"))
        }
        try container.encode("DeleteEndpoint", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input for DeleteEndpoint action.
public struct DeleteEndpointInput: Swift.Equatable {
    /// EndpointArn of endpoint to delete.
    /// This member is required.
    public var endpointArn: Swift.String?

    public init (
        endpointArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

struct DeleteEndpointInputBody: Swift.Equatable {
    let endpointArn: Swift.String?
}

extension DeleteEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
    }
}

extension DeleteEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEndpointOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEndpointOutputResponse: Swift.Equatable {

}

extension DeletePlatformApplicationInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let platformApplicationArn = platformApplicationArn {
            try container.encode(platformApplicationArn, forKey: ClientRuntime.Key("PlatformApplicationArn"))
        }
        try container.encode("DeletePlatformApplication", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeletePlatformApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input for DeletePlatformApplication action.
public struct DeletePlatformApplicationInput: Swift.Equatable {
    /// PlatformApplicationArn of platform application object to delete.
    /// This member is required.
    public var platformApplicationArn: Swift.String?

    public init (
        platformApplicationArn: Swift.String? = nil
    )
    {
        self.platformApplicationArn = platformApplicationArn
    }
}

struct DeletePlatformApplicationInputBody: Swift.Equatable {
    let platformApplicationArn: Swift.String?
}

extension DeletePlatformApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case platformApplicationArn = "PlatformApplicationArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let platformApplicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformApplicationArn)
        platformApplicationArn = platformApplicationArnDecoded
    }
}

extension DeletePlatformApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeletePlatformApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePlatformApplicationOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePlatformApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePlatformApplicationOutputResponse: Swift.Equatable {

}

extension DeleteSMSSandboxPhoneNumberInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: ClientRuntime.Key("PhoneNumber"))
        }
        try container.encode("DeleteSMSSandboxPhoneNumber", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteSMSSandboxPhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSMSSandboxPhoneNumberInput: Swift.Equatable {
    /// The destination phone number to delete.
    /// This member is required.
    public var phoneNumber: Swift.String?

    public init (
        phoneNumber: Swift.String? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

struct DeleteSMSSandboxPhoneNumberInputBody: Swift.Equatable {
    let phoneNumber: Swift.String?
}

extension DeleteSMSSandboxPhoneNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber = "PhoneNumber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
    }
}

extension DeleteSMSSandboxPhoneNumberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteSMSSandboxPhoneNumberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Throttled" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserError" : self = .userErrorException(try UserErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSMSSandboxPhoneNumberOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttledException(ThrottledException)
    case userErrorException(UserErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSMSSandboxPhoneNumberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSMSSandboxPhoneNumberOutputResponse: Swift.Equatable {

}

extension DeleteTopicInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
        try container.encode("DeleteTopic", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteTopicInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteTopicInput: Swift.Equatable {
    /// The ARN of the topic you want to delete.
    /// This member is required.
    public var topicArn: Swift.String?

    public init (
        topicArn: Swift.String? = nil
    )
    {
        self.topicArn = topicArn
    }
}

struct DeleteTopicInputBody: Swift.Equatable {
    let topicArn: Swift.String?
}

extension DeleteTopicInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topicArn = "TopicArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

extension DeleteTopicOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteTopicOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentAccess" : self = .concurrentAccessException(try ConcurrentAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFound" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StaleTag" : self = .staleTagException(try StaleTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicy" : self = .tagPolicyException(try TagPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTopicOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case concurrentAccessException(ConcurrentAccessException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case staleTagException(StaleTagException)
    case tagPolicyException(TagPolicyException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTopicOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTopicOutputResponse: Swift.Equatable {

}

extension EmptyBatchRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<EmptyBatchRequestExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The batch request doesn't contain any entries.
public struct EmptyBatchRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EmptyBatchRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EmptyBatchRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnsClientTypes.Endpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case endpointArn = "EndpointArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let stringValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(stringKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(stringValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let endpointArn = endpointArn {
            try container.encode(endpointArn, forKey: ClientRuntime.Key("EndpointArn"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var attributesBuffer: [Swift.String:Swift.String]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in attributesContainer {
                        attributesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = [:]
            }
        } else {
            attributes = nil
        }
    }
}

extension SnsClientTypes {
    /// The endpoint for mobile app and device.
    public struct Endpoint: Swift.Equatable {
        /// Attributes for endpoint.
        public var attributes: [Swift.String:Swift.String]?
        /// The EndpointArn for mobile app and device.
        public var endpointArn: Swift.String?

        public init (
            attributes: [Swift.String:Swift.String]? = nil,
            endpointArn: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.endpointArn = endpointArn
        }
    }

}

extension EndpointDisabledException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<EndpointDisabledExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception error indicating endpoint disabled.
public struct EndpointDisabledException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Message for endpoint disabled.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EndpointDisabledExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EndpointDisabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FilterPolicyLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<FilterPolicyLimitExceededExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that the number of filter polices in your Amazon Web Services account exceeds the limit. To add more filter polices, submit an Amazon SNS Limit Increase case in the Amazon Web Services Support Center.
public struct FilterPolicyLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FilterPolicyLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension FilterPolicyLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetEndpointAttributesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let endpointArn = endpointArn {
            try container.encode(endpointArn, forKey: ClientRuntime.Key("EndpointArn"))
        }
        try container.encode("GetEndpointAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetEndpointAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input for GetEndpointAttributes action.
public struct GetEndpointAttributesInput: Swift.Equatable {
    /// EndpointArn for GetEndpointAttributes input.
    /// This member is required.
    public var endpointArn: Swift.String?

    public init (
        endpointArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

struct GetEndpointAttributesInputBody: Swift.Equatable {
    let endpointArn: Swift.String?
}

extension GetEndpointAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
    }
}

extension GetEndpointAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetEndpointAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFound" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEndpointAttributesOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEndpointAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetEndpointAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

/// Response from GetEndpointAttributes of the EndpointArn.
public struct GetEndpointAttributesOutputResponse: Swift.Equatable {
    /// Attributes include the following:
    ///
    /// * CustomUserData – arbitrary user data to associate with the endpoint. Amazon SNS does not use this data. The data must be in UTF-8 format and less than 2KB.
    ///
    /// * Enabled – flag that enables/disables delivery to the endpoint. Amazon SNS will set this to false when a notification service indicates to Amazon SNS that the endpoint is invalid. Users can set it back to true, typically after updating Token.
    ///
    /// * Token – device token, also referred to as a registration id, for an app and mobile device. This is returned from the notification service when an app and mobile device are registered with the notification service. The device token for the iOS platform is returned in lowercase.
    public var attributes: [Swift.String:Swift.String]?

    public init (
        attributes: [Swift.String:Swift.String]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct GetEndpointAttributesOutputResponseBody: Swift.Equatable {
    let attributes: [Swift.String:Swift.String]?
}

extension GetEndpointAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetEndpointAttributesResult"))
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var attributesBuffer: [Swift.String:Swift.String]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in attributesContainer {
                        attributesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = [:]
            }
        } else {
            attributes = nil
        }
    }
}

extension GetPlatformApplicationAttributesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let platformApplicationArn = platformApplicationArn {
            try container.encode(platformApplicationArn, forKey: ClientRuntime.Key("PlatformApplicationArn"))
        }
        try container.encode("GetPlatformApplicationAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetPlatformApplicationAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input for GetPlatformApplicationAttributes action.
public struct GetPlatformApplicationAttributesInput: Swift.Equatable {
    /// PlatformApplicationArn for GetPlatformApplicationAttributesInput.
    /// This member is required.
    public var platformApplicationArn: Swift.String?

    public init (
        platformApplicationArn: Swift.String? = nil
    )
    {
        self.platformApplicationArn = platformApplicationArn
    }
}

struct GetPlatformApplicationAttributesInputBody: Swift.Equatable {
    let platformApplicationArn: Swift.String?
}

extension GetPlatformApplicationAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case platformApplicationArn = "PlatformApplicationArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let platformApplicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformApplicationArn)
        platformApplicationArn = platformApplicationArnDecoded
    }
}

extension GetPlatformApplicationAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetPlatformApplicationAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFound" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPlatformApplicationAttributesOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPlatformApplicationAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPlatformApplicationAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

/// Response for GetPlatformApplicationAttributes action.
public struct GetPlatformApplicationAttributesOutputResponse: Swift.Equatable {
    /// Attributes include the following:
    ///
    /// * AppleCertificateExpiryDate – The expiry date of the SSL certificate used to configure certificate-based authentication.
    ///
    /// * ApplePlatformTeamID – The Apple developer account ID used to configure token-based authentication.
    ///
    /// * ApplePlatformBundleID – The app identifier used to configure token-based authentication.
    ///
    /// * EventEndpointCreated – Topic ARN to which EndpointCreated event notifications should be sent.
    ///
    /// * EventEndpointDeleted – Topic ARN to which EndpointDeleted event notifications should be sent.
    ///
    /// * EventEndpointUpdated – Topic ARN to which EndpointUpdate event notifications should be sent.
    ///
    /// * EventDeliveryFailure – Topic ARN to which DeliveryFailure event notifications should be sent upon Direct Publish delivery failure (permanent) to one of the application's endpoints.
    public var attributes: [Swift.String:Swift.String]?

    public init (
        attributes: [Swift.String:Swift.String]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct GetPlatformApplicationAttributesOutputResponseBody: Swift.Equatable {
    let attributes: [Swift.String:Swift.String]?
}

extension GetPlatformApplicationAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetPlatformApplicationAttributesResult"))
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var attributesBuffer: [Swift.String:Swift.String]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in attributesContainer {
                        attributesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = [:]
            }
        } else {
            attributes = nil
        }
    }
}

extension GetSMSAttributesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("attributes"))
            for (index0, string0) in attributes.enumerated() {
                try attributesContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("GetSMSAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetSMSAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The input for the GetSMSAttributes request.
public struct GetSMSAttributesInput: Swift.Equatable {
    /// A list of the individual attribute names, such as MonthlySpendLimit, for which you want values. For all attribute names, see [SetSMSAttributes](https://docs.aws.amazon.com/sns/latest/api/API_SetSMSAttributes.html). If you don't use this parameter, Amazon SNS returns all SMS attributes.
    public var attributes: [Swift.String]?

    public init (
        attributes: [Swift.String]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct GetSMSAttributesInputBody: Swift.Equatable {
    let attributes: [Swift.String]?
}

extension GetSMSAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct member{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var attributesBuffer:[Swift.String]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [Swift.String]()
                    for stringContainer0 in attributesContainer {
                        attributesBuffer?.append(stringContainer0)
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = []
            }
        } else {
            attributes = nil
        }
    }
}

extension GetSMSAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetSMSAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Throttled" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSMSAttributesOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSMSAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSMSAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

/// The response from the GetSMSAttributes request.
public struct GetSMSAttributesOutputResponse: Swift.Equatable {
    /// The SMS attribute names and their values.
    public var attributes: [Swift.String:Swift.String]?

    public init (
        attributes: [Swift.String:Swift.String]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct GetSMSAttributesOutputResponseBody: Swift.Equatable {
    let attributes: [Swift.String:Swift.String]?
}

extension GetSMSAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetSMSAttributesResult"))
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var attributesBuffer: [Swift.String:Swift.String]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in attributesContainer {
                        attributesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = [:]
            }
        } else {
            attributes = nil
        }
    }
}

extension GetSMSSandboxAccountStatusInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("GetSMSSandboxAccountStatus", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetSMSSandboxAccountStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSMSSandboxAccountStatusInput: Swift.Equatable {

}

extension GetSMSSandboxAccountStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetSMSSandboxAccountStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Throttled" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSMSSandboxAccountStatusOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSMSSandboxAccountStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSMSSandboxAccountStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.isInSandbox = output.isInSandbox
        } else {
            self.isInSandbox = false
        }
    }
}

public struct GetSMSSandboxAccountStatusOutputResponse: Swift.Equatable {
    /// Indicates whether the calling Amazon Web Services account is in the SMS sandbox.
    /// This member is required.
    public var isInSandbox: Swift.Bool

    public init (
        isInSandbox: Swift.Bool = false
    )
    {
        self.isInSandbox = isInSandbox
    }
}

struct GetSMSSandboxAccountStatusOutputResponseBody: Swift.Equatable {
    let isInSandbox: Swift.Bool
}

extension GetSMSSandboxAccountStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isInSandbox = "IsInSandbox"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetSMSSandboxAccountStatusResult"))
        let isInSandboxDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isInSandbox)
        isInSandbox = isInSandboxDecoded
    }
}

extension GetSubscriptionAttributesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let subscriptionArn = subscriptionArn {
            try container.encode(subscriptionArn, forKey: ClientRuntime.Key("SubscriptionArn"))
        }
        try container.encode("GetSubscriptionAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetSubscriptionAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input for GetSubscriptionAttributes.
public struct GetSubscriptionAttributesInput: Swift.Equatable {
    /// The ARN of the subscription whose properties you want to get.
    /// This member is required.
    public var subscriptionArn: Swift.String?

    public init (
        subscriptionArn: Swift.String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

struct GetSubscriptionAttributesInputBody: Swift.Equatable {
    let subscriptionArn: Swift.String?
}

extension GetSubscriptionAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriptionArn = "SubscriptionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionArn)
        subscriptionArn = subscriptionArnDecoded
    }
}

extension GetSubscriptionAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetSubscriptionAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFound" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSubscriptionAttributesOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSubscriptionAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSubscriptionAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

/// Response for GetSubscriptionAttributes action.
public struct GetSubscriptionAttributesOutputResponse: Swift.Equatable {
    /// A map of the subscription's attributes. Attributes in this map include the following:
    ///
    /// * ConfirmationWasAuthenticated – true if the subscription confirmation request was authenticated.
    ///
    /// * DeliveryPolicy – The JSON serialization of the subscription's delivery policy.
    ///
    /// * EffectiveDeliveryPolicy – The JSON serialization of the effective delivery policy that takes into account the topic delivery policy and account system defaults.
    ///
    /// * FilterPolicy – The filter policy JSON that is assigned to the subscription. For more information, see [Amazon SNS Message Filtering](https://docs.aws.amazon.com/sns/latest/dg/sns-message-filtering.html) in the Amazon SNS Developer Guide.
    ///
    /// * Owner – The Amazon Web Services account ID of the subscription's owner.
    ///
    /// * PendingConfirmation – true if the subscription hasn't been confirmed. To confirm a pending subscription, call the ConfirmSubscription action with a confirmation token.
    ///
    /// * RawMessageDelivery – true if raw message delivery is enabled for the subscription. Raw messages are free of JSON formatting and can be sent to HTTP/S and Amazon SQS endpoints.
    ///
    /// * RedrivePolicy – When specified, sends undeliverable messages to the specified Amazon SQS dead-letter queue. Messages that can't be delivered due to client errors (for example, when the subscribed endpoint is unreachable) or server errors (for example, when the service that powers the subscribed endpoint becomes unavailable) are held in the dead-letter queue for further analysis or reprocessing.
    ///
    /// * SubscriptionArn – The subscription's ARN.
    ///
    /// * TopicArn – The topic ARN that the subscription is associated with.
    ///
    ///
    /// The following attribute applies only to Amazon Kinesis Data Firehose delivery stream subscriptions:
    ///
    /// * SubscriptionRoleArn – The ARN of the IAM role that has the following:
    ///
    /// * Permission to write to the Kinesis Data Firehose delivery stream
    ///
    /// * Amazon SNS listed as a trusted entity
    ///
    ///
    /// Specifying a valid ARN for this attribute is required for Kinesis Data Firehose delivery stream subscriptions. For more information, see [Fanout to Kinesis Data Firehose delivery streams](https://docs.aws.amazon.com/sns/latest/dg/sns-firehose-as-subscriber.html) in the Amazon SNS Developer Guide.
    public var attributes: [Swift.String:Swift.String]?

    public init (
        attributes: [Swift.String:Swift.String]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct GetSubscriptionAttributesOutputResponseBody: Swift.Equatable {
    let attributes: [Swift.String:Swift.String]?
}

extension GetSubscriptionAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetSubscriptionAttributesResult"))
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var attributesBuffer: [Swift.String:Swift.String]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in attributesContainer {
                        attributesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = [:]
            }
        } else {
            attributes = nil
        }
    }
}

extension GetTopicAttributesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
        try container.encode("GetTopicAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetTopicAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input for GetTopicAttributes action.
public struct GetTopicAttributesInput: Swift.Equatable {
    /// The ARN of the topic whose properties you want to get.
    /// This member is required.
    public var topicArn: Swift.String?

    public init (
        topicArn: Swift.String? = nil
    )
    {
        self.topicArn = topicArn
    }
}

struct GetTopicAttributesInputBody: Swift.Equatable {
    let topicArn: Swift.String?
}

extension GetTopicAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topicArn = "TopicArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

extension GetTopicAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetTopicAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecurity" : self = .invalidSecurityException(try InvalidSecurityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFound" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTopicAttributesOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidSecurityException(InvalidSecurityException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTopicAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetTopicAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

/// Response for GetTopicAttributes action.
public struct GetTopicAttributesOutputResponse: Swift.Equatable {
    /// A map of the topic's attributes. Attributes in this map include the following:
    ///
    /// * DeliveryPolicy – The JSON serialization of the topic's delivery policy.
    ///
    /// * DisplayName – The human-readable name used in the From field for notifications to email and email-json endpoints.
    ///
    /// * Owner – The Amazon Web Services account ID of the topic's owner.
    ///
    /// * Policy – The JSON serialization of the topic's access control policy.
    ///
    /// * SubscriptionsConfirmed – The number of confirmed subscriptions for the topic.
    ///
    /// * SubscriptionsDeleted – The number of deleted subscriptions for the topic.
    ///
    /// * SubscriptionsPending – The number of subscriptions pending confirmation for the topic.
    ///
    /// * TopicArn – The topic's ARN.
    ///
    /// * EffectiveDeliveryPolicy – The JSON serialization of the effective delivery policy, taking system defaults into account.
    ///
    ///
    /// The following attribute applies only to [server-side-encryption](https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html):
    ///
    /// * KmsMasterKeyId - The ID of an Amazon Web Services managed customer master key (CMK) for Amazon SNS or a custom CMK. For more information, see [Key Terms](https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html#sse-key-terms). For more examples, see [KeyId](https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters) in the Key Management Service API Reference.
    ///
    ///
    /// The following attributes apply only to [FIFO topics](https://docs.aws.amazon.com/sns/latest/dg/sns-fifo-topics.html):
    ///
    /// * FifoTopic – When this is set to true, a FIFO topic is created.
    ///
    /// * ContentBasedDeduplication – Enables content-based deduplication for FIFO topics.
    ///
    /// * By default, ContentBasedDeduplication is set to false. If you create a FIFO topic and this attribute is false, you must specify a value for the MessageDeduplicationId parameter for the [Publish](https://docs.aws.amazon.com/sns/latest/api/API_Publish.html) action.
    ///
    /// * When you set ContentBasedDeduplication to true, Amazon SNS uses a SHA-256 hash to generate the MessageDeduplicationId using the body of the message (but not the attributes of the message). (Optional) To override the generated value, you can specify a value for the MessageDeduplicationId parameter for the Publish action.
    public var attributes: [Swift.String:Swift.String]?

    public init (
        attributes: [Swift.String:Swift.String]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct GetTopicAttributesOutputResponseBody: Swift.Equatable {
    let attributes: [Swift.String:Swift.String]?
}

extension GetTopicAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetTopicAttributesResult"))
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var attributesBuffer: [Swift.String:Swift.String]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in attributesContainer {
                        attributesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = [:]
            }
        } else {
            attributes = nil
        }
    }
}

extension InternalErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InternalErrorExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates an internal service error.
public struct InternalErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidBatchEntryIdException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidBatchEntryIdExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Id of a batch entry in a batch request doesn't abide by the specification.
public struct InvalidBatchEntryIdException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidBatchEntryIdExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidBatchEntryIdExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidParameterExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that a request parameter does not comply with the associated constraints.
public struct InvalidParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterValueException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidParameterValueExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that a request parameter does not comply with the associated constraints.
public struct InvalidParameterValueException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The parameter of an entry in a request doesn't abide by the specification.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterValueExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSecurityException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidSecurityExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The credential signature isn't valid. You must use an HTTPS endpoint and sign your request using Signature Version 4.
public struct InvalidSecurityException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSecurityExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidSecurityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSAccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<KMSAccessDeniedExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The ciphertext references a key that doesn't exist or that you don't have access to.
public struct KMSAccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSAccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension KMSAccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSDisabledException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<KMSDisabledExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because the specified customer master key (CMK) isn't enabled.
public struct KMSDisabledException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSDisabledExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension KMSDisabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSInvalidStateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<KMSInvalidStateExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because the state of the specified resource isn't valid for this request. For more information, see [How Key State Affects Use of a Customer Master Key](https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html) in the Key Management Service Developer Guide.
public struct KMSInvalidStateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSInvalidStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension KMSInvalidStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<KMSNotFoundExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because the specified entity or resource can't be found.
public struct KMSNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension KMSNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSOptInRequired {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<KMSOptInRequiredBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Amazon Web Services access key ID needs a subscription for the service.
public struct KMSOptInRequired: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSOptInRequiredBody: Swift.Equatable {
    let message: Swift.String?
}

extension KMSOptInRequiredBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<KMSThrottlingExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling. For more information about throttling, see [Limits](https://docs.aws.amazon.com/kms/latest/developerguide/limits.html#requests-per-second) in the Key Management Service Developer Guide.
public struct KMSThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension KMSThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnsClientTypes {
    /// Supported language code for sending OTP message
    public enum LanguageCodeString: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deDe
        case enGb
        case enUs
        case es419
        case esEs
        case frCa
        case frFr
        case itIt
        case jpJp
        case krKr
        case ptBr
        case zhCn
        case zhTw
        case sdkUnknown(Swift.String)

        public static var allCases: [LanguageCodeString] {
            return [
                .deDe,
                .enGb,
                .enUs,
                .es419,
                .esEs,
                .frCa,
                .frFr,
                .itIt,
                .jpJp,
                .krKr,
                .ptBr,
                .zhCn,
                .zhTw,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deDe: return "de-DE"
            case .enGb: return "en-GB"
            case .enUs: return "en-US"
            case .es419: return "es-419"
            case .esEs: return "es-ES"
            case .frCa: return "fr-CA"
            case .frFr: return "fr-FR"
            case .itIt: return "it-IT"
            case .jpJp: return "ja-JP"
            case .krKr: return "kr-KR"
            case .ptBr: return "pt-BR"
            case .zhCn: return "zh-CN"
            case .zhTw: return "zh-TW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LanguageCodeString(rawValue: rawValue) ?? LanguageCodeString.sdkUnknown(rawValue)
        }
    }
}

extension ListEndpointsByPlatformApplicationInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: ClientRuntime.Key("NextToken"))
        }
        if let platformApplicationArn = platformApplicationArn {
            try container.encode(platformApplicationArn, forKey: ClientRuntime.Key("PlatformApplicationArn"))
        }
        try container.encode("ListEndpointsByPlatformApplication", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListEndpointsByPlatformApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input for ListEndpointsByPlatformApplication action.
public struct ListEndpointsByPlatformApplicationInput: Swift.Equatable {
    /// NextToken string is used when calling ListEndpointsByPlatformApplication action to retrieve additional records that are available after the first page results.
    public var nextToken: Swift.String?
    /// PlatformApplicationArn for ListEndpointsByPlatformApplicationInput action.
    /// This member is required.
    public var platformApplicationArn: Swift.String?

    public init (
        nextToken: Swift.String? = nil,
        platformApplicationArn: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.platformApplicationArn = platformApplicationArn
    }
}

struct ListEndpointsByPlatformApplicationInputBody: Swift.Equatable {
    let platformApplicationArn: Swift.String?
    let nextToken: Swift.String?
}

extension ListEndpointsByPlatformApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case platformApplicationArn = "PlatformApplicationArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let platformApplicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformApplicationArn)
        platformApplicationArn = platformApplicationArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEndpointsByPlatformApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListEndpointsByPlatformApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFound" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEndpointsByPlatformApplicationOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEndpointsByPlatformApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEndpointsByPlatformApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpoints = output.endpoints
            self.nextToken = output.nextToken
        } else {
            self.endpoints = nil
            self.nextToken = nil
        }
    }
}

/// Response for ListEndpointsByPlatformApplication action.
public struct ListEndpointsByPlatformApplicationOutputResponse: Swift.Equatable {
    /// Endpoints returned for ListEndpointsByPlatformApplication action.
    public var endpoints: [SnsClientTypes.Endpoint]?
    /// NextToken string is returned when calling ListEndpointsByPlatformApplication action if additional records are available after the first page results.
    public var nextToken: Swift.String?

    public init (
        endpoints: [SnsClientTypes.Endpoint]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.endpoints = endpoints
        self.nextToken = nextToken
    }
}

struct ListEndpointsByPlatformApplicationOutputResponseBody: Swift.Equatable {
    let endpoints: [SnsClientTypes.Endpoint]?
    let nextToken: Swift.String?
}

extension ListEndpointsByPlatformApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoints = "Endpoints"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListEndpointsByPlatformApplicationResult"))
        if containerValues.contains(.endpoints) {
            struct KeyVal0{struct member{}}
            let endpointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .endpoints)
            if let endpointsWrappedContainer = endpointsWrappedContainer {
                let endpointsContainer = try endpointsWrappedContainer.decodeIfPresent([SnsClientTypes.Endpoint].self, forKey: .member)
                var endpointsBuffer:[SnsClientTypes.Endpoint]? = nil
                if let endpointsContainer = endpointsContainer {
                    endpointsBuffer = [SnsClientTypes.Endpoint]()
                    for structureContainer0 in endpointsContainer {
                        endpointsBuffer?.append(structureContainer0)
                    }
                }
                endpoints = endpointsBuffer
            } else {
                endpoints = []
            }
        } else {
            endpoints = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOriginationNumbersInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let maxResults = maxResults {
            try container.encode(maxResults, forKey: ClientRuntime.Key("MaxResults"))
        }
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: ClientRuntime.Key("NextToken"))
        }
        try container.encode("ListOriginationNumbers", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListOriginationNumbersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListOriginationNumbersInput: Swift.Equatable {
    /// The maximum number of origination numbers to return.
    public var maxResults: Swift.Int?
    /// Token that the previous ListOriginationNumbers request returns.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOriginationNumbersInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListOriginationNumbersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListOriginationNumbersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListOriginationNumbersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Throttled" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOriginationNumbersOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case throttledException(ThrottledException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOriginationNumbersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListOriginationNumbersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.phoneNumbers = output.phoneNumbers
        } else {
            self.nextToken = nil
            self.phoneNumbers = nil
        }
    }
}

public struct ListOriginationNumbersOutputResponse: Swift.Equatable {
    /// A NextToken string is returned when you call the ListOriginationNumbers operation if additional pages of records are available.
    public var nextToken: Swift.String?
    /// A list of the calling account's verified and pending origination numbers.
    public var phoneNumbers: [SnsClientTypes.PhoneNumberInformation]?

    public init (
        nextToken: Swift.String? = nil,
        phoneNumbers: [SnsClientTypes.PhoneNumberInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumbers = phoneNumbers
    }
}

struct ListOriginationNumbersOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let phoneNumbers: [SnsClientTypes.PhoneNumberInformation]?
}

extension ListOriginationNumbersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case phoneNumbers = "PhoneNumbers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListOriginationNumbersResult"))
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        if containerValues.contains(.phoneNumbers) {
            struct KeyVal0{struct member{}}
            let phoneNumbersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .phoneNumbers)
            if let phoneNumbersWrappedContainer = phoneNumbersWrappedContainer {
                let phoneNumbersContainer = try phoneNumbersWrappedContainer.decodeIfPresent([SnsClientTypes.PhoneNumberInformation].self, forKey: .member)
                var phoneNumbersBuffer:[SnsClientTypes.PhoneNumberInformation]? = nil
                if let phoneNumbersContainer = phoneNumbersContainer {
                    phoneNumbersBuffer = [SnsClientTypes.PhoneNumberInformation]()
                    for structureContainer0 in phoneNumbersContainer {
                        phoneNumbersBuffer?.append(structureContainer0)
                    }
                }
                phoneNumbers = phoneNumbersBuffer
            } else {
                phoneNumbers = []
            }
        } else {
            phoneNumbers = nil
        }
    }
}

extension ListPhoneNumbersOptedOutInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: ClientRuntime.Key("nextToken"))
        }
        try container.encode("ListPhoneNumbersOptedOut", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListPhoneNumbersOptedOutInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The input for the ListPhoneNumbersOptedOut action.
public struct ListPhoneNumbersOptedOutInput: Swift.Equatable {
    /// A NextToken string is used when you call the ListPhoneNumbersOptedOut action to retrieve additional records that are available after the first page of results.
    public var nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListPhoneNumbersOptedOutInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension ListPhoneNumbersOptedOutInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPhoneNumbersOptedOutOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListPhoneNumbersOptedOutOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Throttled" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPhoneNumbersOptedOutOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPhoneNumbersOptedOutOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPhoneNumbersOptedOutOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.phoneNumbers = output.phoneNumbers
        } else {
            self.nextToken = nil
            self.phoneNumbers = nil
        }
    }
}

/// The response from the ListPhoneNumbersOptedOut action.
public struct ListPhoneNumbersOptedOutOutputResponse: Swift.Equatable {
    /// A NextToken string is returned when you call the ListPhoneNumbersOptedOut action if additional records are available after the first page of results.
    public var nextToken: Swift.String?
    /// A list of phone numbers that are opted out of receiving SMS messages. The list is paginated, and each page can contain up to 100 phone numbers.
    public var phoneNumbers: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        phoneNumbers: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumbers = phoneNumbers
    }
}

struct ListPhoneNumbersOptedOutOutputResponseBody: Swift.Equatable {
    let phoneNumbers: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListPhoneNumbersOptedOutOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case phoneNumbers
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListPhoneNumbersOptedOutResult"))
        if containerValues.contains(.phoneNumbers) {
            struct KeyVal0{struct member{}}
            let phoneNumbersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .phoneNumbers)
            if let phoneNumbersWrappedContainer = phoneNumbersWrappedContainer {
                let phoneNumbersContainer = try phoneNumbersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var phoneNumbersBuffer:[Swift.String]? = nil
                if let phoneNumbersContainer = phoneNumbersContainer {
                    phoneNumbersBuffer = [Swift.String]()
                    for stringContainer0 in phoneNumbersContainer {
                        phoneNumbersBuffer?.append(stringContainer0)
                    }
                }
                phoneNumbers = phoneNumbersBuffer
            } else {
                phoneNumbers = []
            }
        } else {
            phoneNumbers = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPlatformApplicationsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: ClientRuntime.Key("NextToken"))
        }
        try container.encode("ListPlatformApplications", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListPlatformApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input for ListPlatformApplications action.
public struct ListPlatformApplicationsInput: Swift.Equatable {
    /// NextToken string is used when calling ListPlatformApplications action to retrieve additional records that are available after the first page results.
    public var nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListPlatformApplicationsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension ListPlatformApplicationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPlatformApplicationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListPlatformApplicationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPlatformApplicationsOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPlatformApplicationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPlatformApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.platformApplications = output.platformApplications
        } else {
            self.nextToken = nil
            self.platformApplications = nil
        }
    }
}

/// Response for ListPlatformApplications action.
public struct ListPlatformApplicationsOutputResponse: Swift.Equatable {
    /// NextToken string is returned when calling ListPlatformApplications action if additional records are available after the first page results.
    public var nextToken: Swift.String?
    /// Platform applications returned when calling ListPlatformApplications action.
    public var platformApplications: [SnsClientTypes.PlatformApplication]?

    public init (
        nextToken: Swift.String? = nil,
        platformApplications: [SnsClientTypes.PlatformApplication]? = nil
    )
    {
        self.nextToken = nextToken
        self.platformApplications = platformApplications
    }
}

struct ListPlatformApplicationsOutputResponseBody: Swift.Equatable {
    let platformApplications: [SnsClientTypes.PlatformApplication]?
    let nextToken: Swift.String?
}

extension ListPlatformApplicationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case platformApplications = "PlatformApplications"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListPlatformApplicationsResult"))
        if containerValues.contains(.platformApplications) {
            struct KeyVal0{struct member{}}
            let platformApplicationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .platformApplications)
            if let platformApplicationsWrappedContainer = platformApplicationsWrappedContainer {
                let platformApplicationsContainer = try platformApplicationsWrappedContainer.decodeIfPresent([SnsClientTypes.PlatformApplication].self, forKey: .member)
                var platformApplicationsBuffer:[SnsClientTypes.PlatformApplication]? = nil
                if let platformApplicationsContainer = platformApplicationsContainer {
                    platformApplicationsBuffer = [SnsClientTypes.PlatformApplication]()
                    for structureContainer0 in platformApplicationsContainer {
                        platformApplicationsBuffer?.append(structureContainer0)
                    }
                }
                platformApplications = platformApplicationsBuffer
            } else {
                platformApplications = []
            }
        } else {
            platformApplications = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSMSSandboxPhoneNumbersInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let maxResults = maxResults {
            try container.encode(maxResults, forKey: ClientRuntime.Key("MaxResults"))
        }
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: ClientRuntime.Key("NextToken"))
        }
        try container.encode("ListSMSSandboxPhoneNumbers", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListSMSSandboxPhoneNumbersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSMSSandboxPhoneNumbersInput: Swift.Equatable {
    /// The maximum number of phone numbers to return.
    public var maxResults: Swift.Int?
    /// Token that the previous ListSMSSandboxPhoneNumbersInput request returns.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSMSSandboxPhoneNumbersInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListSMSSandboxPhoneNumbersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSMSSandboxPhoneNumbersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListSMSSandboxPhoneNumbersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Throttled" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSMSSandboxPhoneNumbersOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSMSSandboxPhoneNumbersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSMSSandboxPhoneNumbersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.phoneNumbers = output.phoneNumbers
        } else {
            self.nextToken = nil
            self.phoneNumbers = nil
        }
    }
}

public struct ListSMSSandboxPhoneNumbersOutputResponse: Swift.Equatable {
    /// A NextToken string is returned when you call the ListSMSSandboxPhoneNumbersInput operation if additional pages of records are available.
    public var nextToken: Swift.String?
    /// A list of the calling account's pending and verified phone numbers.
    /// This member is required.
    public var phoneNumbers: [SnsClientTypes.SMSSandboxPhoneNumber]?

    public init (
        nextToken: Swift.String? = nil,
        phoneNumbers: [SnsClientTypes.SMSSandboxPhoneNumber]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumbers = phoneNumbers
    }
}

struct ListSMSSandboxPhoneNumbersOutputResponseBody: Swift.Equatable {
    let phoneNumbers: [SnsClientTypes.SMSSandboxPhoneNumber]?
    let nextToken: Swift.String?
}

extension ListSMSSandboxPhoneNumbersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case phoneNumbers = "PhoneNumbers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListSMSSandboxPhoneNumbersResult"))
        if containerValues.contains(.phoneNumbers) {
            struct KeyVal0{struct member{}}
            let phoneNumbersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .phoneNumbers)
            if let phoneNumbersWrappedContainer = phoneNumbersWrappedContainer {
                let phoneNumbersContainer = try phoneNumbersWrappedContainer.decodeIfPresent([SnsClientTypes.SMSSandboxPhoneNumber].self, forKey: .member)
                var phoneNumbersBuffer:[SnsClientTypes.SMSSandboxPhoneNumber]? = nil
                if let phoneNumbersContainer = phoneNumbersContainer {
                    phoneNumbersBuffer = [SnsClientTypes.SMSSandboxPhoneNumber]()
                    for structureContainer0 in phoneNumbersContainer {
                        phoneNumbersBuffer?.append(structureContainer0)
                    }
                }
                phoneNumbers = phoneNumbersBuffer
            } else {
                phoneNumbers = []
            }
        } else {
            phoneNumbers = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSubscriptionsByTopicInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: ClientRuntime.Key("NextToken"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
        try container.encode("ListSubscriptionsByTopic", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListSubscriptionsByTopicInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input for ListSubscriptionsByTopic action.
public struct ListSubscriptionsByTopicInput: Swift.Equatable {
    /// Token returned by the previous ListSubscriptionsByTopic request.
    public var nextToken: Swift.String?
    /// The ARN of the topic for which you wish to find subscriptions.
    /// This member is required.
    public var topicArn: Swift.String?

    public init (
        nextToken: Swift.String? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.topicArn = topicArn
    }
}

struct ListSubscriptionsByTopicInputBody: Swift.Equatable {
    let topicArn: Swift.String?
    let nextToken: Swift.String?
}

extension ListSubscriptionsByTopicInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case topicArn = "TopicArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSubscriptionsByTopicOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListSubscriptionsByTopicOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFound" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSubscriptionsByTopicOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSubscriptionsByTopicOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSubscriptionsByTopicOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.subscriptions = output.subscriptions
        } else {
            self.nextToken = nil
            self.subscriptions = nil
        }
    }
}

/// Response for ListSubscriptionsByTopic action.
public struct ListSubscriptionsByTopicOutputResponse: Swift.Equatable {
    /// Token to pass along to the next ListSubscriptionsByTopic request. This element is returned if there are more subscriptions to retrieve.
    public var nextToken: Swift.String?
    /// A list of subscriptions.
    public var subscriptions: [SnsClientTypes.Subscription]?

    public init (
        nextToken: Swift.String? = nil,
        subscriptions: [SnsClientTypes.Subscription]? = nil
    )
    {
        self.nextToken = nextToken
        self.subscriptions = subscriptions
    }
}

struct ListSubscriptionsByTopicOutputResponseBody: Swift.Equatable {
    let subscriptions: [SnsClientTypes.Subscription]?
    let nextToken: Swift.String?
}

extension ListSubscriptionsByTopicOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case subscriptions = "Subscriptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListSubscriptionsByTopicResult"))
        if containerValues.contains(.subscriptions) {
            struct KeyVal0{struct member{}}
            let subscriptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .subscriptions)
            if let subscriptionsWrappedContainer = subscriptionsWrappedContainer {
                let subscriptionsContainer = try subscriptionsWrappedContainer.decodeIfPresent([SnsClientTypes.Subscription].self, forKey: .member)
                var subscriptionsBuffer:[SnsClientTypes.Subscription]? = nil
                if let subscriptionsContainer = subscriptionsContainer {
                    subscriptionsBuffer = [SnsClientTypes.Subscription]()
                    for structureContainer0 in subscriptionsContainer {
                        subscriptionsBuffer?.append(structureContainer0)
                    }
                }
                subscriptions = subscriptionsBuffer
            } else {
                subscriptions = []
            }
        } else {
            subscriptions = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSubscriptionsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: ClientRuntime.Key("NextToken"))
        }
        try container.encode("ListSubscriptions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListSubscriptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input for ListSubscriptions action.
public struct ListSubscriptionsInput: Swift.Equatable {
    /// Token returned by the previous ListSubscriptions request.
    public var nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListSubscriptionsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension ListSubscriptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSubscriptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListSubscriptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSubscriptionsOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSubscriptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSubscriptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.subscriptions = output.subscriptions
        } else {
            self.nextToken = nil
            self.subscriptions = nil
        }
    }
}

/// Response for ListSubscriptions action
public struct ListSubscriptionsOutputResponse: Swift.Equatable {
    /// Token to pass along to the next ListSubscriptions request. This element is returned if there are more subscriptions to retrieve.
    public var nextToken: Swift.String?
    /// A list of subscriptions.
    public var subscriptions: [SnsClientTypes.Subscription]?

    public init (
        nextToken: Swift.String? = nil,
        subscriptions: [SnsClientTypes.Subscription]? = nil
    )
    {
        self.nextToken = nextToken
        self.subscriptions = subscriptions
    }
}

struct ListSubscriptionsOutputResponseBody: Swift.Equatable {
    let subscriptions: [SnsClientTypes.Subscription]?
    let nextToken: Swift.String?
}

extension ListSubscriptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case subscriptions = "Subscriptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListSubscriptionsResult"))
        if containerValues.contains(.subscriptions) {
            struct KeyVal0{struct member{}}
            let subscriptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .subscriptions)
            if let subscriptionsWrappedContainer = subscriptionsWrappedContainer {
                let subscriptionsContainer = try subscriptionsWrappedContainer.decodeIfPresent([SnsClientTypes.Subscription].self, forKey: .member)
                var subscriptionsBuffer:[SnsClientTypes.Subscription]? = nil
                if let subscriptionsContainer = subscriptionsContainer {
                    subscriptionsBuffer = [SnsClientTypes.Subscription]()
                    for structureContainer0 in subscriptionsContainer {
                        subscriptionsBuffer?.append(structureContainer0)
                    }
                }
                subscriptions = subscriptionsBuffer
            } else {
                subscriptions = []
            }
        } else {
            subscriptions = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let resourceArn = resourceArn {
            try container.encode(resourceArn, forKey: ClientRuntime.Key("ResourceArn"))
        }
        try container.encode("ListTagsForResource", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the topic for which to list tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentAccess" : self = .concurrentAccessException(try ConcurrentAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicy" : self = .tagPolicyException(try TagPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case concurrentAccessException(ConcurrentAccessException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tagPolicyException(TagPolicyException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags associated with the specified topic.
    public var tags: [SnsClientTypes.Tag]?

    public init (
        tags: [SnsClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [SnsClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListTagsForResourceResult"))
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([SnsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[SnsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [SnsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension ListTopicsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: ClientRuntime.Key("NextToken"))
        }
        try container.encode("ListTopics", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListTopicsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTopicsInput: Swift.Equatable {
    /// Token returned by the previous ListTopics request.
    public var nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListTopicsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension ListTopicsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTopicsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListTopicsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTopicsOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTopicsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTopicsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.topics = output.topics
        } else {
            self.nextToken = nil
            self.topics = nil
        }
    }
}

/// Response for ListTopics action.
public struct ListTopicsOutputResponse: Swift.Equatable {
    /// Token to pass along to the next ListTopics request. This element is returned if there are additional topics to retrieve.
    public var nextToken: Swift.String?
    /// A list of topic ARNs.
    public var topics: [SnsClientTypes.Topic]?

    public init (
        nextToken: Swift.String? = nil,
        topics: [SnsClientTypes.Topic]? = nil
    )
    {
        self.nextToken = nextToken
        self.topics = topics
    }
}

struct ListTopicsOutputResponseBody: Swift.Equatable {
    let topics: [SnsClientTypes.Topic]?
    let nextToken: Swift.String?
}

extension ListTopicsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case topics = "Topics"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListTopicsResult"))
        if containerValues.contains(.topics) {
            struct KeyVal0{struct member{}}
            let topicsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .topics)
            if let topicsWrappedContainer = topicsWrappedContainer {
                let topicsContainer = try topicsWrappedContainer.decodeIfPresent([SnsClientTypes.Topic].self, forKey: .member)
                var topicsBuffer:[SnsClientTypes.Topic]? = nil
                if let topicsContainer = topicsContainer {
                    topicsBuffer = [SnsClientTypes.Topic]()
                    for structureContainer0 in topicsContainer {
                        topicsBuffer?.append(structureContainer0)
                    }
                }
                topics = topicsBuffer
            } else {
                topics = []
            }
        } else {
            topics = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SnsClientTypes.MessageAttributeValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case binaryValue = "BinaryValue"
        case dataType = "DataType"
        case stringValue = "StringValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let binaryValue = binaryValue {
            try container.encode(binaryValue.base64EncodedString(), forKey: ClientRuntime.Key("BinaryValue"))
        }
        if let dataType = dataType {
            try container.encode(dataType, forKey: ClientRuntime.Key("DataType"))
        }
        if let stringValue = stringValue {
            try container.encode(stringValue, forKey: ClientRuntime.Key("StringValue"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let stringValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stringValue)
        stringValue = stringValueDecoded
        if containerValues.contains(.binaryValue) {
            do {
                let binaryValueDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .binaryValue)
                binaryValue = binaryValueDecoded
            } catch {
                binaryValue = "".data(using: .utf8)
            }
        } else {
            binaryValue = nil
        }
    }
}

extension SnsClientTypes {
    /// The user-specified message attribute value. For string data types, the value attribute has the same restrictions on the content as the message body. For more information, see [Publish](https://docs.aws.amazon.com/sns/latest/api/API_Publish.html). Name, type, and value must not be empty or null. In addition, the message body should not be empty or null. All parts of the message attribute, including name, type, and value, are included in the message size restriction, which is currently 256 KB (262,144 bytes). For more information, see [Amazon SNS message attributes](https://docs.aws.amazon.com/sns/latest/dg/SNSMessageAttributes.html) and [Publishing to a mobile phone](https://docs.aws.amazon.com/sns/latest/dg/sms_publish-to-phone.html) in the Amazon SNS Developer Guide.
    public struct MessageAttributeValue: Swift.Equatable {
        /// Binary type attributes can store any binary data, for example, compressed data, encrypted data, or images.
        public var binaryValue: ClientRuntime.Data?
        /// Amazon SNS supports the following logical data types: String, String.Array, Number, and Binary. For more information, see [Message Attribute Data Types](https://docs.aws.amazon.com/sns/latest/dg/SNSMessageAttributes.html#SNSMessageAttributes.DataTypes).
        /// This member is required.
        public var dataType: Swift.String?
        /// Strings are Unicode with UTF8 binary encoding. For a list of code values, see [ASCII Printable Characters](https://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters).
        public var stringValue: Swift.String?

        public init (
            binaryValue: ClientRuntime.Data? = nil,
            dataType: Swift.String? = nil,
            stringValue: Swift.String? = nil
        )
        {
            self.binaryValue = binaryValue
            self.dataType = dataType
            self.stringValue = stringValue
        }
    }

}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<NotFoundExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that the requested resource does not exist.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnsClientTypes {
    /// Enum listing out all supported number capabilities.
    public enum NumberCapability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mms
        case sms
        case voice
        case sdkUnknown(Swift.String)

        public static var allCases: [NumberCapability] {
            return [
                .mms,
                .sms,
                .voice,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mms: return "MMS"
            case .sms: return "SMS"
            case .voice: return "VOICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NumberCapability(rawValue: rawValue) ?? NumberCapability.sdkUnknown(rawValue)
        }
    }
}

extension OptInPhoneNumberInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: ClientRuntime.Key("phoneNumber"))
        }
        try container.encode("OptInPhoneNumber", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension OptInPhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input for the OptInPhoneNumber action.
public struct OptInPhoneNumberInput: Swift.Equatable {
    /// The phone number to opt in. Use E.164 format.
    /// This member is required.
    public var phoneNumber: Swift.String?

    public init (
        phoneNumber: Swift.String? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

struct OptInPhoneNumberInputBody: Swift.Equatable {
    let phoneNumber: Swift.String?
}

extension OptInPhoneNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
    }
}

extension OptInPhoneNumberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension OptInPhoneNumberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Throttled" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum OptInPhoneNumberOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension OptInPhoneNumberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// The response for the OptInPhoneNumber action.
public struct OptInPhoneNumberOutputResponse: Swift.Equatable {

}

extension OptedOutException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<OptedOutExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that the specified phone number opted out of receiving SMS messages from your Amazon Web Services account. You can't send SMS messages to phone numbers that opt out.
public struct OptedOutException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OptedOutExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OptedOutExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnsClientTypes.PhoneNumberInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case iso2CountryCode = "Iso2CountryCode"
        case numberCapabilities = "NumberCapabilities"
        case phoneNumber = "PhoneNumber"
        case routeType = "RouteType"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let createdAt = createdAt {
            try container.encode(ClientRuntime.TimestampWrapper(createdAt, format: .dateTime), forKey: ClientRuntime.Key("createdAt"))
        }
        if let iso2CountryCode = iso2CountryCode {
            try container.encode(iso2CountryCode, forKey: ClientRuntime.Key("Iso2CountryCode"))
        }
        if let numberCapabilities = numberCapabilities {
            var numberCapabilitiesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("NumberCapabilities"))
            for (index0, numbercapability0) in numberCapabilities.enumerated() {
                try numberCapabilitiesContainer.encode(numbercapability0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: ClientRuntime.Key("PhoneNumber"))
        }
        if let routeType = routeType {
            try container.encode(routeType, forKey: ClientRuntime.Key("RouteType"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        var createdAtBuffer:ClientRuntime.Date? = nil
        if let createdAtDecoded = createdAtDecoded {
            createdAtBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createdAtDecoded, format: .dateTime)
        }
        createdAt = createdAtBuffer
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let iso2CountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iso2CountryCode)
        iso2CountryCode = iso2CountryCodeDecoded
        let routeTypeDecoded = try containerValues.decodeIfPresent(SnsClientTypes.RouteType.self, forKey: .routeType)
        routeType = routeTypeDecoded
        if containerValues.contains(.numberCapabilities) {
            struct KeyVal0{struct member{}}
            let numberCapabilitiesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .numberCapabilities)
            if let numberCapabilitiesWrappedContainer = numberCapabilitiesWrappedContainer {
                let numberCapabilitiesContainer = try numberCapabilitiesWrappedContainer.decodeIfPresent([SnsClientTypes.NumberCapability].self, forKey: .member)
                var numberCapabilitiesBuffer:[SnsClientTypes.NumberCapability]? = nil
                if let numberCapabilitiesContainer = numberCapabilitiesContainer {
                    numberCapabilitiesBuffer = [SnsClientTypes.NumberCapability]()
                    for stringContainer0 in numberCapabilitiesContainer {
                        numberCapabilitiesBuffer?.append(stringContainer0)
                    }
                }
                numberCapabilities = numberCapabilitiesBuffer
            } else {
                numberCapabilities = []
            }
        } else {
            numberCapabilities = nil
        }
    }
}

extension SnsClientTypes {
    /// A list of phone numbers and their metadata.
    public struct PhoneNumberInformation: Swift.Equatable {
        /// The date and time when the phone number was created.
        public var createdAt: ClientRuntime.Date?
        /// The two-character code for the country or region, in ISO 3166-1 alpha-2 format.
        public var iso2CountryCode: Swift.String?
        /// The capabilities of each phone number.
        public var numberCapabilities: [SnsClientTypes.NumberCapability]?
        /// The phone number.
        public var phoneNumber: Swift.String?
        /// The list of supported routes.
        public var routeType: SnsClientTypes.RouteType?
        /// The status of the phone number.
        public var status: Swift.String?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            iso2CountryCode: Swift.String? = nil,
            numberCapabilities: [SnsClientTypes.NumberCapability]? = nil,
            phoneNumber: Swift.String? = nil,
            routeType: SnsClientTypes.RouteType? = nil,
            status: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.iso2CountryCode = iso2CountryCode
            self.numberCapabilities = numberCapabilities
            self.phoneNumber = phoneNumber
            self.routeType = routeType
            self.status = status
        }
    }

}

extension SnsClientTypes.PlatformApplication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case platformApplicationArn = "PlatformApplicationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let stringValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(stringKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(stringValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let platformApplicationArn = platformApplicationArn {
            try container.encode(platformApplicationArn, forKey: ClientRuntime.Key("PlatformApplicationArn"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let platformApplicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformApplicationArn)
        platformApplicationArn = platformApplicationArnDecoded
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var attributesBuffer: [Swift.String:Swift.String]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in attributesContainer {
                        attributesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = [:]
            }
        } else {
            attributes = nil
        }
    }
}

extension SnsClientTypes {
    /// Platform application object.
    public struct PlatformApplication: Swift.Equatable {
        /// Attributes for platform application object.
        public var attributes: [Swift.String:Swift.String]?
        /// PlatformApplicationArn for platform application object.
        public var platformApplicationArn: Swift.String?

        public init (
            attributes: [Swift.String:Swift.String]? = nil,
            platformApplicationArn: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.platformApplicationArn = platformApplicationArn
        }
    }

}

extension PlatformApplicationDisabledException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<PlatformApplicationDisabledExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception error indicating platform application disabled.
public struct PlatformApplicationDisabledException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Message for platform application disabled.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PlatformApplicationDisabledExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PlatformApplicationDisabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PublishBatchInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let publishBatchRequestEntries = publishBatchRequestEntries {
            var publishBatchRequestEntriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PublishBatchRequestEntries"))
            for (index0, publishbatchrequestentry0) in publishBatchRequestEntries.enumerated() {
                try publishBatchRequestEntriesContainer.encode(publishbatchrequestentry0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
        try container.encode("PublishBatch", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension PublishBatchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PublishBatchInput: Swift.Equatable {
    /// A list of PublishBatch request entries to be sent to the SNS topic.
    /// This member is required.
    public var publishBatchRequestEntries: [SnsClientTypes.PublishBatchRequestEntry]?
    /// The Amazon resource name (ARN) of the topic you want to batch publish to.
    /// This member is required.
    public var topicArn: Swift.String?

    public init (
        publishBatchRequestEntries: [SnsClientTypes.PublishBatchRequestEntry]? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.publishBatchRequestEntries = publishBatchRequestEntries
        self.topicArn = topicArn
    }
}

struct PublishBatchInputBody: Swift.Equatable {
    let topicArn: Swift.String?
    let publishBatchRequestEntries: [SnsClientTypes.PublishBatchRequestEntry]?
}

extension PublishBatchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publishBatchRequestEntries = "PublishBatchRequestEntries"
        case topicArn = "TopicArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
        if containerValues.contains(.publishBatchRequestEntries) {
            struct KeyVal0{struct member{}}
            let publishBatchRequestEntriesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .publishBatchRequestEntries)
            if let publishBatchRequestEntriesWrappedContainer = publishBatchRequestEntriesWrappedContainer {
                let publishBatchRequestEntriesContainer = try publishBatchRequestEntriesWrappedContainer.decodeIfPresent([SnsClientTypes.PublishBatchRequestEntry].self, forKey: .member)
                var publishBatchRequestEntriesBuffer:[SnsClientTypes.PublishBatchRequestEntry]? = nil
                if let publishBatchRequestEntriesContainer = publishBatchRequestEntriesContainer {
                    publishBatchRequestEntriesBuffer = [SnsClientTypes.PublishBatchRequestEntry]()
                    for structureContainer0 in publishBatchRequestEntriesContainer {
                        publishBatchRequestEntriesBuffer?.append(structureContainer0)
                    }
                }
                publishBatchRequestEntries = publishBatchRequestEntriesBuffer
            } else {
                publishBatchRequestEntries = []
            }
        } else {
            publishBatchRequestEntries = nil
        }
    }
}

extension PublishBatchOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PublishBatchOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BatchEntryIdsNotDistinct" : self = .batchEntryIdsNotDistinctException(try BatchEntryIdsNotDistinctException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BatchRequestTooLong" : self = .batchRequestTooLongException(try BatchRequestTooLongException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EmptyBatchRequest" : self = .emptyBatchRequestException(try EmptyBatchRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointDisabled" : self = .endpointDisabledException(try EndpointDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidBatchEntryId" : self = .invalidBatchEntryIdException(try InvalidBatchEntryIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterValueInvalid" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecurity" : self = .invalidSecurityException(try InvalidSecurityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSAccessDenied" : self = .kMSAccessDeniedException(try KMSAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSDisabled" : self = .kMSDisabledException(try KMSDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidState" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSNotFound" : self = .kMSNotFoundException(try KMSNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSOptInRequired" : self = .kMSOptInRequired(try KMSOptInRequired(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSThrottling" : self = .kMSThrottlingException(try KMSThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFound" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PlatformApplicationDisabled" : self = .platformApplicationDisabledException(try PlatformApplicationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyEntriesInBatchRequest" : self = .tooManyEntriesInBatchRequestException(try TooManyEntriesInBatchRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PublishBatchOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case batchEntryIdsNotDistinctException(BatchEntryIdsNotDistinctException)
    case batchRequestTooLongException(BatchRequestTooLongException)
    case emptyBatchRequestException(EmptyBatchRequestException)
    case endpointDisabledException(EndpointDisabledException)
    case internalErrorException(InternalErrorException)
    case invalidBatchEntryIdException(InvalidBatchEntryIdException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidSecurityException(InvalidSecurityException)
    case kMSAccessDeniedException(KMSAccessDeniedException)
    case kMSDisabledException(KMSDisabledException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case kMSNotFoundException(KMSNotFoundException)
    case kMSOptInRequired(KMSOptInRequired)
    case kMSThrottlingException(KMSThrottlingException)
    case notFoundException(NotFoundException)
    case platformApplicationDisabledException(PlatformApplicationDisabledException)
    case tooManyEntriesInBatchRequestException(TooManyEntriesInBatchRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PublishBatchOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PublishBatchOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failed = output.failed
            self.successful = output.successful
        } else {
            self.failed = nil
            self.successful = nil
        }
    }
}

public struct PublishBatchOutputResponse: Swift.Equatable {
    /// A list of failed PublishBatch responses.
    public var failed: [SnsClientTypes.BatchResultErrorEntry]?
    /// A list of successful PublishBatch responses.
    public var successful: [SnsClientTypes.PublishBatchResultEntry]?

    public init (
        failed: [SnsClientTypes.BatchResultErrorEntry]? = nil,
        successful: [SnsClientTypes.PublishBatchResultEntry]? = nil
    )
    {
        self.failed = failed
        self.successful = successful
    }
}

struct PublishBatchOutputResponseBody: Swift.Equatable {
    let successful: [SnsClientTypes.PublishBatchResultEntry]?
    let failed: [SnsClientTypes.BatchResultErrorEntry]?
}

extension PublishBatchOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failed = "Failed"
        case successful = "Successful"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("PublishBatchResult"))
        if containerValues.contains(.successful) {
            struct KeyVal0{struct member{}}
            let successfulWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .successful)
            if let successfulWrappedContainer = successfulWrappedContainer {
                let successfulContainer = try successfulWrappedContainer.decodeIfPresent([SnsClientTypes.PublishBatchResultEntry].self, forKey: .member)
                var successfulBuffer:[SnsClientTypes.PublishBatchResultEntry]? = nil
                if let successfulContainer = successfulContainer {
                    successfulBuffer = [SnsClientTypes.PublishBatchResultEntry]()
                    for structureContainer0 in successfulContainer {
                        successfulBuffer?.append(structureContainer0)
                    }
                }
                successful = successfulBuffer
            } else {
                successful = []
            }
        } else {
            successful = nil
        }
        if containerValues.contains(.failed) {
            struct KeyVal0{struct member{}}
            let failedWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .failed)
            if let failedWrappedContainer = failedWrappedContainer {
                let failedContainer = try failedWrappedContainer.decodeIfPresent([SnsClientTypes.BatchResultErrorEntry].self, forKey: .member)
                var failedBuffer:[SnsClientTypes.BatchResultErrorEntry]? = nil
                if let failedContainer = failedContainer {
                    failedBuffer = [SnsClientTypes.BatchResultErrorEntry]()
                    for structureContainer0 in failedContainer {
                        failedBuffer?.append(structureContainer0)
                    }
                }
                failed = failedBuffer
            } else {
                failed = []
            }
        } else {
            failed = nil
        }
    }
}

extension SnsClientTypes.PublishBatchRequestEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case message = "Message"
        case messageAttributes = "MessageAttributes"
        case messageDeduplicationId = "MessageDeduplicationId"
        case messageGroupId = "MessageGroupId"
        case messageStructure = "MessageStructure"
        case subject = "Subject"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let message = message {
            try container.encode(message, forKey: ClientRuntime.Key("Message"))
        }
        if let messageAttributes = messageAttributes {
            var messageAttributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MessageAttributes"))
            for (index0, element0) in messageAttributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let messageattributevalueValue0 = element0.value
                var entryContainer0 = messageAttributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Name"))
                try keyContainer0.encode(stringKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Value"))
                try valueContainer0.encode(messageattributevalueValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let messageDeduplicationId = messageDeduplicationId {
            try container.encode(messageDeduplicationId, forKey: ClientRuntime.Key("MessageDeduplicationId"))
        }
        if let messageGroupId = messageGroupId {
            try container.encode(messageGroupId, forKey: ClientRuntime.Key("MessageGroupId"))
        }
        if let messageStructure = messageStructure {
            try container.encode(messageStructure, forKey: ClientRuntime.Key("MessageStructure"))
        }
        if let subject = subject {
            try container.encode(subject, forKey: ClientRuntime.Key("Subject"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let messageStructureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageStructure)
        messageStructure = messageStructureDecoded
        if containerValues.contains(.messageAttributes) {
            struct KeyVal0{struct Name{}; struct Value{}}
            let messageAttributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, SnsClientTypes.MessageAttributeValue, KeyVal0.Name, KeyVal0.Value>.CodingKeys.self, forKey: .messageAttributes)
            if let messageAttributesWrappedContainer = messageAttributesWrappedContainer {
                let messageAttributesContainer = try messageAttributesWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, SnsClientTypes.MessageAttributeValue, KeyVal0.Name, KeyVal0.Value>].self, forKey: .entry)
                var messageAttributesBuffer: [Swift.String:SnsClientTypes.MessageAttributeValue]? = nil
                if let messageAttributesContainer = messageAttributesContainer {
                    messageAttributesBuffer = [Swift.String:SnsClientTypes.MessageAttributeValue]()
                    for structureContainer0 in messageAttributesContainer {
                        messageAttributesBuffer?[structureContainer0.key] = structureContainer0.value
                    }
                }
                messageAttributes = messageAttributesBuffer
            } else {
                messageAttributes = [:]
            }
        } else {
            messageAttributes = nil
        }
        let messageDeduplicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageDeduplicationId)
        messageDeduplicationId = messageDeduplicationIdDecoded
        let messageGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageGroupId)
        messageGroupId = messageGroupIdDecoded
    }
}

extension SnsClientTypes {
    /// Contains the details of a single Amazon SNS message along with an Id that identifies a message within the batch.
    public struct PublishBatchRequestEntry: Swift.Equatable {
        /// An identifier for the message in this batch. The Ids of a batch request must be unique within a request. This identifier can have up to 80 characters. The following characters are accepted: alphanumeric characters, hyphens(-), and underscores (_).
        /// This member is required.
        public var id: Swift.String?
        /// The body of the message.
        /// This member is required.
        public var message: Swift.String?
        /// Each message attribute consists of a Name, Type, and Value. For more information, see [Amazon SNS message attributes](https://docs.aws.amazon.com/sns/latest/dg/sns-message-attributes.html) in the Amazon SNS Developer Guide.
        public var messageAttributes: [Swift.String:SnsClientTypes.MessageAttributeValue]?
        /// This parameter applies only to FIFO (first-in-first-out) topics. The token used for deduplication of messages within a 5-minute minimum deduplication interval. If a message with a particular MessageDeduplicationId is sent successfully, subsequent messages with the same MessageDeduplicationId are accepted successfully but aren't delivered.
        ///
        /// * Every message must have a unique MessageDeduplicationId.
        ///
        /// * You may provide a MessageDeduplicationId explicitly.
        ///
        /// * If you aren't able to provide a MessageDeduplicationId and you enable ContentBasedDeduplication for your topic, Amazon SNS uses a SHA-256 hash to generate the MessageDeduplicationId using the body of the message (but not the attributes of the message).
        ///
        /// * If you don't provide a MessageDeduplicationId and the topic doesn't have ContentBasedDeduplication set, the action fails with an error.
        ///
        /// * If the topic has a ContentBasedDeduplication set, your MessageDeduplicationId overrides the generated one.
        ///
        ///
        ///
        ///
        /// * When ContentBasedDeduplication is in effect, messages with identical content sent within the deduplication interval are treated as duplicates and only one copy of the message is delivered.
        ///
        /// * If you send one message with ContentBasedDeduplication enabled, and then another message with a MessageDeduplicationId that is the same as the one generated for the first MessageDeduplicationId, the two messages are treated as duplicates and only one copy of the message is delivered.
        ///
        ///
        /// The MessageDeduplicationId is available to the consumer of the message (this can be useful for troubleshooting delivery issues). If a message is sent successfully but the acknowledgement is lost and the message is resent with the same MessageDeduplicationId after the deduplication interval, Amazon SNS can't detect duplicate messages. Amazon SNS continues to keep track of the message deduplication ID even after the message is received and deleted. The length of MessageDeduplicationId is 128 characters. MessageDeduplicationId can contain alphanumeric characters (a-z, A-Z, 0-9) and punctuation (!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~).
        public var messageDeduplicationId: Swift.String?
        /// This parameter applies only to FIFO (first-in-first-out) topics. The tag that specifies that a message belongs to a specific message group. Messages that belong to the same message group are processed in a FIFO manner (however, messages in different message groups might be processed out of order). To interleave multiple ordered streams within a single topic, use MessageGroupId values (for example, session data for multiple users). In this scenario, multiple consumers can process the topic, but the session data of each user is processed in a FIFO fashion. You must associate a non-empty MessageGroupId with a message. If you don't provide a MessageGroupId, the action fails. The length of MessageGroupId is 128 characters. MessageGroupId can contain alphanumeric characters (a-z, A-Z, 0-9) and punctuation (!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~). MessageGroupId is required for FIFO topics. You can't use it for standard topics.
        public var messageGroupId: Swift.String?
        /// Set MessageStructure to json if you want to send a different message for each protocol. For example, using one publish action, you can send a short message to your SMS subscribers and a longer message to your email subscribers. If you set MessageStructure to json, the value of the Message parameter must:
        ///
        /// * be a syntactically valid JSON object; and
        ///
        /// * contain at least a top-level JSON key of "default" with a value that is a string.
        ///
        ///
        /// You can define other top-level keys that define the message you want to send to a specific transport protocol (e.g. http).
        public var messageStructure: Swift.String?
        /// The subject of the batch message.
        public var subject: Swift.String?

        public init (
            id: Swift.String? = nil,
            message: Swift.String? = nil,
            messageAttributes: [Swift.String:SnsClientTypes.MessageAttributeValue]? = nil,
            messageDeduplicationId: Swift.String? = nil,
            messageGroupId: Swift.String? = nil,
            messageStructure: Swift.String? = nil,
            subject: Swift.String? = nil
        )
        {
            self.id = id
            self.message = message
            self.messageAttributes = messageAttributes
            self.messageDeduplicationId = messageDeduplicationId
            self.messageGroupId = messageGroupId
            self.messageStructure = messageStructure
            self.subject = subject
        }
    }

}

extension SnsClientTypes.PublishBatchResultEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case messageId = "MessageId"
        case sequenceNumber = "SequenceNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let messageId = messageId {
            try container.encode(messageId, forKey: ClientRuntime.Key("MessageId"))
        }
        if let sequenceNumber = sequenceNumber {
            try container.encode(sequenceNumber, forKey: ClientRuntime.Key("SequenceNumber"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let sequenceNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceNumber)
        sequenceNumber = sequenceNumberDecoded
    }
}

extension SnsClientTypes {
    /// Encloses data related to a successful message in a batch request for topic.
    public struct PublishBatchResultEntry: Swift.Equatable {
        /// The Id of an entry in a batch request.
        public var id: Swift.String?
        /// An identifier for the message.
        public var messageId: Swift.String?
        /// This parameter applies only to FIFO (first-in-first-out) topics. The large, non-consecutive number that Amazon SNS assigns to each message. The length of SequenceNumber is 128 bits. SequenceNumber continues to increase for a particular MessageGroupId.
        public var sequenceNumber: Swift.String?

        public init (
            id: Swift.String? = nil,
            messageId: Swift.String? = nil,
            sequenceNumber: Swift.String? = nil
        )
        {
            self.id = id
            self.messageId = messageId
            self.sequenceNumber = sequenceNumber
        }
    }

}

extension PublishInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let message = message {
            try container.encode(message, forKey: ClientRuntime.Key("Message"))
        }
        if let messageAttributes = messageAttributes {
            var messageAttributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MessageAttributes"))
            for (index0, element0) in messageAttributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let messageattributevalueValue0 = element0.value
                var entryContainer0 = messageAttributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Name"))
                try keyContainer0.encode(stringKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Value"))
                try valueContainer0.encode(messageattributevalueValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let messageDeduplicationId = messageDeduplicationId {
            try container.encode(messageDeduplicationId, forKey: ClientRuntime.Key("MessageDeduplicationId"))
        }
        if let messageGroupId = messageGroupId {
            try container.encode(messageGroupId, forKey: ClientRuntime.Key("MessageGroupId"))
        }
        if let messageStructure = messageStructure {
            try container.encode(messageStructure, forKey: ClientRuntime.Key("MessageStructure"))
        }
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: ClientRuntime.Key("PhoneNumber"))
        }
        if let subject = subject {
            try container.encode(subject, forKey: ClientRuntime.Key("Subject"))
        }
        if let targetArn = targetArn {
            try container.encode(targetArn, forKey: ClientRuntime.Key("TargetArn"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
        try container.encode("Publish", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension PublishInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input for Publish action.
public struct PublishInput: Swift.Equatable {
    /// The message you want to send. If you are publishing to a topic and you want to send the same message to all transport protocols, include the text of the message as a String value. If you want to send different messages for each transport protocol, set the value of the MessageStructure parameter to json and use a JSON object for the Message parameter. Constraints:
    ///
    /// * With the exception of SMS, messages must be UTF-8 encoded strings and at most 256 KB in size (262,144 bytes, not 262,144 characters).
    ///
    /// * For SMS, each message can contain up to 140 characters. This character limit depends on the encoding schema. For example, an SMS message can contain 160 GSM characters, 140 ASCII characters, or 70 UCS-2 characters. If you publish a message that exceeds this size limit, Amazon SNS sends the message as multiple messages, each fitting within the size limit. Messages aren't truncated mid-word but are cut off at whole-word boundaries. The total size limit for a single SMS Publish action is 1,600 characters.
    ///
    ///
    /// JSON-specific constraints:
    ///
    /// * Keys in the JSON object that correspond to supported transport protocols must have simple JSON string values.
    ///
    /// * The values will be parsed (unescaped) before they are used in outgoing messages.
    ///
    /// * Outbound notifications are JSON encoded (meaning that the characters will be reescaped for sending).
    ///
    /// * Values have a minimum length of 0 (the empty string, "", is allowed).
    ///
    /// * Values have a maximum length bounded by the overall message size (so, including multiple protocols may limit message sizes).
    ///
    /// * Non-string values will cause the key to be ignored.
    ///
    /// * Keys that do not correspond to supported transport protocols are ignored.
    ///
    /// * Duplicate keys are not allowed.
    ///
    /// * Failure to parse or validate any key or value in the message will cause the Publish call to return an error (no partial delivery).
    /// This member is required.
    public var message: Swift.String?
    /// Message attributes for Publish action.
    public var messageAttributes: [Swift.String:SnsClientTypes.MessageAttributeValue]?
    /// This parameter applies only to FIFO (first-in-first-out) topics. The MessageDeduplicationId can contain up to 128 alphanumeric characters (a-z, A-Z, 0-9) and punctuation (!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~). Every message must have a unique MessageDeduplicationId, which is a token used for deduplication of sent messages. If a message with a particular MessageDeduplicationId is sent successfully, any message sent with the same MessageDeduplicationId during the 5-minute deduplication interval is treated as a duplicate. If the topic has ContentBasedDeduplication set, the system generates a MessageDeduplicationId based on the contents of the message. Your MessageDeduplicationId overrides the generated one.
    public var messageDeduplicationId: Swift.String?
    /// This parameter applies only to FIFO (first-in-first-out) topics. The MessageGroupId can contain up to 128 alphanumeric characters (a-z, A-Z, 0-9) and punctuation (!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~). The MessageGroupId is a tag that specifies that a message belongs to a specific message group. Messages that belong to the same message group are processed in a FIFO manner (however, messages in different message groups might be processed out of order). Every message must include a MessageGroupId.
    public var messageGroupId: Swift.String?
    /// Set MessageStructure to json if you want to send a different message for each protocol. For example, using one publish action, you can send a short message to your SMS subscribers and a longer message to your email subscribers. If you set MessageStructure to json, the value of the Message parameter must:
    ///
    /// * be a syntactically valid JSON object; and
    ///
    /// * contain at least a top-level JSON key of "default" with a value that is a string.
    ///
    ///
    /// You can define other top-level keys that define the message you want to send to a specific transport protocol (e.g., "http"). Valid value: json
    public var messageStructure: Swift.String?
    /// The phone number to which you want to deliver an SMS message. Use E.164 format. If you don't specify a value for the PhoneNumber parameter, you must specify a value for the TargetArn or TopicArn parameters.
    public var phoneNumber: Swift.String?
    /// Optional parameter to be used as the "Subject" line when the message is delivered to email endpoints. This field will also be included, if present, in the standard JSON messages delivered to other endpoints. Constraints: Subjects must be ASCII text that begins with a letter, number, or punctuation mark; must not include line breaks or control characters; and must be less than 100 characters long.
    public var subject: Swift.String?
    /// If you don't specify a value for the TargetArn parameter, you must specify a value for the PhoneNumber or TopicArn parameters.
    public var targetArn: Swift.String?
    /// The topic you want to publish to. If you don't specify a value for the TopicArn parameter, you must specify a value for the PhoneNumber or TargetArn parameters.
    public var topicArn: Swift.String?

    public init (
        message: Swift.String? = nil,
        messageAttributes: [Swift.String:SnsClientTypes.MessageAttributeValue]? = nil,
        messageDeduplicationId: Swift.String? = nil,
        messageGroupId: Swift.String? = nil,
        messageStructure: Swift.String? = nil,
        phoneNumber: Swift.String? = nil,
        subject: Swift.String? = nil,
        targetArn: Swift.String? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.message = message
        self.messageAttributes = messageAttributes
        self.messageDeduplicationId = messageDeduplicationId
        self.messageGroupId = messageGroupId
        self.messageStructure = messageStructure
        self.phoneNumber = phoneNumber
        self.subject = subject
        self.targetArn = targetArn
        self.topicArn = topicArn
    }
}

struct PublishInputBody: Swift.Equatable {
    let topicArn: Swift.String?
    let targetArn: Swift.String?
    let phoneNumber: Swift.String?
    let message: Swift.String?
    let subject: Swift.String?
    let messageStructure: Swift.String?
    let messageAttributes: [Swift.String:SnsClientTypes.MessageAttributeValue]?
    let messageDeduplicationId: Swift.String?
    let messageGroupId: Swift.String?
}

extension PublishInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case messageAttributes = "MessageAttributes"
        case messageDeduplicationId = "MessageDeduplicationId"
        case messageGroupId = "MessageGroupId"
        case messageStructure = "MessageStructure"
        case phoneNumber = "PhoneNumber"
        case subject = "Subject"
        case targetArn = "TargetArn"
        case topicArn = "TopicArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let messageStructureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageStructure)
        messageStructure = messageStructureDecoded
        if containerValues.contains(.messageAttributes) {
            struct KeyVal0{struct Name{}; struct Value{}}
            let messageAttributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, SnsClientTypes.MessageAttributeValue, KeyVal0.Name, KeyVal0.Value>.CodingKeys.self, forKey: .messageAttributes)
            if let messageAttributesWrappedContainer = messageAttributesWrappedContainer {
                let messageAttributesContainer = try messageAttributesWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, SnsClientTypes.MessageAttributeValue, KeyVal0.Name, KeyVal0.Value>].self, forKey: .entry)
                var messageAttributesBuffer: [Swift.String:SnsClientTypes.MessageAttributeValue]? = nil
                if let messageAttributesContainer = messageAttributesContainer {
                    messageAttributesBuffer = [Swift.String:SnsClientTypes.MessageAttributeValue]()
                    for structureContainer0 in messageAttributesContainer {
                        messageAttributesBuffer?[structureContainer0.key] = structureContainer0.value
                    }
                }
                messageAttributes = messageAttributesBuffer
            } else {
                messageAttributes = [:]
            }
        } else {
            messageAttributes = nil
        }
        let messageDeduplicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageDeduplicationId)
        messageDeduplicationId = messageDeduplicationIdDecoded
        let messageGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageGroupId)
        messageGroupId = messageGroupIdDecoded
    }
}

extension PublishOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PublishOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointDisabled" : self = .endpointDisabledException(try EndpointDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterValueInvalid" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecurity" : self = .invalidSecurityException(try InvalidSecurityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSAccessDenied" : self = .kMSAccessDeniedException(try KMSAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSDisabled" : self = .kMSDisabledException(try KMSDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidState" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSNotFound" : self = .kMSNotFoundException(try KMSNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSOptInRequired" : self = .kMSOptInRequired(try KMSOptInRequired(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSThrottling" : self = .kMSThrottlingException(try KMSThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFound" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PlatformApplicationDisabled" : self = .platformApplicationDisabledException(try PlatformApplicationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PublishOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case endpointDisabledException(EndpointDisabledException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidSecurityException(InvalidSecurityException)
    case kMSAccessDeniedException(KMSAccessDeniedException)
    case kMSDisabledException(KMSDisabledException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case kMSNotFoundException(KMSNotFoundException)
    case kMSOptInRequired(KMSOptInRequired)
    case kMSThrottlingException(KMSThrottlingException)
    case notFoundException(NotFoundException)
    case platformApplicationDisabledException(PlatformApplicationDisabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PublishOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PublishOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.messageId = output.messageId
            self.sequenceNumber = output.sequenceNumber
        } else {
            self.messageId = nil
            self.sequenceNumber = nil
        }
    }
}

/// Response for Publish action.
public struct PublishOutputResponse: Swift.Equatable {
    /// Unique identifier assigned to the published message. Length Constraint: Maximum 100 characters
    public var messageId: Swift.String?
    /// This response element applies only to FIFO (first-in-first-out) topics. The sequence number is a large, non-consecutive number that Amazon SNS assigns to each message. The length of SequenceNumber is 128 bits. SequenceNumber continues to increase for each MessageGroupId.
    public var sequenceNumber: Swift.String?

    public init (
        messageId: Swift.String? = nil,
        sequenceNumber: Swift.String? = nil
    )
    {
        self.messageId = messageId
        self.sequenceNumber = sequenceNumber
    }
}

struct PublishOutputResponseBody: Swift.Equatable {
    let messageId: Swift.String?
    let sequenceNumber: Swift.String?
}

extension PublishOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageId = "MessageId"
        case sequenceNumber = "SequenceNumber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("PublishResult"))
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let sequenceNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceNumber)
        sequenceNumber = sequenceNumberDecoded
    }
}

extension RemovePermissionInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let label = label {
            try container.encode(label, forKey: ClientRuntime.Key("Label"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
        try container.encode("RemovePermission", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension RemovePermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input for RemovePermission action.
public struct RemovePermissionInput: Swift.Equatable {
    /// The unique label of the statement you want to remove.
    /// This member is required.
    public var label: Swift.String?
    /// The ARN of the topic whose access control policy you wish to modify.
    /// This member is required.
    public var topicArn: Swift.String?

    public init (
        label: Swift.String? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.label = label
        self.topicArn = topicArn
    }
}

struct RemovePermissionInputBody: Swift.Equatable {
    let topicArn: Swift.String?
    let label: Swift.String?
}

extension RemovePermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case label = "Label"
        case topicArn = "TopicArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
    }
}

extension RemovePermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemovePermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFound" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemovePermissionOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemovePermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemovePermissionOutputResponse: Swift.Equatable {

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<ResourceNotFoundExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Can’t perform the action on the specified resource. Make sure that the resource exists.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnsClientTypes {
    /// Enum listing out all supported route types. The following enum values are supported. 1. Transactional : Non-marketing traffic 2. Promotional : Marketing 3. Premium : Premium routes for OTP delivery to the carriers
    public enum RouteType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case premium
        case promotional
        case transactional
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteType] {
            return [
                .premium,
                .promotional,
                .transactional,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .premium: return "Premium"
            case .promotional: return "Promotional"
            case .transactional: return "Transactional"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RouteType(rawValue: rawValue) ?? RouteType.sdkUnknown(rawValue)
        }
    }
}

extension SnsClientTypes.SMSSandboxPhoneNumber: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber = "PhoneNumber"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: ClientRuntime.Key("PhoneNumber"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SnsClientTypes.SMSSandboxPhoneNumberVerificationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension SnsClientTypes {
    /// A verified or pending destination phone number in the SMS sandbox. When you start using Amazon SNS to send SMS messages, your Amazon Web Services account is in the SMS sandbox. The SMS sandbox provides a safe environment for you to try Amazon SNS features without risking your reputation as an SMS sender. While your Amazon Web Services account is in the SMS sandbox, you can use all of the features of Amazon SNS. However, you can send SMS messages only to verified destination phone numbers. For more information, including how to move out of the sandbox to send messages without restrictions, see [SMS sandbox](https://docs.aws.amazon.com/sns/latest/dg/sns-sms-sandbox.html) in the Amazon SNS Developer Guide.
    public struct SMSSandboxPhoneNumber: Swift.Equatable {
        /// The destination phone number.
        public var phoneNumber: Swift.String?
        /// The destination phone number's verification status.
        public var status: SnsClientTypes.SMSSandboxPhoneNumberVerificationStatus?

        public init (
            phoneNumber: Swift.String? = nil,
            status: SnsClientTypes.SMSSandboxPhoneNumberVerificationStatus? = nil
        )
        {
            self.phoneNumber = phoneNumber
            self.status = status
        }
    }

}

extension SnsClientTypes {
    /// Enum listing out all supported destination phone number verification statuses. The following enum values are supported. 1. PENDING : The destination phone number is pending verification. 2. VERIFIED : The destination phone number is verified.
    public enum SMSSandboxPhoneNumberVerificationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pending
        case verified
        case sdkUnknown(Swift.String)

        public static var allCases: [SMSSandboxPhoneNumberVerificationStatus] {
            return [
                .pending,
                .verified,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pending: return "Pending"
            case .verified: return "Verified"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SMSSandboxPhoneNumberVerificationStatus(rawValue: rawValue) ?? SMSSandboxPhoneNumberVerificationStatus.sdkUnknown(rawValue)
        }
    }
}

extension SetEndpointAttributesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let stringValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(stringKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(stringValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let endpointArn = endpointArn {
            try container.encode(endpointArn, forKey: ClientRuntime.Key("EndpointArn"))
        }
        try container.encode("SetEndpointAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension SetEndpointAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input for SetEndpointAttributes action.
public struct SetEndpointAttributesInput: Swift.Equatable {
    /// A map of the endpoint attributes. Attributes in this map include the following:
    ///
    /// * CustomUserData – arbitrary user data to associate with the endpoint. Amazon SNS does not use this data. The data must be in UTF-8 format and less than 2KB.
    ///
    /// * Enabled – flag that enables/disables delivery to the endpoint. Amazon SNS will set this to false when a notification service indicates to Amazon SNS that the endpoint is invalid. Users can set it back to true, typically after updating Token.
    ///
    /// * Token – device token, also referred to as a registration id, for an app and mobile device. This is returned from the notification service when an app and mobile device are registered with the notification service.
    /// This member is required.
    public var attributes: [Swift.String:Swift.String]?
    /// EndpointArn used for SetEndpointAttributes action.
    /// This member is required.
    public var endpointArn: Swift.String?

    public init (
        attributes: [Swift.String:Swift.String]? = nil,
        endpointArn: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.endpointArn = endpointArn
    }
}

struct SetEndpointAttributesInputBody: Swift.Equatable {
    let endpointArn: Swift.String?
    let attributes: [Swift.String:Swift.String]?
}

extension SetEndpointAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case endpointArn = "EndpointArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var attributesBuffer: [Swift.String:Swift.String]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in attributesContainer {
                        attributesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = [:]
            }
        } else {
            attributes = nil
        }
    }
}

extension SetEndpointAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetEndpointAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFound" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetEndpointAttributesOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetEndpointAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SetEndpointAttributesOutputResponse: Swift.Equatable {

}

extension SetPlatformApplicationAttributesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let stringValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(stringKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(stringValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let platformApplicationArn = platformApplicationArn {
            try container.encode(platformApplicationArn, forKey: ClientRuntime.Key("PlatformApplicationArn"))
        }
        try container.encode("SetPlatformApplicationAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension SetPlatformApplicationAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input for SetPlatformApplicationAttributes action.
public struct SetPlatformApplicationAttributesInput: Swift.Equatable {
    /// A map of the platform application attributes. Attributes in this map include the following:
    ///
    /// * PlatformCredential – The credential received from the notification service.
    ///
    /// * For ADM, PlatformCredentialis client secret.
    ///
    /// * For Apple Services using certificate credentials, PlatformCredential is private key.
    ///
    /// * For Apple Services using token credentials, PlatformCredential is signing key.
    ///
    /// * For GCM (Firebase Cloud Messaging), PlatformCredential is API key.
    ///
    ///
    ///
    ///
    ///
    ///
    ///
    /// * PlatformPrincipal – The principal received from the notification service.
    ///
    /// * For ADM, PlatformPrincipalis client id.
    ///
    /// * For Apple Services using certificate credentials, PlatformPrincipal is SSL certificate.
    ///
    /// * For Apple Services using token credentials, PlatformPrincipal is signing key ID.
    ///
    /// * For GCM (Firebase Cloud Messaging), there is no PlatformPrincipal.
    ///
    ///
    ///
    ///
    ///
    ///
    ///
    /// * EventEndpointCreated – Topic ARN to which EndpointCreated event notifications are sent.
    ///
    /// * EventEndpointDeleted – Topic ARN to which EndpointDeleted event notifications are sent.
    ///
    /// * EventEndpointUpdated – Topic ARN to which EndpointUpdate event notifications are sent.
    ///
    /// * EventDeliveryFailure – Topic ARN to which DeliveryFailure event notifications are sent upon Direct Publish delivery failure (permanent) to one of the application's endpoints.
    ///
    /// * SuccessFeedbackRoleArn – IAM role ARN used to give Amazon SNS write access to use CloudWatch Logs on your behalf.
    ///
    /// * FailureFeedbackRoleArn – IAM role ARN used to give Amazon SNS write access to use CloudWatch Logs on your behalf.
    ///
    /// * SuccessFeedbackSampleRate – Sample rate percentage (0-100) of successfully delivered messages.
    ///
    ///
    /// The following attributes only apply to APNs token-based authentication:
    ///
    /// * ApplePlatformTeamID – The identifier that's assigned to your Apple developer account team.
    ///
    /// * ApplePlatformBundleID – The bundle identifier that's assigned to your iOS app.
    /// This member is required.
    public var attributes: [Swift.String:Swift.String]?
    /// PlatformApplicationArn for SetPlatformApplicationAttributes action.
    /// This member is required.
    public var platformApplicationArn: Swift.String?

    public init (
        attributes: [Swift.String:Swift.String]? = nil,
        platformApplicationArn: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.platformApplicationArn = platformApplicationArn
    }
}

struct SetPlatformApplicationAttributesInputBody: Swift.Equatable {
    let platformApplicationArn: Swift.String?
    let attributes: [Swift.String:Swift.String]?
}

extension SetPlatformApplicationAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case platformApplicationArn = "PlatformApplicationArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let platformApplicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformApplicationArn)
        platformApplicationArn = platformApplicationArnDecoded
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var attributesBuffer: [Swift.String:Swift.String]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in attributesContainer {
                        attributesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = [:]
            }
        } else {
            attributes = nil
        }
    }
}

extension SetPlatformApplicationAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetPlatformApplicationAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFound" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetPlatformApplicationAttributesOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetPlatformApplicationAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SetPlatformApplicationAttributesOutputResponse: Swift.Equatable {

}

extension SetSMSAttributesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let stringValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(stringKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(stringValue0, forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("SetSMSAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension SetSMSAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The input for the SetSMSAttributes action.
public struct SetSMSAttributesInput: Swift.Equatable {
    /// The default settings for sending SMS messages from your Amazon Web Services account. You can set values for the following attribute names: MonthlySpendLimit – The maximum amount in USD that you are willing to spend each month to send SMS messages. When Amazon SNS determines that sending an SMS message would incur a cost that exceeds this limit, it stops sending SMS messages within minutes. Amazon SNS stops sending SMS messages within minutes of the limit being crossed. During that interval, if you continue to send SMS messages, you will incur costs that exceed your limit. By default, the spend limit is set to the maximum allowed by Amazon SNS. If you want to raise the limit, submit an [SNS Limit Increase case](https://console.aws.amazon.com/support/home#/case/create?issueType=service-limit-increase&limitType=service-code-sns). For New limit value, enter your desired monthly spend limit. In the Use Case Description field, explain that you are requesting an SMS monthly spend limit increase. DeliveryStatusIAMRole – The ARN of the IAM role that allows Amazon SNS to write logs about SMS deliveries in CloudWatch Logs. For each SMS message that you send, Amazon SNS writes a log that includes the message price, the success or failure status, the reason for failure (if the message failed), the message dwell time, and other information. DeliveryStatusSuccessSamplingRate – The percentage of successful SMS deliveries for which Amazon SNS will write logs in CloudWatch Logs. The value can be an integer from 0 - 100. For example, to write logs only for failed deliveries, set this value to 0. To write logs for 10% of your successful deliveries, set it to 10. DefaultSenderID – A string, such as your business brand, that is displayed as the sender on the receiving device. Support for sender IDs varies by country. The sender ID can be 1 - 11 alphanumeric characters, and it must contain at least one letter. DefaultSMSType – The type of SMS message that you will send by default. You can assign the following values:
    ///
    /// * Promotional – (Default) Noncritical messages, such as marketing messages. Amazon SNS optimizes the message delivery to incur the lowest cost.
    ///
    /// * Transactional – Critical messages that support customer transactions, such as one-time passcodes for multi-factor authentication. Amazon SNS optimizes the message delivery to achieve the highest reliability.
    ///
    ///
    /// UsageReportS3Bucket – The name of the Amazon S3 bucket to receive daily SMS usage reports from Amazon SNS. Each day, Amazon SNS will deliver a usage report as a CSV file to the bucket. The report includes the following information for each SMS message that was successfully delivered by your Amazon Web Services account:
    ///
    /// * Time that the message was published (in UTC)
    ///
    /// * Message ID
    ///
    /// * Destination phone number
    ///
    /// * Message type
    ///
    /// * Delivery status
    ///
    /// * Message price (in USD)
    ///
    /// * Part number (a message is split into multiple parts if it is too long for a single message)
    ///
    /// * Total number of parts
    ///
    ///
    /// To receive the report, the bucket must have a policy that allows the Amazon SNS service principal to perform the s3:PutObject and s3:GetBucketLocation actions. For an example bucket policy and usage report, see [Monitoring SMS Activity](https://docs.aws.amazon.com/sns/latest/dg/sms_stats.html) in the Amazon SNS Developer Guide.
    /// This member is required.
    public var attributes: [Swift.String:Swift.String]?

    public init (
        attributes: [Swift.String:Swift.String]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct SetSMSAttributesInputBody: Swift.Equatable {
    let attributes: [Swift.String:Swift.String]?
}

extension SetSMSAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var attributesBuffer: [Swift.String:Swift.String]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in attributesContainer {
                        attributesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = [:]
            }
        } else {
            attributes = nil
        }
    }
}

extension SetSMSAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetSMSAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Throttled" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetSMSAttributesOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetSMSAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// The response for the SetSMSAttributes action.
public struct SetSMSAttributesOutputResponse: Swift.Equatable {

}

extension SetSubscriptionAttributesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: ClientRuntime.Key("AttributeName"))
        }
        if let attributeValue = attributeValue {
            try container.encode(attributeValue, forKey: ClientRuntime.Key("AttributeValue"))
        }
        if let subscriptionArn = subscriptionArn {
            try container.encode(subscriptionArn, forKey: ClientRuntime.Key("SubscriptionArn"))
        }
        try container.encode("SetSubscriptionAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension SetSubscriptionAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input for SetSubscriptionAttributes action.
public struct SetSubscriptionAttributesInput: Swift.Equatable {
    /// A map of attributes with their corresponding values. The following lists the names, descriptions, and values of the special request parameters that this action uses:
    ///
    /// * DeliveryPolicy – The policy that defines how Amazon SNS retries failed deliveries to HTTP/S endpoints.
    ///
    /// * FilterPolicy – The simple JSON object that lets your subscriber receive only a subset of messages, rather than receiving every message published to the topic.
    ///
    /// * RawMessageDelivery – When set to true, enables raw message delivery to Amazon SQS or HTTP/S endpoints. This eliminates the need for the endpoints to process JSON formatting, which is otherwise created for Amazon SNS metadata.
    ///
    /// * RedrivePolicy – When specified, sends undeliverable messages to the specified Amazon SQS dead-letter queue. Messages that can't be delivered due to client errors (for example, when the subscribed endpoint is unreachable) or server errors (for example, when the service that powers the subscribed endpoint becomes unavailable) are held in the dead-letter queue for further analysis or reprocessing.
    ///
    ///
    /// The following attribute applies only to Amazon Kinesis Data Firehose delivery stream subscriptions:
    ///
    /// * SubscriptionRoleArn – The ARN of the IAM role that has the following:
    ///
    /// * Permission to write to the Kinesis Data Firehose delivery stream
    ///
    /// * Amazon SNS listed as a trusted entity
    ///
    ///
    /// Specifying a valid ARN for this attribute is required for Kinesis Data Firehose delivery stream subscriptions. For more information, see [Fanout to Kinesis Data Firehose delivery streams](https://docs.aws.amazon.com/sns/latest/dg/sns-firehose-as-subscriber.html) in the Amazon SNS Developer Guide.
    /// This member is required.
    public var attributeName: Swift.String?
    /// The new value for the attribute in JSON format.
    public var attributeValue: Swift.String?
    /// The ARN of the subscription to modify.
    /// This member is required.
    public var subscriptionArn: Swift.String?

    public init (
        attributeName: Swift.String? = nil,
        attributeValue: Swift.String? = nil,
        subscriptionArn: Swift.String? = nil
    )
    {
        self.attributeName = attributeName
        self.attributeValue = attributeValue
        self.subscriptionArn = subscriptionArn
    }
}

struct SetSubscriptionAttributesInputBody: Swift.Equatable {
    let subscriptionArn: Swift.String?
    let attributeName: Swift.String?
    let attributeValue: Swift.String?
}

extension SetSubscriptionAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case attributeValue = "AttributeValue"
        case subscriptionArn = "SubscriptionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionArn)
        subscriptionArn = subscriptionArnDecoded
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let attributeValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeValue)
        attributeValue = attributeValueDecoded
    }
}

extension SetSubscriptionAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetSubscriptionAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FilterPolicyLimitExceeded" : self = .filterPolicyLimitExceededException(try FilterPolicyLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFound" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetSubscriptionAttributesOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case filterPolicyLimitExceededException(FilterPolicyLimitExceededException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetSubscriptionAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SetSubscriptionAttributesOutputResponse: Swift.Equatable {

}

extension SetTopicAttributesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: ClientRuntime.Key("AttributeName"))
        }
        if let attributeValue = attributeValue {
            try container.encode(attributeValue, forKey: ClientRuntime.Key("AttributeValue"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
        try container.encode("SetTopicAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension SetTopicAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input for SetTopicAttributes action.
public struct SetTopicAttributesInput: Swift.Equatable {
    /// A map of attributes with their corresponding values. The following lists the names, descriptions, and values of the special request parameters that the SetTopicAttributes action uses:
    ///
    /// * DeliveryPolicy – The policy that defines how Amazon SNS retries failed deliveries to HTTP/S endpoints.
    ///
    /// * DisplayName – The display name to use for a topic with SMS subscriptions.
    ///
    /// * Policy – The policy that defines who can access your topic. By default, only the topic owner can publish or subscribe to the topic.
    ///
    ///
    /// The following attribute applies only to [server-side-encryption](https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html):
    ///
    /// * KmsMasterKeyId – The ID of an Amazon Web Services managed customer master key (CMK) for Amazon SNS or a custom CMK. For more information, see [Key Terms](https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html#sse-key-terms). For more examples, see [KeyId](https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters) in the Key Management Service API Reference.
    ///
    ///
    /// The following attribute applies only to [FIFO topics](https://docs.aws.amazon.com/sns/latest/dg/sns-fifo-topics.html):
    ///
    /// * ContentBasedDeduplication – Enables content-based deduplication for FIFO topics.
    ///
    /// * By default, ContentBasedDeduplication is set to false. If you create a FIFO topic and this attribute is false, you must specify a value for the MessageDeduplicationId parameter for the [Publish](https://docs.aws.amazon.com/sns/latest/api/API_Publish.html) action.
    ///
    /// * When you set ContentBasedDeduplication to true, Amazon SNS uses a SHA-256 hash to generate the MessageDeduplicationId using the body of the message (but not the attributes of the message). (Optional) To override the generated value, you can specify a value for the MessageDeduplicationId parameter for the Publish action.
    /// This member is required.
    public var attributeName: Swift.String?
    /// The new value for the attribute.
    public var attributeValue: Swift.String?
    /// The ARN of the topic to modify.
    /// This member is required.
    public var topicArn: Swift.String?

    public init (
        attributeName: Swift.String? = nil,
        attributeValue: Swift.String? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.attributeName = attributeName
        self.attributeValue = attributeValue
        self.topicArn = topicArn
    }
}

struct SetTopicAttributesInputBody: Swift.Equatable {
    let topicArn: Swift.String?
    let attributeName: Swift.String?
    let attributeValue: Swift.String?
}

extension SetTopicAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case attributeValue = "AttributeValue"
        case topicArn = "TopicArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let attributeValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeValue)
        attributeValue = attributeValueDecoded
    }
}

extension SetTopicAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetTopicAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecurity" : self = .invalidSecurityException(try InvalidSecurityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFound" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetTopicAttributesOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidSecurityException(InvalidSecurityException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetTopicAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SetTopicAttributesOutputResponse: Swift.Equatable {

}

extension StaleTagException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<StaleTagExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A tag has been added to a resource with the same ARN as a deleted resource. Wait a short while and then retry the operation.
public struct StaleTagException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct StaleTagExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension StaleTagExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubscribeInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let attributenameKey0 = element0.key
                let attributevalueValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(attributenameKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(attributevalueValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: ClientRuntime.Key("Endpoint"))
        }
        if let `protocol` = `protocol` {
            try container.encode(`protocol`, forKey: ClientRuntime.Key("Protocol"))
        }
        if returnSubscriptionArn != false {
            try container.encode(returnSubscriptionArn, forKey: ClientRuntime.Key("ReturnSubscriptionArn"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
        try container.encode("Subscribe", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension SubscribeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input for Subscribe action.
public struct SubscribeInput: Swift.Equatable {
    /// A map of attributes with their corresponding values. The following lists the names, descriptions, and values of the special request parameters that the Subscribe action uses:
    ///
    /// * DeliveryPolicy – The policy that defines how Amazon SNS retries failed deliveries to HTTP/S endpoints.
    ///
    /// * FilterPolicy – The simple JSON object that lets your subscriber receive only a subset of messages, rather than receiving every message published to the topic.
    ///
    /// * RawMessageDelivery – When set to true, enables raw message delivery to Amazon SQS or HTTP/S endpoints. This eliminates the need for the endpoints to process JSON formatting, which is otherwise created for Amazon SNS metadata.
    ///
    /// * RedrivePolicy – When specified, sends undeliverable messages to the specified Amazon SQS dead-letter queue. Messages that can't be delivered due to client errors (for example, when the subscribed endpoint is unreachable) or server errors (for example, when the service that powers the subscribed endpoint becomes unavailable) are held in the dead-letter queue for further analysis or reprocessing.
    ///
    ///
    /// The following attribute applies only to Amazon Kinesis Data Firehose delivery stream subscriptions:
    ///
    /// * SubscriptionRoleArn – The ARN of the IAM role that has the following:
    ///
    /// * Permission to write to the Kinesis Data Firehose delivery stream
    ///
    /// * Amazon SNS listed as a trusted entity
    ///
    ///
    /// Specifying a valid ARN for this attribute is required for Kinesis Data Firehose delivery stream subscriptions. For more information, see [Fanout to Kinesis Data Firehose delivery streams](https://docs.aws.amazon.com/sns/latest/dg/sns-firehose-as-subscriber.html) in the Amazon SNS Developer Guide.
    public var attributes: [Swift.String:Swift.String]?
    /// The endpoint that you want to receive notifications. Endpoints vary by protocol:
    ///
    /// * For the http protocol, the (public) endpoint is a URL beginning with http://.
    ///
    /// * For the https protocol, the (public) endpoint is a URL beginning with https://.
    ///
    /// * For the email protocol, the endpoint is an email address.
    ///
    /// * For the email-json protocol, the endpoint is an email address.
    ///
    /// * For the sms protocol, the endpoint is a phone number of an SMS-enabled device.
    ///
    /// * For the sqs protocol, the endpoint is the ARN of an Amazon SQS queue.
    ///
    /// * For the application protocol, the endpoint is the EndpointArn of a mobile app and device.
    ///
    /// * For the lambda protocol, the endpoint is the ARN of an Lambda function.
    ///
    /// * For the firehose protocol, the endpoint is the ARN of an Amazon Kinesis Data Firehose delivery stream.
    public var endpoint: Swift.String?
    /// The protocol that you want to use. Supported protocols include:
    ///
    /// * http – delivery of JSON-encoded message via HTTP POST
    ///
    /// * https – delivery of JSON-encoded message via HTTPS POST
    ///
    /// * email – delivery of message via SMTP
    ///
    /// * email-json – delivery of JSON-encoded message via SMTP
    ///
    /// * sms – delivery of message via SMS
    ///
    /// * sqs – delivery of JSON-encoded message to an Amazon SQS queue
    ///
    /// * application – delivery of JSON-encoded message to an EndpointArn for a mobile app and device
    ///
    /// * lambda – delivery of JSON-encoded message to an Lambda function
    ///
    /// * firehose – delivery of JSON-encoded message to an Amazon Kinesis Data Firehose delivery stream.
    /// This member is required.
    public var `protocol`: Swift.String?
    /// Sets whether the response from the Subscribe request includes the subscription ARN, even if the subscription is not yet confirmed. If you set this parameter to true, the response includes the ARN in all cases, even if the subscription is not yet confirmed. In addition to the ARN for confirmed subscriptions, the response also includes the pending subscription ARN value for subscriptions that aren't yet confirmed. A subscription becomes confirmed when the subscriber calls the ConfirmSubscription action with a confirmation token. The default value is false.
    public var returnSubscriptionArn: Swift.Bool
    /// The ARN of the topic you want to subscribe to.
    /// This member is required.
    public var topicArn: Swift.String?

    public init (
        attributes: [Swift.String:Swift.String]? = nil,
        endpoint: Swift.String? = nil,
        `protocol`: Swift.String? = nil,
        returnSubscriptionArn: Swift.Bool = false,
        topicArn: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.endpoint = endpoint
        self.`protocol` = `protocol`
        self.returnSubscriptionArn = returnSubscriptionArn
        self.topicArn = topicArn
    }
}

struct SubscribeInputBody: Swift.Equatable {
    let topicArn: Swift.String?
    let `protocol`: Swift.String?
    let endpoint: Swift.String?
    let attributes: [Swift.String:Swift.String]?
    let returnSubscriptionArn: Swift.Bool
}

extension SubscribeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case endpoint = "Endpoint"
        case `protocol` = "Protocol"
        case returnSubscriptionArn = "ReturnSubscriptionArn"
        case topicArn = "TopicArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var attributesBuffer: [Swift.String:Swift.String]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in attributesContainer {
                        attributesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = [:]
            }
        } else {
            attributes = nil
        }
        let returnSubscriptionArnDecoded = try containerValues.decode(Swift.Bool.self, forKey: .returnSubscriptionArn)
        returnSubscriptionArn = returnSubscriptionArnDecoded
    }
}

extension SubscribeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SubscribeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FilterPolicyLimitExceeded" : self = .filterPolicyLimitExceededException(try FilterPolicyLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecurity" : self = .invalidSecurityException(try InvalidSecurityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFound" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionLimitExceeded" : self = .subscriptionLimitExceededException(try SubscriptionLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SubscribeOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case filterPolicyLimitExceededException(FilterPolicyLimitExceededException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidSecurityException(InvalidSecurityException)
    case notFoundException(NotFoundException)
    case subscriptionLimitExceededException(SubscriptionLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SubscribeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SubscribeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.subscriptionArn = output.subscriptionArn
        } else {
            self.subscriptionArn = nil
        }
    }
}

/// Response for Subscribe action.
public struct SubscribeOutputResponse: Swift.Equatable {
    /// The ARN of the subscription if it is confirmed, or the string "pending confirmation" if the subscription requires confirmation. However, if the API request parameter ReturnSubscriptionArn is true, then the value is always the subscription ARN, even if the subscription requires confirmation.
    public var subscriptionArn: Swift.String?

    public init (
        subscriptionArn: Swift.String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

struct SubscribeOutputResponseBody: Swift.Equatable {
    let subscriptionArn: Swift.String?
}

extension SubscribeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriptionArn = "SubscriptionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("SubscribeResult"))
        let subscriptionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionArn)
        subscriptionArn = subscriptionArnDecoded
    }
}

extension SnsClientTypes.Subscription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint = "Endpoint"
        case owner = "Owner"
        case `protocol` = "Protocol"
        case subscriptionArn = "SubscriptionArn"
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: ClientRuntime.Key("Endpoint"))
        }
        if let owner = owner {
            try container.encode(owner, forKey: ClientRuntime.Key("Owner"))
        }
        if let `protocol` = `protocol` {
            try container.encode(`protocol`, forKey: ClientRuntime.Key("Protocol"))
        }
        if let subscriptionArn = subscriptionArn {
            try container.encode(subscriptionArn, forKey: ClientRuntime.Key("SubscriptionArn"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionArn)
        subscriptionArn = subscriptionArnDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

extension SnsClientTypes {
    /// A wrapper type for the attributes of an Amazon SNS subscription.
    public struct Subscription: Swift.Equatable {
        /// The subscription's endpoint (format depends on the protocol).
        public var endpoint: Swift.String?
        /// The subscription's owner.
        public var owner: Swift.String?
        /// The subscription's protocol.
        public var `protocol`: Swift.String?
        /// The subscription's ARN.
        public var subscriptionArn: Swift.String?
        /// The ARN of the subscription's topic.
        public var topicArn: Swift.String?

        public init (
            endpoint: Swift.String? = nil,
            owner: Swift.String? = nil,
            `protocol`: Swift.String? = nil,
            subscriptionArn: Swift.String? = nil,
            topicArn: Swift.String? = nil
        )
        {
            self.endpoint = endpoint
            self.owner = owner
            self.`protocol` = `protocol`
            self.subscriptionArn = subscriptionArn
            self.topicArn = topicArn
        }
    }

}

extension SubscriptionLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<SubscriptionLimitExceededExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that the customer already owns the maximum allowed number of subscriptions.
public struct SubscriptionLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubscriptionLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension SubscriptionLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnsClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SnsClientTypes {
    /// The list of tags to be added to the specified topic.
    public struct Tag: Swift.Equatable {
        /// The required key portion of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The optional value portion of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TagLimitExceededExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Can't add more than 50 tags to a topic.
public struct TagLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TagLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TagLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagPolicyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TagPolicyExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request doesn't comply with the IAM tag policy. Correct your request and then retry it.
public struct TagPolicyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TagPolicyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TagPolicyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let resourceArn = resourceArn {
            try container.encode(resourceArn, forKey: ClientRuntime.Key("ResourceArn"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("TagResource", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the topic to which to add tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to be added to the specified topic. A tag consists of a required key and an optional value.
    /// This member is required.
    public var tags: [SnsClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [SnsClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [SnsClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([SnsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[SnsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [SnsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentAccess" : self = .concurrentAccessException(try ConcurrentAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StaleTag" : self = .staleTagException(try StaleTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceeded" : self = .tagLimitExceededException(try TagLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicy" : self = .tagPolicyException(try TagPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case concurrentAccessException(ConcurrentAccessException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case staleTagException(StaleTagException)
    case tagLimitExceededException(TagLimitExceededException)
    case tagPolicyException(TagPolicyException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension ThrottledException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<ThrottledExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that the rate at which requests have been submitted for this action exceeds the limit for your Amazon Web Services account.
public struct ThrottledException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Throttled request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottledExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyEntriesInBatchRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyEntriesInBatchRequestExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The batch request contains more entries than permissible.
public struct TooManyEntriesInBatchRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyEntriesInBatchRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyEntriesInBatchRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnsClientTypes.Topic: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

extension SnsClientTypes {
    /// A wrapper type for the topic's Amazon Resource Name (ARN). To retrieve a topic's attributes, use GetTopicAttributes.
    public struct Topic: Swift.Equatable {
        /// The topic's ARN.
        public var topicArn: Swift.String?

        public init (
            topicArn: Swift.String? = nil
        )
        {
            self.topicArn = topicArn
        }
    }

}

extension TopicLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TopicLimitExceededExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that the customer already owns the maximum allowed number of topics.
public struct TopicLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TopicLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TopicLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsubscribeInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let subscriptionArn = subscriptionArn {
            try container.encode(subscriptionArn, forKey: ClientRuntime.Key("SubscriptionArn"))
        }
        try container.encode("Unsubscribe", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension UnsubscribeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Input for Unsubscribe action.
public struct UnsubscribeInput: Swift.Equatable {
    /// The ARN of the subscription to be deleted.
    /// This member is required.
    public var subscriptionArn: Swift.String?

    public init (
        subscriptionArn: Swift.String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

struct UnsubscribeInputBody: Swift.Equatable {
    let subscriptionArn: Swift.String?
}

extension UnsubscribeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriptionArn = "SubscriptionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionArn)
        subscriptionArn = subscriptionArnDecoded
    }
}

extension UnsubscribeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UnsubscribeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecurity" : self = .invalidSecurityException(try InvalidSecurityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFound" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UnsubscribeOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidSecurityException(InvalidSecurityException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnsubscribeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UnsubscribeOutputResponse: Swift.Equatable {

}

extension UntagResourceInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let resourceArn = resourceArn {
            try container.encode(resourceArn, forKey: ClientRuntime.Key("ResourceArn"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
            for (index0, tagkey0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(tagkey0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("UntagResource", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the topic from which to remove tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the specified topic.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        if containerValues.contains(.tagKeys) {
            struct KeyVal0{struct member{}}
            let tagKeysWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tagKeys)
            if let tagKeysWrappedContainer = tagKeysWrappedContainer {
                let tagKeysContainer = try tagKeysWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var tagKeysBuffer:[Swift.String]? = nil
                if let tagKeysContainer = tagKeysContainer {
                    tagKeysBuffer = [Swift.String]()
                    for stringContainer0 in tagKeysContainer {
                        tagKeysBuffer?.append(stringContainer0)
                    }
                }
                tagKeys = tagKeysBuffer
            } else {
                tagKeys = []
            }
        } else {
            tagKeys = nil
        }
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentAccess" : self = .concurrentAccessException(try ConcurrentAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StaleTag" : self = .staleTagException(try StaleTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceeded" : self = .tagLimitExceededException(try TagLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicy" : self = .tagPolicyException(try TagPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case concurrentAccessException(ConcurrentAccessException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case staleTagException(StaleTagException)
    case tagLimitExceededException(TagLimitExceededException)
    case tagPolicyException(TagPolicyException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UserErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<UserErrorExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that a request parameter does not comply with the associated constraints.
public struct UserErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UserErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UserErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<ValidationExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that a parameter in the request is invalid.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VerificationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<VerificationExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
            self.status = output.error.status
        } else {
            self.message = nil
            self.status = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that the one-time password (OTP) used for verification is invalid.
public struct VerificationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The status of the verification error.
    /// This member is required.
    public var status: Swift.String?

    public init (
        message: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.message = message
        self.status = status
    }
}

struct VerificationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let status: Swift.String?
}

extension VerificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension VerifySMSSandboxPhoneNumberInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let oneTimePassword = oneTimePassword {
            try container.encode(oneTimePassword, forKey: ClientRuntime.Key("OneTimePassword"))
        }
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: ClientRuntime.Key("PhoneNumber"))
        }
        try container.encode("VerifySMSSandboxPhoneNumber", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension VerifySMSSandboxPhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct VerifySMSSandboxPhoneNumberInput: Swift.Equatable {
    /// The OTP sent to the destination number from the CreateSMSSandBoxPhoneNumber call.
    /// This member is required.
    public var oneTimePassword: Swift.String?
    /// The destination phone number to verify.
    /// This member is required.
    public var phoneNumber: Swift.String?

    public init (
        oneTimePassword: Swift.String? = nil,
        phoneNumber: Swift.String? = nil
    )
    {
        self.oneTimePassword = oneTimePassword
        self.phoneNumber = phoneNumber
    }
}

struct VerifySMSSandboxPhoneNumberInputBody: Swift.Equatable {
    let phoneNumber: Swift.String?
    let oneTimePassword: Swift.String?
}

extension VerifySMSSandboxPhoneNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case oneTimePassword = "OneTimePassword"
        case phoneNumber = "PhoneNumber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let oneTimePasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .oneTimePassword)
        oneTimePassword = oneTimePasswordDecoded
    }
}

extension VerifySMSSandboxPhoneNumberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension VerifySMSSandboxPhoneNumberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationError" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Throttled" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VerificationException" : self = .verificationException(try VerificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum VerifySMSSandboxPhoneNumberOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttledException(ThrottledException)
    case verificationException(VerificationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension VerifySMSSandboxPhoneNumberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// The destination phone number's verification status.
public struct VerifySMSSandboxPhoneNumberOutputResponse: Swift.Equatable {

}
