// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient permissions to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BatchEvaluateFeatureInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requests
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let requests = requests {
            var requestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requests)
            for evaluationrequestslist0 in requests {
                try requestsContainer.encode(evaluationrequestslist0)
            }
        }
    }
}

extension BatchEvaluateFeatureInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/evaluations"
    }
}

public struct BatchEvaluateFeatureInput: Swift.Equatable {
    /// The name or ARN of the project that contains the feature being evaluated.
    /// This member is required.
    public var project: Swift.String?
    /// An array of structures, where each structure assigns a feature variation to one user session.
    /// This member is required.
    public var requests: [EvidentlyClientTypes.EvaluationRequest]?

    public init (
        project: Swift.String? = nil,
        requests: [EvidentlyClientTypes.EvaluationRequest]? = nil
    )
    {
        self.project = project
        self.requests = requests
    }
}

struct BatchEvaluateFeatureInputBody: Swift.Equatable {
    let requests: [EvidentlyClientTypes.EvaluationRequest]?
}

extension BatchEvaluateFeatureInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requests
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.EvaluationRequest?].self, forKey: .requests)
        var requestsDecoded0:[EvidentlyClientTypes.EvaluationRequest]? = nil
        if let requestsContainer = requestsContainer {
            requestsDecoded0 = [EvidentlyClientTypes.EvaluationRequest]()
            for structure0 in requestsContainer {
                if let structure0 = structure0 {
                    requestsDecoded0?.append(structure0)
                }
            }
        }
        requests = requestsDecoded0
    }
}

extension BatchEvaluateFeatureOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchEvaluateFeatureOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchEvaluateFeatureOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchEvaluateFeatureOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchEvaluateFeatureOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.results = output.results
        } else {
            self.results = nil
        }
    }
}

public struct BatchEvaluateFeatureOutputResponse: Swift.Equatable {
    /// An array of structures, where each structure displays the results of one feature evaluation assignment to one user session.
    public var results: [EvidentlyClientTypes.EvaluationResult]?

    public init (
        results: [EvidentlyClientTypes.EvaluationResult]? = nil
    )
    {
        self.results = results
    }
}

struct BatchEvaluateFeatureOutputResponseBody: Swift.Equatable {
    let results: [EvidentlyClientTypes.EvaluationResult]?
}

extension BatchEvaluateFeatureOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case results
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.EvaluationResult?].self, forKey: .results)
        var resultsDecoded0:[EvidentlyClientTypes.EvaluationResult]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [EvidentlyClientTypes.EvaluationResult]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
    }
}

extension EvidentlyClientTypes {
    public enum ChangeDirectionEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case decrease
        case increase
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeDirectionEnum] {
            return [
                .decrease,
                .increase,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .decrease: return "DECREASE"
            case .increase: return "INCREASE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeDirectionEnum(rawValue: rawValue) ?? ChangeDirectionEnum.sdkUnknown(rawValue)
        }
    }
}

extension EvidentlyClientTypes.CloudWatchLogsDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroup
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroup = logGroup {
            try encodeContainer.encode(logGroup, forKey: .logGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroup)
        logGroup = logGroupDecoded
    }
}

extension EvidentlyClientTypes {
    /// A structure containing the CloudWatch Logs log group where the project stores evaluation events.
    public struct CloudWatchLogsDestination: Swift.Equatable {
        /// The name of the log group where the project stores evaluation events.
        public var logGroup: Swift.String?

        public init (
            logGroup: Swift.String? = nil
        )
        {
            self.logGroup = logGroup
        }
    }

}

extension EvidentlyClientTypes.CloudWatchLogsDestinationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroup
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroup = logGroup {
            try encodeContainer.encode(logGroup, forKey: .logGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroup)
        logGroup = logGroupDecoded
    }
}

extension EvidentlyClientTypes {
    /// A structure containing the CloudWatch Logs log group where the project stores evaluation events.
    public struct CloudWatchLogsDestinationConfig: Swift.Equatable {
        /// The name of the log group where the project stores evaluation events.
        public var logGroup: Swift.String?

        public init (
            logGroup: Swift.String? = nil
        )
        {
            self.logGroup = logGroup
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A resource was in an inconsistent state during an update or a deletion.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The ID of the resource that caused the exception.
    public var resourceId: Swift.String?
    /// The type of the resource that is associated with the error.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CreateExperimentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case metricGoals
        case name
        case onlineAbConfig
        case randomizationSalt
        case samplingRate
        case tags
        case treatments
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let metricGoals = metricGoals {
            var metricGoalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricGoals)
            for metricgoalconfiglist0 in metricGoals {
                try metricGoalsContainer.encode(metricgoalconfiglist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let onlineAbConfig = onlineAbConfig {
            try encodeContainer.encode(onlineAbConfig, forKey: .onlineAbConfig)
        }
        if let randomizationSalt = randomizationSalt {
            try encodeContainer.encode(randomizationSalt, forKey: .randomizationSalt)
        }
        if samplingRate != 0 {
            try encodeContainer.encode(samplingRate, forKey: .samplingRate)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let treatments = treatments {
            var treatmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .treatments)
            for treatmentconfiglist0 in treatments {
                try treatmentsContainer.encode(treatmentconfiglist0)
            }
        }
    }
}

extension CreateExperimentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/experiments"
    }
}

public struct CreateExperimentInput: Swift.Equatable {
    /// An optional description of the experiment.
    public var description: Swift.String?
    /// An array of structures that defines the metrics used for the experiment, and whether a higher or lower value for each metric is the goal.
    /// This member is required.
    public var metricGoals: [EvidentlyClientTypes.MetricGoalConfig]?
    /// A name for the new experiment.
    /// This member is required.
    public var name: Swift.String?
    /// A structure that contains the configuration of which variation to use as the "control" version. tThe "control" version is used for comparison with other variations. This structure also specifies how much experiment traffic is allocated to each variation.
    public var onlineAbConfig: EvidentlyClientTypes.OnlineAbConfig?
    /// The name or ARN of the project that you want to create the new experiment in.
    /// This member is required.
    public var project: Swift.String?
    /// When Evidently assigns a particular user session to an experiment, it must use a randomization ID to determine which variation the user session is served. This randomization ID is a combination of the entity ID and randomizationSalt. If you omit randomizationSalt, Evidently uses the experiment name as the randomizationSalt.
    public var randomizationSalt: Swift.String?
    /// The portion of the available audience that you want to allocate to this experiment, in thousandths of a percent. The available audience is the total audience minus the audience that you have allocated to overrides or current launches of this feature. This is represented in thousandths of a percent. For example, specify 10,000 to allocate 10% of the available audience.
    public var samplingRate: Swift.Int
    /// Assigns one or more tags (key-value pairs) to the experiment. Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values. Tags don't have any semantic meaning to Amazon Web Services and are interpreted strictly as strings of characters. You can associate as many as 50 tags with an experiment. For more information, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html).
    public var tags: [Swift.String:Swift.String]?
    /// An array of structures that describe the configuration of each feature variation used in the experiment.
    /// This member is required.
    public var treatments: [EvidentlyClientTypes.TreatmentConfig]?

    public init (
        description: Swift.String? = nil,
        metricGoals: [EvidentlyClientTypes.MetricGoalConfig]? = nil,
        name: Swift.String? = nil,
        onlineAbConfig: EvidentlyClientTypes.OnlineAbConfig? = nil,
        project: Swift.String? = nil,
        randomizationSalt: Swift.String? = nil,
        samplingRate: Swift.Int = 0,
        tags: [Swift.String:Swift.String]? = nil,
        treatments: [EvidentlyClientTypes.TreatmentConfig]? = nil
    )
    {
        self.description = description
        self.metricGoals = metricGoals
        self.name = name
        self.onlineAbConfig = onlineAbConfig
        self.project = project
        self.randomizationSalt = randomizationSalt
        self.samplingRate = samplingRate
        self.tags = tags
        self.treatments = treatments
    }
}

struct CreateExperimentInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let treatments: [EvidentlyClientTypes.TreatmentConfig]?
    let metricGoals: [EvidentlyClientTypes.MetricGoalConfig]?
    let randomizationSalt: Swift.String?
    let samplingRate: Swift.Int
    let onlineAbConfig: EvidentlyClientTypes.OnlineAbConfig?
    let tags: [Swift.String:Swift.String]?
}

extension CreateExperimentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case metricGoals
        case name
        case onlineAbConfig
        case randomizationSalt
        case samplingRate
        case tags
        case treatments
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let treatmentsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.TreatmentConfig?].self, forKey: .treatments)
        var treatmentsDecoded0:[EvidentlyClientTypes.TreatmentConfig]? = nil
        if let treatmentsContainer = treatmentsContainer {
            treatmentsDecoded0 = [EvidentlyClientTypes.TreatmentConfig]()
            for structure0 in treatmentsContainer {
                if let structure0 = structure0 {
                    treatmentsDecoded0?.append(structure0)
                }
            }
        }
        treatments = treatmentsDecoded0
        let metricGoalsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.MetricGoalConfig?].self, forKey: .metricGoals)
        var metricGoalsDecoded0:[EvidentlyClientTypes.MetricGoalConfig]? = nil
        if let metricGoalsContainer = metricGoalsContainer {
            metricGoalsDecoded0 = [EvidentlyClientTypes.MetricGoalConfig]()
            for structure0 in metricGoalsContainer {
                if let structure0 = structure0 {
                    metricGoalsDecoded0?.append(structure0)
                }
            }
        }
        metricGoals = metricGoalsDecoded0
        let randomizationSaltDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .randomizationSalt)
        randomizationSalt = randomizationSaltDecoded
        let samplingRateDecoded = try containerValues.decode(Swift.Int.self, forKey: .samplingRate)
        samplingRate = samplingRateDecoded
        let onlineAbConfigDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.OnlineAbConfig.self, forKey: .onlineAbConfig)
        onlineAbConfig = onlineAbConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateExperimentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateExperimentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateExperimentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateExperimentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateExperimentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.experiment = output.experiment
        } else {
            self.experiment = nil
        }
    }
}

public struct CreateExperimentOutputResponse: Swift.Equatable {
    /// A structure containing the configuration details of the experiment that you created.
    /// This member is required.
    public var experiment: EvidentlyClientTypes.Experiment?

    public init (
        experiment: EvidentlyClientTypes.Experiment? = nil
    )
    {
        self.experiment = experiment
    }
}

struct CreateExperimentOutputResponseBody: Swift.Equatable {
    let experiment: EvidentlyClientTypes.Experiment?
}

extension CreateExperimentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experiment
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.Experiment.self, forKey: .experiment)
        experiment = experimentDecoded
    }
}

extension CreateFeatureInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultVariation
        case description
        case entityOverrides
        case evaluationStrategy
        case name
        case tags
        case variations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultVariation = defaultVariation {
            try encodeContainer.encode(defaultVariation, forKey: .defaultVariation)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entityOverrides = entityOverrides {
            var entityOverridesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .entityOverrides)
            for (dictKey0, entityoverridemap0) in entityOverrides {
                try entityOverridesContainer.encode(entityoverridemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let evaluationStrategy = evaluationStrategy {
            try encodeContainer.encode(evaluationStrategy.rawValue, forKey: .evaluationStrategy)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let variations = variations {
            var variationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variations)
            for variationconfigslist0 in variations {
                try variationsContainer.encode(variationconfigslist0)
            }
        }
    }
}

extension CreateFeatureInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/features"
    }
}

public struct CreateFeatureInput: Swift.Equatable {
    /// The name of the variation to use as the default variation. The default variation is served to users who are not allocated to any ongoing launches or experiments of this feature. This variation must also be listed in the variations structure. If you omit defaultVariation, the first variation listed in the variations structure is used as the default variation.
    public var defaultVariation: Swift.String?
    /// An optional description of the feature.
    public var description: Swift.String?
    /// Specify users that should always be served a specific variation of a feature. Each user is specified by a key-value pair . For each key, specify a user by entering their user ID, account ID, or some other identifier. For the value, specify the name of the variation that they are to be served.
    public var entityOverrides: [Swift.String:Swift.String]?
    /// Specify ALL_RULES to activate the traffic allocation specified by any ongoing launches or experiments. Specify DEFAULT_VARIATION to serve the default variation to all users instead.
    public var evaluationStrategy: EvidentlyClientTypes.FeatureEvaluationStrategy?
    /// The name for the new feature.
    /// This member is required.
    public var name: Swift.String?
    /// The name or ARN of the project that is to contain the new feature.
    /// This member is required.
    public var project: Swift.String?
    /// Assigns one or more tags (key-value pairs) to the feature. Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values. Tags don't have any semantic meaning to Amazon Web Services and are interpreted strictly as strings of characters. You can associate as many as 50 tags with a feature. For more information, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html).
    public var tags: [Swift.String:Swift.String]?
    /// An array of structures that contain the configuration of the feature's different variations.
    /// This member is required.
    public var variations: [EvidentlyClientTypes.VariationConfig]?

    public init (
        defaultVariation: Swift.String? = nil,
        description: Swift.String? = nil,
        entityOverrides: [Swift.String:Swift.String]? = nil,
        evaluationStrategy: EvidentlyClientTypes.FeatureEvaluationStrategy? = nil,
        name: Swift.String? = nil,
        project: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        variations: [EvidentlyClientTypes.VariationConfig]? = nil
    )
    {
        self.defaultVariation = defaultVariation
        self.description = description
        self.entityOverrides = entityOverrides
        self.evaluationStrategy = evaluationStrategy
        self.name = name
        self.project = project
        self.tags = tags
        self.variations = variations
    }
}

struct CreateFeatureInputBody: Swift.Equatable {
    let name: Swift.String?
    let evaluationStrategy: EvidentlyClientTypes.FeatureEvaluationStrategy?
    let description: Swift.String?
    let variations: [EvidentlyClientTypes.VariationConfig]?
    let defaultVariation: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let entityOverrides: [Swift.String:Swift.String]?
}

extension CreateFeatureInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultVariation
        case description
        case entityOverrides
        case evaluationStrategy
        case name
        case tags
        case variations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let evaluationStrategyDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.FeatureEvaluationStrategy.self, forKey: .evaluationStrategy)
        evaluationStrategy = evaluationStrategyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let variationsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.VariationConfig?].self, forKey: .variations)
        var variationsDecoded0:[EvidentlyClientTypes.VariationConfig]? = nil
        if let variationsContainer = variationsContainer {
            variationsDecoded0 = [EvidentlyClientTypes.VariationConfig]()
            for structure0 in variationsContainer {
                if let structure0 = structure0 {
                    variationsDecoded0?.append(structure0)
                }
            }
        }
        variations = variationsDecoded0
        let defaultVariationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultVariation)
        defaultVariation = defaultVariationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let entityOverridesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .entityOverrides)
        var entityOverridesDecoded0: [Swift.String:Swift.String]? = nil
        if let entityOverridesContainer = entityOverridesContainer {
            entityOverridesDecoded0 = [Swift.String:Swift.String]()
            for (key0, variationname0) in entityOverridesContainer {
                if let variationname0 = variationname0 {
                    entityOverridesDecoded0?[key0] = variationname0
                }
            }
        }
        entityOverrides = entityOverridesDecoded0
    }
}

extension CreateFeatureOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFeatureOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFeatureOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFeatureOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFeatureOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.feature = output.feature
        } else {
            self.feature = nil
        }
    }
}

public struct CreateFeatureOutputResponse: Swift.Equatable {
    /// A structure that contains information about the new feature.
    public var feature: EvidentlyClientTypes.Feature?

    public init (
        feature: EvidentlyClientTypes.Feature? = nil
    )
    {
        self.feature = feature
    }
}

struct CreateFeatureOutputResponseBody: Swift.Equatable {
    let feature: EvidentlyClientTypes.Feature?
}

extension CreateFeatureOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case feature
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.Feature.self, forKey: .feature)
        feature = featureDecoded
    }
}

extension CreateLaunchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case groups
        case metricMonitors
        case name
        case randomizationSalt
        case scheduledSplitsConfig
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for launchgroupconfiglist0 in groups {
                try groupsContainer.encode(launchgroupconfiglist0)
            }
        }
        if let metricMonitors = metricMonitors {
            var metricMonitorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricMonitors)
            for metricmonitorconfiglist0 in metricMonitors {
                try metricMonitorsContainer.encode(metricmonitorconfiglist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let randomizationSalt = randomizationSalt {
            try encodeContainer.encode(randomizationSalt, forKey: .randomizationSalt)
        }
        if let scheduledSplitsConfig = scheduledSplitsConfig {
            try encodeContainer.encode(scheduledSplitsConfig, forKey: .scheduledSplitsConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateLaunchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/launches"
    }
}

public struct CreateLaunchInput: Swift.Equatable {
    /// An optional description for the launch.
    public var description: Swift.String?
    /// An array of structures that contains the feature and variations that are to be used for the launch.
    /// This member is required.
    public var groups: [EvidentlyClientTypes.LaunchGroupConfig]?
    /// An array of structures that define the metrics that will be used to monitor the launch performance.
    public var metricMonitors: [EvidentlyClientTypes.MetricMonitorConfig]?
    /// The name for the new launch.
    /// This member is required.
    public var name: Swift.String?
    /// The name or ARN of the project that you want to create the launch in.
    /// This member is required.
    public var project: Swift.String?
    /// When Evidently assigns a particular user session to a launch, it must use a randomization ID to determine which variation the user session is served. This randomization ID is a combination of the entity ID and randomizationSalt. If you omit randomizationSalt, Evidently uses the launch name as the randomizationsSalt.
    public var randomizationSalt: Swift.String?
    /// An array of structures that define the traffic allocation percentages among the feature variations during each step of the launch.
    public var scheduledSplitsConfig: EvidentlyClientTypes.ScheduledSplitsLaunchConfig?
    /// Assigns one or more tags (key-value pairs) to the launch. Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values. Tags don't have any semantic meaning to Amazon Web Services and are interpreted strictly as strings of characters. You can associate as many as 50 tags with a launch. For more information, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html).
    public var tags: [Swift.String:Swift.String]?

    public init (
        description: Swift.String? = nil,
        groups: [EvidentlyClientTypes.LaunchGroupConfig]? = nil,
        metricMonitors: [EvidentlyClientTypes.MetricMonitorConfig]? = nil,
        name: Swift.String? = nil,
        project: Swift.String? = nil,
        randomizationSalt: Swift.String? = nil,
        scheduledSplitsConfig: EvidentlyClientTypes.ScheduledSplitsLaunchConfig? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.groups = groups
        self.metricMonitors = metricMonitors
        self.name = name
        self.project = project
        self.randomizationSalt = randomizationSalt
        self.scheduledSplitsConfig = scheduledSplitsConfig
        self.tags = tags
    }
}

struct CreateLaunchInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let scheduledSplitsConfig: EvidentlyClientTypes.ScheduledSplitsLaunchConfig?
    let metricMonitors: [EvidentlyClientTypes.MetricMonitorConfig]?
    let groups: [EvidentlyClientTypes.LaunchGroupConfig]?
    let randomizationSalt: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateLaunchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case groups
        case metricMonitors
        case name
        case randomizationSalt
        case scheduledSplitsConfig
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let scheduledSplitsConfigDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ScheduledSplitsLaunchConfig.self, forKey: .scheduledSplitsConfig)
        scheduledSplitsConfig = scheduledSplitsConfigDecoded
        let metricMonitorsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.MetricMonitorConfig?].self, forKey: .metricMonitors)
        var metricMonitorsDecoded0:[EvidentlyClientTypes.MetricMonitorConfig]? = nil
        if let metricMonitorsContainer = metricMonitorsContainer {
            metricMonitorsDecoded0 = [EvidentlyClientTypes.MetricMonitorConfig]()
            for structure0 in metricMonitorsContainer {
                if let structure0 = structure0 {
                    metricMonitorsDecoded0?.append(structure0)
                }
            }
        }
        metricMonitors = metricMonitorsDecoded0
        let groupsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.LaunchGroupConfig?].self, forKey: .groups)
        var groupsDecoded0:[EvidentlyClientTypes.LaunchGroupConfig]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [EvidentlyClientTypes.LaunchGroupConfig]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let randomizationSaltDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .randomizationSalt)
        randomizationSalt = randomizationSaltDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLaunchOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLaunchOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLaunchOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLaunchOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateLaunchOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.launch = output.launch
        } else {
            self.launch = nil
        }
    }
}

public struct CreateLaunchOutputResponse: Swift.Equatable {
    /// A structure that contains the configuration of the launch that was created.
    /// This member is required.
    public var launch: EvidentlyClientTypes.Launch?

    public init (
        launch: EvidentlyClientTypes.Launch? = nil
    )
    {
        self.launch = launch
    }
}

struct CreateLaunchOutputResponseBody: Swift.Equatable {
    let launch: EvidentlyClientTypes.Launch?
}

extension CreateLaunchOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launch
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.Launch.self, forKey: .launch)
        launch = launchDecoded
    }
}

extension CreateProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataDelivery
        case description
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataDelivery = dataDelivery {
            try encodeContainer.encode(dataDelivery, forKey: .dataDelivery)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/projects"
    }
}

public struct CreateProjectInput: Swift.Equatable {
    /// A structure that contains information about where Evidently is to store evaluation events for longer term storage, if you choose to do so. If you choose not to store these events, Evidently deletes them after using them to produce metrics and other experiment results that you can view.
    public var dataDelivery: EvidentlyClientTypes.ProjectDataDeliveryConfig?
    /// An optional description of the project.
    public var description: Swift.String?
    /// The name for the project.
    /// This member is required.
    public var name: Swift.String?
    /// Assigns one or more tags (key-value pairs) to the project. Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values. Tags don't have any semantic meaning to Amazon Web Services and are interpreted strictly as strings of characters. You can associate as many as 50 tags with a project. For more information, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html).
    public var tags: [Swift.String:Swift.String]?

    public init (
        dataDelivery: EvidentlyClientTypes.ProjectDataDeliveryConfig? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.dataDelivery = dataDelivery
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateProjectInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let dataDelivery: EvidentlyClientTypes.ProjectDataDeliveryConfig?
    let tags: [Swift.String:Swift.String]?
}

extension CreateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataDelivery
        case description
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataDeliveryDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ProjectDataDeliveryConfig.self, forKey: .dataDelivery)
        dataDelivery = dataDeliveryDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProjectOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.project = output.project
        } else {
            self.project = nil
        }
    }
}

public struct CreateProjectOutputResponse: Swift.Equatable {
    /// A structure that contains information about the created project.
    /// This member is required.
    public var project: EvidentlyClientTypes.Project?

    public init (
        project: EvidentlyClientTypes.Project? = nil
    )
    {
        self.project = project
    }
}

struct CreateProjectOutputResponseBody: Swift.Equatable {
    let project: EvidentlyClientTypes.Project?
}

extension CreateProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case project
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.Project.self, forKey: .project)
        project = projectDecoded
    }
}

extension DeleteExperimentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        guard let experiment = experiment else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/experiments/\(experiment.urlPercentEncoding())"
    }
}

public struct DeleteExperimentInput: Swift.Equatable {
    /// The name of the experiment to delete.
    /// This member is required.
    public var experiment: Swift.String?
    /// The name or ARN of the project that contains the experiment to delete.
    /// This member is required.
    public var project: Swift.String?

    public init (
        experiment: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.experiment = experiment
        self.project = project
    }
}

struct DeleteExperimentInputBody: Swift.Equatable {
}

extension DeleteExperimentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteExperimentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteExperimentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteExperimentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteExperimentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteExperimentOutputResponse: Swift.Equatable {

}

extension DeleteFeatureInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        guard let feature = feature else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/features/\(feature.urlPercentEncoding())"
    }
}

public struct DeleteFeatureInput: Swift.Equatable {
    /// The name of the feature to delete.
    /// This member is required.
    public var feature: Swift.String?
    /// The name or ARN of the project that contains the feature to delete.
    /// This member is required.
    public var project: Swift.String?

    public init (
        feature: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.feature = feature
        self.project = project
    }
}

struct DeleteFeatureInputBody: Swift.Equatable {
}

extension DeleteFeatureInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFeatureOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFeatureOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFeatureOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFeatureOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFeatureOutputResponse: Swift.Equatable {

}

extension DeleteLaunchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        guard let launch = launch else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/launches/\(launch.urlPercentEncoding())"
    }
}

public struct DeleteLaunchInput: Swift.Equatable {
    /// The name of the launch to delete.
    /// This member is required.
    public var launch: Swift.String?
    /// The name or ARN of the project that contains the launch to delete.
    /// This member is required.
    public var project: Swift.String?

    public init (
        launch: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.launch = launch
        self.project = project
    }
}

struct DeleteLaunchInputBody: Swift.Equatable {
}

extension DeleteLaunchInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLaunchOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLaunchOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLaunchOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLaunchOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLaunchOutputResponse: Swift.Equatable {

}

extension DeleteProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())"
    }
}

public struct DeleteProjectInput: Swift.Equatable {
    /// The name or ARN of the project to delete.
    /// This member is required.
    public var project: Swift.String?

    public init (
        project: Swift.String? = nil
    )
    {
        self.project = project
    }
}

struct DeleteProjectInputBody: Swift.Equatable {
}

extension DeleteProjectInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProjectOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProjectOutputResponse: Swift.Equatable {

}

extension EvaluateFeatureInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId
        case evaluationContext
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let evaluationContext = evaluationContext {
            try encodeContainer.encode(evaluationContext, forKey: .evaluationContext)
        }
    }
}

extension EvaluateFeatureInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        guard let feature = feature else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/evaluations/\(feature.urlPercentEncoding())"
    }
}

public struct EvaluateFeatureInput: Swift.Equatable {
    /// An internal ID that represents a unique user of the application. This entityID is checked against any override rules assigned for this feature.
    /// This member is required.
    public var entityId: Swift.String?
    /// A JSON block of attributes that you can optionally pass in. This JSON block is included in the evaluation events sent to Evidently from the user session.
    public var evaluationContext: Swift.String?
    /// The name of the feature being evaluated.
    /// This member is required.
    public var feature: Swift.String?
    /// The name or ARN of the project that contains this feature.
    /// This member is required.
    public var project: Swift.String?

    public init (
        entityId: Swift.String? = nil,
        evaluationContext: Swift.String? = nil,
        feature: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.evaluationContext = evaluationContext
        self.feature = feature
        self.project = project
    }
}

struct EvaluateFeatureInputBody: Swift.Equatable {
    let entityId: Swift.String?
    let evaluationContext: Swift.String?
}

extension EvaluateFeatureInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId
        case evaluationContext
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let evaluationContextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationContext)
        evaluationContext = evaluationContextDecoded
    }
}

extension EvaluateFeatureOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EvaluateFeatureOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EvaluateFeatureOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EvaluateFeatureOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EvaluateFeatureOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.details = output.details
            self.reason = output.reason
            self.value = output.value
            self.variation = output.variation
        } else {
            self.details = nil
            self.reason = nil
            self.value = nil
            self.variation = nil
        }
    }
}

public struct EvaluateFeatureOutputResponse: Swift.Equatable {
    /// If this user was assigned to a launch or experiment, this field lists the launch or experiment name.
    public var details: Swift.String?
    /// Specifies the reason that the user session was assigned this variation. Possible values include DEFAULT, meaning the user was served the default variation; LAUNCH_RULE_MATCH, if the user session was enrolled in a launch; EXPERIMENT_RULE_MATCH, if the user session was enrolled in an experiment; or ENTITY_OVERRIDES_MATCH, if the user's entityId matches an override rule.
    public var reason: Swift.String?
    /// The value assigned to this variation to differentiate it from the other variations of this feature.
    public var value: EvidentlyClientTypes.VariableValue?
    /// The name of the variation that was served to the user session.
    public var variation: Swift.String?

    public init (
        details: Swift.String? = nil,
        reason: Swift.String? = nil,
        value: EvidentlyClientTypes.VariableValue? = nil,
        variation: Swift.String? = nil
    )
    {
        self.details = details
        self.reason = reason
        self.value = value
        self.variation = variation
    }
}

struct EvaluateFeatureOutputResponseBody: Swift.Equatable {
    let variation: Swift.String?
    let value: EvidentlyClientTypes.VariableValue?
    let reason: Swift.String?
    let details: Swift.String?
}

extension EvaluateFeatureOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details
        case reason
        case value
        case variation
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .variation)
        variation = variationDecoded
        let valueDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.VariableValue.self, forKey: .value)
        value = valueDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .details)
        details = detailsDecoded
    }
}

extension EvidentlyClientTypes.EvaluationRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId
        case evaluationContext
        case feature
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let evaluationContext = evaluationContext {
            try encodeContainer.encode(evaluationContext, forKey: .evaluationContext)
        }
        if let feature = feature {
            try encodeContainer.encode(feature, forKey: .feature)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .feature)
        feature = featureDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let evaluationContextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationContext)
        evaluationContext = evaluationContextDecoded
    }
}

extension EvidentlyClientTypes {
    /// This structure assigns a feature variation to one user session.
    public struct EvaluationRequest: Swift.Equatable {
        /// An internal ID that represents a unique user session of the application. This entityID is checked against any override rules assigned for this feature.
        /// This member is required.
        public var entityId: Swift.String?
        /// A JSON block of attributes that you can optionally pass in. This JSON block is included in the evaluation events sent to Evidently from the user session.
        public var evaluationContext: Swift.String?
        /// The name of the feature being evaluated.
        /// This member is required.
        public var feature: Swift.String?

        public init (
            entityId: Swift.String? = nil,
            evaluationContext: Swift.String? = nil,
            feature: Swift.String? = nil
        )
        {
            self.entityId = entityId
            self.evaluationContext = evaluationContext
            self.feature = feature
        }
    }

}

extension EvidentlyClientTypes.EvaluationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details
        case entityId
        case feature
        case project
        case reason
        case value
        case variation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let details = details {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let feature = feature {
            try encodeContainer.encode(feature, forKey: .feature)
        }
        if let project = project {
            try encodeContainer.encode(project, forKey: .project)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
        if let variation = variation {
            try encodeContainer.encode(variation, forKey: .variation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .project)
        project = projectDecoded
        let featureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .feature)
        feature = featureDecoded
        let variationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .variation)
        variation = variationDecoded
        let valueDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.VariableValue.self, forKey: .value)
        value = valueDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .details)
        details = detailsDecoded
    }
}

extension EvidentlyClientTypes {
    /// This structure displays the results of one feature evaluation assignment to one user session.
    public struct EvaluationResult: Swift.Equatable {
        /// If this user was assigned to a launch or experiment, this field lists the launch or experiment name.
        public var details: Swift.String?
        /// An internal ID that represents a unique user session of the application.
        /// This member is required.
        public var entityId: Swift.String?
        /// The name of the feature being evaluated.
        /// This member is required.
        public var feature: Swift.String?
        /// The name or ARN of the project that contains the feature being evaluated.
        public var project: Swift.String?
        /// Specifies the reason that the user session was assigned this variation. Possible values include DEFAULT, meaning the user was served the default variation; LAUNCH_RULE_MATCH, if the user session was enrolled in a launch; or EXPERIMENT_RULE_MATCH, if the user session was enrolled in an experiment.
        public var reason: Swift.String?
        /// The value assigned to this variation to differentiate it from the other variations of this feature.
        public var value: EvidentlyClientTypes.VariableValue?
        /// The name of the variation that was served to the user session.
        public var variation: Swift.String?

        public init (
            details: Swift.String? = nil,
            entityId: Swift.String? = nil,
            feature: Swift.String? = nil,
            project: Swift.String? = nil,
            reason: Swift.String? = nil,
            value: EvidentlyClientTypes.VariableValue? = nil,
            variation: Swift.String? = nil
        )
        {
            self.details = details
            self.entityId = entityId
            self.feature = feature
            self.project = project
            self.reason = reason
            self.value = value
            self.variation = variation
        }
    }

}

extension EvidentlyClientTypes.EvaluationRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension EvidentlyClientTypes {
    /// A structure that contains the information about an evaluation rule for this feature, if it is used in a launch or experiment.
    public struct EvaluationRule: Swift.Equatable {
        /// The name of the experiment or launch.
        public var name: Swift.String?
        /// This value is aws.evidently.splits if this is an evaluation rule for a launch, and it is aws.evidently.onlineab if this is an evaluation rule for an experiment.
        /// This member is required.
        public var type: Swift.String?

        public init (
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }

}

extension EvidentlyClientTypes.Event: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data
        case timestamp
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let typeDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.EventType.self, forKey: .type)
        type = typeDecoded
        let dataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .data)
        data = dataDecoded
    }
}

extension EvidentlyClientTypes {
    /// A structure that contains the information about one evaluation event or custom event sent to Evidently. This is a JSON payload. If this event specifies a pre-defined event type, the payload must follow the defined event schema.
    public struct Event: Swift.Equatable {
        /// The event data.
        /// This member is required.
        public var data: Swift.String?
        /// The timestamp of the event.
        /// This member is required.
        public var timestamp: ClientRuntime.Date?
        /// aws.evidently.evaluation specifies an evaluation event, which determines which feature variation that a user sees. aws.evidently.custom specifies a custom event, which generates metrics from user actions such as clicks and checkouts.
        /// This member is required.
        public var type: EvidentlyClientTypes.EventType?

        public init (
            data: Swift.String? = nil,
            timestamp: ClientRuntime.Date? = nil,
            type: EvidentlyClientTypes.EventType? = nil
        )
        {
            self.data = data
            self.timestamp = timestamp
            self.type = type
        }
    }

}

extension EvidentlyClientTypes {
    public enum EventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case evaluation
        case sdkUnknown(Swift.String)

        public static var allCases: [EventType] {
            return [
                .custom,
                .evaluation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "aws.evidently.custom"
            case .evaluation: return "aws.evidently.evaluation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventType(rawValue: rawValue) ?? EventType.sdkUnknown(rawValue)
        }
    }
}

extension EvidentlyClientTypes.Experiment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case description
        case execution
        case lastUpdatedTime
        case metricGoals
        case name
        case onlineAbDefinition
        case project
        case randomizationSalt
        case samplingRate
        case schedule
        case status
        case statusReason
        case tags
        case treatments
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let execution = execution {
            try encodeContainer.encode(execution, forKey: .execution)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let metricGoals = metricGoals {
            var metricGoalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricGoals)
            for metricgoalslist0 in metricGoals {
                try metricGoalsContainer.encode(metricgoalslist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let onlineAbDefinition = onlineAbDefinition {
            try encodeContainer.encode(onlineAbDefinition, forKey: .onlineAbDefinition)
        }
        if let project = project {
            try encodeContainer.encode(project, forKey: .project)
        }
        if let randomizationSalt = randomizationSalt {
            try encodeContainer.encode(randomizationSalt, forKey: .randomizationSalt)
        }
        if samplingRate != 0 {
            try encodeContainer.encode(samplingRate, forKey: .samplingRate)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let treatments = treatments {
            var treatmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .treatments)
            for treatmentlist0 in treatments {
                try treatmentsContainer.encode(treatmentlist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let projectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .project)
        project = projectDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ExperimentStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ExperimentSchedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let executionDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ExperimentExecution.self, forKey: .execution)
        execution = executionDecoded
        let treatmentsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.Treatment?].self, forKey: .treatments)
        var treatmentsDecoded0:[EvidentlyClientTypes.Treatment]? = nil
        if let treatmentsContainer = treatmentsContainer {
            treatmentsDecoded0 = [EvidentlyClientTypes.Treatment]()
            for structure0 in treatmentsContainer {
                if let structure0 = structure0 {
                    treatmentsDecoded0?.append(structure0)
                }
            }
        }
        treatments = treatmentsDecoded0
        let metricGoalsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.MetricGoal?].self, forKey: .metricGoals)
        var metricGoalsDecoded0:[EvidentlyClientTypes.MetricGoal]? = nil
        if let metricGoalsContainer = metricGoalsContainer {
            metricGoalsDecoded0 = [EvidentlyClientTypes.MetricGoal]()
            for structure0 in metricGoalsContainer {
                if let structure0 = structure0 {
                    metricGoalsDecoded0?.append(structure0)
                }
            }
        }
        metricGoals = metricGoalsDecoded0
        let randomizationSaltDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .randomizationSalt)
        randomizationSalt = randomizationSaltDecoded
        let samplingRateDecoded = try containerValues.decode(Swift.Int.self, forKey: .samplingRate)
        samplingRate = samplingRateDecoded
        let typeDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ExperimentType.self, forKey: .type)
        type = typeDecoded
        let onlineAbDefinitionDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.OnlineAbDefinition.self, forKey: .onlineAbDefinition)
        onlineAbDefinition = onlineAbDefinitionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension EvidentlyClientTypes {
    /// A structure containing the configuration details of an experiment.
    public struct Experiment: Swift.Equatable {
        /// The ARN of the experiment.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the experiment is first created.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// A description of the experiment.
        public var description: Swift.String?
        /// A structure that contains the date and time that the experiment started and ended.
        public var execution: EvidentlyClientTypes.ExperimentExecution?
        /// The date and time that the experiment was most recently updated.
        /// This member is required.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// An array of structures that defines the metrics used for the experiment, and whether a higher or lower value for each metric is the goal.
        public var metricGoals: [EvidentlyClientTypes.MetricGoal]?
        /// The name of the experiment.
        /// This member is required.
        public var name: Swift.String?
        /// A structure that contains the configuration of which variation to use as the "control" version. The "control" version is used for comparison with other variations. This structure also specifies how much experiment traffic is allocated to each variation.
        public var onlineAbDefinition: EvidentlyClientTypes.OnlineAbDefinition?
        /// The name or ARN of the project that contains this experiment.
        public var project: Swift.String?
        /// This value is used when Evidently assigns a particular user session to the experiment. It helps create a randomization ID to determine which variation the user session is served. This randomization ID is a combination of the entity ID and randomizationSalt.
        public var randomizationSalt: Swift.String?
        /// In thousandths of a percent, the amount of the available audience that is allocated to this experiment. The available audience is the total audience minus the audience that you have allocated to overrides or current launches of this feature. This is represented in thousandths of a percent, so a value of 10,000 is 10% of the available audience.
        public var samplingRate: Swift.Int
        /// A structure that contains the time and date that Evidently completed the analysis of the experiment.
        public var schedule: EvidentlyClientTypes.ExperimentSchedule?
        /// The current state of the experiment.
        /// This member is required.
        public var status: EvidentlyClientTypes.ExperimentStatus?
        /// If the experiment was stopped, this is the string that was entered by the person who stopped the experiment, to explain why it was stopped.
        public var statusReason: Swift.String?
        /// The list of tag keys and values associated with this experiment.
        public var tags: [Swift.String:Swift.String]?
        /// An array of structures that describe the configuration of each feature variation used in the experiment.
        public var treatments: [EvidentlyClientTypes.Treatment]?
        /// The type of this experiment. Currently, this value must be aws.experiment.onlineab.
        /// This member is required.
        public var type: EvidentlyClientTypes.ExperimentType?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            execution: EvidentlyClientTypes.ExperimentExecution? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            metricGoals: [EvidentlyClientTypes.MetricGoal]? = nil,
            name: Swift.String? = nil,
            onlineAbDefinition: EvidentlyClientTypes.OnlineAbDefinition? = nil,
            project: Swift.String? = nil,
            randomizationSalt: Swift.String? = nil,
            samplingRate: Swift.Int = 0,
            schedule: EvidentlyClientTypes.ExperimentSchedule? = nil,
            status: EvidentlyClientTypes.ExperimentStatus? = nil,
            statusReason: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            treatments: [EvidentlyClientTypes.Treatment]? = nil,
            type: EvidentlyClientTypes.ExperimentType? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.execution = execution
            self.lastUpdatedTime = lastUpdatedTime
            self.metricGoals = metricGoals
            self.name = name
            self.onlineAbDefinition = onlineAbDefinition
            self.project = project
            self.randomizationSalt = randomizationSalt
            self.samplingRate = samplingRate
            self.schedule = schedule
            self.status = status
            self.statusReason = statusReason
            self.tags = tags
            self.treatments = treatments
            self.type = type
        }
    }

}

extension EvidentlyClientTypes {
    public enum ExperimentBaseStat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mean
        case sdkUnknown(Swift.String)

        public static var allCases: [ExperimentBaseStat] {
            return [
                .mean,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mean: return "Mean"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExperimentBaseStat(rawValue: rawValue) ?? ExperimentBaseStat.sdkUnknown(rawValue)
        }
    }
}

extension EvidentlyClientTypes.ExperimentExecution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endedTime
        case startedTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endedTime = endedTime {
            try encodeContainer.encode(endedTime.timeIntervalSince1970, forKey: .endedTime)
        }
        if let startedTime = startedTime {
            try encodeContainer.encode(startedTime.timeIntervalSince1970, forKey: .startedTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startedTime)
        startedTime = startedTimeDecoded
        let endedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endedTime)
        endedTime = endedTimeDecoded
    }
}

extension EvidentlyClientTypes {
    /// This structure contains the date and time that the experiment started and ended.
    public struct ExperimentExecution: Swift.Equatable {
        /// The date and time that the experiment ended.
        public var endedTime: ClientRuntime.Date?
        /// The date and time that the experiment started.
        public var startedTime: ClientRuntime.Date?

        public init (
            endedTime: ClientRuntime.Date? = nil,
            startedTime: ClientRuntime.Date? = nil
        )
        {
            self.endedTime = endedTime
            self.startedTime = startedTime
        }
    }

}

extension EvidentlyClientTypes.ExperimentReport: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case metricName
        case reportName
        case treatmentName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let reportName = reportName {
            try encodeContainer.encode(reportName.rawValue, forKey: .reportName)
        }
        if let treatmentName = treatmentName {
            try encodeContainer.encode(treatmentName, forKey: .treatmentName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let treatmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .treatmentName)
        treatmentName = treatmentNameDecoded
        let reportNameDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ExperimentReportName.self, forKey: .reportName)
        reportName = reportNameDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
    }
}

extension EvidentlyClientTypes {
    /// A structure that contains results of an experiment.
    public struct ExperimentReport: Swift.Equatable {
        /// The content of the report.
        public var content: Swift.String?
        /// The name of the metric that is analyzed in this experiment report.
        public var metricName: Swift.String?
        /// The type of analysis used for this report.
        public var reportName: EvidentlyClientTypes.ExperimentReportName?
        /// The name of the variation that this report pertains to.
        public var treatmentName: Swift.String?

        public init (
            content: Swift.String? = nil,
            metricName: Swift.String? = nil,
            reportName: EvidentlyClientTypes.ExperimentReportName? = nil,
            treatmentName: Swift.String? = nil
        )
        {
            self.content = content
            self.metricName = metricName
            self.reportName = reportName
            self.treatmentName = treatmentName
        }
    }

}

extension EvidentlyClientTypes {
    public enum ExperimentReportName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bayesianInference
        case sdkUnknown(Swift.String)

        public static var allCases: [ExperimentReportName] {
            return [
                .bayesianInference,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bayesianInference: return "BayesianInference"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExperimentReportName(rawValue: rawValue) ?? ExperimentReportName.sdkUnknown(rawValue)
        }
    }
}

extension EvidentlyClientTypes {
    public enum ExperimentResultRequestType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case baseStat
        case confidenceInterval
        case pValue
        case treatmentEffect
        case sdkUnknown(Swift.String)

        public static var allCases: [ExperimentResultRequestType] {
            return [
                .baseStat,
                .confidenceInterval,
                .pValue,
                .treatmentEffect,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .baseStat: return "BaseStat"
            case .confidenceInterval: return "ConfidenceInterval"
            case .pValue: return "PValue"
            case .treatmentEffect: return "TreatmentEffect"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExperimentResultRequestType(rawValue: rawValue) ?? ExperimentResultRequestType.sdkUnknown(rawValue)
        }
    }
}

extension EvidentlyClientTypes {
    public enum ExperimentResultResponseType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case confidenceIntervalLowerbound
        case confidenceIntervalUpperbound
        case mean
        case pValue
        case treatmentEffect
        case sdkUnknown(Swift.String)

        public static var allCases: [ExperimentResultResponseType] {
            return [
                .confidenceIntervalLowerbound,
                .confidenceIntervalUpperbound,
                .mean,
                .pValue,
                .treatmentEffect,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .confidenceIntervalLowerbound: return "ConfidenceIntervalLowerBound"
            case .confidenceIntervalUpperbound: return "ConfidenceIntervalUpperBound"
            case .mean: return "Mean"
            case .pValue: return "PValue"
            case .treatmentEffect: return "TreatmentEffect"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExperimentResultResponseType(rawValue: rawValue) ?? ExperimentResultResponseType.sdkUnknown(rawValue)
        }
    }
}

extension EvidentlyClientTypes.ExperimentResultsData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricName
        case resultStat
        case treatmentName
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let resultStat = resultStat {
            try encodeContainer.encode(resultStat.rawValue, forKey: .resultStat)
        }
        if let treatmentName = treatmentName {
            try encodeContainer.encode(treatmentName, forKey: .treatmentName)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for doublevaluelist0 in values {
                try valuesContainer.encode(doublevaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let treatmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .treatmentName)
        treatmentName = treatmentNameDecoded
        let resultStatDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ExperimentResultResponseType.self, forKey: .resultStat)
        resultStat = resultStatDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .values)
        var valuesDecoded0:[Swift.Double]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.Double]()
            for double0 in valuesContainer {
                if let double0 = double0 {
                    valuesDecoded0?.append(double0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension EvidentlyClientTypes {
    /// A structure that contains experiment results for one metric that is monitored in the experiment.
    public struct ExperimentResultsData: Swift.Equatable {
        /// The name of the metric.
        public var metricName: Swift.String?
        /// The experiment statistic that these results pertain to.
        public var resultStat: EvidentlyClientTypes.ExperimentResultResponseType?
        /// The treatment, or variation, that returned the values in this structure.
        public var treatmentName: Swift.String?
        /// The values for the metricName that were recorded in the experiment.
        public var values: [Swift.Double]?

        public init (
            metricName: Swift.String? = nil,
            resultStat: EvidentlyClientTypes.ExperimentResultResponseType? = nil,
            treatmentName: Swift.String? = nil,
            values: [Swift.Double]? = nil
        )
        {
            self.metricName = metricName
            self.resultStat = resultStat
            self.treatmentName = treatmentName
            self.values = values
        }
    }

}

extension EvidentlyClientTypes.ExperimentSchedule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisCompleteTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analysisCompleteTime = analysisCompleteTime {
            try encodeContainer.encode(analysisCompleteTime.timeIntervalSince1970, forKey: .analysisCompleteTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisCompleteTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .analysisCompleteTime)
        analysisCompleteTime = analysisCompleteTimeDecoded
    }
}

extension EvidentlyClientTypes {
    /// This structure contains the time and date that Evidently completed the analysis of the experiment.
    public struct ExperimentSchedule: Swift.Equatable {
        /// The time and date that Evidently completed the analysis of the experiment.
        public var analysisCompleteTime: ClientRuntime.Date?

        public init (
            analysisCompleteTime: ClientRuntime.Date? = nil
        )
        {
            self.analysisCompleteTime = analysisCompleteTime
        }
    }

}

extension EvidentlyClientTypes {
    public enum ExperimentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case completed
        case created
        case running
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ExperimentStatus] {
            return [
                .cancelled,
                .completed,
                .created,
                .running,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .created: return "CREATED"
            case .running: return "RUNNING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExperimentStatus(rawValue: rawValue) ?? ExperimentStatus.sdkUnknown(rawValue)
        }
    }
}

extension EvidentlyClientTypes {
    public enum ExperimentStopDesiredState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case completed
        case sdkUnknown(Swift.String)

        public static var allCases: [ExperimentStopDesiredState] {
            return [
                .cancelled,
                .completed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExperimentStopDesiredState(rawValue: rawValue) ?? ExperimentStopDesiredState.sdkUnknown(rawValue)
        }
    }
}

extension EvidentlyClientTypes {
    public enum ExperimentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case onlineAbExperiment
        case sdkUnknown(Swift.String)

        public static var allCases: [ExperimentType] {
            return [
                .onlineAbExperiment,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .onlineAbExperiment: return "aws.evidently.onlineab"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExperimentType(rawValue: rawValue) ?? ExperimentType.sdkUnknown(rawValue)
        }
    }
}

extension EvidentlyClientTypes.Feature: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case defaultVariation
        case description
        case entityOverrides
        case evaluationRules
        case evaluationStrategy
        case lastUpdatedTime
        case name
        case project
        case status
        case tags
        case valueType
        case variations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let defaultVariation = defaultVariation {
            try encodeContainer.encode(defaultVariation, forKey: .defaultVariation)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entityOverrides = entityOverrides {
            var entityOverridesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .entityOverrides)
            for (dictKey0, entityoverridemap0) in entityOverrides {
                try entityOverridesContainer.encode(entityoverridemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let evaluationRules = evaluationRules {
            var evaluationRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .evaluationRules)
            for evaluationruleslist0 in evaluationRules {
                try evaluationRulesContainer.encode(evaluationruleslist0)
            }
        }
        if let evaluationStrategy = evaluationStrategy {
            try encodeContainer.encode(evaluationStrategy.rawValue, forKey: .evaluationStrategy)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let project = project {
            try encodeContainer.encode(project, forKey: .project)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let valueType = valueType {
            try encodeContainer.encode(valueType.rawValue, forKey: .valueType)
        }
        if let variations = variations {
            var variationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variations)
            for variationslist0 in variations {
                try variationsContainer.encode(variationslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let projectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .project)
        project = projectDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.FeatureStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let evaluationStrategyDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.FeatureEvaluationStrategy.self, forKey: .evaluationStrategy)
        evaluationStrategy = evaluationStrategyDecoded
        let valueTypeDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.VariationValueType.self, forKey: .valueType)
        valueType = valueTypeDecoded
        let variationsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.Variation?].self, forKey: .variations)
        var variationsDecoded0:[EvidentlyClientTypes.Variation]? = nil
        if let variationsContainer = variationsContainer {
            variationsDecoded0 = [EvidentlyClientTypes.Variation]()
            for structure0 in variationsContainer {
                if let structure0 = structure0 {
                    variationsDecoded0?.append(structure0)
                }
            }
        }
        variations = variationsDecoded0
        let defaultVariationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultVariation)
        defaultVariation = defaultVariationDecoded
        let evaluationRulesContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.EvaluationRule?].self, forKey: .evaluationRules)
        var evaluationRulesDecoded0:[EvidentlyClientTypes.EvaluationRule]? = nil
        if let evaluationRulesContainer = evaluationRulesContainer {
            evaluationRulesDecoded0 = [EvidentlyClientTypes.EvaluationRule]()
            for structure0 in evaluationRulesContainer {
                if let structure0 = structure0 {
                    evaluationRulesDecoded0?.append(structure0)
                }
            }
        }
        evaluationRules = evaluationRulesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let entityOverridesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .entityOverrides)
        var entityOverridesDecoded0: [Swift.String:Swift.String]? = nil
        if let entityOverridesContainer = entityOverridesContainer {
            entityOverridesDecoded0 = [Swift.String:Swift.String]()
            for (key0, variationname0) in entityOverridesContainer {
                if let variationname0 = variationname0 {
                    entityOverridesDecoded0?[key0] = variationname0
                }
            }
        }
        entityOverrides = entityOverridesDecoded0
    }
}

extension EvidentlyClientTypes {
    /// This structure contains information about one Evidently feature in your account.
    public struct Feature: Swift.Equatable {
        /// The ARN of the feature.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the feature is created.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The name of the variation that is used as the default variation. The default variation is served to users who are not allocated to any ongoing launches or experiments of this feature. This variation must also be listed in the variations structure. If you omit defaultVariation, the first variation listed in the variations structure is used as the default variation.
        public var defaultVariation: Swift.String?
        /// The description of the feature.
        public var description: Swift.String?
        /// A set of key-value pairs that specify users who should always be served a specific variation of a feature. Each key specifies a user using their user ID, account ID, or some other identifier. The value specifies the name of the variation that the user is to be served. For the override to be successful, the value of the key must match the entityId used in the [EvaluateFeature](https://docs.aws.amazon.com/cloudwatchevidently/latest/APIReference/API_EvaluateFeature.html) operation.
        public var entityOverrides: [Swift.String:Swift.String]?
        /// An array of structures that define the evaluation rules for the feature.
        public var evaluationRules: [EvidentlyClientTypes.EvaluationRule]?
        /// If this value is ALL_RULES, the traffic allocation specified by any ongoing launches or experiments is being used. If this is DEFAULT_VARIATION, the default variation is being served to all users.
        /// This member is required.
        public var evaluationStrategy: EvidentlyClientTypes.FeatureEvaluationStrategy?
        /// The date and time that the feature was most recently updated.
        /// This member is required.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of the feature.
        /// This member is required.
        public var name: Swift.String?
        /// The name or ARN of the project that contains the feature.
        public var project: Swift.String?
        /// The current state of the feature.
        /// This member is required.
        public var status: EvidentlyClientTypes.FeatureStatus?
        /// The list of tag keys and values associated with this feature.
        public var tags: [Swift.String:Swift.String]?
        /// Defines the type of value used to define the different feature variations. For more information, see [Variation types](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-Evidently-variationtypes.html)
        /// This member is required.
        public var valueType: EvidentlyClientTypes.VariationValueType?
        /// An array of structures that contain the configuration of the feature's different variations.
        /// This member is required.
        public var variations: [EvidentlyClientTypes.Variation]?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            defaultVariation: Swift.String? = nil,
            description: Swift.String? = nil,
            entityOverrides: [Swift.String:Swift.String]? = nil,
            evaluationRules: [EvidentlyClientTypes.EvaluationRule]? = nil,
            evaluationStrategy: EvidentlyClientTypes.FeatureEvaluationStrategy? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            project: Swift.String? = nil,
            status: EvidentlyClientTypes.FeatureStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            valueType: EvidentlyClientTypes.VariationValueType? = nil,
            variations: [EvidentlyClientTypes.Variation]? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.defaultVariation = defaultVariation
            self.description = description
            self.entityOverrides = entityOverrides
            self.evaluationRules = evaluationRules
            self.evaluationStrategy = evaluationStrategy
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.project = project
            self.status = status
            self.tags = tags
            self.valueType = valueType
            self.variations = variations
        }
    }

}

extension EvidentlyClientTypes {
    public enum FeatureEvaluationStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allRules
        case defaultVariation
        case sdkUnknown(Swift.String)

        public static var allCases: [FeatureEvaluationStrategy] {
            return [
                .allRules,
                .defaultVariation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allRules: return "ALL_RULES"
            case .defaultVariation: return "DEFAULT_VARIATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FeatureEvaluationStrategy(rawValue: rawValue) ?? FeatureEvaluationStrategy.sdkUnknown(rawValue)
        }
    }
}

extension EvidentlyClientTypes {
    public enum FeatureStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [FeatureStatus] {
            return [
                .available,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FeatureStatus(rawValue: rawValue) ?? FeatureStatus.sdkUnknown(rawValue)
        }
    }
}

extension EvidentlyClientTypes.FeatureSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case defaultVariation
        case evaluationRules
        case evaluationStrategy
        case lastUpdatedTime
        case name
        case project
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let defaultVariation = defaultVariation {
            try encodeContainer.encode(defaultVariation, forKey: .defaultVariation)
        }
        if let evaluationRules = evaluationRules {
            var evaluationRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .evaluationRules)
            for evaluationruleslist0 in evaluationRules {
                try evaluationRulesContainer.encode(evaluationruleslist0)
            }
        }
        if let evaluationStrategy = evaluationStrategy {
            try encodeContainer.encode(evaluationStrategy.rawValue, forKey: .evaluationStrategy)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let project = project {
            try encodeContainer.encode(project, forKey: .project)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let projectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .project)
        project = projectDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.FeatureStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let evaluationStrategyDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.FeatureEvaluationStrategy.self, forKey: .evaluationStrategy)
        evaluationStrategy = evaluationStrategyDecoded
        let evaluationRulesContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.EvaluationRule?].self, forKey: .evaluationRules)
        var evaluationRulesDecoded0:[EvidentlyClientTypes.EvaluationRule]? = nil
        if let evaluationRulesContainer = evaluationRulesContainer {
            evaluationRulesDecoded0 = [EvidentlyClientTypes.EvaluationRule]()
            for structure0 in evaluationRulesContainer {
                if let structure0 = structure0 {
                    evaluationRulesDecoded0?.append(structure0)
                }
            }
        }
        evaluationRules = evaluationRulesDecoded0
        let defaultVariationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultVariation)
        defaultVariation = defaultVariationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension EvidentlyClientTypes {
    /// This structure contains information about one Evidently feature in your account.
    public struct FeatureSummary: Swift.Equatable {
        /// The ARN of the feature.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the feature is created.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The name of the variation that is used as the default variation. The default variation is served to users who are not allocated to any ongoing launches or experiments of this feature.
        public var defaultVariation: Swift.String?
        /// An array of structures that define
        public var evaluationRules: [EvidentlyClientTypes.EvaluationRule]?
        /// If this value is ALL_RULES, the traffic allocation specified by any ongoing launches or experiments is being used. If this is DEFAULT_VARIATION, the default variation is being served to all users.
        /// This member is required.
        public var evaluationStrategy: EvidentlyClientTypes.FeatureEvaluationStrategy?
        /// The date and time that the feature was most recently updated.
        /// This member is required.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of the feature.
        /// This member is required.
        public var name: Swift.String?
        /// The name or ARN of the project that contains the feature.
        public var project: Swift.String?
        /// The current state of the feature.
        /// This member is required.
        public var status: EvidentlyClientTypes.FeatureStatus?
        /// The list of tag keys and values associated with this feature.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            defaultVariation: Swift.String? = nil,
            evaluationRules: [EvidentlyClientTypes.EvaluationRule]? = nil,
            evaluationStrategy: EvidentlyClientTypes.FeatureEvaluationStrategy? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            project: Swift.String? = nil,
            status: EvidentlyClientTypes.FeatureStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.defaultVariation = defaultVariation
            self.evaluationRules = evaluationRules
            self.evaluationStrategy = evaluationStrategy
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.project = project
            self.status = status
            self.tags = tags
        }
    }

}

extension GetExperimentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        guard let experiment = experiment else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/experiments/\(experiment.urlPercentEncoding())"
    }
}

public struct GetExperimentInput: Swift.Equatable {
    /// The name of the experiment that you want to see the details of.
    /// This member is required.
    public var experiment: Swift.String?
    /// The name or ARN of the project that contains the experiment.
    /// This member is required.
    public var project: Swift.String?

    public init (
        experiment: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.experiment = experiment
        self.project = project
    }
}

struct GetExperimentInputBody: Swift.Equatable {
}

extension GetExperimentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetExperimentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetExperimentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetExperimentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetExperimentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetExperimentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.experiment = output.experiment
        } else {
            self.experiment = nil
        }
    }
}

public struct GetExperimentOutputResponse: Swift.Equatable {
    /// A structure containing the configuration details of the experiment.
    public var experiment: EvidentlyClientTypes.Experiment?

    public init (
        experiment: EvidentlyClientTypes.Experiment? = nil
    )
    {
        self.experiment = experiment
    }
}

struct GetExperimentOutputResponseBody: Swift.Equatable {
    let experiment: EvidentlyClientTypes.Experiment?
}

extension GetExperimentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experiment
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.Experiment.self, forKey: .experiment)
        experiment = experimentDecoded
    }
}

extension GetExperimentResultsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseStat
        case endTime
        case metricNames
        case period
        case reportNames
        case resultStats
        case startTime
        case treatmentNames
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseStat = baseStat {
            try encodeContainer.encode(baseStat.rawValue, forKey: .baseStat)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let metricNames = metricNames {
            var metricNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricNames)
            for metricnamelist0 in metricNames {
                try metricNamesContainer.encode(metricnamelist0)
            }
        }
        if period != 0 {
            try encodeContainer.encode(period, forKey: .period)
        }
        if let reportNames = reportNames {
            var reportNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reportNames)
            for experimentreportnamelist0 in reportNames {
                try reportNamesContainer.encode(experimentreportnamelist0.rawValue)
            }
        }
        if let resultStats = resultStats {
            var resultStatsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resultStats)
            for experimentresultrequesttypelist0 in resultStats {
                try resultStatsContainer.encode(experimentresultrequesttypelist0.rawValue)
            }
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let treatmentNames = treatmentNames {
            var treatmentNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .treatmentNames)
            for treatmentnamelist0 in treatmentNames {
                try treatmentNamesContainer.encode(treatmentnamelist0)
            }
        }
    }
}

extension GetExperimentResultsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        guard let experiment = experiment else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/experiments/\(experiment.urlPercentEncoding())/results"
    }
}

public struct GetExperimentResultsInput: Swift.Equatable {
    /// The statistic used to calculate experiment results. Currently the only valid value is mean, which uses the mean of the collected values as the statistic.
    public var baseStat: EvidentlyClientTypes.ExperimentBaseStat?
    /// The date and time that the experiment ended, if it is completed.
    public var endTime: ClientRuntime.Date?
    /// The name of the experiment to retrieve the results of.
    /// This member is required.
    public var experiment: Swift.String?
    /// The names of the experiment metrics that you want to see the results of.
    /// This member is required.
    public var metricNames: [Swift.String]?
    /// In seconds, the amount of time to aggregate results together.
    public var period: Swift.Int
    /// The name or ARN of the project that contains the experiment that you want to see the results of.
    /// This member is required.
    public var project: Swift.String?
    /// The names of the report types that you want to see. Currently, BayesianInference is the only valid value.
    public var reportNames: [EvidentlyClientTypes.ExperimentReportName]?
    /// The statistics that you want to see in the returned results.
    ///
    /// * PValue specifies to use p-values for the results. A p-value is used in hypothesis testing to measure how often you are willing to make a mistake in rejecting the null hypothesis. A general practice is to reject the null hypothesis and declare that the results are statistically significant when the p-value is less than 0.05.
    ///
    /// * ConfidenceInterval specifies a confidence interval for the results. The confidence interval represents the range of values for the chosen metric that is likely to contain the true difference between the baseStat of a variation and the baseline. Evidently returns the 95% confidence interval.
    ///
    /// * TreatmentEffect is the difference in the statistic specified by the baseStat parameter between each variation and the default variation.
    ///
    /// * BaseStat returns the statistical values collected for the metric for each variation. The statistic uses the same statistic specified in the baseStat parameter. Therefore, if baseStat is mean, this returns the mean of the values collected for each variation.
    public var resultStats: [EvidentlyClientTypes.ExperimentResultRequestType]?
    /// The date and time that the experiment started.
    public var startTime: ClientRuntime.Date?
    /// The names of the experiment treatments that you want to see the results for.
    /// This member is required.
    public var treatmentNames: [Swift.String]?

    public init (
        baseStat: EvidentlyClientTypes.ExperimentBaseStat? = nil,
        endTime: ClientRuntime.Date? = nil,
        experiment: Swift.String? = nil,
        metricNames: [Swift.String]? = nil,
        period: Swift.Int = 0,
        project: Swift.String? = nil,
        reportNames: [EvidentlyClientTypes.ExperimentReportName]? = nil,
        resultStats: [EvidentlyClientTypes.ExperimentResultRequestType]? = nil,
        startTime: ClientRuntime.Date? = nil,
        treatmentNames: [Swift.String]? = nil
    )
    {
        self.baseStat = baseStat
        self.endTime = endTime
        self.experiment = experiment
        self.metricNames = metricNames
        self.period = period
        self.project = project
        self.reportNames = reportNames
        self.resultStats = resultStats
        self.startTime = startTime
        self.treatmentNames = treatmentNames
    }
}

struct GetExperimentResultsInputBody: Swift.Equatable {
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let metricNames: [Swift.String]?
    let treatmentNames: [Swift.String]?
    let baseStat: EvidentlyClientTypes.ExperimentBaseStat?
    let resultStats: [EvidentlyClientTypes.ExperimentResultRequestType]?
    let reportNames: [EvidentlyClientTypes.ExperimentReportName]?
    let period: Swift.Int
}

extension GetExperimentResultsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseStat
        case endTime
        case metricNames
        case period
        case reportNames
        case resultStats
        case startTime
        case treatmentNames
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let metricNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .metricNames)
        var metricNamesDecoded0:[Swift.String]? = nil
        if let metricNamesContainer = metricNamesContainer {
            metricNamesDecoded0 = [Swift.String]()
            for string0 in metricNamesContainer {
                if let string0 = string0 {
                    metricNamesDecoded0?.append(string0)
                }
            }
        }
        metricNames = metricNamesDecoded0
        let treatmentNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .treatmentNames)
        var treatmentNamesDecoded0:[Swift.String]? = nil
        if let treatmentNamesContainer = treatmentNamesContainer {
            treatmentNamesDecoded0 = [Swift.String]()
            for string0 in treatmentNamesContainer {
                if let string0 = string0 {
                    treatmentNamesDecoded0?.append(string0)
                }
            }
        }
        treatmentNames = treatmentNamesDecoded0
        let baseStatDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ExperimentBaseStat.self, forKey: .baseStat)
        baseStat = baseStatDecoded
        let resultStatsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.ExperimentResultRequestType?].self, forKey: .resultStats)
        var resultStatsDecoded0:[EvidentlyClientTypes.ExperimentResultRequestType]? = nil
        if let resultStatsContainer = resultStatsContainer {
            resultStatsDecoded0 = [EvidentlyClientTypes.ExperimentResultRequestType]()
            for string0 in resultStatsContainer {
                if let string0 = string0 {
                    resultStatsDecoded0?.append(string0)
                }
            }
        }
        resultStats = resultStatsDecoded0
        let reportNamesContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.ExperimentReportName?].self, forKey: .reportNames)
        var reportNamesDecoded0:[EvidentlyClientTypes.ExperimentReportName]? = nil
        if let reportNamesContainer = reportNamesContainer {
            reportNamesDecoded0 = [EvidentlyClientTypes.ExperimentReportName]()
            for string0 in reportNamesContainer {
                if let string0 = string0 {
                    reportNamesDecoded0?.append(string0)
                }
            }
        }
        reportNames = reportNamesDecoded0
        let periodDecoded = try containerValues.decode(Swift.Int.self, forKey: .period)
        period = periodDecoded
    }
}

extension GetExperimentResultsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetExperimentResultsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetExperimentResultsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetExperimentResultsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetExperimentResultsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reports = output.reports
            self.resultsData = output.resultsData
            self.timestamps = output.timestamps
        } else {
            self.reports = nil
            self.resultsData = nil
            self.timestamps = nil
        }
    }
}

public struct GetExperimentResultsOutputResponse: Swift.Equatable {
    /// An array of structures that include the reports that you requested.
    public var reports: [EvidentlyClientTypes.ExperimentReport]?
    /// An array of structures that include experiment results including metric names and values.
    public var resultsData: [EvidentlyClientTypes.ExperimentResultsData]?
    /// The timestamps of each result returned.
    public var timestamps: [ClientRuntime.Date]?

    public init (
        reports: [EvidentlyClientTypes.ExperimentReport]? = nil,
        resultsData: [EvidentlyClientTypes.ExperimentResultsData]? = nil,
        timestamps: [ClientRuntime.Date]? = nil
    )
    {
        self.reports = reports
        self.resultsData = resultsData
        self.timestamps = timestamps
    }
}

struct GetExperimentResultsOutputResponseBody: Swift.Equatable {
    let resultsData: [EvidentlyClientTypes.ExperimentResultsData]?
    let reports: [EvidentlyClientTypes.ExperimentReport]?
    let timestamps: [ClientRuntime.Date]?
}

extension GetExperimentResultsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reports
        case resultsData
        case timestamps
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsDataContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.ExperimentResultsData?].self, forKey: .resultsData)
        var resultsDataDecoded0:[EvidentlyClientTypes.ExperimentResultsData]? = nil
        if let resultsDataContainer = resultsDataContainer {
            resultsDataDecoded0 = [EvidentlyClientTypes.ExperimentResultsData]()
            for structure0 in resultsDataContainer {
                if let structure0 = structure0 {
                    resultsDataDecoded0?.append(structure0)
                }
            }
        }
        resultsData = resultsDataDecoded0
        let reportsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.ExperimentReport?].self, forKey: .reports)
        var reportsDecoded0:[EvidentlyClientTypes.ExperimentReport]? = nil
        if let reportsContainer = reportsContainer {
            reportsDecoded0 = [EvidentlyClientTypes.ExperimentReport]()
            for structure0 in reportsContainer {
                if let structure0 = structure0 {
                    reportsDecoded0?.append(structure0)
                }
            }
        }
        reports = reportsDecoded0
        let timestampsContainer = try containerValues.decodeIfPresent([ClientRuntime.Date?].self, forKey: .timestamps)
        var timestampsDecoded0:[ClientRuntime.Date]? = nil
        if let timestampsContainer = timestampsContainer {
            timestampsDecoded0 = [ClientRuntime.Date]()
            for timestamp0 in timestampsContainer {
                if let timestamp0 = timestamp0 {
                    timestampsDecoded0?.append(timestamp0)
                }
            }
        }
        timestamps = timestampsDecoded0
    }
}

extension GetFeatureInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        guard let feature = feature else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/features/\(feature.urlPercentEncoding())"
    }
}

public struct GetFeatureInput: Swift.Equatable {
    /// The name of the feature that you want to retrieve information for.
    /// This member is required.
    public var feature: Swift.String?
    /// The name or ARN of the project that contains the feature.
    /// This member is required.
    public var project: Swift.String?

    public init (
        feature: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.feature = feature
        self.project = project
    }
}

struct GetFeatureInputBody: Swift.Equatable {
}

extension GetFeatureInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFeatureOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFeatureOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFeatureOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFeatureOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFeatureOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.feature = output.feature
        } else {
            self.feature = nil
        }
    }
}

public struct GetFeatureOutputResponse: Swift.Equatable {
    /// A structure containing the configuration details of the feature.
    /// This member is required.
    public var feature: EvidentlyClientTypes.Feature?

    public init (
        feature: EvidentlyClientTypes.Feature? = nil
    )
    {
        self.feature = feature
    }
}

struct GetFeatureOutputResponseBody: Swift.Equatable {
    let feature: EvidentlyClientTypes.Feature?
}

extension GetFeatureOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case feature
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.Feature.self, forKey: .feature)
        feature = featureDecoded
    }
}

extension GetLaunchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        guard let launch = launch else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/launches/\(launch.urlPercentEncoding())"
    }
}

public struct GetLaunchInput: Swift.Equatable {
    /// The name of the launch that you want to see the details of.
    /// This member is required.
    public var launch: Swift.String?
    /// The name or ARN of the project that contains the launch.
    /// This member is required.
    public var project: Swift.String?

    public init (
        launch: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.launch = launch
        self.project = project
    }
}

struct GetLaunchInputBody: Swift.Equatable {
}

extension GetLaunchInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLaunchOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLaunchOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLaunchOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLaunchOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLaunchOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.launch = output.launch
        } else {
            self.launch = nil
        }
    }
}

public struct GetLaunchOutputResponse: Swift.Equatable {
    /// A structure containing the configuration details of the launch.
    public var launch: EvidentlyClientTypes.Launch?

    public init (
        launch: EvidentlyClientTypes.Launch? = nil
    )
    {
        self.launch = launch
    }
}

struct GetLaunchOutputResponseBody: Swift.Equatable {
    let launch: EvidentlyClientTypes.Launch?
}

extension GetLaunchOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launch
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.Launch.self, forKey: .launch)
        launch = launchDecoded
    }
}

extension GetProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())"
    }
}

public struct GetProjectInput: Swift.Equatable {
    /// The name or ARN of the project that you want to see the details of.
    /// This member is required.
    public var project: Swift.String?

    public init (
        project: Swift.String? = nil
    )
    {
        self.project = project
    }
}

struct GetProjectInputBody: Swift.Equatable {
}

extension GetProjectInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetProjectOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.project = output.project
        } else {
            self.project = nil
        }
    }
}

public struct GetProjectOutputResponse: Swift.Equatable {
    /// A structure containing the configuration details of the project.
    /// This member is required.
    public var project: EvidentlyClientTypes.Project?

    public init (
        project: EvidentlyClientTypes.Project? = nil
    )
    {
        self.project = project
    }
}

struct GetProjectOutputResponseBody: Swift.Equatable {
    let project: EvidentlyClientTypes.Project?
}

extension GetProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case project
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.Project.self, forKey: .project)
        project = projectDecoded
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Unexpected error while processing the request. Retry the request.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EvidentlyClientTypes.Launch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case description
        case execution
        case groups
        case lastUpdatedTime
        case metricMonitors
        case name
        case project
        case randomizationSalt
        case scheduledSplitsDefinition
        case status
        case statusReason
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let execution = execution {
            try encodeContainer.encode(execution, forKey: .execution)
        }
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for launchgrouplist0 in groups {
                try groupsContainer.encode(launchgrouplist0)
            }
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let metricMonitors = metricMonitors {
            var metricMonitorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricMonitors)
            for metricmonitorlist0 in metricMonitors {
                try metricMonitorsContainer.encode(metricmonitorlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let project = project {
            try encodeContainer.encode(project, forKey: .project)
        }
        if let randomizationSalt = randomizationSalt {
            try encodeContainer.encode(randomizationSalt, forKey: .randomizationSalt)
        }
        if let scheduledSplitsDefinition = scheduledSplitsDefinition {
            try encodeContainer.encode(scheduledSplitsDefinition, forKey: .scheduledSplitsDefinition)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let projectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .project)
        project = projectDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.LaunchStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let executionDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.LaunchExecution.self, forKey: .execution)
        execution = executionDecoded
        let groupsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.LaunchGroup?].self, forKey: .groups)
        var groupsDecoded0:[EvidentlyClientTypes.LaunchGroup]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [EvidentlyClientTypes.LaunchGroup]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let metricMonitorsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.MetricMonitor?].self, forKey: .metricMonitors)
        var metricMonitorsDecoded0:[EvidentlyClientTypes.MetricMonitor]? = nil
        if let metricMonitorsContainer = metricMonitorsContainer {
            metricMonitorsDecoded0 = [EvidentlyClientTypes.MetricMonitor]()
            for structure0 in metricMonitorsContainer {
                if let structure0 = structure0 {
                    metricMonitorsDecoded0?.append(structure0)
                }
            }
        }
        metricMonitors = metricMonitorsDecoded0
        let randomizationSaltDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .randomizationSalt)
        randomizationSalt = randomizationSaltDecoded
        let typeDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.LaunchType.self, forKey: .type)
        type = typeDecoded
        let scheduledSplitsDefinitionDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ScheduledSplitsLaunchDefinition.self, forKey: .scheduledSplitsDefinition)
        scheduledSplitsDefinition = scheduledSplitsDefinitionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension EvidentlyClientTypes {
    /// This structure contains the configuration details of one Evidently launch.
    public struct Launch: Swift.Equatable {
        /// The ARN of the launch.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the launch is created.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The description of the launch.
        public var description: Swift.String?
        /// A structure that contains information about the start and end times of the launch.
        public var execution: EvidentlyClientTypes.LaunchExecution?
        /// An array of structures that define the feature variations that are being used in the launch.
        public var groups: [EvidentlyClientTypes.LaunchGroup]?
        /// The date and time that the launch was most recently updated.
        /// This member is required.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// An array of structures that define the metrics that are being used to monitor the launch performance.
        public var metricMonitors: [EvidentlyClientTypes.MetricMonitor]?
        /// The name of the launch.
        /// This member is required.
        public var name: Swift.String?
        /// The name or ARN of the project that contains the launch.
        public var project: Swift.String?
        /// This value is used when Evidently assigns a particular user session to the launch, to help create a randomization ID to determine which variation the user session is served. This randomization ID is a combination of the entity ID and randomizationSalt.
        public var randomizationSalt: Swift.String?
        /// An array of structures that define the traffic allocation percentages among the feature variations during each step of the launch.
        public var scheduledSplitsDefinition: EvidentlyClientTypes.ScheduledSplitsLaunchDefinition?
        /// The current state of the launch.
        /// This member is required.
        public var status: EvidentlyClientTypes.LaunchStatus?
        /// If the launch was stopped, this is the string that was entered by the person who stopped the launch, to explain why it was stopped.
        public var statusReason: Swift.String?
        /// The list of tag keys and values associated with this launch.
        public var tags: [Swift.String:Swift.String]?
        /// The type of launch.
        /// This member is required.
        public var type: EvidentlyClientTypes.LaunchType?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            execution: EvidentlyClientTypes.LaunchExecution? = nil,
            groups: [EvidentlyClientTypes.LaunchGroup]? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            metricMonitors: [EvidentlyClientTypes.MetricMonitor]? = nil,
            name: Swift.String? = nil,
            project: Swift.String? = nil,
            randomizationSalt: Swift.String? = nil,
            scheduledSplitsDefinition: EvidentlyClientTypes.ScheduledSplitsLaunchDefinition? = nil,
            status: EvidentlyClientTypes.LaunchStatus? = nil,
            statusReason: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: EvidentlyClientTypes.LaunchType? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.execution = execution
            self.groups = groups
            self.lastUpdatedTime = lastUpdatedTime
            self.metricMonitors = metricMonitors
            self.name = name
            self.project = project
            self.randomizationSalt = randomizationSalt
            self.scheduledSplitsDefinition = scheduledSplitsDefinition
            self.status = status
            self.statusReason = statusReason
            self.tags = tags
            self.type = type
        }
    }

}

extension EvidentlyClientTypes.LaunchExecution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endedTime
        case startedTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endedTime = endedTime {
            try encodeContainer.encode(endedTime.timeIntervalSince1970, forKey: .endedTime)
        }
        if let startedTime = startedTime {
            try encodeContainer.encode(startedTime.timeIntervalSince1970, forKey: .startedTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startedTime)
        startedTime = startedTimeDecoded
        let endedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endedTime)
        endedTime = endedTimeDecoded
    }
}

extension EvidentlyClientTypes {
    /// This structure contains information about the start and end times of the launch.
    public struct LaunchExecution: Swift.Equatable {
        /// The date and time that the launch ended.
        public var endedTime: ClientRuntime.Date?
        /// The date and time that the launch started.
        public var startedTime: ClientRuntime.Date?

        public init (
            endedTime: ClientRuntime.Date? = nil,
            startedTime: ClientRuntime.Date? = nil
        )
        {
            self.endedTime = endedTime
            self.startedTime = startedTime
        }
    }

}

extension EvidentlyClientTypes.LaunchGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case featureVariations
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let featureVariations = featureVariations {
            var featureVariationsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .featureVariations)
            for (dictKey0, featuretovariationmap0) in featureVariations {
                try featureVariationsContainer.encode(featuretovariationmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let featureVariationsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .featureVariations)
        var featureVariationsDecoded0: [Swift.String:Swift.String]? = nil
        if let featureVariationsContainer = featureVariationsContainer {
            featureVariationsDecoded0 = [Swift.String:Swift.String]()
            for (key0, variationname0) in featureVariationsContainer {
                if let variationname0 = variationname0 {
                    featureVariationsDecoded0?[key0] = variationname0
                }
            }
        }
        featureVariations = featureVariationsDecoded0
    }
}

extension EvidentlyClientTypes {
    /// A structure that defines one launch group in a launch. A launch group is a variation of the feature that you are including in the launch.
    public struct LaunchGroup: Swift.Equatable {
        /// A description of the launch group.
        public var description: Swift.String?
        /// The feature variation for this launch group. This is a key-value pair.
        /// This member is required.
        public var featureVariations: [Swift.String:Swift.String]?
        /// The name of the launch group.
        /// This member is required.
        public var name: Swift.String?

        public init (
            description: Swift.String? = nil,
            featureVariations: [Swift.String:Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.description = description
            self.featureVariations = featureVariations
            self.name = name
        }
    }

}

extension EvidentlyClientTypes.LaunchGroupConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case feature
        case name
        case variation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let feature = feature {
            try encodeContainer.encode(feature, forKey: .feature)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let variation = variation {
            try encodeContainer.encode(variation, forKey: .variation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let featureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .feature)
        feature = featureDecoded
        let variationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .variation)
        variation = variationDecoded
    }
}

extension EvidentlyClientTypes {
    /// A structure that defines one launch group in a launch. A launch group is a variation of the feature that you are including in the launch.
    public struct LaunchGroupConfig: Swift.Equatable {
        /// A description of the launch group.
        public var description: Swift.String?
        /// The feature that this launch is using.
        /// This member is required.
        public var feature: Swift.String?
        /// A name for this launch group.
        /// This member is required.
        public var name: Swift.String?
        /// The feature variation to use for this launch group.
        /// This member is required.
        public var variation: Swift.String?

        public init (
            description: Swift.String? = nil,
            feature: Swift.String? = nil,
            name: Swift.String? = nil,
            variation: Swift.String? = nil
        )
        {
            self.description = description
            self.feature = feature
            self.name = name
            self.variation = variation
        }
    }

}

extension EvidentlyClientTypes {
    public enum LaunchStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case completed
        case created
        case running
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchStatus] {
            return [
                .cancelled,
                .completed,
                .created,
                .running,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .created: return "CREATED"
            case .running: return "RUNNING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchStatus(rawValue: rawValue) ?? LaunchStatus.sdkUnknown(rawValue)
        }
    }
}

extension EvidentlyClientTypes {
    public enum LaunchStopDesiredState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case completed
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchStopDesiredState] {
            return [
                .cancelled,
                .completed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchStopDesiredState(rawValue: rawValue) ?? LaunchStopDesiredState.sdkUnknown(rawValue)
        }
    }
}

extension EvidentlyClientTypes {
    public enum LaunchType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case scheduledSplitsLaunch
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchType] {
            return [
                .scheduledSplitsLaunch,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .scheduledSplitsLaunch: return "aws.evidently.splits"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchType(rawValue: rawValue) ?? LaunchType.sdkUnknown(rawValue)
        }
    }
}

extension ListExperimentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListExperimentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/experiments"
    }
}

public struct ListExperimentsInput: Swift.Equatable {
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token to use when requesting the next set of results. You received this token from a previous ListExperiments operation.
    public var nextToken: Swift.String?
    /// The name or ARN of the project to return the experiment list from.
    /// This member is required.
    public var project: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.project = project
    }
}

struct ListExperimentsInputBody: Swift.Equatable {
}

extension ListExperimentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListExperimentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListExperimentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListExperimentsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListExperimentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListExperimentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.experiments = output.experiments
            self.nextToken = output.nextToken
        } else {
            self.experiments = nil
            self.nextToken = nil
        }
    }
}

public struct ListExperimentsOutputResponse: Swift.Equatable {
    /// An array of structures that contain the configuration details of the experiments in the specified project.
    public var experiments: [EvidentlyClientTypes.Experiment]?
    /// The token to use in a subsequent ListExperiments operation to return the next set of results.
    public var nextToken: Swift.String?

    public init (
        experiments: [EvidentlyClientTypes.Experiment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.experiments = experiments
        self.nextToken = nextToken
    }
}

struct ListExperimentsOutputResponseBody: Swift.Equatable {
    let experiments: [EvidentlyClientTypes.Experiment]?
    let nextToken: Swift.String?
}

extension ListExperimentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experiments
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.Experiment?].self, forKey: .experiments)
        var experimentsDecoded0:[EvidentlyClientTypes.Experiment]? = nil
        if let experimentsContainer = experimentsContainer {
            experimentsDecoded0 = [EvidentlyClientTypes.Experiment]()
            for structure0 in experimentsContainer {
                if let structure0 = structure0 {
                    experimentsDecoded0?.append(structure0)
                }
            }
        }
        experiments = experimentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFeaturesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListFeaturesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/features"
    }
}

public struct ListFeaturesInput: Swift.Equatable {
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token to use when requesting the next set of results. You received this token from a previous ListFeatures operation.
    public var nextToken: Swift.String?
    /// The name or ARN of the project to return the feature list from.
    /// This member is required.
    public var project: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.project = project
    }
}

struct ListFeaturesInputBody: Swift.Equatable {
}

extension ListFeaturesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFeaturesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFeaturesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFeaturesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFeaturesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFeaturesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.features = output.features
            self.nextToken = output.nextToken
        } else {
            self.features = nil
            self.nextToken = nil
        }
    }
}

public struct ListFeaturesOutputResponse: Swift.Equatable {
    /// An array of structures that contain the configuration details of the features in the specified project.
    public var features: [EvidentlyClientTypes.FeatureSummary]?
    /// The token to use in a subsequent ListFeatures operation to return the next set of results.
    public var nextToken: Swift.String?

    public init (
        features: [EvidentlyClientTypes.FeatureSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.features = features
        self.nextToken = nextToken
    }
}

struct ListFeaturesOutputResponseBody: Swift.Equatable {
    let features: [EvidentlyClientTypes.FeatureSummary]?
    let nextToken: Swift.String?
}

extension ListFeaturesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case features
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featuresContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.FeatureSummary?].self, forKey: .features)
        var featuresDecoded0:[EvidentlyClientTypes.FeatureSummary]? = nil
        if let featuresContainer = featuresContainer {
            featuresDecoded0 = [EvidentlyClientTypes.FeatureSummary]()
            for structure0 in featuresContainer {
                if let structure0 = structure0 {
                    featuresDecoded0?.append(structure0)
                }
            }
        }
        features = featuresDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLaunchesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListLaunchesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/launches"
    }
}

public struct ListLaunchesInput: Swift.Equatable {
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token to use when requesting the next set of results. You received this token from a previous ListLaunches operation.
    public var nextToken: Swift.String?
    /// The name or ARN of the project to return the launch list from.
    /// This member is required.
    public var project: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.project = project
    }
}

struct ListLaunchesInputBody: Swift.Equatable {
}

extension ListLaunchesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListLaunchesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLaunchesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLaunchesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLaunchesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLaunchesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.launches = output.launches
            self.nextToken = output.nextToken
        } else {
            self.launches = nil
            self.nextToken = nil
        }
    }
}

public struct ListLaunchesOutputResponse: Swift.Equatable {
    /// An array of structures that contain the configuration details of the launches in the specified project.
    public var launches: [EvidentlyClientTypes.Launch]?
    /// The token to use in a subsequent ListLaunches operation to return the next set of results.
    public var nextToken: Swift.String?

    public init (
        launches: [EvidentlyClientTypes.Launch]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.launches = launches
        self.nextToken = nextToken
    }
}

struct ListLaunchesOutputResponseBody: Swift.Equatable {
    let launches: [EvidentlyClientTypes.Launch]?
    let nextToken: Swift.String?
}

extension ListLaunchesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launches
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchesContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.Launch?].self, forKey: .launches)
        var launchesDecoded0:[EvidentlyClientTypes.Launch]? = nil
        if let launchesContainer = launchesContainer {
            launchesDecoded0 = [EvidentlyClientTypes.Launch]()
            for structure0 in launchesContainer {
                if let structure0 = structure0 {
                    launchesDecoded0?.append(structure0)
                }
            }
        }
        launches = launchesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProjectsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListProjectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/projects"
    }
}

public struct ListProjectsInput: Swift.Equatable {
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token to use when requesting the next set of results. You received this token from a previous ListProjects operation.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProjectsInputBody: Swift.Equatable {
}

extension ListProjectsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListProjectsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProjectsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProjectsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProjectsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListProjectsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.projects = output.projects
        } else {
            self.nextToken = nil
            self.projects = nil
        }
    }
}

public struct ListProjectsOutputResponse: Swift.Equatable {
    /// The token to use in a subsequent ListProjects operation to return the next set of results.
    public var nextToken: Swift.String?
    /// An array of structures that contain the configuration details of the projects in the Region.
    public var projects: [EvidentlyClientTypes.ProjectSummary]?

    public init (
        nextToken: Swift.String? = nil,
        projects: [EvidentlyClientTypes.ProjectSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.projects = projects
    }
}

struct ListProjectsOutputResponseBody: Swift.Equatable {
    let projects: [EvidentlyClientTypes.ProjectSummary]?
    let nextToken: Swift.String?
}

extension ListProjectsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case projects
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.ProjectSummary?].self, forKey: .projects)
        var projectsDecoded0:[EvidentlyClientTypes.ProjectSummary]? = nil
        if let projectsContainer = projectsContainer {
            projectsDecoded0 = [EvidentlyClientTypes.ProjectSummary]()
            for structure0 in projectsContainer {
                if let structure0 = structure0 {
                    projectsDecoded0?.append(structure0)
                }
            }
        }
        projects = projectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource that you want to see the tags of.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The list of tag keys and values associated with the resource you specified.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension EvidentlyClientTypes.MetricDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityIdKey
        case eventPattern
        case name
        case unitLabel
        case valueKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityIdKey = entityIdKey {
            try encodeContainer.encode(entityIdKey, forKey: .entityIdKey)
        }
        if let eventPattern = eventPattern {
            try encodeContainer.encode(eventPattern, forKey: .eventPattern)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let unitLabel = unitLabel {
            try encodeContainer.encode(unitLabel, forKey: .unitLabel)
        }
        if let valueKey = valueKey {
            try encodeContainer.encode(valueKey, forKey: .valueKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let entityIdKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityIdKey)
        entityIdKey = entityIdKeyDecoded
        let valueKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .valueKey)
        valueKey = valueKeyDecoded
        let eventPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventPattern)
        eventPattern = eventPatternDecoded
        let unitLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unitLabel)
        unitLabel = unitLabelDecoded
    }
}

extension EvidentlyClientTypes {
    /// This structure defines a metric that is being used to evaluate the variations during a launch or experiment.
    public struct MetricDefinition: Swift.Equatable {
        /// The entity, such as a user or session, that does an action that causes a metric value to be recorded.
        public var entityIdKey: Swift.String?
        /// The EventBridge event pattern that defines how the metric is recorded. For more information about EventBridge event patterns, see [Amazon EventBridge event patterns](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-event-patterns.html).
        public var eventPattern: Swift.String?
        /// The name of the metric.
        public var name: Swift.String?
        /// The label for the units that the metric is measuring.
        public var unitLabel: Swift.String?
        /// The value that is tracked to produce the metric.
        public var valueKey: Swift.String?

        public init (
            entityIdKey: Swift.String? = nil,
            eventPattern: Swift.String? = nil,
            name: Swift.String? = nil,
            unitLabel: Swift.String? = nil,
            valueKey: Swift.String? = nil
        )
        {
            self.entityIdKey = entityIdKey
            self.eventPattern = eventPattern
            self.name = name
            self.unitLabel = unitLabel
            self.valueKey = valueKey
        }
    }

}

extension EvidentlyClientTypes.MetricDefinitionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityIdKey
        case eventPattern
        case name
        case unitLabel
        case valueKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityIdKey = entityIdKey {
            try encodeContainer.encode(entityIdKey, forKey: .entityIdKey)
        }
        if let eventPattern = eventPattern {
            try encodeContainer.encode(eventPattern, forKey: .eventPattern)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let unitLabel = unitLabel {
            try encodeContainer.encode(unitLabel, forKey: .unitLabel)
        }
        if let valueKey = valueKey {
            try encodeContainer.encode(valueKey, forKey: .valueKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let entityIdKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityIdKey)
        entityIdKey = entityIdKeyDecoded
        let valueKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .valueKey)
        valueKey = valueKeyDecoded
        let eventPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventPattern)
        eventPattern = eventPatternDecoded
        let unitLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unitLabel)
        unitLabel = unitLabelDecoded
    }
}

extension EvidentlyClientTypes {
    /// This structure defines a metric that you want to use to evaluate the variations during a launch or experiment.
    public struct MetricDefinitionConfig: Swift.Equatable {
        /// The entity, such as a user or session, that does an action that causes a metric value to be recorded. An example is userDetails.userID.
        public var entityIdKey: Swift.String?
        /// The EventBridge event pattern that defines how the metric is recorded. For more information about EventBridge event patterns, see [Amazon EventBridge event patterns](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-event-patterns.html).
        public var eventPattern: Swift.String?
        /// A name for the metric.
        public var name: Swift.String?
        /// A label for the units that the metric is measuring.
        public var unitLabel: Swift.String?
        /// The value that is tracked to produce the metric.
        public var valueKey: Swift.String?

        public init (
            entityIdKey: Swift.String? = nil,
            eventPattern: Swift.String? = nil,
            name: Swift.String? = nil,
            unitLabel: Swift.String? = nil,
            valueKey: Swift.String? = nil
        )
        {
            self.entityIdKey = entityIdKey
            self.eventPattern = eventPattern
            self.name = name
            self.unitLabel = unitLabel
            self.valueKey = valueKey
        }
    }

}

extension EvidentlyClientTypes.MetricGoal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredChange
        case metricDefinition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let desiredChange = desiredChange {
            try encodeContainer.encode(desiredChange.rawValue, forKey: .desiredChange)
        }
        if let metricDefinition = metricDefinition {
            try encodeContainer.encode(metricDefinition, forKey: .metricDefinition)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDefinitionDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.MetricDefinition.self, forKey: .metricDefinition)
        metricDefinition = metricDefinitionDecoded
        let desiredChangeDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ChangeDirectionEnum.self, forKey: .desiredChange)
        desiredChange = desiredChangeDecoded
    }
}

extension EvidentlyClientTypes {
    /// A structure that tells Evidently whether higher or lower values are desired for a metric that is used in an experiment.
    public struct MetricGoal: Swift.Equatable {
        /// INCREASE means that a variation with a higher number for this metric is performing better. DECREASE means that a variation with a lower number for this metric is performing better.
        public var desiredChange: EvidentlyClientTypes.ChangeDirectionEnum?
        /// A structure that contains details about the metric.
        /// This member is required.
        public var metricDefinition: EvidentlyClientTypes.MetricDefinition?

        public init (
            desiredChange: EvidentlyClientTypes.ChangeDirectionEnum? = nil,
            metricDefinition: EvidentlyClientTypes.MetricDefinition? = nil
        )
        {
            self.desiredChange = desiredChange
            self.metricDefinition = metricDefinition
        }
    }

}

extension EvidentlyClientTypes.MetricGoalConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredChange
        case metricDefinition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let desiredChange = desiredChange {
            try encodeContainer.encode(desiredChange.rawValue, forKey: .desiredChange)
        }
        if let metricDefinition = metricDefinition {
            try encodeContainer.encode(metricDefinition, forKey: .metricDefinition)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDefinitionDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.MetricDefinitionConfig.self, forKey: .metricDefinition)
        metricDefinition = metricDefinitionDecoded
        let desiredChangeDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ChangeDirectionEnum.self, forKey: .desiredChange)
        desiredChange = desiredChangeDecoded
    }
}

extension EvidentlyClientTypes {
    /// Use this structure to tell Evidently whether higher or lower values are desired for a metric that is used in an experiment.
    public struct MetricGoalConfig: Swift.Equatable {
        /// INCREASE means that a variation with a higher number for this metric is performing better. DECREASE means that a variation with a lower number for this metric is performing better.
        public var desiredChange: EvidentlyClientTypes.ChangeDirectionEnum?
        /// A structure that contains details about the metric.
        /// This member is required.
        public var metricDefinition: EvidentlyClientTypes.MetricDefinitionConfig?

        public init (
            desiredChange: EvidentlyClientTypes.ChangeDirectionEnum? = nil,
            metricDefinition: EvidentlyClientTypes.MetricDefinitionConfig? = nil
        )
        {
            self.desiredChange = desiredChange
            self.metricDefinition = metricDefinition
        }
    }

}

extension EvidentlyClientTypes.MetricMonitor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricDefinition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricDefinition = metricDefinition {
            try encodeContainer.encode(metricDefinition, forKey: .metricDefinition)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDefinitionDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.MetricDefinition.self, forKey: .metricDefinition)
        metricDefinition = metricDefinitionDecoded
    }
}

extension EvidentlyClientTypes {
    /// A structure that defines a metric to be used to monitor performance of the variations during a launch.
    public struct MetricMonitor: Swift.Equatable {
        /// A structure that defines the metric.
        /// This member is required.
        public var metricDefinition: EvidentlyClientTypes.MetricDefinition?

        public init (
            metricDefinition: EvidentlyClientTypes.MetricDefinition? = nil
        )
        {
            self.metricDefinition = metricDefinition
        }
    }

}

extension EvidentlyClientTypes.MetricMonitorConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricDefinition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricDefinition = metricDefinition {
            try encodeContainer.encode(metricDefinition, forKey: .metricDefinition)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDefinitionDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.MetricDefinitionConfig.self, forKey: .metricDefinition)
        metricDefinition = metricDefinitionDecoded
    }
}

extension EvidentlyClientTypes {
    /// A structure that defines a metric to be used to monitor performance of the variations during a launch.
    public struct MetricMonitorConfig: Swift.Equatable {
        /// A structure that defines the metric.
        /// This member is required.
        public var metricDefinition: EvidentlyClientTypes.MetricDefinitionConfig?

        public init (
            metricDefinition: EvidentlyClientTypes.MetricDefinitionConfig? = nil
        )
        {
            self.metricDefinition = metricDefinition
        }
    }

}

extension EvidentlyClientTypes.OnlineAbConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlTreatmentName
        case treatmentWeights
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controlTreatmentName = controlTreatmentName {
            try encodeContainer.encode(controlTreatmentName, forKey: .controlTreatmentName)
        }
        if let treatmentWeights = treatmentWeights {
            var treatmentWeightsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .treatmentWeights)
            for (dictKey0, treatmenttoweightmap0) in treatmentWeights {
                try treatmentWeightsContainer.encode(treatmenttoweightmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlTreatmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlTreatmentName)
        controlTreatmentName = controlTreatmentNameDecoded
        let treatmentWeightsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .treatmentWeights)
        var treatmentWeightsDecoded0: [Swift.String:Swift.Int]? = nil
        if let treatmentWeightsContainer = treatmentWeightsContainer {
            treatmentWeightsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, splitweight0) in treatmentWeightsContainer {
                if let splitweight0 = splitweight0 {
                    treatmentWeightsDecoded0?[key0] = splitweight0
                }
            }
        }
        treatmentWeights = treatmentWeightsDecoded0
    }
}

extension EvidentlyClientTypes {
    /// A structure that contains the configuration of which variation to use as the "control" version. The "control" version is used for comparison with other variations. This structure also specifies how much experiment traffic is allocated to each variation.
    public struct OnlineAbConfig: Swift.Equatable {
        /// The name of the variation that is to be the default variation that the other variations are compared to.
        public var controlTreatmentName: Swift.String?
        /// A set of key-value pairs. The keys are variation names, and the values are the portion of experiment traffic to be assigned to that variation. Specify the traffic portion in thousandths of a percent, so 20,000 for a variation would allocate 20% of the experiment traffic to that variation.
        public var treatmentWeights: [Swift.String:Swift.Int]?

        public init (
            controlTreatmentName: Swift.String? = nil,
            treatmentWeights: [Swift.String:Swift.Int]? = nil
        )
        {
            self.controlTreatmentName = controlTreatmentName
            self.treatmentWeights = treatmentWeights
        }
    }

}

extension EvidentlyClientTypes.OnlineAbDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlTreatmentName
        case treatmentWeights
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controlTreatmentName = controlTreatmentName {
            try encodeContainer.encode(controlTreatmentName, forKey: .controlTreatmentName)
        }
        if let treatmentWeights = treatmentWeights {
            var treatmentWeightsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .treatmentWeights)
            for (dictKey0, treatmenttoweightmap0) in treatmentWeights {
                try treatmentWeightsContainer.encode(treatmenttoweightmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlTreatmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlTreatmentName)
        controlTreatmentName = controlTreatmentNameDecoded
        let treatmentWeightsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .treatmentWeights)
        var treatmentWeightsDecoded0: [Swift.String:Swift.Int]? = nil
        if let treatmentWeightsContainer = treatmentWeightsContainer {
            treatmentWeightsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, splitweight0) in treatmentWeightsContainer {
                if let splitweight0 = splitweight0 {
                    treatmentWeightsDecoded0?[key0] = splitweight0
                }
            }
        }
        treatmentWeights = treatmentWeightsDecoded0
    }
}

extension EvidentlyClientTypes {
    /// A structure that contains the configuration of which variation to use as the "control" version. The "control" version is used for comparison with other variations. This structure also specifies how much experiment traffic is allocated to each variation.
    public struct OnlineAbDefinition: Swift.Equatable {
        /// The name of the variation that is the default variation that the other variations are compared to.
        public var controlTreatmentName: Swift.String?
        /// A set of key-value pairs. The keys are variation names, and the values are the portion of experiment traffic to be assigned to that variation. The traffic portion is specified in thousandths of a percent, so 20,000 for a variation would allocate 20% of the experiment traffic to that variation.
        public var treatmentWeights: [Swift.String:Swift.Int]?

        public init (
            controlTreatmentName: Swift.String? = nil,
            treatmentWeights: [Swift.String:Swift.Int]? = nil
        )
        {
            self.controlTreatmentName = controlTreatmentName
            self.treatmentWeights = treatmentWeights
        }
    }

}

extension EvidentlyClientTypes.Project: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeExperimentCount
        case activeLaunchCount
        case arn
        case createdTime
        case dataDelivery
        case description
        case experimentCount
        case featureCount
        case lastUpdatedTime
        case launchCount
        case name
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeExperimentCount = activeExperimentCount {
            try encodeContainer.encode(activeExperimentCount, forKey: .activeExperimentCount)
        }
        if let activeLaunchCount = activeLaunchCount {
            try encodeContainer.encode(activeLaunchCount, forKey: .activeLaunchCount)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let dataDelivery = dataDelivery {
            try encodeContainer.encode(dataDelivery, forKey: .dataDelivery)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let experimentCount = experimentCount {
            try encodeContainer.encode(experimentCount, forKey: .experimentCount)
        }
        if let featureCount = featureCount {
            try encodeContainer.encode(featureCount, forKey: .featureCount)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let launchCount = launchCount {
            try encodeContainer.encode(launchCount, forKey: .launchCount)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ProjectStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let featureCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .featureCount)
        featureCount = featureCountDecoded
        let launchCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .launchCount)
        launchCount = launchCountDecoded
        let activeLaunchCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeLaunchCount)
        activeLaunchCount = activeLaunchCountDecoded
        let experimentCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .experimentCount)
        experimentCount = experimentCountDecoded
        let activeExperimentCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeExperimentCount)
        activeExperimentCount = activeExperimentCountDecoded
        let dataDeliveryDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ProjectDataDelivery.self, forKey: .dataDelivery)
        dataDelivery = dataDeliveryDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension EvidentlyClientTypes {
    /// This structure defines a project, which is the logical object in Evidently that can contain features, launches, and experiments. Use projects to group similar features together.
    public struct Project: Swift.Equatable {
        /// The number of ongoing experiments currently in the project.
        public var activeExperimentCount: Swift.Int?
        /// The number of ongoing launches currently in the project.
        public var activeLaunchCount: Swift.Int?
        /// The name or ARN of the project.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the project is created.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// A structure that contains information about where Evidently is to store evaluation events for longer term storage.
        public var dataDelivery: EvidentlyClientTypes.ProjectDataDelivery?
        /// The user-entered description of the project.
        public var description: Swift.String?
        /// The number of experiments currently in the project. This includes all experiments that have been created and not deleted, whether they are ongoing or not.
        public var experimentCount: Swift.Int?
        /// The number of features currently in the project.
        public var featureCount: Swift.Int?
        /// The date and time that the project was most recently updated.
        /// This member is required.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The number of launches currently in the project. This includes all launches that have been created and not deleted, whether they are ongoing or not.
        public var launchCount: Swift.Int?
        /// The name of the project.
        /// This member is required.
        public var name: Swift.String?
        /// The current state of the project.
        /// This member is required.
        public var status: EvidentlyClientTypes.ProjectStatus?
        /// The list of tag keys and values associated with this project.
        public var tags: [Swift.String:Swift.String]?

        public init (
            activeExperimentCount: Swift.Int? = nil,
            activeLaunchCount: Swift.Int? = nil,
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            dataDelivery: EvidentlyClientTypes.ProjectDataDelivery? = nil,
            description: Swift.String? = nil,
            experimentCount: Swift.Int? = nil,
            featureCount: Swift.Int? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            launchCount: Swift.Int? = nil,
            name: Swift.String? = nil,
            status: EvidentlyClientTypes.ProjectStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.activeExperimentCount = activeExperimentCount
            self.activeLaunchCount = activeLaunchCount
            self.arn = arn
            self.createdTime = createdTime
            self.dataDelivery = dataDelivery
            self.description = description
            self.experimentCount = experimentCount
            self.featureCount = featureCount
            self.lastUpdatedTime = lastUpdatedTime
            self.launchCount = launchCount
            self.name = name
            self.status = status
            self.tags = tags
        }
    }

}

extension EvidentlyClientTypes.ProjectDataDelivery: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogs
        case s3Destination
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogs = cloudWatchLogs {
            try encodeContainer.encode(cloudWatchLogs, forKey: .cloudWatchLogs)
        }
        if let s3Destination = s3Destination {
            try encodeContainer.encode(s3Destination, forKey: .s3Destination)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DestinationDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.S3Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
        let cloudWatchLogsDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.CloudWatchLogsDestination.self, forKey: .cloudWatchLogs)
        cloudWatchLogs = cloudWatchLogsDecoded
    }
}

extension EvidentlyClientTypes {
    /// A structure that contains information about where Evidently is to store evaluation events for longer term storage.
    public struct ProjectDataDelivery: Swift.Equatable {
        /// If the project stores evaluation events in CloudWatch Logs, this structure stores the log group name.
        public var cloudWatchLogs: EvidentlyClientTypes.CloudWatchLogsDestination?
        /// If the project stores evaluation events in an Amazon S3 bucket, this structure stores the bucket name and bucket prefix.
        public var s3Destination: EvidentlyClientTypes.S3Destination?

        public init (
            cloudWatchLogs: EvidentlyClientTypes.CloudWatchLogsDestination? = nil,
            s3Destination: EvidentlyClientTypes.S3Destination? = nil
        )
        {
            self.cloudWatchLogs = cloudWatchLogs
            self.s3Destination = s3Destination
        }
    }

}

extension EvidentlyClientTypes.ProjectDataDeliveryConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogs
        case s3Destination
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogs = cloudWatchLogs {
            try encodeContainer.encode(cloudWatchLogs, forKey: .cloudWatchLogs)
        }
        if let s3Destination = s3Destination {
            try encodeContainer.encode(s3Destination, forKey: .s3Destination)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DestinationDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.S3DestinationConfig.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
        let cloudWatchLogsDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.CloudWatchLogsDestinationConfig.self, forKey: .cloudWatchLogs)
        cloudWatchLogs = cloudWatchLogsDecoded
    }
}

extension EvidentlyClientTypes {
    /// A structure that contains information about where Evidently is to store evaluation events for longer term storage.
    public struct ProjectDataDeliveryConfig: Swift.Equatable {
        /// If the project stores evaluation events in CloudWatch Logs, this structure stores the log group name.
        public var cloudWatchLogs: EvidentlyClientTypes.CloudWatchLogsDestinationConfig?
        /// If the project stores evaluation events in an Amazon S3 bucket, this structure stores the bucket name and bucket prefix.
        public var s3Destination: EvidentlyClientTypes.S3DestinationConfig?

        public init (
            cloudWatchLogs: EvidentlyClientTypes.CloudWatchLogsDestinationConfig? = nil,
            s3Destination: EvidentlyClientTypes.S3DestinationConfig? = nil
        )
        {
            self.cloudWatchLogs = cloudWatchLogs
            self.s3Destination = s3Destination
        }
    }

}

extension EvidentlyClientTypes {
    public enum ProjectStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ProjectStatus] {
            return [
                .available,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProjectStatus(rawValue: rawValue) ?? ProjectStatus.sdkUnknown(rawValue)
        }
    }
}

extension EvidentlyClientTypes.ProjectSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeExperimentCount
        case activeLaunchCount
        case arn
        case createdTime
        case description
        case experimentCount
        case featureCount
        case lastUpdatedTime
        case launchCount
        case name
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeExperimentCount = activeExperimentCount {
            try encodeContainer.encode(activeExperimentCount, forKey: .activeExperimentCount)
        }
        if let activeLaunchCount = activeLaunchCount {
            try encodeContainer.encode(activeLaunchCount, forKey: .activeLaunchCount)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let experimentCount = experimentCount {
            try encodeContainer.encode(experimentCount, forKey: .experimentCount)
        }
        if let featureCount = featureCount {
            try encodeContainer.encode(featureCount, forKey: .featureCount)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let launchCount = launchCount {
            try encodeContainer.encode(launchCount, forKey: .launchCount)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ProjectStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let featureCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .featureCount)
        featureCount = featureCountDecoded
        let launchCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .launchCount)
        launchCount = launchCountDecoded
        let activeLaunchCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeLaunchCount)
        activeLaunchCount = activeLaunchCountDecoded
        let experimentCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .experimentCount)
        experimentCount = experimentCountDecoded
        let activeExperimentCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeExperimentCount)
        activeExperimentCount = activeExperimentCountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension EvidentlyClientTypes {
    /// A structure that contains configuration information about an Evidently project.
    public struct ProjectSummary: Swift.Equatable {
        /// The number of experiments currently in the project.
        public var activeExperimentCount: Swift.Int?
        /// The number of ongoing launches currently in the project.
        public var activeLaunchCount: Swift.Int?
        /// The name or ARN of the project.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the project is created.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The description of the project.
        public var description: Swift.String?
        /// The number of experiments currently in the project.
        public var experimentCount: Swift.Int?
        /// The number of features currently in the project.
        public var featureCount: Swift.Int?
        /// The date and time that the project was most recently updated.
        /// This member is required.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The number of launches currently in the project, including launches that are ongoing, completed, and not started yet.
        public var launchCount: Swift.Int?
        /// The name of the project.
        /// This member is required.
        public var name: Swift.String?
        /// The current state of the project.
        /// This member is required.
        public var status: EvidentlyClientTypes.ProjectStatus?
        /// The list of tag keys and values associated with this project.
        public var tags: [Swift.String:Swift.String]?

        public init (
            activeExperimentCount: Swift.Int? = nil,
            activeLaunchCount: Swift.Int? = nil,
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            experimentCount: Swift.Int? = nil,
            featureCount: Swift.Int? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            launchCount: Swift.Int? = nil,
            name: Swift.String? = nil,
            status: EvidentlyClientTypes.ProjectStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.activeExperimentCount = activeExperimentCount
            self.activeLaunchCount = activeLaunchCount
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.experimentCount = experimentCount
            self.featureCount = featureCount
            self.lastUpdatedTime = lastUpdatedTime
            self.launchCount = launchCount
            self.name = name
            self.status = status
            self.tags = tags
        }
    }

}

extension PutProjectEventsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for eventlist0 in events {
                try eventsContainer.encode(eventlist0)
            }
        }
    }
}

extension PutProjectEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        return "/events/projects/\(project.urlPercentEncoding())"
    }
}

public struct PutProjectEventsInput: Swift.Equatable {
    /// An array of event structures that contain the performance data that is being sent to Evidently.
    /// This member is required.
    public var events: [EvidentlyClientTypes.Event]?
    /// The name or ARN of the project to write the events to.
    /// This member is required.
    public var project: Swift.String?

    public init (
        events: [EvidentlyClientTypes.Event]? = nil,
        project: Swift.String? = nil
    )
    {
        self.events = events
        self.project = project
    }
}

struct PutProjectEventsInputBody: Swift.Equatable {
    let events: [EvidentlyClientTypes.Event]?
}

extension PutProjectEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.Event?].self, forKey: .events)
        var eventsDecoded0:[EvidentlyClientTypes.Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [EvidentlyClientTypes.Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension PutProjectEventsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutProjectEventsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutProjectEventsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutProjectEventsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutProjectEventsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventResults = output.eventResults
            self.failedEventCount = output.failedEventCount
        } else {
            self.eventResults = nil
            self.failedEventCount = nil
        }
    }
}

public struct PutProjectEventsOutputResponse: Swift.Equatable {
    /// A structure that contains Evidently's response to the sent events, including an event ID and error codes, if any.
    public var eventResults: [EvidentlyClientTypes.PutProjectEventsResultEntry]?
    /// The number of events in the operation that could not be used by Evidently.
    public var failedEventCount: Swift.Int?

    public init (
        eventResults: [EvidentlyClientTypes.PutProjectEventsResultEntry]? = nil,
        failedEventCount: Swift.Int? = nil
    )
    {
        self.eventResults = eventResults
        self.failedEventCount = failedEventCount
    }
}

struct PutProjectEventsOutputResponseBody: Swift.Equatable {
    let failedEventCount: Swift.Int?
    let eventResults: [EvidentlyClientTypes.PutProjectEventsResultEntry]?
}

extension PutProjectEventsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventResults
        case failedEventCount
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedEventCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failedEventCount)
        failedEventCount = failedEventCountDecoded
        let eventResultsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.PutProjectEventsResultEntry?].self, forKey: .eventResults)
        var eventResultsDecoded0:[EvidentlyClientTypes.PutProjectEventsResultEntry]? = nil
        if let eventResultsContainer = eventResultsContainer {
            eventResultsDecoded0 = [EvidentlyClientTypes.PutProjectEventsResultEntry]()
            for structure0 in eventResultsContainer {
                if let structure0 = structure0 {
                    eventResultsDecoded0?.append(structure0)
                }
            }
        }
        eventResults = eventResultsDecoded0
    }
}

extension EvidentlyClientTypes.PutProjectEventsResultEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case eventId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension EvidentlyClientTypes {
    /// A structure that contains Evidently's response to the sent events, including an event ID and error codes, if any.
    public struct PutProjectEventsResultEntry: Swift.Equatable {
        /// If the PutProjectEvents operation has an error, the error code is returned here.
        public var errorCode: Swift.String?
        /// If the PutProjectEvents operation has an error, the error message is returned here.
        public var errorMessage: Swift.String?
        /// A unique ID assigned to this PutProjectEvents operation.
        public var eventId: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            eventId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.eventId = eventId
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request references a resource that does not exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The ID of the resource that caused the exception.
    public var resourceId: Swift.String?
    /// The type of the resource that is associated with the error.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension EvidentlyClientTypes.S3Destination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case `prefix` = "prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let `prefix` = `prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension EvidentlyClientTypes {
    /// If the project stores evaluation events in an Amazon S3 bucket, this structure stores the bucket name and bucket prefix.
    public struct S3Destination: Swift.Equatable {
        /// The name of the bucket in which Evidently stores evaluation events.
        public var bucket: Swift.String?
        /// The bucket prefix in which Evidently stores evaluation events.
        public var `prefix`: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.`prefix` = `prefix`
        }
    }

}

extension EvidentlyClientTypes.S3DestinationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case `prefix` = "prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let `prefix` = `prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension EvidentlyClientTypes {
    /// If the project stores evaluation events in an Amazon S3 bucket, this structure stores the bucket name and bucket prefix.
    public struct S3DestinationConfig: Swift.Equatable {
        /// The name of the bucket in which Evidently stores evaluation events.
        public var bucket: Swift.String?
        /// The bucket prefix in which Evidently stores evaluation events.
        public var `prefix`: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.`prefix` = `prefix`
        }
    }

}

extension EvidentlyClientTypes.ScheduledSplit: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupWeights
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupWeights = groupWeights {
            var groupWeightsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .groupWeights)
            for (dictKey0, grouptoweightmap0) in groupWeights {
                try groupWeightsContainer.encode(grouptoweightmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let groupWeightsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .groupWeights)
        var groupWeightsDecoded0: [Swift.String:Swift.Int]? = nil
        if let groupWeightsContainer = groupWeightsContainer {
            groupWeightsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, splitweight0) in groupWeightsContainer {
                if let splitweight0 = splitweight0 {
                    groupWeightsDecoded0?[key0] = splitweight0
                }
            }
        }
        groupWeights = groupWeightsDecoded0
    }
}

extension EvidentlyClientTypes {
    /// This structure defines the traffic allocation percentages among the feature variations during one step of a launch, and the start time of that step.
    public struct ScheduledSplit: Swift.Equatable {
        /// The traffic allocation percentages among the feature variations during one step of a launch. This is a set of key-value pairs. The keys are variation names. The values represent the percentage of traffic to allocate to that variation during this step.
        public var groupWeights: [Swift.String:Swift.Int]?
        /// The date and time that this step of the launch starts.
        /// This member is required.
        public var startTime: ClientRuntime.Date?

        public init (
            groupWeights: [Swift.String:Swift.Int]? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.groupWeights = groupWeights
            self.startTime = startTime
        }
    }

}

extension EvidentlyClientTypes.ScheduledSplitConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupWeights
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupWeights = groupWeights {
            var groupWeightsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .groupWeights)
            for (dictKey0, grouptoweightmap0) in groupWeights {
                try groupWeightsContainer.encode(grouptoweightmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let groupWeightsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .groupWeights)
        var groupWeightsDecoded0: [Swift.String:Swift.Int]? = nil
        if let groupWeightsContainer = groupWeightsContainer {
            groupWeightsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, splitweight0) in groupWeightsContainer {
                if let splitweight0 = splitweight0 {
                    groupWeightsDecoded0?[key0] = splitweight0
                }
            }
        }
        groupWeights = groupWeightsDecoded0
    }
}

extension EvidentlyClientTypes {
    /// This structure defines the traffic allocation percentages among the feature variations during one step of a launch, and the start time of that step.
    public struct ScheduledSplitConfig: Swift.Equatable {
        /// The traffic allocation percentages among the feature variations during one step of a launch. This is a set of key-value pairs. The keys are variation names. The values represent the percentage of traffic to allocate to that variation during this step.
        /// This member is required.
        public var groupWeights: [Swift.String:Swift.Int]?
        /// The date and time that this step of the launch starts.
        /// This member is required.
        public var startTime: ClientRuntime.Date?

        public init (
            groupWeights: [Swift.String:Swift.Int]? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.groupWeights = groupWeights
            self.startTime = startTime
        }
    }

}

extension EvidentlyClientTypes.ScheduledSplitsLaunchConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case steps
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for scheduledsplitconfiglist0 in steps {
                try stepsContainer.encode(scheduledsplitconfiglist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.ScheduledSplitConfig?].self, forKey: .steps)
        var stepsDecoded0:[EvidentlyClientTypes.ScheduledSplitConfig]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [EvidentlyClientTypes.ScheduledSplitConfig]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
    }
}

extension EvidentlyClientTypes {
    /// An array of structures that define the traffic allocation percentages among the feature variations during each step of a launch. This also defines the start time of each step.
    public struct ScheduledSplitsLaunchConfig: Swift.Equatable {
        /// An array of structures that define the traffic allocation percentages among the feature variations during each step of the launch. This also defines the start time of each step.
        /// This member is required.
        public var steps: [EvidentlyClientTypes.ScheduledSplitConfig]?

        public init (
            steps: [EvidentlyClientTypes.ScheduledSplitConfig]? = nil
        )
        {
            self.steps = steps
        }
    }

}

extension EvidentlyClientTypes.ScheduledSplitsLaunchDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case steps
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for scheduledsteplist0 in steps {
                try stepsContainer.encode(scheduledsteplist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.ScheduledSplit?].self, forKey: .steps)
        var stepsDecoded0:[EvidentlyClientTypes.ScheduledSplit]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [EvidentlyClientTypes.ScheduledSplit]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
    }
}

extension EvidentlyClientTypes {
    /// An array of structures that define the traffic allocation percentages among the feature variations during each step of a launch. This also defines the start time of each step.
    public struct ScheduledSplitsLaunchDefinition: Swift.Equatable {
        /// An array of structures that define the traffic allocation percentages among the feature variations during each step of the launch. This also defines the start time of each step.
        public var steps: [EvidentlyClientTypes.ScheduledSplit]?

        public init (
            steps: [EvidentlyClientTypes.ScheduledSplit]? = nil
        )
        {
            self.steps = steps
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The ID of the service quota that was exceeded.
    public var quotaCode: Swift.String?
    /// The ID of the resource that caused the exception.
    public var resourceId: Swift.String?
    /// The type of the resource that is associated with the error.
    public var resourceType: Swift.String?
    /// The ID of the service that is associated with the error.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case resourceId
        case resourceType
        case serviceCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service was unavailable. Retry the request.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartExperimentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisCompleteTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analysisCompleteTime = analysisCompleteTime {
            try encodeContainer.encode(analysisCompleteTime.timeIntervalSince1970, forKey: .analysisCompleteTime)
        }
    }
}

extension StartExperimentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        guard let experiment = experiment else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/experiments/\(experiment.urlPercentEncoding())/start"
    }
}

public struct StartExperimentInput: Swift.Equatable {
    /// The date and time to end the experiment.
    /// This member is required.
    public var analysisCompleteTime: ClientRuntime.Date?
    /// The name of the experiment to start.
    /// This member is required.
    public var experiment: Swift.String?
    /// The name or ARN of the project that contains the experiment to start.
    /// This member is required.
    public var project: Swift.String?

    public init (
        analysisCompleteTime: ClientRuntime.Date? = nil,
        experiment: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.analysisCompleteTime = analysisCompleteTime
        self.experiment = experiment
        self.project = project
    }
}

struct StartExperimentInputBody: Swift.Equatable {
    let analysisCompleteTime: ClientRuntime.Date?
}

extension StartExperimentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisCompleteTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisCompleteTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .analysisCompleteTime)
        analysisCompleteTime = analysisCompleteTimeDecoded
    }
}

extension StartExperimentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartExperimentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartExperimentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartExperimentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartExperimentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.startedTime = output.startedTime
        } else {
            self.startedTime = nil
        }
    }
}

public struct StartExperimentOutputResponse: Swift.Equatable {
    /// A timestamp that indicates when the experiment started.
    public var startedTime: ClientRuntime.Date?

    public init (
        startedTime: ClientRuntime.Date? = nil
    )
    {
        self.startedTime = startedTime
    }
}

struct StartExperimentOutputResponseBody: Swift.Equatable {
    let startedTime: ClientRuntime.Date?
}

extension StartExperimentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case startedTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startedTime)
        startedTime = startedTimeDecoded
    }
}

extension StartLaunchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        guard let launch = launch else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/launches/\(launch.urlPercentEncoding())/start"
    }
}

public struct StartLaunchInput: Swift.Equatable {
    /// The name of the launch to start.
    /// This member is required.
    public var launch: Swift.String?
    /// The name or ARN of the project that contains the launch to start.
    /// This member is required.
    public var project: Swift.String?

    public init (
        launch: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.launch = launch
        self.project = project
    }
}

struct StartLaunchInputBody: Swift.Equatable {
}

extension StartLaunchInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StartLaunchOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartLaunchOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartLaunchOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartLaunchOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartLaunchOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.launch = output.launch
        } else {
            self.launch = nil
        }
    }
}

public struct StartLaunchOutputResponse: Swift.Equatable {
    /// A structure that contains information about the launch that was started.
    /// This member is required.
    public var launch: EvidentlyClientTypes.Launch?

    public init (
        launch: EvidentlyClientTypes.Launch? = nil
    )
    {
        self.launch = launch
    }
}

struct StartLaunchOutputResponseBody: Swift.Equatable {
    let launch: EvidentlyClientTypes.Launch?
}

extension StartLaunchOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launch
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.Launch.self, forKey: .launch)
        launch = launchDecoded
    }
}

extension StopExperimentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredState
        case reason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let desiredState = desiredState {
            try encodeContainer.encode(desiredState.rawValue, forKey: .desiredState)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }
}

extension StopExperimentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        guard let experiment = experiment else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/experiments/\(experiment.urlPercentEncoding())/cancel"
    }
}

public struct StopExperimentInput: Swift.Equatable {
    /// Specify whether the experiment is to be considered COMPLETED or CANCELLED after it stops.
    public var desiredState: EvidentlyClientTypes.ExperimentStopDesiredState?
    /// The name of the experiment to stop.
    /// This member is required.
    public var experiment: Swift.String?
    /// The name or ARN of the project that contains the experiment to stop.
    /// This member is required.
    public var project: Swift.String?
    /// A string that describes why you are stopping the experiment.
    public var reason: Swift.String?

    public init (
        desiredState: EvidentlyClientTypes.ExperimentStopDesiredState? = nil,
        experiment: Swift.String? = nil,
        project: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.desiredState = desiredState
        self.experiment = experiment
        self.project = project
        self.reason = reason
    }
}

struct StopExperimentInputBody: Swift.Equatable {
    let desiredState: EvidentlyClientTypes.ExperimentStopDesiredState?
    let reason: Swift.String?
}

extension StopExperimentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredState
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let desiredStateDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ExperimentStopDesiredState.self, forKey: .desiredState)
        desiredState = desiredStateDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension StopExperimentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopExperimentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopExperimentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopExperimentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopExperimentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endedTime = output.endedTime
        } else {
            self.endedTime = nil
        }
    }
}

public struct StopExperimentOutputResponse: Swift.Equatable {
    /// The date and time that the experiment stopped.
    public var endedTime: ClientRuntime.Date?

    public init (
        endedTime: ClientRuntime.Date? = nil
    )
    {
        self.endedTime = endedTime
    }
}

struct StopExperimentOutputResponseBody: Swift.Equatable {
    let endedTime: ClientRuntime.Date?
}

extension StopExperimentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endedTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endedTime)
        endedTime = endedTimeDecoded
    }
}

extension StopLaunchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredState
        case reason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let desiredState = desiredState {
            try encodeContainer.encode(desiredState.rawValue, forKey: .desiredState)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }
}

extension StopLaunchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        guard let launch = launch else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/launches/\(launch.urlPercentEncoding())/cancel"
    }
}

public struct StopLaunchInput: Swift.Equatable {
    /// Specify whether to consider the launch as COMPLETED or CANCELLED after it stops.
    public var desiredState: EvidentlyClientTypes.LaunchStopDesiredState?
    /// The name of the launch to stop.
    /// This member is required.
    public var launch: Swift.String?
    /// The name or ARN of the project that contains the launch that you want to stop.
    /// This member is required.
    public var project: Swift.String?
    /// A string that describes why you are stopping the launch.
    public var reason: Swift.String?

    public init (
        desiredState: EvidentlyClientTypes.LaunchStopDesiredState? = nil,
        launch: Swift.String? = nil,
        project: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.desiredState = desiredState
        self.launch = launch
        self.project = project
        self.reason = reason
    }
}

struct StopLaunchInputBody: Swift.Equatable {
    let desiredState: EvidentlyClientTypes.LaunchStopDesiredState?
    let reason: Swift.String?
}

extension StopLaunchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredState
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let desiredStateDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.LaunchStopDesiredState.self, forKey: .desiredState)
        desiredState = desiredStateDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension StopLaunchOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopLaunchOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopLaunchOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopLaunchOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopLaunchOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endedTime = output.endedTime
        } else {
            self.endedTime = nil
        }
    }
}

public struct StopLaunchOutputResponse: Swift.Equatable {
    /// The date and time that the launch stopped.
    public var endedTime: ClientRuntime.Date?

    public init (
        endedTime: ClientRuntime.Date? = nil
    )
    {
        self.endedTime = endedTime
    }
}

struct StopLaunchOutputResponseBody: Swift.Equatable {
    let endedTime: ClientRuntime.Date?
}

extension StopLaunchOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endedTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endedTime)
        endedTime = endedTimeDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the CloudWatch Evidently resource that you're adding tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of key-value pairs to associate with the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied because of request throttling. Retry the request.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The ID of the service quota that was exceeded.
    public var quotaCode: Swift.String?
    /// The ID of the service that is associated with the error.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension EvidentlyClientTypes.Treatment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case featureVariations
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let featureVariations = featureVariations {
            var featureVariationsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .featureVariations)
            for (dictKey0, featuretovariationmap0) in featureVariations {
                try featureVariationsContainer.encode(featuretovariationmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let featureVariationsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .featureVariations)
        var featureVariationsDecoded0: [Swift.String:Swift.String]? = nil
        if let featureVariationsContainer = featureVariationsContainer {
            featureVariationsDecoded0 = [Swift.String:Swift.String]()
            for (key0, variationname0) in featureVariationsContainer {
                if let variationname0 = variationname0 {
                    featureVariationsDecoded0?[key0] = variationname0
                }
            }
        }
        featureVariations = featureVariationsDecoded0
    }
}

extension EvidentlyClientTypes {
    /// A structure that defines one treatment in an experiment. A treatment is a variation of the feature that you are including in the experiment.
    public struct Treatment: Swift.Equatable {
        /// The description of the treatment.
        public var description: Swift.String?
        /// The feature variation used for this treatment. This is a key-value pair. The key is the feature name, and the value is the variation name.
        public var featureVariations: [Swift.String:Swift.String]?
        /// The name of this treatment.
        /// This member is required.
        public var name: Swift.String?

        public init (
            description: Swift.String? = nil,
            featureVariations: [Swift.String:Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.description = description
            self.featureVariations = featureVariations
            self.name = name
        }
    }

}

extension EvidentlyClientTypes.TreatmentConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case feature
        case name
        case variation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let feature = feature {
            try encodeContainer.encode(feature, forKey: .feature)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let variation = variation {
            try encodeContainer.encode(variation, forKey: .variation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let featureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .feature)
        feature = featureDecoded
        let variationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .variation)
        variation = variationDecoded
    }
}

extension EvidentlyClientTypes {
    /// A structure that defines one treatment in an experiment. A treatment is a variation of the feature that you are including in the experiment.
    public struct TreatmentConfig: Swift.Equatable {
        /// A description for this treatment.
        public var description: Swift.String?
        /// The feature that this experiment is testing.
        /// This member is required.
        public var feature: Swift.String?
        /// A name for this treatment.
        /// This member is required.
        public var name: Swift.String?
        /// The name of the variation to use as this treatment in the experiment.
        /// This member is required.
        public var variation: Swift.String?

        public init (
            description: Swift.String? = nil,
            feature: Swift.String? = nil,
            name: Swift.String? = nil,
            variation: Swift.String? = nil
        )
        {
            self.description = description
            self.feature = feature
            self.name = name
            self.variation = variation
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the CloudWatch Evidently resource that you're removing tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateExperimentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case metricGoals
        case onlineAbConfig
        case randomizationSalt
        case samplingRate
        case treatments
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let metricGoals = metricGoals {
            var metricGoalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricGoals)
            for metricgoalconfiglist0 in metricGoals {
                try metricGoalsContainer.encode(metricgoalconfiglist0)
            }
        }
        if let onlineAbConfig = onlineAbConfig {
            try encodeContainer.encode(onlineAbConfig, forKey: .onlineAbConfig)
        }
        if let randomizationSalt = randomizationSalt {
            try encodeContainer.encode(randomizationSalt, forKey: .randomizationSalt)
        }
        if samplingRate != 0 {
            try encodeContainer.encode(samplingRate, forKey: .samplingRate)
        }
        if let treatments = treatments {
            var treatmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .treatments)
            for treatmentconfiglist0 in treatments {
                try treatmentsContainer.encode(treatmentconfiglist0)
            }
        }
    }
}

extension UpdateExperimentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        guard let experiment = experiment else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/experiments/\(experiment.urlPercentEncoding())"
    }
}

public struct UpdateExperimentInput: Swift.Equatable {
    /// An optional description of the experiment.
    public var description: Swift.String?
    /// The name of the experiment to update.
    /// This member is required.
    public var experiment: Swift.String?
    /// An array of structures that defines the metrics used for the experiment, and whether a higher or lower value for each metric is the goal.
    public var metricGoals: [EvidentlyClientTypes.MetricGoalConfig]?
    /// A structure that contains the configuration of which variation o use as the "control" version. The "control" version is used for comparison with other variations. This structure also specifies how much experiment traffic is allocated to each variation.
    public var onlineAbConfig: EvidentlyClientTypes.OnlineAbConfig?
    /// The name or ARN of the project that contains the experiment that you want to update.
    /// This member is required.
    public var project: Swift.String?
    /// When Evidently assigns a particular user session to an experiment, it must use a randomization ID to determine which variation the user session is served. This randomization ID is a combination of the entity ID and randomizationSalt. If you omit randomizationSalt, Evidently uses the experiment name as the randomizationSalt.
    public var randomizationSalt: Swift.String?
    /// The portion of the available audience that you want to allocate to this experiment, in thousandths of a percent. The available audience is the total audience minus the audience that you have allocated to overrides or current launches of this feature. This is represented in thousandths of a percent. For example, specify 20,000 to allocate 20% of the available audience.
    public var samplingRate: Swift.Int
    /// An array of structures that define the variations being tested in the experiment.
    public var treatments: [EvidentlyClientTypes.TreatmentConfig]?

    public init (
        description: Swift.String? = nil,
        experiment: Swift.String? = nil,
        metricGoals: [EvidentlyClientTypes.MetricGoalConfig]? = nil,
        onlineAbConfig: EvidentlyClientTypes.OnlineAbConfig? = nil,
        project: Swift.String? = nil,
        randomizationSalt: Swift.String? = nil,
        samplingRate: Swift.Int = 0,
        treatments: [EvidentlyClientTypes.TreatmentConfig]? = nil
    )
    {
        self.description = description
        self.experiment = experiment
        self.metricGoals = metricGoals
        self.onlineAbConfig = onlineAbConfig
        self.project = project
        self.randomizationSalt = randomizationSalt
        self.samplingRate = samplingRate
        self.treatments = treatments
    }
}

struct UpdateExperimentInputBody: Swift.Equatable {
    let description: Swift.String?
    let treatments: [EvidentlyClientTypes.TreatmentConfig]?
    let metricGoals: [EvidentlyClientTypes.MetricGoalConfig]?
    let randomizationSalt: Swift.String?
    let samplingRate: Swift.Int
    let onlineAbConfig: EvidentlyClientTypes.OnlineAbConfig?
}

extension UpdateExperimentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case metricGoals
        case onlineAbConfig
        case randomizationSalt
        case samplingRate
        case treatments
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let treatmentsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.TreatmentConfig?].self, forKey: .treatments)
        var treatmentsDecoded0:[EvidentlyClientTypes.TreatmentConfig]? = nil
        if let treatmentsContainer = treatmentsContainer {
            treatmentsDecoded0 = [EvidentlyClientTypes.TreatmentConfig]()
            for structure0 in treatmentsContainer {
                if let structure0 = structure0 {
                    treatmentsDecoded0?.append(structure0)
                }
            }
        }
        treatments = treatmentsDecoded0
        let metricGoalsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.MetricGoalConfig?].self, forKey: .metricGoals)
        var metricGoalsDecoded0:[EvidentlyClientTypes.MetricGoalConfig]? = nil
        if let metricGoalsContainer = metricGoalsContainer {
            metricGoalsDecoded0 = [EvidentlyClientTypes.MetricGoalConfig]()
            for structure0 in metricGoalsContainer {
                if let structure0 = structure0 {
                    metricGoalsDecoded0?.append(structure0)
                }
            }
        }
        metricGoals = metricGoalsDecoded0
        let randomizationSaltDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .randomizationSalt)
        randomizationSalt = randomizationSaltDecoded
        let samplingRateDecoded = try containerValues.decode(Swift.Int.self, forKey: .samplingRate)
        samplingRate = samplingRateDecoded
        let onlineAbConfigDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.OnlineAbConfig.self, forKey: .onlineAbConfig)
        onlineAbConfig = onlineAbConfigDecoded
    }
}

extension UpdateExperimentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateExperimentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateExperimentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateExperimentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateExperimentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.experiment = output.experiment
        } else {
            self.experiment = nil
        }
    }
}

public struct UpdateExperimentOutputResponse: Swift.Equatable {
    /// A structure containing the configuration details of the experiment that was updated.
    /// This member is required.
    public var experiment: EvidentlyClientTypes.Experiment?

    public init (
        experiment: EvidentlyClientTypes.Experiment? = nil
    )
    {
        self.experiment = experiment
    }
}

struct UpdateExperimentOutputResponseBody: Swift.Equatable {
    let experiment: EvidentlyClientTypes.Experiment?
}

extension UpdateExperimentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experiment
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.Experiment.self, forKey: .experiment)
        experiment = experimentDecoded
    }
}

extension UpdateFeatureInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addOrUpdateVariations
        case defaultVariation
        case description
        case entityOverrides
        case evaluationStrategy
        case removeVariations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addOrUpdateVariations = addOrUpdateVariations {
            var addOrUpdateVariationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addOrUpdateVariations)
            for variationconfigslist0 in addOrUpdateVariations {
                try addOrUpdateVariationsContainer.encode(variationconfigslist0)
            }
        }
        if let defaultVariation = defaultVariation {
            try encodeContainer.encode(defaultVariation, forKey: .defaultVariation)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entityOverrides = entityOverrides {
            var entityOverridesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .entityOverrides)
            for (dictKey0, entityoverridemap0) in entityOverrides {
                try entityOverridesContainer.encode(entityoverridemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let evaluationStrategy = evaluationStrategy {
            try encodeContainer.encode(evaluationStrategy.rawValue, forKey: .evaluationStrategy)
        }
        if let removeVariations = removeVariations {
            var removeVariationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .removeVariations)
            for variationnamelist0 in removeVariations {
                try removeVariationsContainer.encode(variationnamelist0)
            }
        }
    }
}

extension UpdateFeatureInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        guard let feature = feature else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/features/\(feature.urlPercentEncoding())"
    }
}

public struct UpdateFeatureInput: Swift.Equatable {
    /// To update variation configurations for this feature, or add new ones, specify this structure. In this array, include any variations that you want to add or update. If the array includes a variation name that already exists for this feature, it is updated. If it includes a new variation name, it is added as a new variation.
    public var addOrUpdateVariations: [EvidentlyClientTypes.VariationConfig]?
    /// The name of the variation to use as the default variation. The default variation is served to users who are not allocated to any ongoing launches or experiments of this feature.
    public var defaultVariation: Swift.String?
    /// An optional description of the feature.
    public var description: Swift.String?
    /// Specified users that should always be served a specific variation of a feature. Each user is specified by a key-value pair . For each key, specify a user by entering their user ID, account ID, or some other identifier. For the value, specify the name of the variation that they are to be served.
    public var entityOverrides: [Swift.String:Swift.String]?
    /// Specify ALL_RULES to activate the traffic allocation specified by any ongoing launches or experiments. Specify DEFAULT_VARIATION to serve the default variation to all users instead.
    public var evaluationStrategy: EvidentlyClientTypes.FeatureEvaluationStrategy?
    /// The name of the feature to be updated.
    /// This member is required.
    public var feature: Swift.String?
    /// The name or ARN of the project that contains the feature to be updated.
    /// This member is required.
    public var project: Swift.String?
    /// Removes a variation from the feature. If the variation you specify doesn't exist, then this makes no change and does not report an error. This operation fails if you try to remove a variation that is part of an ongoing launch or experiment.
    public var removeVariations: [Swift.String]?

    public init (
        addOrUpdateVariations: [EvidentlyClientTypes.VariationConfig]? = nil,
        defaultVariation: Swift.String? = nil,
        description: Swift.String? = nil,
        entityOverrides: [Swift.String:Swift.String]? = nil,
        evaluationStrategy: EvidentlyClientTypes.FeatureEvaluationStrategy? = nil,
        feature: Swift.String? = nil,
        project: Swift.String? = nil,
        removeVariations: [Swift.String]? = nil
    )
    {
        self.addOrUpdateVariations = addOrUpdateVariations
        self.defaultVariation = defaultVariation
        self.description = description
        self.entityOverrides = entityOverrides
        self.evaluationStrategy = evaluationStrategy
        self.feature = feature
        self.project = project
        self.removeVariations = removeVariations
    }
}

struct UpdateFeatureInputBody: Swift.Equatable {
    let evaluationStrategy: EvidentlyClientTypes.FeatureEvaluationStrategy?
    let description: Swift.String?
    let addOrUpdateVariations: [EvidentlyClientTypes.VariationConfig]?
    let removeVariations: [Swift.String]?
    let defaultVariation: Swift.String?
    let entityOverrides: [Swift.String:Swift.String]?
}

extension UpdateFeatureInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addOrUpdateVariations
        case defaultVariation
        case description
        case entityOverrides
        case evaluationStrategy
        case removeVariations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationStrategyDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.FeatureEvaluationStrategy.self, forKey: .evaluationStrategy)
        evaluationStrategy = evaluationStrategyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let addOrUpdateVariationsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.VariationConfig?].self, forKey: .addOrUpdateVariations)
        var addOrUpdateVariationsDecoded0:[EvidentlyClientTypes.VariationConfig]? = nil
        if let addOrUpdateVariationsContainer = addOrUpdateVariationsContainer {
            addOrUpdateVariationsDecoded0 = [EvidentlyClientTypes.VariationConfig]()
            for structure0 in addOrUpdateVariationsContainer {
                if let structure0 = structure0 {
                    addOrUpdateVariationsDecoded0?.append(structure0)
                }
            }
        }
        addOrUpdateVariations = addOrUpdateVariationsDecoded0
        let removeVariationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .removeVariations)
        var removeVariationsDecoded0:[Swift.String]? = nil
        if let removeVariationsContainer = removeVariationsContainer {
            removeVariationsDecoded0 = [Swift.String]()
            for string0 in removeVariationsContainer {
                if let string0 = string0 {
                    removeVariationsDecoded0?.append(string0)
                }
            }
        }
        removeVariations = removeVariationsDecoded0
        let defaultVariationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultVariation)
        defaultVariation = defaultVariationDecoded
        let entityOverridesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .entityOverrides)
        var entityOverridesDecoded0: [Swift.String:Swift.String]? = nil
        if let entityOverridesContainer = entityOverridesContainer {
            entityOverridesDecoded0 = [Swift.String:Swift.String]()
            for (key0, variationname0) in entityOverridesContainer {
                if let variationname0 = variationname0 {
                    entityOverridesDecoded0?[key0] = variationname0
                }
            }
        }
        entityOverrides = entityOverridesDecoded0
    }
}

extension UpdateFeatureOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFeatureOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFeatureOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFeatureOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFeatureOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.feature = output.feature
        } else {
            self.feature = nil
        }
    }
}

public struct UpdateFeatureOutputResponse: Swift.Equatable {
    /// A structure that contains information about the updated feature.
    /// This member is required.
    public var feature: EvidentlyClientTypes.Feature?

    public init (
        feature: EvidentlyClientTypes.Feature? = nil
    )
    {
        self.feature = feature
    }
}

struct UpdateFeatureOutputResponseBody: Swift.Equatable {
    let feature: EvidentlyClientTypes.Feature?
}

extension UpdateFeatureOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case feature
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.Feature.self, forKey: .feature)
        feature = featureDecoded
    }
}

extension UpdateLaunchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case groups
        case metricMonitors
        case randomizationSalt
        case scheduledSplitsConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for launchgroupconfiglist0 in groups {
                try groupsContainer.encode(launchgroupconfiglist0)
            }
        }
        if let metricMonitors = metricMonitors {
            var metricMonitorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricMonitors)
            for metricmonitorconfiglist0 in metricMonitors {
                try metricMonitorsContainer.encode(metricmonitorconfiglist0)
            }
        }
        if let randomizationSalt = randomizationSalt {
            try encodeContainer.encode(randomizationSalt, forKey: .randomizationSalt)
        }
        if let scheduledSplitsConfig = scheduledSplitsConfig {
            try encodeContainer.encode(scheduledSplitsConfig, forKey: .scheduledSplitsConfig)
        }
    }
}

extension UpdateLaunchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        guard let launch = launch else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/launches/\(launch.urlPercentEncoding())"
    }
}

public struct UpdateLaunchInput: Swift.Equatable {
    /// An optional description for the launch.
    public var description: Swift.String?
    /// An array of structures that contains the feature and variations that are to be used for the launch.
    public var groups: [EvidentlyClientTypes.LaunchGroupConfig]?
    /// The name of the launch that is to be updated.
    /// This member is required.
    public var launch: Swift.String?
    /// An array of structures that define the metrics that will be used to monitor the launch performance.
    public var metricMonitors: [EvidentlyClientTypes.MetricMonitorConfig]?
    /// The name or ARN of the project that contains the launch that you want to update.
    /// This member is required.
    public var project: Swift.String?
    /// When Evidently assigns a particular user session to a launch, it must use a randomization ID to determine which variation the user session is served. This randomization ID is a combination of the entity ID and randomizationSalt. If you omit randomizationSalt, Evidently uses the launch name as the randomizationSalt.
    public var randomizationSalt: Swift.String?
    /// An array of structures that define the traffic allocation percentages among the feature variations during each step of the launch.
    public var scheduledSplitsConfig: EvidentlyClientTypes.ScheduledSplitsLaunchConfig?

    public init (
        description: Swift.String? = nil,
        groups: [EvidentlyClientTypes.LaunchGroupConfig]? = nil,
        launch: Swift.String? = nil,
        metricMonitors: [EvidentlyClientTypes.MetricMonitorConfig]? = nil,
        project: Swift.String? = nil,
        randomizationSalt: Swift.String? = nil,
        scheduledSplitsConfig: EvidentlyClientTypes.ScheduledSplitsLaunchConfig? = nil
    )
    {
        self.description = description
        self.groups = groups
        self.launch = launch
        self.metricMonitors = metricMonitors
        self.project = project
        self.randomizationSalt = randomizationSalt
        self.scheduledSplitsConfig = scheduledSplitsConfig
    }
}

struct UpdateLaunchInputBody: Swift.Equatable {
    let description: Swift.String?
    let groups: [EvidentlyClientTypes.LaunchGroupConfig]?
    let metricMonitors: [EvidentlyClientTypes.MetricMonitorConfig]?
    let randomizationSalt: Swift.String?
    let scheduledSplitsConfig: EvidentlyClientTypes.ScheduledSplitsLaunchConfig?
}

extension UpdateLaunchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case groups
        case metricMonitors
        case randomizationSalt
        case scheduledSplitsConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let groupsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.LaunchGroupConfig?].self, forKey: .groups)
        var groupsDecoded0:[EvidentlyClientTypes.LaunchGroupConfig]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [EvidentlyClientTypes.LaunchGroupConfig]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let metricMonitorsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.MetricMonitorConfig?].self, forKey: .metricMonitors)
        var metricMonitorsDecoded0:[EvidentlyClientTypes.MetricMonitorConfig]? = nil
        if let metricMonitorsContainer = metricMonitorsContainer {
            metricMonitorsDecoded0 = [EvidentlyClientTypes.MetricMonitorConfig]()
            for structure0 in metricMonitorsContainer {
                if let structure0 = structure0 {
                    metricMonitorsDecoded0?.append(structure0)
                }
            }
        }
        metricMonitors = metricMonitorsDecoded0
        let randomizationSaltDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .randomizationSalt)
        randomizationSalt = randomizationSaltDecoded
        let scheduledSplitsConfigDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ScheduledSplitsLaunchConfig.self, forKey: .scheduledSplitsConfig)
        scheduledSplitsConfig = scheduledSplitsConfigDecoded
    }
}

extension UpdateLaunchOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLaunchOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLaunchOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLaunchOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateLaunchOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.launch = output.launch
        } else {
            self.launch = nil
        }
    }
}

public struct UpdateLaunchOutputResponse: Swift.Equatable {
    /// A structure that contains the new configuration of the launch that was updated.
    /// This member is required.
    public var launch: EvidentlyClientTypes.Launch?

    public init (
        launch: EvidentlyClientTypes.Launch? = nil
    )
    {
        self.launch = launch
    }
}

struct UpdateLaunchOutputResponseBody: Swift.Equatable {
    let launch: EvidentlyClientTypes.Launch?
}

extension UpdateLaunchOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launch
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.Launch.self, forKey: .launch)
        launch = launchDecoded
    }
}

extension UpdateProjectDataDeliveryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogs
        case s3Destination
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogs = cloudWatchLogs {
            try encodeContainer.encode(cloudWatchLogs, forKey: .cloudWatchLogs)
        }
        if let s3Destination = s3Destination {
            try encodeContainer.encode(s3Destination, forKey: .s3Destination)
        }
    }
}

extension UpdateProjectDataDeliveryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/data-delivery"
    }
}

public struct UpdateProjectDataDeliveryInput: Swift.Equatable {
    /// A structure containing the CloudWatch Logs log group where you want to store evaluation events.
    public var cloudWatchLogs: EvidentlyClientTypes.CloudWatchLogsDestinationConfig?
    /// The name or ARN of the project that you want to modify the data storage options for.
    /// This member is required.
    public var project: Swift.String?
    /// A structure containing the S3 bucket name and bucket prefix where you want to store evaluation events.
    public var s3Destination: EvidentlyClientTypes.S3DestinationConfig?

    public init (
        cloudWatchLogs: EvidentlyClientTypes.CloudWatchLogsDestinationConfig? = nil,
        project: Swift.String? = nil,
        s3Destination: EvidentlyClientTypes.S3DestinationConfig? = nil
    )
    {
        self.cloudWatchLogs = cloudWatchLogs
        self.project = project
        self.s3Destination = s3Destination
    }
}

struct UpdateProjectDataDeliveryInputBody: Swift.Equatable {
    let s3Destination: EvidentlyClientTypes.S3DestinationConfig?
    let cloudWatchLogs: EvidentlyClientTypes.CloudWatchLogsDestinationConfig?
}

extension UpdateProjectDataDeliveryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogs
        case s3Destination
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DestinationDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.S3DestinationConfig.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
        let cloudWatchLogsDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.CloudWatchLogsDestinationConfig.self, forKey: .cloudWatchLogs)
        cloudWatchLogs = cloudWatchLogsDecoded
    }
}

extension UpdateProjectDataDeliveryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProjectDataDeliveryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProjectDataDeliveryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProjectDataDeliveryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateProjectDataDeliveryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.project = output.project
        } else {
            self.project = nil
        }
    }
}

public struct UpdateProjectDataDeliveryOutputResponse: Swift.Equatable {
    /// A structure containing details about the project that you updated.
    /// This member is required.
    public var project: EvidentlyClientTypes.Project?

    public init (
        project: EvidentlyClientTypes.Project? = nil
    )
    {
        self.project = project
    }
}

struct UpdateProjectDataDeliveryOutputResponseBody: Swift.Equatable {
    let project: EvidentlyClientTypes.Project?
}

extension UpdateProjectDataDeliveryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case project
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.Project.self, forKey: .project)
        project = projectDecoded
    }
}

extension UpdateProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())"
    }
}

public struct UpdateProjectInput: Swift.Equatable {
    /// An optional description of the project.
    public var description: Swift.String?
    /// The name or ARN of the project to update.
    /// This member is required.
    public var project: Swift.String?

    public init (
        description: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.description = description
        self.project = project
    }
}

struct UpdateProjectInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProjectOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.project = output.project
        } else {
            self.project = nil
        }
    }
}

public struct UpdateProjectOutputResponse: Swift.Equatable {
    /// A structure containing information about the updated project.
    /// This member is required.
    public var project: EvidentlyClientTypes.Project?

    public init (
        project: EvidentlyClientTypes.Project? = nil
    )
    {
        self.project = project
    }
}

struct UpdateProjectOutputResponseBody: Swift.Equatable {
    let project: EvidentlyClientTypes.Project?
}

extension UpdateProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case project
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.Project.self, forKey: .project)
        project = projectDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fieldList = output.fieldList
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fieldList = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The value of a parameter in the request caused an error.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The parameter that caused the exception.
    public var fieldList: [EvidentlyClientTypes.ValidationExceptionField]?
    public var message: Swift.String?
    /// A reason for the error.
    public var reason: EvidentlyClientTypes.ValidationExceptionReason?

    public init (
        fieldList: [EvidentlyClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: EvidentlyClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fieldList = fieldList
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: EvidentlyClientTypes.ValidationExceptionReason?
    let fieldList: [EvidentlyClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[EvidentlyClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [EvidentlyClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension EvidentlyClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EvidentlyClientTypes {
    /// A structure containing an error name and message.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The error message.
        /// This member is required.
        public var message: Swift.String?
        /// The error name.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension EvidentlyClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension EvidentlyClientTypes.VariableValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case boolvalue = "boolValue"
        case doublevalue = "doubleValue"
        case longvalue = "longValue"
        case sdkUnknown
        case stringvalue = "stringValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .boolvalue(boolvalue):
                try container.encode(boolvalue, forKey: .boolvalue)
            case let .doublevalue(doublevalue):
                try container.encode(doublevalue, forKey: .doublevalue)
            case let .longvalue(longvalue):
                try container.encode(longvalue, forKey: .longvalue)
            case let .stringvalue(stringvalue):
                try container.encode(stringvalue, forKey: .stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let boolvalueDecoded = try values.decodeIfPresent(Swift.Bool.self, forKey: .boolvalue)
        if let boolvalue = boolvalueDecoded {
            self = .boolvalue(boolvalue)
            return
        }
        let stringvalueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .stringvalue)
        if let stringvalue = stringvalueDecoded {
            self = .stringvalue(stringvalue)
            return
        }
        let longvalueDecoded = try values.decodeIfPresent(Swift.Int.self, forKey: .longvalue)
        if let longvalue = longvalueDecoded {
            self = .longvalue(longvalue)
            return
        }
        let doublevalueDecoded = try values.decodeIfPresent(Swift.Double.self, forKey: .doublevalue)
        if let doublevalue = doublevalueDecoded {
            self = .doublevalue(doublevalue)
            return
        }
        self = .sdkUnknown("")
    }
}

extension EvidentlyClientTypes {
    /// The value assigned to a feature variation. This structure must contain exactly one field. It can be boolValue, doubleValue, longValue, or stringValue.
    public enum VariableValue: Swift.Equatable {
        /// If this feature uses the Boolean variation type, this field contains the Boolean value of this variation.
        case boolvalue(Swift.Bool)
        /// If this feature uses the string variation type, this field contains the string value of this variation.
        case stringvalue(Swift.String)
        /// If this feature uses the long variation type, this field contains the long value of this variation.
        case longvalue(Swift.Int)
        /// If this feature uses the double integer variation type, this field contains the double integer value of this variation.
        case doublevalue(Swift.Double)
        case sdkUnknown(Swift.String)
    }

}

extension EvidentlyClientTypes.Variation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.VariableValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension EvidentlyClientTypes {
    /// This structure contains the name and variation value of one variation of a feature.
    public struct Variation: Swift.Equatable {
        /// The name of the variation.
        public var name: Swift.String?
        /// The value assigned to this variation.
        public var value: EvidentlyClientTypes.VariableValue?

        public init (
            name: Swift.String? = nil,
            value: EvidentlyClientTypes.VariableValue? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension EvidentlyClientTypes.VariationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.VariableValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension EvidentlyClientTypes {
    /// This structure contains the name and variation value of one variation of a feature.
    public struct VariationConfig: Swift.Equatable {
        /// The name of the variation.
        /// This member is required.
        public var name: Swift.String?
        /// The value assigned to this variation.
        /// This member is required.
        public var value: EvidentlyClientTypes.VariableValue?

        public init (
            name: Swift.String? = nil,
            value: EvidentlyClientTypes.VariableValue? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension EvidentlyClientTypes {
    public enum VariationValueType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case boolean
        case double
        case long
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [VariationValueType] {
            return [
                .boolean,
                .double,
                .long,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "BOOLEAN"
            case .double: return "DOUBLE"
            case .long: return "LONG"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VariationValueType(rawValue: rawValue) ?? VariationValueType.sdkUnknown(rawValue)
        }
    }
}
