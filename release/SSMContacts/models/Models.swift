// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AcceptPageInputBodyMiddleware: Middleware {
    public let id: String = "AcceptPageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptPageInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptPageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptPageInput>
    public typealias MOutput = OperationOutput<AcceptPageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptPageOutputError>
}

extension AcceptPageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptPageInput(acceptCode: \(String(describing: acceptCode)), acceptType: \(String(describing: acceptType)), contactChannelId: \(String(describing: contactChannelId)), note: \(String(describing: note)), pageId: \(String(describing: pageId)))"}
}

extension AcceptPageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptCode = "AcceptCode"
        case acceptType = "AcceptType"
        case contactChannelId = "ContactChannelId"
        case note = "Note"
        case pageId = "PageId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptCode = acceptCode {
            try encodeContainer.encode(acceptCode, forKey: .acceptCode)
        }
        if let acceptType = acceptType {
            try encodeContainer.encode(acceptType.rawValue, forKey: .acceptType)
        }
        if let contactChannelId = contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
        if let note = note {
            try encodeContainer.encode(note, forKey: .note)
        }
        if let pageId = pageId {
            try encodeContainer.encode(pageId, forKey: .pageId)
        }
    }
}

public struct AcceptPageInputHeadersMiddleware: Middleware {
    public let id: String = "AcceptPageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptPageInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptPageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptPageInput>
    public typealias MOutput = OperationOutput<AcceptPageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptPageOutputError>
}

public struct AcceptPageInputQueryItemMiddleware: Middleware {
    public let id: String = "AcceptPageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptPageInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptPageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptPageInput>
    public typealias MOutput = OperationOutput<AcceptPageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptPageOutputError>
}

public struct AcceptPageInput: Equatable {
    /// <p>The accept code is a 6-digit code used to acknowledge the page.</p>
    public let acceptCode: String?
    /// <p>The type indicates if the page was <code>DELIVERED</code> or <code>READ</code>.</p>
    public let acceptType: AcceptType?
    /// <p>The ARN of the contact channel.</p>
    public let contactChannelId: String?
    /// <p>Information provided by the user when the user acknowledges the page.</p>
    public let note: String?
    /// <p>The Amazon Resource Name (ARN) of the engagement to a contact channel.</p>
    public let pageId: String?

    public init (
        acceptCode: String? = nil,
        acceptType: AcceptType? = nil,
        contactChannelId: String? = nil,
        note: String? = nil,
        pageId: String? = nil
    )
    {
        self.acceptCode = acceptCode
        self.acceptType = acceptType
        self.contactChannelId = contactChannelId
        self.note = note
        self.pageId = pageId
    }
}

struct AcceptPageInputBody: Equatable {
    public let pageId: String?
    public let contactChannelId: String?
    public let acceptType: AcceptType?
    public let note: String?
    public let acceptCode: String?
}

extension AcceptPageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptCode = "AcceptCode"
        case acceptType = "AcceptType"
        case contactChannelId = "ContactChannelId"
        case note = "Note"
        case pageId = "PageId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pageId)
        pageId = pageIdDecoded
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
        let acceptTypeDecoded = try containerValues.decodeIfPresent(AcceptType.self, forKey: .acceptType)
        acceptType = acceptTypeDecoded
        let noteDecoded = try containerValues.decodeIfPresent(String.self, forKey: .note)
        note = noteDecoded
        let acceptCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptCode)
        acceptCode = acceptCodeDecoded
    }
}

extension AcceptPageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptPageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcceptPageOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptPageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptPageOutputResponse()"}
}

extension AcceptPageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AcceptPageOutputResponse: Equatable {

    public init() {}
}

struct AcceptPageOutputResponseBody: Equatable {
}

extension AcceptPageOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum AcceptType {
    case delivered
    case read
    case sdkUnknown(String)
}

extension AcceptType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AcceptType] {
        return [
            .delivered,
            .read,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .delivered: return "DELIVERED"
        case .read: return "READ"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AcceptType(rawValue: rawValue) ?? AcceptType.sdkUnknown(rawValue)
    }
}

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You don't have sufficient access to perform this action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ActivateContactChannelInputBodyMiddleware: Middleware {
    public let id: String = "ActivateContactChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ActivateContactChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<ActivateContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ActivateContactChannelInput>
    public typealias MOutput = OperationOutput<ActivateContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ActivateContactChannelOutputError>
}

extension ActivateContactChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActivateContactChannelInput(activationCode: \(String(describing: activationCode)), contactChannelId: \(String(describing: contactChannelId)))"}
}

extension ActivateContactChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activationCode = "ActivationCode"
        case contactChannelId = "ContactChannelId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationCode = activationCode {
            try encodeContainer.encode(activationCode, forKey: .activationCode)
        }
        if let contactChannelId = contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
    }
}

public struct ActivateContactChannelInputHeadersMiddleware: Middleware {
    public let id: String = "ActivateContactChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ActivateContactChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<ActivateContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ActivateContactChannelInput>
    public typealias MOutput = OperationOutput<ActivateContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ActivateContactChannelOutputError>
}

public struct ActivateContactChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "ActivateContactChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ActivateContactChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<ActivateContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ActivateContactChannelInput>
    public typealias MOutput = OperationOutput<ActivateContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ActivateContactChannelOutputError>
}

public struct ActivateContactChannelInput: Equatable {
    /// <p>The code sent to the contact channel when it was created in the contact. </p>
    public let activationCode: String?
    /// <p>The Amazon Resource Name (ARN) of the contact channel.</p>
    public let contactChannelId: String?

    public init (
        activationCode: String? = nil,
        contactChannelId: String? = nil
    )
    {
        self.activationCode = activationCode
        self.contactChannelId = contactChannelId
    }
}

struct ActivateContactChannelInputBody: Equatable {
    public let contactChannelId: String?
    public let activationCode: String?
}

extension ActivateContactChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case activationCode = "ActivationCode"
        case contactChannelId = "ContactChannelId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
        let activationCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .activationCode)
        activationCode = activationCodeDecoded
    }
}

extension ActivateContactChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ActivateContactChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ActivateContactChannelOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ActivateContactChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActivateContactChannelOutputResponse()"}
}

extension ActivateContactChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ActivateContactChannelOutputResponse: Equatable {

    public init() {}
}

struct ActivateContactChannelOutputResponseBody: Equatable {
}

extension ActivateContactChannelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum ActivationStatus {
    case activated
    case notActivated
    case sdkUnknown(String)
}

extension ActivationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ActivationStatus] {
        return [
            .activated,
            .notActivated,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .activated: return "ACTIVATED"
        case .notActivated: return "NOT_ACTIVATED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ActivationStatus(rawValue: rawValue) ?? ActivationStatus.sdkUnknown(rawValue)
    }
}

extension ChannelTargetInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactChannelId = "ContactChannelId"
        case retryIntervalInMinutes = "RetryIntervalInMinutes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactChannelId = contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
        if let retryIntervalInMinutes = retryIntervalInMinutes {
            try encodeContainer.encode(retryIntervalInMinutes, forKey: .retryIntervalInMinutes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
        let retryIntervalInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .retryIntervalInMinutes)
        retryIntervalInMinutes = retryIntervalInMinutesDecoded
    }
}

extension ChannelTargetInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ChannelTargetInfo(contactChannelId: \(String(describing: contactChannelId)), retryIntervalInMinutes: \(String(describing: retryIntervalInMinutes)))"}
}

/// <p>Information about the contact channel that Incident Manager uses to engage the
///          contact.</p>
public struct ChannelTargetInfo: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the contact channel.</p>
    public let contactChannelId: String?
    /// <p>The number of minutes to wait to retry sending engagement in the case the engagement
    ///          initially fails.</p>
    public let retryIntervalInMinutes: Int?

    public init (
        contactChannelId: String? = nil,
        retryIntervalInMinutes: Int? = nil
    )
    {
        self.contactChannelId = contactChannelId
        self.retryIntervalInMinutes = retryIntervalInMinutes
    }
}

public enum ChannelType {
    case email
    case sms
    case voice
    case sdkUnknown(String)
}

extension ChannelType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ChannelType] {
        return [
            .email,
            .sms,
            .voice,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .email: return "EMAIL"
        case .sms: return "SMS"
        case .voice: return "VOICE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ChannelType(rawValue: rawValue) ?? ChannelType.sdkUnknown(rawValue)
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Updating or deleting a resource causes an inconsistent state.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// Identifier of the resource in use
    public var resourceId: String?
    /// ype of the resource in use
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension Contact: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alias = "Alias"
        case contactArn = "ContactArn"
        case displayName = "DisplayName"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alias)
        alias = aliasDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ContactType.self, forKey: .type)
        type = typeDecoded
    }
}

extension Contact: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Contact(alias: \(String(describing: alias)), contactArn: \(String(describing: contactArn)), displayName: \(String(describing: displayName)), type: \(String(describing: type)))"}
}

/// <p>A personal contact or escalation plan that Incident Manager engages during an
///          incident.</p>
public struct Contact: Equatable {
    /// <p>The unique and identifiable alias of the contact or escalation plan.</p>
    public let alias: String?
    /// <p>The Amazon Resource Name (ARN) of the contact or escalation plan.</p>
    public let contactArn: String?
    /// <p>The full name of the contact or escalation plan.</p>
    public let displayName: String?
    /// <p>Refers to the type of contact. A single contact is type <code>PERSONAL</code> and an
    ///          escalation plan is type <code>ESCALATION</code>.</p>
    public let type: ContactType?

    public init (
        alias: String? = nil,
        contactArn: String? = nil,
        displayName: String? = nil,
        type: ContactType? = nil
    )
    {
        self.alias = alias
        self.contactArn = contactArn
        self.displayName = displayName
        self.type = type
    }
}

extension ContactChannel: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activationStatus = "ActivationStatus"
        case contactArn = "ContactArn"
        case contactChannelArn = "ContactChannelArn"
        case deliveryAddress = "DeliveryAddress"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationStatus = activationStatus {
            try encodeContainer.encode(activationStatus.rawValue, forKey: .activationStatus)
        }
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let contactChannelArn = contactChannelArn {
            try encodeContainer.encode(contactChannelArn, forKey: .contactChannelArn)
        }
        if let deliveryAddress = deliveryAddress {
            try encodeContainer.encode(deliveryAddress, forKey: .deliveryAddress)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactChannelArn)
        contactChannelArn = contactChannelArnDecoded
        let contactArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChannelType.self, forKey: .type)
        type = typeDecoded
        let deliveryAddressDecoded = try containerValues.decodeIfPresent(ContactChannelAddress.self, forKey: .deliveryAddress)
        deliveryAddress = deliveryAddressDecoded
        let activationStatusDecoded = try containerValues.decodeIfPresent(ActivationStatus.self, forKey: .activationStatus)
        activationStatus = activationStatusDecoded
    }
}

extension ContactChannel: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContactChannel(activationStatus: \(String(describing: activationStatus)), contactArn: \(String(describing: contactArn)), contactChannelArn: \(String(describing: contactChannelArn)), deliveryAddress: \(String(describing: deliveryAddress)), name: \(String(describing: name)), type: \(String(describing: type)))"}
}

/// <p>The method that Incident Manager uses to engage a contact.</p>
public struct ContactChannel: Equatable {
    /// <p>A Boolean value describing if the contact channel has been activated or not. If the
    ///          contact channel isn't activated, Incident Manager can't engage the contact through it. </p>
    public let activationStatus: ActivationStatus?
    /// <p>The ARN of the contact that contains the contact channel.</p>
    public let contactArn: String?
    /// <p>The Amazon Resource Name (ARN) of the contact channel.</p>
    public let contactChannelArn: String?
    /// <p>The details that Incident Manager uses when trying to engage the contact channel.</p>
    public let deliveryAddress: ContactChannelAddress?
    /// <p>The name of the contact channel.</p>
    public let name: String?
    /// <p>The type of the contact channel. Incident Manager supports three contact methods:</p>
    ///          <ul>
    ///             <li>
    ///                <p>SMS</p>
    ///             </li>
    ///             <li>
    ///                <p>VOICE</p>
    ///             </li>
    ///             <li>
    ///                <p>EMAIL</p>
    ///             </li>
    ///          </ul>
    public let type: ChannelType?

    public init (
        activationStatus: ActivationStatus? = nil,
        contactArn: String? = nil,
        contactChannelArn: String? = nil,
        deliveryAddress: ContactChannelAddress? = nil,
        name: String? = nil,
        type: ChannelType? = nil
    )
    {
        self.activationStatus = activationStatus
        self.contactArn = contactArn
        self.contactChannelArn = contactChannelArn
        self.deliveryAddress = deliveryAddress
        self.name = name
        self.type = type
    }
}

extension ContactChannelAddress: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case simpleAddress = "SimpleAddress"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let simpleAddress = simpleAddress {
            try encodeContainer.encode(simpleAddress, forKey: .simpleAddress)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simpleAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .simpleAddress)
        simpleAddress = simpleAddressDecoded
    }
}

extension ContactChannelAddress: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContactChannelAddress(simpleAddress: \(String(describing: simpleAddress)))"}
}

/// <p>The details that Incident Manager uses when trying to engage the contact channel. </p>
public struct ContactChannelAddress: Equatable {
    /// <p>The format is dependent on the type of the contact channel. The following are the
    ///          expected formats:</p>
    ///          <ul>
    ///             <li>
    ///                <p>SMS - '+' followed by the country code and phone number</p>
    ///             </li>
    ///             <li>
    ///                <p>VOICE - '+' followed by the country code and phone number</p>
    ///             </li>
    ///             <li>
    ///                <p>EMAIL - any standard email format</p>
    ///             </li>
    ///          </ul>
    public let simpleAddress: String?

    public init (
        simpleAddress: String? = nil
    )
    {
        self.simpleAddress = simpleAddress
    }
}

extension ContactTargetInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
        case isEssential = "IsEssential"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let isEssential = isEssential {
            try encodeContainer.encode(isEssential, forKey: .isEssential)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let isEssentialDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isEssential)
        isEssential = isEssentialDecoded
    }
}

extension ContactTargetInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContactTargetInfo(contactId: \(String(describing: contactId)), isEssential: \(String(describing: isEssential)))"}
}

/// <p>The contact that Incident Manager is engaging during an incident.</p>
public struct ContactTargetInfo: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the contact.</p>
    public let contactId: String?
    /// <p>A Boolean value determining if the contact's acknowledgement stops the progress of
    ///          stages in the plan.</p>
    public let isEssential: Bool?

    public init (
        contactId: String? = nil,
        isEssential: Bool? = nil
    )
    {
        self.contactId = contactId
        self.isEssential = isEssential
    }
}

public enum ContactType {
    case escalation
    case personal
    case sdkUnknown(String)
}

extension ContactType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ContactType] {
        return [
            .escalation,
            .personal,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .escalation: return "ESCALATION"
        case .personal: return "PERSONAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ContactType(rawValue: rawValue) ?? ContactType.sdkUnknown(rawValue)
    }
}

public struct CreateContactChannelInputBodyMiddleware: Middleware {
    public let id: String = "CreateContactChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateContactChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateContactChannelInput>
    public typealias MOutput = OperationOutput<CreateContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateContactChannelOutputError>
}

extension CreateContactChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateContactChannelInput(contactId: \(String(describing: contactId)), deferActivation: \(String(describing: deferActivation)), deliveryAddress: \(String(describing: deliveryAddress)), idempotencyToken: \(String(describing: idempotencyToken)), name: \(String(describing: name)), type: \(String(describing: type)))"}
}

extension CreateContactChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
        case deferActivation = "DeferActivation"
        case deliveryAddress = "DeliveryAddress"
        case idempotencyToken = "IdempotencyToken"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let deferActivation = deferActivation {
            try encodeContainer.encode(deferActivation, forKey: .deferActivation)
        }
        if let deliveryAddress = deliveryAddress {
            try encodeContainer.encode(deliveryAddress, forKey: .deliveryAddress)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateContactChannelInputHeadersMiddleware: Middleware {
    public let id: String = "CreateContactChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateContactChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateContactChannelInput>
    public typealias MOutput = OperationOutput<CreateContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateContactChannelOutputError>
}

public struct CreateContactChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateContactChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateContactChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateContactChannelInput>
    public typealias MOutput = OperationOutput<CreateContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateContactChannelOutputError>
}

public struct CreateContactChannelInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the contact channel.</p>
    public let contactId: String?
    /// <p>If you want to activate the channel at a later time, you can choose to defer activation.
    ///          Incident Manager can't engage your contact channel until it has been activated.</p>
    public let deferActivation: Bool?
    /// <p>The details that Incident Manager uses when trying to engage the contact channel. The format
    ///          is dependent on the type of the contact channel. The following are the expected
    ///          formats:</p>
    ///          <ul>
    ///             <li>
    ///                <p>SMS - '+' followed by the country code and phone number</p>
    ///             </li>
    ///             <li>
    ///                <p>VOICE - '+' followed by the country code and phone number</p>
    ///             </li>
    ///             <li>
    ///                <p>EMAIL - any standard email format</p>
    ///             </li>
    ///          </ul>
    public let deliveryAddress: ContactChannelAddress?
    /// <p>A token ensuring that the action is called only once with the specified details.</p>
    public var idempotencyToken: String?
    /// <p>The name of the contact channel.</p>
    public let name: String?
    /// <p>Incident Manager supports three types of contact channels:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>SMS</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>VOICE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>EMAIL</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let type: ChannelType?

    public init (
        contactId: String? = nil,
        deferActivation: Bool? = nil,
        deliveryAddress: ContactChannelAddress? = nil,
        idempotencyToken: String? = nil,
        name: String? = nil,
        type: ChannelType? = nil
    )
    {
        self.contactId = contactId
        self.deferActivation = deferActivation
        self.deliveryAddress = deliveryAddress
        self.idempotencyToken = idempotencyToken
        self.name = name
        self.type = type
    }
}

struct CreateContactChannelInputBody: Equatable {
    public let contactId: String?
    public let name: String?
    public let type: ChannelType?
    public let deliveryAddress: ContactChannelAddress?
    public let deferActivation: Bool?
    public let idempotencyToken: String?
}

extension CreateContactChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
        case deferActivation = "DeferActivation"
        case deliveryAddress = "DeliveryAddress"
        case idempotencyToken = "IdempotencyToken"
        case name = "Name"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChannelType.self, forKey: .type)
        type = typeDecoded
        let deliveryAddressDecoded = try containerValues.decodeIfPresent(ContactChannelAddress.self, forKey: .deliveryAddress)
        deliveryAddress = deliveryAddressDecoded
        let deferActivationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .deferActivation)
        deferActivation = deferActivationDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateContactChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateContactChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateContactChannelOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateContactChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateContactChannelOutputResponse(contactChannelArn: \(String(describing: contactChannelArn)))"}
}

extension CreateContactChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateContactChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactChannelArn = output.contactChannelArn
        } else {
            self.contactChannelArn = nil
        }
    }
}

public struct CreateContactChannelOutputResponse: Equatable {
    /// <p>The ARN of the contact channel.</p>
    public let contactChannelArn: String?

    public init (
        contactChannelArn: String? = nil
    )
    {
        self.contactChannelArn = contactChannelArn
    }
}

struct CreateContactChannelOutputResponseBody: Equatable {
    public let contactChannelArn: String?
}

extension CreateContactChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactChannelArn = "ContactChannelArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactChannelArn)
        contactChannelArn = contactChannelArnDecoded
    }
}

public struct CreateContactInputBodyMiddleware: Middleware {
    public let id: String = "CreateContactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateContactInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateContactInput>
    public typealias MOutput = OperationOutput<CreateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateContactOutputError>
}

extension CreateContactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateContactInput(alias: \(String(describing: alias)), displayName: \(String(describing: displayName)), idempotencyToken: \(String(describing: idempotencyToken)), plan: \(String(describing: plan)), tags: \(String(describing: tags)), type: \(String(describing: type)))"}
}

extension CreateContactInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alias = "Alias"
        case displayName = "DisplayName"
        case idempotencyToken = "IdempotencyToken"
        case plan = "Plan"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let plan = plan {
            try encodeContainer.encode(plan, forKey: .plan)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagslist0 in tags {
                try tagsContainer.encode(tagslist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateContactInputHeadersMiddleware: Middleware {
    public let id: String = "CreateContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateContactInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateContactInput>
    public typealias MOutput = OperationOutput<CreateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateContactOutputError>
}

public struct CreateContactInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateContactInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateContactInput>
    public typealias MOutput = OperationOutput<CreateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateContactOutputError>
}

public struct CreateContactInput: Equatable {
    /// <p>The short name to quickly identify a contact or escalation plan. The contact alias must
    ///          be unique and identifiable. </p>
    public let alias: String?
    /// <p>The full name of the contact or escalation plan.  </p>
    public let displayName: String?
    /// <p>A token ensuring that the action is called only once with the specified details.</p>
    public var idempotencyToken: String?
    /// <p>A list of stages. A contact has an engagement plan with stages that contact specified
    ///          contact channels. An escalation plan uses stages that contact specified contacts. </p>
    public let plan: Plan?
    /// <p>Adds a tag to the target. You can only tag resources created in the first Region of your
    ///          replication set. </p>
    public let tags: [Tag]?
    /// <p>To create an escalation plan use <code>ESCALATION</code>. To create a contact use
    ///             <code>PERSONAL</code>.</p>
    public let type: ContactType?

    public init (
        alias: String? = nil,
        displayName: String? = nil,
        idempotencyToken: String? = nil,
        plan: Plan? = nil,
        tags: [Tag]? = nil,
        type: ContactType? = nil
    )
    {
        self.alias = alias
        self.displayName = displayName
        self.idempotencyToken = idempotencyToken
        self.plan = plan
        self.tags = tags
        self.type = type
    }
}

struct CreateContactInputBody: Equatable {
    public let alias: String?
    public let displayName: String?
    public let type: ContactType?
    public let plan: Plan?
    public let tags: [Tag]?
    public let idempotencyToken: String?
}

extension CreateContactInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case alias = "Alias"
        case displayName = "DisplayName"
        case idempotencyToken = "IdempotencyToken"
        case plan = "Plan"
        case tags = "Tags"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alias)
        alias = aliasDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ContactType.self, forKey: .type)
        type = typeDecoded
        let planDecoded = try containerValues.decodeIfPresent(Plan.self, forKey: .plan)
        plan = planDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateContactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateContactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateContactOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateContactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateContactOutputResponse(contactArn: \(String(describing: contactArn)))"}
}

extension CreateContactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateContactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactArn = output.contactArn
        } else {
            self.contactArn = nil
        }
    }
}

public struct CreateContactOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the created contact or escalation plan.</p>
    public let contactArn: String?

    public init (
        contactArn: String? = nil
    )
    {
        self.contactArn = contactArn
    }
}

struct CreateContactOutputResponseBody: Equatable {
    public let contactArn: String?
}

extension CreateContactOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactArn = "ContactArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
    }
}

extension DataEncryptionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataEncryptionException(message: \(String(describing: message)))"}
}

extension DataEncryptionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DataEncryptionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The action failed to due an encryption key error.</p>
public struct DataEncryptionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DataEncryptionExceptionBody: Equatable {
    public let message: String?
}

extension DataEncryptionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct DeactivateContactChannelInputBodyMiddleware: Middleware {
    public let id: String = "DeactivateContactChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeactivateContactChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeactivateContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeactivateContactChannelInput>
    public typealias MOutput = OperationOutput<DeactivateContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeactivateContactChannelOutputError>
}

extension DeactivateContactChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeactivateContactChannelInput(contactChannelId: \(String(describing: contactChannelId)))"}
}

extension DeactivateContactChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactChannelId = contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
    }
}

public struct DeactivateContactChannelInputHeadersMiddleware: Middleware {
    public let id: String = "DeactivateContactChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeactivateContactChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeactivateContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeactivateContactChannelInput>
    public typealias MOutput = OperationOutput<DeactivateContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeactivateContactChannelOutputError>
}

public struct DeactivateContactChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "DeactivateContactChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeactivateContactChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeactivateContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeactivateContactChannelInput>
    public typealias MOutput = OperationOutput<DeactivateContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeactivateContactChannelOutputError>
}

public struct DeactivateContactChannelInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the contact channel you're deactivating.</p>
    public let contactChannelId: String?

    public init (
        contactChannelId: String? = nil
    )
    {
        self.contactChannelId = contactChannelId
    }
}

struct DeactivateContactChannelInputBody: Equatable {
    public let contactChannelId: String?
}

extension DeactivateContactChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
    }
}

extension DeactivateContactChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeactivateContactChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeactivateContactChannelOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeactivateContactChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeactivateContactChannelOutputResponse()"}
}

extension DeactivateContactChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeactivateContactChannelOutputResponse: Equatable {

    public init() {}
}

struct DeactivateContactChannelOutputResponseBody: Equatable {
}

extension DeactivateContactChannelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteContactChannelInputBodyMiddleware: Middleware {
    public let id: String = "DeleteContactChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteContactChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteContactChannelInput>
    public typealias MOutput = OperationOutput<DeleteContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteContactChannelOutputError>
}

extension DeleteContactChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteContactChannelInput(contactChannelId: \(String(describing: contactChannelId)))"}
}

extension DeleteContactChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactChannelId = contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
    }
}

public struct DeleteContactChannelInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteContactChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteContactChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteContactChannelInput>
    public typealias MOutput = OperationOutput<DeleteContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteContactChannelOutputError>
}

public struct DeleteContactChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteContactChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteContactChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteContactChannelInput>
    public typealias MOutput = OperationOutput<DeleteContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteContactChannelOutputError>
}

public struct DeleteContactChannelInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the contact channel.</p>
    public let contactChannelId: String?

    public init (
        contactChannelId: String? = nil
    )
    {
        self.contactChannelId = contactChannelId
    }
}

struct DeleteContactChannelInputBody: Equatable {
    public let contactChannelId: String?
}

extension DeleteContactChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
    }
}

extension DeleteContactChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteContactChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteContactChannelOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteContactChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteContactChannelOutputResponse()"}
}

extension DeleteContactChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteContactChannelOutputResponse: Equatable {

    public init() {}
}

struct DeleteContactChannelOutputResponseBody: Equatable {
}

extension DeleteContactChannelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteContactInputBodyMiddleware: Middleware {
    public let id: String = "DeleteContactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteContactInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteContactInput>
    public typealias MOutput = OperationOutput<DeleteContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteContactOutputError>
}

extension DeleteContactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteContactInput(contactId: \(String(describing: contactId)))"}
}

extension DeleteContactInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
    }
}

public struct DeleteContactInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteContactInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteContactInput>
    public typealias MOutput = OperationOutput<DeleteContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteContactOutputError>
}

public struct DeleteContactInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteContactInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteContactInput>
    public typealias MOutput = OperationOutput<DeleteContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteContactOutputError>
}

public struct DeleteContactInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the contact that you're deleting.</p>
    public let contactId: String?

    public init (
        contactId: String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct DeleteContactInputBody: Equatable {
    public let contactId: String?
}

extension DeleteContactInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactId)
        contactId = contactIdDecoded
    }
}

extension DeleteContactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteContactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteContactOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteContactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteContactOutputResponse()"}
}

extension DeleteContactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteContactOutputResponse: Equatable {

    public init() {}
}

struct DeleteContactOutputResponseBody: Equatable {
}

extension DeleteContactOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeEngagementInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEngagementInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEngagementInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEngagementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEngagementInput>
    public typealias MOutput = OperationOutput<DescribeEngagementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEngagementOutputError>
}

extension DescribeEngagementInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEngagementInput(engagementId: \(String(describing: engagementId)))"}
}

extension DescribeEngagementInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case engagementId = "EngagementId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engagementId = engagementId {
            try encodeContainer.encode(engagementId, forKey: .engagementId)
        }
    }
}

public struct DescribeEngagementInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEngagementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEngagementInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEngagementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEngagementInput>
    public typealias MOutput = OperationOutput<DescribeEngagementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEngagementOutputError>
}

public struct DescribeEngagementInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEngagementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEngagementInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEngagementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEngagementInput>
    public typealias MOutput = OperationOutput<DescribeEngagementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEngagementOutputError>
}

public struct DescribeEngagementInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the engagement you want the details of.</p>
    public let engagementId: String?

    public init (
        engagementId: String? = nil
    )
    {
        self.engagementId = engagementId
    }
}

struct DescribeEngagementInputBody: Equatable {
    public let engagementId: String?
}

extension DescribeEngagementInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case engagementId = "EngagementId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engagementIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engagementId)
        engagementId = engagementIdDecoded
    }
}

extension DescribeEngagementOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEngagementOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEngagementOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEngagementOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEngagementOutputResponse(contactArn: \(String(describing: contactArn)), content: \(String(describing: content)), engagementArn: \(String(describing: engagementArn)), incidentId: \(String(describing: incidentId)), publicContent: \(String(describing: publicContent)), publicSubject: \(String(describing: publicSubject)), sender: \(String(describing: sender)), startTime: \(String(describing: startTime)), stopTime: \(String(describing: stopTime)), subject: \(String(describing: subject)))"}
}

extension DescribeEngagementOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEngagementOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactArn = output.contactArn
            self.content = output.content
            self.engagementArn = output.engagementArn
            self.incidentId = output.incidentId
            self.publicContent = output.publicContent
            self.publicSubject = output.publicSubject
            self.sender = output.sender
            self.startTime = output.startTime
            self.stopTime = output.stopTime
            self.subject = output.subject
        } else {
            self.contactArn = nil
            self.content = nil
            self.engagementArn = nil
            self.incidentId = nil
            self.publicContent = nil
            self.publicSubject = nil
            self.sender = nil
            self.startTime = nil
            self.stopTime = nil
            self.subject = nil
        }
    }
}

public struct DescribeEngagementOutputResponse: Equatable {
    /// <p>The ARN of the escalation plan or contacts involved in the engagement.</p>
    public let contactArn: String?
    /// <p>The secure content of the message that was sent to the contact. Use this field for
    ///          engagements to <code>VOICE</code> and <code>EMAIL</code>.</p>
    public let content: String?
    /// <p>The ARN of the engagement.</p>
    public let engagementArn: String?
    /// <p>The ARN of the incident in which the engagement occurred.</p>
    public let incidentId: String?
    /// <p>The insecure content of the message that was sent to the contact. Use this field for
    ///          engagements to <code>SMS</code>.</p>
    public let publicContent: String?
    /// <p>The insecure subject of the message that was sent to the contact. Use this field for
    ///          engagements to <code>SMS</code>.</p>
    public let publicSubject: String?
    /// <p>The user that started the engagement.</p>
    public let sender: String?
    /// <p>The time that the engagement started.</p>
    public let startTime: Date?
    /// <p>The time that the engagement ended.</p>
    public let stopTime: Date?
    /// <p>The secure subject of the message that was sent to the contact. Use this field for
    ///          engagements to <code>VOICE</code> and <code>EMAIL</code>.</p>
    public let subject: String?

    public init (
        contactArn: String? = nil,
        content: String? = nil,
        engagementArn: String? = nil,
        incidentId: String? = nil,
        publicContent: String? = nil,
        publicSubject: String? = nil,
        sender: String? = nil,
        startTime: Date? = nil,
        stopTime: Date? = nil,
        subject: String? = nil
    )
    {
        self.contactArn = contactArn
        self.content = content
        self.engagementArn = engagementArn
        self.incidentId = incidentId
        self.publicContent = publicContent
        self.publicSubject = publicSubject
        self.sender = sender
        self.startTime = startTime
        self.stopTime = stopTime
        self.subject = subject
    }
}

struct DescribeEngagementOutputResponseBody: Equatable {
    public let contactArn: String?
    public let engagementArn: String?
    public let sender: String?
    public let subject: String?
    public let content: String?
    public let publicSubject: String?
    public let publicContent: String?
    public let incidentId: String?
    public let startTime: Date?
    public let stopTime: Date?
}

extension DescribeEngagementOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactArn = "ContactArn"
        case content = "Content"
        case engagementArn = "EngagementArn"
        case incidentId = "IncidentId"
        case publicContent = "PublicContent"
        case publicSubject = "PublicSubject"
        case sender = "Sender"
        case startTime = "StartTime"
        case stopTime = "StopTime"
        case subject = "Subject"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let engagementArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engagementArn)
        engagementArn = engagementArnDecoded
        let senderDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sender)
        sender = senderDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subject)
        subject = subjectDecoded
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
        let publicSubjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publicSubject)
        publicSubject = publicSubjectDecoded
        let publicContentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publicContent)
        publicContent = publicContentDecoded
        let incidentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .incidentId)
        incidentId = incidentIdDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let stopTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .stopTime)
        stopTime = stopTimeDecoded
    }
}

public struct DescribePageInputBodyMiddleware: Middleware {
    public let id: String = "DescribePageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePageInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePageInput>
    public typealias MOutput = OperationOutput<DescribePageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePageOutputError>
}

extension DescribePageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePageInput(pageId: \(String(describing: pageId)))"}
}

extension DescribePageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pageId = "PageId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pageId = pageId {
            try encodeContainer.encode(pageId, forKey: .pageId)
        }
    }
}

public struct DescribePageInputHeadersMiddleware: Middleware {
    public let id: String = "DescribePageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePageInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePageInput>
    public typealias MOutput = OperationOutput<DescribePageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePageOutputError>
}

public struct DescribePageInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribePageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePageInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePageInput>
    public typealias MOutput = OperationOutput<DescribePageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePageOutputError>
}

public struct DescribePageInput: Equatable {
    /// <p>The ID of the engagement to a contact channel.</p>
    public let pageId: String?

    public init (
        pageId: String? = nil
    )
    {
        self.pageId = pageId
    }
}

struct DescribePageInputBody: Equatable {
    public let pageId: String?
}

extension DescribePageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pageId = "PageId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pageId)
        pageId = pageIdDecoded
    }
}

extension DescribePageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePageOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePageOutputResponse(contactArn: \(String(describing: contactArn)), content: \(String(describing: content)), deliveryTime: \(String(describing: deliveryTime)), engagementArn: \(String(describing: engagementArn)), incidentId: \(String(describing: incidentId)), pageArn: \(String(describing: pageArn)), publicContent: \(String(describing: publicContent)), publicSubject: \(String(describing: publicSubject)), readTime: \(String(describing: readTime)), sender: \(String(describing: sender)), sentTime: \(String(describing: sentTime)), subject: \(String(describing: subject)))"}
}

extension DescribePageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactArn = output.contactArn
            self.content = output.content
            self.deliveryTime = output.deliveryTime
            self.engagementArn = output.engagementArn
            self.incidentId = output.incidentId
            self.pageArn = output.pageArn
            self.publicContent = output.publicContent
            self.publicSubject = output.publicSubject
            self.readTime = output.readTime
            self.sender = output.sender
            self.sentTime = output.sentTime
            self.subject = output.subject
        } else {
            self.contactArn = nil
            self.content = nil
            self.deliveryTime = nil
            self.engagementArn = nil
            self.incidentId = nil
            self.pageArn = nil
            self.publicContent = nil
            self.publicSubject = nil
            self.readTime = nil
            self.sender = nil
            self.sentTime = nil
            self.subject = nil
        }
    }
}

public struct DescribePageOutputResponse: Equatable {
    /// <p>The ARN of the contact that was engaged.</p>
    public let contactArn: String?
    /// <p>The secure content of the message that was sent to the contact. Use this field for
    ///          engagements to <code>VOICE</code> and <code>EMAIL</code>.</p>
    public let content: String?
    /// <p>The time that the contact channel received the engagement.</p>
    public let deliveryTime: Date?
    /// <p>The ARN of the engagement that engaged the contact channel.</p>
    public let engagementArn: String?
    /// <p>The ARN of the incident that engaged the contact channel.</p>
    public let incidentId: String?
    /// <p>The Amazon Resource Name (ARN) of the engagement to a contact channel.</p>
    public let pageArn: String?
    /// <p>The insecure content of the message that was sent to the contact. Use this field for
    ///          engagements to <code>SMS</code>.</p>
    public let publicContent: String?
    /// <p>The insecure subject of the message that was sent to the contact. Use this field for
    ///          engagements to <code>SMS</code>.</p>
    public let publicSubject: String?
    /// <p>The time that the contact channel acknowledged the engagement.</p>
    public let readTime: Date?
    /// <p>The user that started the engagement.</p>
    public let sender: String?
    /// <p>The time the engagement was sent to the contact channel.</p>
    public let sentTime: Date?
    /// <p>The secure subject of the message that was sent to the contact. Use this field for
    ///          engagements to <code>VOICE</code> and <code>EMAIL</code>.</p>
    public let subject: String?

    public init (
        contactArn: String? = nil,
        content: String? = nil,
        deliveryTime: Date? = nil,
        engagementArn: String? = nil,
        incidentId: String? = nil,
        pageArn: String? = nil,
        publicContent: String? = nil,
        publicSubject: String? = nil,
        readTime: Date? = nil,
        sender: String? = nil,
        sentTime: Date? = nil,
        subject: String? = nil
    )
    {
        self.contactArn = contactArn
        self.content = content
        self.deliveryTime = deliveryTime
        self.engagementArn = engagementArn
        self.incidentId = incidentId
        self.pageArn = pageArn
        self.publicContent = publicContent
        self.publicSubject = publicSubject
        self.readTime = readTime
        self.sender = sender
        self.sentTime = sentTime
        self.subject = subject
    }
}

struct DescribePageOutputResponseBody: Equatable {
    public let pageArn: String?
    public let engagementArn: String?
    public let contactArn: String?
    public let sender: String?
    public let subject: String?
    public let content: String?
    public let publicSubject: String?
    public let publicContent: String?
    public let incidentId: String?
    public let sentTime: Date?
    public let readTime: Date?
    public let deliveryTime: Date?
}

extension DescribePageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactArn = "ContactArn"
        case content = "Content"
        case deliveryTime = "DeliveryTime"
        case engagementArn = "EngagementArn"
        case incidentId = "IncidentId"
        case pageArn = "PageArn"
        case publicContent = "PublicContent"
        case publicSubject = "PublicSubject"
        case readTime = "ReadTime"
        case sender = "Sender"
        case sentTime = "SentTime"
        case subject = "Subject"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pageArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pageArn)
        pageArn = pageArnDecoded
        let engagementArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engagementArn)
        engagementArn = engagementArnDecoded
        let contactArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let senderDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sender)
        sender = senderDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subject)
        subject = subjectDecoded
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
        let publicSubjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publicSubject)
        publicSubject = publicSubjectDecoded
        let publicContentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publicContent)
        publicContent = publicContentDecoded
        let incidentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .incidentId)
        incidentId = incidentIdDecoded
        let sentTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .sentTime)
        sentTime = sentTimeDecoded
        let readTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .readTime)
        readTime = readTimeDecoded
        let deliveryTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .deliveryTime)
        deliveryTime = deliveryTimeDecoded
    }
}

extension Engagement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactArn = "ContactArn"
        case engagementArn = "EngagementArn"
        case incidentId = "IncidentId"
        case sender = "Sender"
        case startTime = "StartTime"
        case stopTime = "StopTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let engagementArn = engagementArn {
            try encodeContainer.encode(engagementArn, forKey: .engagementArn)
        }
        if let incidentId = incidentId {
            try encodeContainer.encode(incidentId, forKey: .incidentId)
        }
        if let sender = sender {
            try encodeContainer.encode(sender, forKey: .sender)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let stopTime = stopTime {
            try encodeContainer.encode(stopTime.timeIntervalSince1970, forKey: .stopTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engagementArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engagementArn)
        engagementArn = engagementArnDecoded
        let contactArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let senderDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sender)
        sender = senderDecoded
        let incidentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .incidentId)
        incidentId = incidentIdDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let stopTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .stopTime)
        stopTime = stopTimeDecoded
    }
}

extension Engagement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Engagement(contactArn: \(String(describing: contactArn)), engagementArn: \(String(describing: engagementArn)), incidentId: \(String(describing: incidentId)), sender: \(String(describing: sender)), startTime: \(String(describing: startTime)), stopTime: \(String(describing: stopTime)))"}
}

/// <p>Incident Manager reaching out to a contact or escalation plan to engage contact during an
///          incident.</p>
public struct Engagement: Equatable {
    /// <p>The ARN of the escalation plan or contact that Incident Manager is engaging.</p>
    public let contactArn: String?
    /// <p>The Amazon Resource Name (ARN) of the engagement.</p>
    public let engagementArn: String?
    /// <p>The ARN of the incident that's engaging the contact.</p>
    public let incidentId: String?
    /// <p>The user that started the engagement.</p>
    public let sender: String?
    /// <p>The time that the engagement began.</p>
    public let startTime: Date?
    /// <p>The time that the engagement ended.</p>
    public let stopTime: Date?

    public init (
        contactArn: String? = nil,
        engagementArn: String? = nil,
        incidentId: String? = nil,
        sender: String? = nil,
        startTime: Date? = nil,
        stopTime: Date? = nil
    )
    {
        self.contactArn = contactArn
        self.engagementArn = engagementArn
        self.incidentId = incidentId
        self.sender = sender
        self.startTime = startTime
        self.stopTime = stopTime
    }
}

public struct GetContactChannelInputBodyMiddleware: Middleware {
    public let id: String = "GetContactChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContactChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContactChannelInput>
    public typealias MOutput = OperationOutput<GetContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContactChannelOutputError>
}

extension GetContactChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetContactChannelInput(contactChannelId: \(String(describing: contactChannelId)))"}
}

extension GetContactChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactChannelId = contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
    }
}

public struct GetContactChannelInputHeadersMiddleware: Middleware {
    public let id: String = "GetContactChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContactChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContactChannelInput>
    public typealias MOutput = OperationOutput<GetContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContactChannelOutputError>
}

public struct GetContactChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "GetContactChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContactChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContactChannelInput>
    public typealias MOutput = OperationOutput<GetContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContactChannelOutputError>
}

public struct GetContactChannelInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the contact channel you want information about.</p>
    public let contactChannelId: String?

    public init (
        contactChannelId: String? = nil
    )
    {
        self.contactChannelId = contactChannelId
    }
}

struct GetContactChannelInputBody: Equatable {
    public let contactChannelId: String?
}

extension GetContactChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
    }
}

extension GetContactChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetContactChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetContactChannelOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContactChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetContactChannelOutputResponse(activationStatus: \(String(describing: activationStatus)), contactArn: \(String(describing: contactArn)), contactChannelArn: \(String(describing: contactChannelArn)), deliveryAddress: \(String(describing: deliveryAddress)), name: \(String(describing: name)), type: \(String(describing: type)))"}
}

extension GetContactChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetContactChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.activationStatus = output.activationStatus
            self.contactArn = output.contactArn
            self.contactChannelArn = output.contactChannelArn
            self.deliveryAddress = output.deliveryAddress
            self.name = output.name
            self.type = output.type
        } else {
            self.activationStatus = nil
            self.contactArn = nil
            self.contactChannelArn = nil
            self.deliveryAddress = nil
            self.name = nil
            self.type = nil
        }
    }
}

public struct GetContactChannelOutputResponse: Equatable {
    /// <p>A Boolean value indicating if the contact channel has been activated or not.</p>
    public let activationStatus: ActivationStatus?
    /// <p>The ARN of the contact that the channel belongs to.</p>
    public let contactArn: String?
    /// <p>The ARN of the contact channel.</p>
    public let contactChannelArn: String?
    /// <p>The details that Incident Manager uses when trying to engage the contact channel. </p>
    public let deliveryAddress: ContactChannelAddress?
    /// <p>The name of the contact channel</p>
    public let name: String?
    /// <p>The type of contact channel. The type is <code>SMS</code>, <code>VOICE</code>, or
    ///             <code>EMAIL</code>.</p>
    public let type: ChannelType?

    public init (
        activationStatus: ActivationStatus? = nil,
        contactArn: String? = nil,
        contactChannelArn: String? = nil,
        deliveryAddress: ContactChannelAddress? = nil,
        name: String? = nil,
        type: ChannelType? = nil
    )
    {
        self.activationStatus = activationStatus
        self.contactArn = contactArn
        self.contactChannelArn = contactChannelArn
        self.deliveryAddress = deliveryAddress
        self.name = name
        self.type = type
    }
}

struct GetContactChannelOutputResponseBody: Equatable {
    public let contactArn: String?
    public let contactChannelArn: String?
    public let name: String?
    public let type: ChannelType?
    public let deliveryAddress: ContactChannelAddress?
    public let activationStatus: ActivationStatus?
}

extension GetContactChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case activationStatus = "ActivationStatus"
        case contactArn = "ContactArn"
        case contactChannelArn = "ContactChannelArn"
        case deliveryAddress = "DeliveryAddress"
        case name = "Name"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let contactChannelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactChannelArn)
        contactChannelArn = contactChannelArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChannelType.self, forKey: .type)
        type = typeDecoded
        let deliveryAddressDecoded = try containerValues.decodeIfPresent(ContactChannelAddress.self, forKey: .deliveryAddress)
        deliveryAddress = deliveryAddressDecoded
        let activationStatusDecoded = try containerValues.decodeIfPresent(ActivationStatus.self, forKey: .activationStatus)
        activationStatus = activationStatusDecoded
    }
}

public struct GetContactInputBodyMiddleware: Middleware {
    public let id: String = "GetContactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContactInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContactInput>
    public typealias MOutput = OperationOutput<GetContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContactOutputError>
}

extension GetContactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetContactInput(contactId: \(String(describing: contactId)))"}
}

extension GetContactInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
    }
}

public struct GetContactInputHeadersMiddleware: Middleware {
    public let id: String = "GetContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContactInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContactInput>
    public typealias MOutput = OperationOutput<GetContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContactOutputError>
}

public struct GetContactInputQueryItemMiddleware: Middleware {
    public let id: String = "GetContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContactInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContactInput>
    public typealias MOutput = OperationOutput<GetContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContactOutputError>
}

public struct GetContactInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the contact or escalation plan.</p>
    public let contactId: String?

    public init (
        contactId: String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct GetContactInputBody: Equatable {
    public let contactId: String?
}

extension GetContactInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactId)
        contactId = contactIdDecoded
    }
}

extension GetContactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetContactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetContactOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetContactOutputResponse(alias: \(String(describing: alias)), contactArn: \(String(describing: contactArn)), displayName: \(String(describing: displayName)), plan: \(String(describing: plan)), type: \(String(describing: type)))"}
}

extension GetContactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetContactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alias = output.alias
            self.contactArn = output.contactArn
            self.displayName = output.displayName
            self.plan = output.plan
            self.type = output.type
        } else {
            self.alias = nil
            self.contactArn = nil
            self.displayName = nil
            self.plan = nil
            self.type = nil
        }
    }
}

public struct GetContactOutputResponse: Equatable {
    /// <p>The alias of the contact or escalation plan. The alias is unique and
    ///          identifiable.</p>
    public let alias: String?
    /// <p>The ARN of the contact or escalation plan.</p>
    public let contactArn: String?
    /// <p>The full name of the contact or escalation plan.</p>
    public let displayName: String?
    /// <p>Details about the specific timing or stages and targets of the escalation plan or
    ///          engagement plan.</p>
    public let plan: Plan?
    /// <p>The type of contact, either <code>PERSONAL</code> or <code>ESCALATION</code>. </p>
    public let type: ContactType?

    public init (
        alias: String? = nil,
        contactArn: String? = nil,
        displayName: String? = nil,
        plan: Plan? = nil,
        type: ContactType? = nil
    )
    {
        self.alias = alias
        self.contactArn = contactArn
        self.displayName = displayName
        self.plan = plan
        self.type = type
    }
}

struct GetContactOutputResponseBody: Equatable {
    public let contactArn: String?
    public let alias: String?
    public let displayName: String?
    public let type: ContactType?
    public let plan: Plan?
}

extension GetContactOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case alias = "Alias"
        case contactArn = "ContactArn"
        case displayName = "DisplayName"
        case plan = "Plan"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alias)
        alias = aliasDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ContactType.self, forKey: .type)
        type = typeDecoded
        let planDecoded = try containerValues.decodeIfPresent(Plan.self, forKey: .plan)
        plan = planDecoded
    }
}

public struct GetContactPolicyInputBodyMiddleware: Middleware {
    public let id: String = "GetContactPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContactPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContactPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContactPolicyInput>
    public typealias MOutput = OperationOutput<GetContactPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContactPolicyOutputError>
}

extension GetContactPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetContactPolicyInput(contactArn: \(String(describing: contactArn)))"}
}

extension GetContactPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactArn = "ContactArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
    }
}

public struct GetContactPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetContactPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContactPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContactPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContactPolicyInput>
    public typealias MOutput = OperationOutput<GetContactPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContactPolicyOutputError>
}

public struct GetContactPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetContactPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContactPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContactPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContactPolicyInput>
    public typealias MOutput = OperationOutput<GetContactPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContactPolicyOutputError>
}

public struct GetContactPolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the contact or escalation plan.</p>
    public let contactArn: String?

    public init (
        contactArn: String? = nil
    )
    {
        self.contactArn = contactArn
    }
}

struct GetContactPolicyInputBody: Equatable {
    public let contactArn: String?
}

extension GetContactPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactArn = "ContactArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
    }
}

extension GetContactPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetContactPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetContactPolicyOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContactPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetContactPolicyOutputResponse(contactArn: \(String(describing: contactArn)), policy: \(String(describing: policy)))"}
}

extension GetContactPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetContactPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactArn = output.contactArn
            self.policy = output.policy
        } else {
            self.contactArn = nil
            self.policy = nil
        }
    }
}

public struct GetContactPolicyOutputResponse: Equatable {
    /// <p>The ARN of the contact or escalation plan.</p>
    public let contactArn: String?
    /// <p>Details about the resource policy attached to the contact or escalation plan.</p>
    public let policy: String?

    public init (
        contactArn: String? = nil,
        policy: String? = nil
    )
    {
        self.contactArn = contactArn
        self.policy = policy
    }
}

struct GetContactPolicyOutputResponseBody: Equatable {
    public let contactArn: String?
    public let policy: String?
}

extension GetContactPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactArn = "ContactArn"
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)), retryAfterSeconds: \(String(describing: retryAfterSeconds)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Unexpected error occurred while
///          processing the request.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?
    /// Advice to clients on when the call can be safely retried
    public var retryAfterSeconds: Int

    public init (
        message: String? = nil,
        retryAfterSeconds: Int = 0
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListContactChannelsInputBodyMiddleware: Middleware {
    public let id: String = "ListContactChannelsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListContactChannelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListContactChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListContactChannelsInput>
    public typealias MOutput = OperationOutput<ListContactChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListContactChannelsOutputError>
}

extension ListContactChannelsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListContactChannelsInput(contactId: \(String(describing: contactId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListContactChannelsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListContactChannelsInputHeadersMiddleware: Middleware {
    public let id: String = "ListContactChannelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListContactChannelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListContactChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListContactChannelsInput>
    public typealias MOutput = OperationOutput<ListContactChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListContactChannelsOutputError>
}

public struct ListContactChannelsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListContactChannelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListContactChannelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListContactChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListContactChannelsInput>
    public typealias MOutput = OperationOutput<ListContactChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListContactChannelsOutputError>
}

public struct ListContactChannelsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the contact. </p>
    public let contactId: String?
    /// <p>The maximum number of contact channels per page.</p>
    public let maxResults: Int?
    /// <p>The pagination token to continue to the next page of results.</p>
    public let nextToken: String?

    public init (
        contactId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.contactId = contactId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListContactChannelsInputBody: Equatable {
    public let contactId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListContactChannelsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListContactChannelsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListContactChannelsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListContactChannelsOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListContactChannelsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListContactChannelsOutputResponse(contactChannels: \(String(describing: contactChannels)), nextToken: \(String(describing: nextToken)))"}
}

extension ListContactChannelsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListContactChannelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactChannels = output.contactChannels
            self.nextToken = output.nextToken
        } else {
            self.contactChannels = nil
            self.nextToken = nil
        }
    }
}

public struct ListContactChannelsOutputResponse: Equatable {
    /// <p>A list of contact channels related to the specified contact.</p>
    public let contactChannels: [ContactChannel]?
    /// <p>The pagination token to continue to the next page of results.</p>
    public let nextToken: String?

    public init (
        contactChannels: [ContactChannel]? = nil,
        nextToken: String? = nil
    )
    {
        self.contactChannels = contactChannels
        self.nextToken = nextToken
    }
}

struct ListContactChannelsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let contactChannels: [ContactChannel]?
}

extension ListContactChannelsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactChannels = "ContactChannels"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let contactChannelsContainer = try containerValues.decodeIfPresent([ContactChannel?].self, forKey: .contactChannels)
        var contactChannelsDecoded0:[ContactChannel]? = nil
        if let contactChannelsContainer = contactChannelsContainer {
            contactChannelsDecoded0 = [ContactChannel]()
            for structure0 in contactChannelsContainer {
                if let structure0 = structure0 {
                    contactChannelsDecoded0?.append(structure0)
                }
            }
        }
        contactChannels = contactChannelsDecoded0
    }
}

public struct ListContactsInputBodyMiddleware: Middleware {
    public let id: String = "ListContactsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListContactsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListContactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListContactsInput>
    public typealias MOutput = OperationOutput<ListContactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListContactsOutputError>
}

extension ListContactsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListContactsInput(aliasPrefix: \(String(describing: aliasPrefix)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), type: \(String(describing: type)))"}
}

extension ListContactsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aliasPrefix = "AliasPrefix"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasPrefix = aliasPrefix {
            try encodeContainer.encode(aliasPrefix, forKey: .aliasPrefix)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct ListContactsInputHeadersMiddleware: Middleware {
    public let id: String = "ListContactsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListContactsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListContactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListContactsInput>
    public typealias MOutput = OperationOutput<ListContactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListContactsOutputError>
}

public struct ListContactsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListContactsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListContactsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListContactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListContactsInput>
    public typealias MOutput = OperationOutput<ListContactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListContactsOutputError>
}

public struct ListContactsInput: Equatable {
    /// <p>Used to list only contacts who's aliases start with the specified prefix.</p>
    public let aliasPrefix: String?
    /// <p>The maximum number of contacts and escalation plans per page of results.</p>
    public let maxResults: Int?
    /// <p>The pagination token to continue to the next page of results.</p>
    public let nextToken: String?
    /// <p>The type of contact. A contact is type <code>PERSONAL</code> and an escalation plan is
    ///          type <code>ESCALATION</code>.</p>
    public let type: ContactType?

    public init (
        aliasPrefix: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        type: ContactType? = nil
    )
    {
        self.aliasPrefix = aliasPrefix
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
    }
}

struct ListContactsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let aliasPrefix: String?
    public let type: ContactType?
}

extension ListContactsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aliasPrefix = "AliasPrefix"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let aliasPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aliasPrefix)
        aliasPrefix = aliasPrefixDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ContactType.self, forKey: .type)
        type = typeDecoded
    }
}

extension ListContactsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListContactsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListContactsOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListContactsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListContactsOutputResponse(contacts: \(String(describing: contacts)), nextToken: \(String(describing: nextToken)))"}
}

extension ListContactsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListContactsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contacts = output.contacts
            self.nextToken = output.nextToken
        } else {
            self.contacts = nil
            self.nextToken = nil
        }
    }
}

public struct ListContactsOutputResponse: Equatable {
    /// <p>A list of the contacts and escalation plans in your Incident Manager account.</p>
    public let contacts: [Contact]?
    /// <p>The pagination token to continue to the next page of results.</p>
    public let nextToken: String?

    public init (
        contacts: [Contact]? = nil,
        nextToken: String? = nil
    )
    {
        self.contacts = contacts
        self.nextToken = nextToken
    }
}

struct ListContactsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let contacts: [Contact]?
}

extension ListContactsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contacts = "Contacts"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let contactsContainer = try containerValues.decodeIfPresent([Contact?].self, forKey: .contacts)
        var contactsDecoded0:[Contact]? = nil
        if let contactsContainer = contactsContainer {
            contactsDecoded0 = [Contact]()
            for structure0 in contactsContainer {
                if let structure0 = structure0 {
                    contactsDecoded0?.append(structure0)
                }
            }
        }
        contacts = contactsDecoded0
    }
}

public struct ListEngagementsInputBodyMiddleware: Middleware {
    public let id: String = "ListEngagementsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEngagementsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEngagementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEngagementsInput>
    public typealias MOutput = OperationOutput<ListEngagementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEngagementsOutputError>
}

extension ListEngagementsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEngagementsInput(incidentId: \(String(describing: incidentId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), timeRangeValue: \(String(describing: timeRangeValue)))"}
}

extension ListEngagementsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case incidentId = "IncidentId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timeRangeValue = "TimeRangeValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let incidentId = incidentId {
            try encodeContainer.encode(incidentId, forKey: .incidentId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let timeRangeValue = timeRangeValue {
            try encodeContainer.encode(timeRangeValue, forKey: .timeRangeValue)
        }
    }
}

public struct ListEngagementsInputHeadersMiddleware: Middleware {
    public let id: String = "ListEngagementsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEngagementsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEngagementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEngagementsInput>
    public typealias MOutput = OperationOutput<ListEngagementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEngagementsOutputError>
}

public struct ListEngagementsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEngagementsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEngagementsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEngagementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEngagementsInput>
    public typealias MOutput = OperationOutput<ListEngagementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEngagementsOutputError>
}

public struct ListEngagementsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the incident you're listing engagements for.</p>
    public let incidentId: String?
    /// <p>The maximum number of engagements per page of results.</p>
    public let maxResults: Int?
    /// <p>The pagination token to continue to the next page of results.</p>
    public let nextToken: String?
    /// <p>The time range to lists engagements for an incident.</p>
    public let timeRangeValue: TimeRange?

    public init (
        incidentId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        timeRangeValue: TimeRange? = nil
    )
    {
        self.incidentId = incidentId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.timeRangeValue = timeRangeValue
    }
}

struct ListEngagementsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let incidentId: String?
    public let timeRangeValue: TimeRange?
}

extension ListEngagementsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case incidentId = "IncidentId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timeRangeValue = "TimeRangeValue"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let incidentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .incidentId)
        incidentId = incidentIdDecoded
        let timeRangeValueDecoded = try containerValues.decodeIfPresent(TimeRange.self, forKey: .timeRangeValue)
        timeRangeValue = timeRangeValueDecoded
    }
}

extension ListEngagementsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEngagementsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEngagementsOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEngagementsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEngagementsOutputResponse(engagements: \(String(describing: engagements)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEngagementsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEngagementsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.engagements = output.engagements
            self.nextToken = output.nextToken
        } else {
            self.engagements = nil
            self.nextToken = nil
        }
    }
}

public struct ListEngagementsOutputResponse: Equatable {
    /// <p>A list of each engagement that occurred during the specified time range of an
    ///          incident.</p>
    public let engagements: [Engagement]?
    /// <p>The pagination token to continue to the next page of results.</p>
    public let nextToken: String?

    public init (
        engagements: [Engagement]? = nil,
        nextToken: String? = nil
    )
    {
        self.engagements = engagements
        self.nextToken = nextToken
    }
}

struct ListEngagementsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let engagements: [Engagement]?
}

extension ListEngagementsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case engagements = "Engagements"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let engagementsContainer = try containerValues.decodeIfPresent([Engagement?].self, forKey: .engagements)
        var engagementsDecoded0:[Engagement]? = nil
        if let engagementsContainer = engagementsContainer {
            engagementsDecoded0 = [Engagement]()
            for structure0 in engagementsContainer {
                if let structure0 = structure0 {
                    engagementsDecoded0?.append(structure0)
                }
            }
        }
        engagements = engagementsDecoded0
    }
}

public struct ListPageReceiptsInputBodyMiddleware: Middleware {
    public let id: String = "ListPageReceiptsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPageReceiptsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPageReceiptsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPageReceiptsInput>
    public typealias MOutput = OperationOutput<ListPageReceiptsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPageReceiptsOutputError>
}

extension ListPageReceiptsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPageReceiptsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), pageId: \(String(describing: pageId)))"}
}

extension ListPageReceiptsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case pageId = "PageId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let pageId = pageId {
            try encodeContainer.encode(pageId, forKey: .pageId)
        }
    }
}

public struct ListPageReceiptsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPageReceiptsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPageReceiptsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPageReceiptsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPageReceiptsInput>
    public typealias MOutput = OperationOutput<ListPageReceiptsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPageReceiptsOutputError>
}

public struct ListPageReceiptsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPageReceiptsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPageReceiptsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPageReceiptsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPageReceiptsInput>
    public typealias MOutput = OperationOutput<ListPageReceiptsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPageReceiptsOutputError>
}

public struct ListPageReceiptsInput: Equatable {
    /// <p>The maximum number of acknowledgements per page of results.</p>
    public let maxResults: Int?
    /// <p>The pagination token to continue to the next page of results.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) of the engagement to a specific contact channel.</p>
    public let pageId: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        pageId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pageId = pageId
    }
}

struct ListPageReceiptsInputBody: Equatable {
    public let pageId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListPageReceiptsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case pageId = "PageId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pageId)
        pageId = pageIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPageReceiptsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPageReceiptsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPageReceiptsOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPageReceiptsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPageReceiptsOutputResponse(nextToken: \(String(describing: nextToken)), receipts: \(String(describing: receipts)))"}
}

extension ListPageReceiptsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPageReceiptsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.receipts = output.receipts
        } else {
            self.nextToken = nil
            self.receipts = nil
        }
    }
}

public struct ListPageReceiptsOutputResponse: Equatable {
    /// <p>The pagination token to continue to the next page of results.</p>
    public let nextToken: String?
    /// <p>A list of each acknowledgement.</p>
    public let receipts: [Receipt]?

    public init (
        nextToken: String? = nil,
        receipts: [Receipt]? = nil
    )
    {
        self.nextToken = nextToken
        self.receipts = receipts
    }
}

struct ListPageReceiptsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let receipts: [Receipt]?
}

extension ListPageReceiptsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case receipts = "Receipts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let receiptsContainer = try containerValues.decodeIfPresent([Receipt?].self, forKey: .receipts)
        var receiptsDecoded0:[Receipt]? = nil
        if let receiptsContainer = receiptsContainer {
            receiptsDecoded0 = [Receipt]()
            for structure0 in receiptsContainer {
                if let structure0 = structure0 {
                    receiptsDecoded0?.append(structure0)
                }
            }
        }
        receipts = receiptsDecoded0
    }
}

public struct ListPagesByContactInputBodyMiddleware: Middleware {
    public let id: String = "ListPagesByContactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPagesByContactInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPagesByContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPagesByContactInput>
    public typealias MOutput = OperationOutput<ListPagesByContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPagesByContactOutputError>
}

extension ListPagesByContactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPagesByContactInput(contactId: \(String(describing: contactId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListPagesByContactInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListPagesByContactInputHeadersMiddleware: Middleware {
    public let id: String = "ListPagesByContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPagesByContactInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPagesByContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPagesByContactInput>
    public typealias MOutput = OperationOutput<ListPagesByContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPagesByContactOutputError>
}

public struct ListPagesByContactInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPagesByContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPagesByContactInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPagesByContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPagesByContactInput>
    public typealias MOutput = OperationOutput<ListPagesByContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPagesByContactOutputError>
}

public struct ListPagesByContactInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the contact you are retrieving engagements for.</p>
    public let contactId: String?
    /// <p>The maximum number of engagements to contact channels to list per page of results. </p>
    public let maxResults: Int?
    /// <p>The pagination token to continue to the next page of results.</p>
    public let nextToken: String?

    public init (
        contactId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.contactId = contactId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPagesByContactInputBody: Equatable {
    public let contactId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListPagesByContactInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPagesByContactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPagesByContactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPagesByContactOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPagesByContactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPagesByContactOutputResponse(nextToken: \(String(describing: nextToken)), pages: \(String(describing: pages)))"}
}

extension ListPagesByContactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPagesByContactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.pages = output.pages
        } else {
            self.nextToken = nil
            self.pages = nil
        }
    }
}

public struct ListPagesByContactOutputResponse: Equatable {
    /// <p>The pagination token to continue to the next page of results.</p>
    public let nextToken: String?
    /// <p>The list of engagements to a contact's contact channel.</p>
    public let pages: [Page]?

    public init (
        nextToken: String? = nil,
        pages: [Page]? = nil
    )
    {
        self.nextToken = nextToken
        self.pages = pages
    }
}

struct ListPagesByContactOutputResponseBody: Equatable {
    public let nextToken: String?
    public let pages: [Page]?
}

extension ListPagesByContactOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case pages = "Pages"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let pagesContainer = try containerValues.decodeIfPresent([Page?].self, forKey: .pages)
        var pagesDecoded0:[Page]? = nil
        if let pagesContainer = pagesContainer {
            pagesDecoded0 = [Page]()
            for structure0 in pagesContainer {
                if let structure0 = structure0 {
                    pagesDecoded0?.append(structure0)
                }
            }
        }
        pages = pagesDecoded0
    }
}

public struct ListPagesByEngagementInputBodyMiddleware: Middleware {
    public let id: String = "ListPagesByEngagementInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPagesByEngagementInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPagesByEngagementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPagesByEngagementInput>
    public typealias MOutput = OperationOutput<ListPagesByEngagementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPagesByEngagementOutputError>
}

extension ListPagesByEngagementInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPagesByEngagementInput(engagementId: \(String(describing: engagementId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListPagesByEngagementInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case engagementId = "EngagementId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engagementId = engagementId {
            try encodeContainer.encode(engagementId, forKey: .engagementId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListPagesByEngagementInputHeadersMiddleware: Middleware {
    public let id: String = "ListPagesByEngagementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPagesByEngagementInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPagesByEngagementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPagesByEngagementInput>
    public typealias MOutput = OperationOutput<ListPagesByEngagementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPagesByEngagementOutputError>
}

public struct ListPagesByEngagementInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPagesByEngagementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPagesByEngagementInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPagesByEngagementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPagesByEngagementInput>
    public typealias MOutput = OperationOutput<ListPagesByEngagementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPagesByEngagementOutputError>
}

public struct ListPagesByEngagementInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the engagement.</p>
    public let engagementId: String?
    /// <p>The maximum number of engagements to contact channels to list per page of
    ///          results.</p>
    public let maxResults: Int?
    /// <p>The pagination token to continue to the next page of results.</p>
    public let nextToken: String?

    public init (
        engagementId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.engagementId = engagementId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPagesByEngagementInputBody: Equatable {
    public let engagementId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListPagesByEngagementInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case engagementId = "EngagementId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engagementIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engagementId)
        engagementId = engagementIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPagesByEngagementOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPagesByEngagementOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPagesByEngagementOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPagesByEngagementOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPagesByEngagementOutputResponse(nextToken: \(String(describing: nextToken)), pages: \(String(describing: pages)))"}
}

extension ListPagesByEngagementOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPagesByEngagementOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.pages = output.pages
        } else {
            self.nextToken = nil
            self.pages = nil
        }
    }
}

public struct ListPagesByEngagementOutputResponse: Equatable {
    /// <p>The pagination token to continue to the next page of results.</p>
    public let nextToken: String?
    /// <p>The list of engagements to contact channels.</p>
    public let pages: [Page]?

    public init (
        nextToken: String? = nil,
        pages: [Page]? = nil
    )
    {
        self.nextToken = nextToken
        self.pages = pages
    }
}

struct ListPagesByEngagementOutputResponseBody: Equatable {
    public let nextToken: String?
    public let pages: [Page]?
}

extension ListPagesByEngagementOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case pages = "Pages"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let pagesContainer = try containerValues.decodeIfPresent([Page?].self, forKey: .pages)
        var pagesDecoded0:[Page]? = nil
        if let pagesContainer = pagesContainer {
            pagesDecoded0 = [Page]()
            for structure0 in pagesContainer {
                if let structure0 = structure0 {
                    pagesDecoded0?.append(structure0)
                }
            }
        }
        pages = pagesDecoded0
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceARN: \(String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the contact or escalation plan.</p>
    public let resourceARN: String?

    public init (
        resourceARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceARN: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The tags related to the contact or escalation plan.</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Page: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactArn = "ContactArn"
        case deliveryTime = "DeliveryTime"
        case engagementArn = "EngagementArn"
        case incidentId = "IncidentId"
        case pageArn = "PageArn"
        case readTime = "ReadTime"
        case sender = "Sender"
        case sentTime = "SentTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let deliveryTime = deliveryTime {
            try encodeContainer.encode(deliveryTime.timeIntervalSince1970, forKey: .deliveryTime)
        }
        if let engagementArn = engagementArn {
            try encodeContainer.encode(engagementArn, forKey: .engagementArn)
        }
        if let incidentId = incidentId {
            try encodeContainer.encode(incidentId, forKey: .incidentId)
        }
        if let pageArn = pageArn {
            try encodeContainer.encode(pageArn, forKey: .pageArn)
        }
        if let readTime = readTime {
            try encodeContainer.encode(readTime.timeIntervalSince1970, forKey: .readTime)
        }
        if let sender = sender {
            try encodeContainer.encode(sender, forKey: .sender)
        }
        if let sentTime = sentTime {
            try encodeContainer.encode(sentTime.timeIntervalSince1970, forKey: .sentTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pageArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pageArn)
        pageArn = pageArnDecoded
        let engagementArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engagementArn)
        engagementArn = engagementArnDecoded
        let contactArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let senderDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sender)
        sender = senderDecoded
        let incidentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .incidentId)
        incidentId = incidentIdDecoded
        let sentTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .sentTime)
        sentTime = sentTimeDecoded
        let deliveryTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .deliveryTime)
        deliveryTime = deliveryTimeDecoded
        let readTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .readTime)
        readTime = readTimeDecoded
    }
}

extension Page: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Page(contactArn: \(String(describing: contactArn)), deliveryTime: \(String(describing: deliveryTime)), engagementArn: \(String(describing: engagementArn)), incidentId: \(String(describing: incidentId)), pageArn: \(String(describing: pageArn)), readTime: \(String(describing: readTime)), sender: \(String(describing: sender)), sentTime: \(String(describing: sentTime)))"}
}

/// <p>Incident Manager engaging a contact's contact channel.</p>
public struct Page: Equatable {
    /// <p>The ARN of the contact that Incident Manager is engaging.</p>
    public let contactArn: String?
    /// <p>The time the message was delivered to the contact channel.</p>
    public let deliveryTime: Date?
    /// <p>The ARN of the engagement that this page is part of.</p>
    public let engagementArn: String?
    /// <p>The ARN of the incident that's engaging the contact channel.</p>
    public let incidentId: String?
    /// <p>The Amazon Resource Name (ARN) of the page to the contact channel.</p>
    public let pageArn: String?
    /// <p>The time that the contact channel acknowledged engagement.</p>
    public let readTime: Date?
    /// <p>The user that started the engagement.</p>
    public let sender: String?
    /// <p>The time that Incident Manager engaged the contact channel.</p>
    public let sentTime: Date?

    public init (
        contactArn: String? = nil,
        deliveryTime: Date? = nil,
        engagementArn: String? = nil,
        incidentId: String? = nil,
        pageArn: String? = nil,
        readTime: Date? = nil,
        sender: String? = nil,
        sentTime: Date? = nil
    )
    {
        self.contactArn = contactArn
        self.deliveryTime = deliveryTime
        self.engagementArn = engagementArn
        self.incidentId = incidentId
        self.pageArn = pageArn
        self.readTime = readTime
        self.sender = sender
        self.sentTime = sentTime
    }
}

extension Plan: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case stages = "Stages"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stages = stages {
            var stagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stages)
            for stageslist0 in stages {
                try stagesContainer.encode(stageslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stagesContainer = try containerValues.decodeIfPresent([Stage?].self, forKey: .stages)
        var stagesDecoded0:[Stage]? = nil
        if let stagesContainer = stagesContainer {
            stagesDecoded0 = [Stage]()
            for structure0 in stagesContainer {
                if let structure0 = structure0 {
                    stagesDecoded0?.append(structure0)
                }
            }
        }
        stages = stagesDecoded0
    }
}

extension Plan: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Plan(stages: \(String(describing: stages)))"}
}

/// <p>The stages that an escalation plan or engagement plan engages contacts and contact
///          methods in.</p>
public struct Plan: Equatable {
    /// <p>A list of stages that the escalation plan or engagement plan uses to engage contacts and
    ///          contact methods.</p>
    public let stages: [Stage]?

    public init (
        stages: [Stage]? = nil
    )
    {
        self.stages = stages
    }
}

public struct PutContactPolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutContactPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutContactPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutContactPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutContactPolicyInput>
    public typealias MOutput = OperationOutput<PutContactPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutContactPolicyOutputError>
}

extension PutContactPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutContactPolicyInput(contactArn: \(String(describing: contactArn)), policy: \(String(describing: policy)))"}
}

extension PutContactPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactArn = "ContactArn"
        case policy = "Policy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

public struct PutContactPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutContactPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutContactPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutContactPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutContactPolicyInput>
    public typealias MOutput = OperationOutput<PutContactPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutContactPolicyOutputError>
}

public struct PutContactPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutContactPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutContactPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutContactPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutContactPolicyInput>
    public typealias MOutput = OperationOutput<PutContactPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutContactPolicyOutputError>
}

public struct PutContactPolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the contact or escalation plan.</p>
    public let contactArn: String?
    /// <p>Details of the resource policy.</p>
    public let policy: String?

    public init (
        contactArn: String? = nil,
        policy: String? = nil
    )
    {
        self.contactArn = contactArn
        self.policy = policy
    }
}

struct PutContactPolicyInputBody: Equatable {
    public let contactArn: String?
    public let policy: String?
}

extension PutContactPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactArn = "ContactArn"
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutContactPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutContactPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutContactPolicyOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutContactPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutContactPolicyOutputResponse()"}
}

extension PutContactPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutContactPolicyOutputResponse: Equatable {

    public init() {}
}

struct PutContactPolicyOutputResponseBody: Equatable {
}

extension PutContactPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Receipt: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactChannelArn = "ContactChannelArn"
        case receiptInfo = "ReceiptInfo"
        case receiptTime = "ReceiptTime"
        case receiptType = "ReceiptType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactChannelArn = contactChannelArn {
            try encodeContainer.encode(contactChannelArn, forKey: .contactChannelArn)
        }
        if let receiptInfo = receiptInfo {
            try encodeContainer.encode(receiptInfo, forKey: .receiptInfo)
        }
        if let receiptTime = receiptTime {
            try encodeContainer.encode(receiptTime.timeIntervalSince1970, forKey: .receiptTime)
        }
        if let receiptType = receiptType {
            try encodeContainer.encode(receiptType.rawValue, forKey: .receiptType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactChannelArn)
        contactChannelArn = contactChannelArnDecoded
        let receiptTypeDecoded = try containerValues.decodeIfPresent(ReceiptType.self, forKey: .receiptType)
        receiptType = receiptTypeDecoded
        let receiptInfoDecoded = try containerValues.decodeIfPresent(String.self, forKey: .receiptInfo)
        receiptInfo = receiptInfoDecoded
        let receiptTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .receiptTime)
        receiptTime = receiptTimeDecoded
    }
}

extension Receipt: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Receipt(contactChannelArn: \(String(describing: contactChannelArn)), receiptInfo: \(String(describing: receiptInfo)), receiptTime: \(String(describing: receiptTime)), receiptType: \(String(describing: receiptType)))"}
}

/// <p>Records events during an engagement.</p>
public struct Receipt: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the contact channel Incident Manager engaged.</p>
    public let contactChannelArn: String?
    /// <p>Information provided during the page acknowledgement.</p>
    public let receiptInfo: String?
    /// <p>The time receipt was <code>SENT</code>, <code>DELIVERED</code>, or
    ///          <code>READ</code>.</p>
    public let receiptTime: Date?
    /// <p>The type follows the engagement cycle, <code>SENT</code>, <code>DELIVERED</code>, and
    ///             <code>READ</code>.</p>
    public let receiptType: ReceiptType?

    public init (
        contactChannelArn: String? = nil,
        receiptInfo: String? = nil,
        receiptTime: Date? = nil,
        receiptType: ReceiptType? = nil
    )
    {
        self.contactChannelArn = contactChannelArn
        self.receiptInfo = receiptInfo
        self.receiptTime = receiptTime
        self.receiptType = receiptType
    }
}

public enum ReceiptType {
    case delivered
    case error
    case read
    case sent
    case stop
    case sdkUnknown(String)
}

extension ReceiptType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReceiptType] {
        return [
            .delivered,
            .error,
            .read,
            .sent,
            .stop,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .delivered: return "DELIVERED"
        case .error: return "ERROR"
        case .read: return "READ"
        case .sent: return "SENT"
        case .stop: return "STOP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReceiptType(rawValue: rawValue) ?? ReceiptType.sdkUnknown(rawValue)
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Request references a resource that
///          doesn't
///          exist.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// Hypothetical resource identifier that was not found
    public var resourceId: String?
    /// Hypothetical resource type that was not found
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public struct SendActivationCodeInputBodyMiddleware: Middleware {
    public let id: String = "SendActivationCodeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendActivationCodeInput>,
                  next: H) -> Swift.Result<OperationOutput<SendActivationCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendActivationCodeInput>
    public typealias MOutput = OperationOutput<SendActivationCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendActivationCodeOutputError>
}

extension SendActivationCodeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendActivationCodeInput(contactChannelId: \(String(describing: contactChannelId)))"}
}

extension SendActivationCodeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactChannelId = contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
    }
}

public struct SendActivationCodeInputHeadersMiddleware: Middleware {
    public let id: String = "SendActivationCodeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendActivationCodeInput>,
                  next: H) -> Swift.Result<OperationOutput<SendActivationCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendActivationCodeInput>
    public typealias MOutput = OperationOutput<SendActivationCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendActivationCodeOutputError>
}

public struct SendActivationCodeInputQueryItemMiddleware: Middleware {
    public let id: String = "SendActivationCodeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendActivationCodeInput>,
                  next: H) -> Swift.Result<OperationOutput<SendActivationCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendActivationCodeInput>
    public typealias MOutput = OperationOutput<SendActivationCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendActivationCodeOutputError>
}

public struct SendActivationCodeInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the contact channel.</p>
    public let contactChannelId: String?

    public init (
        contactChannelId: String? = nil
    )
    {
        self.contactChannelId = contactChannelId
    }
}

struct SendActivationCodeInputBody: Equatable {
    public let contactChannelId: String?
}

extension SendActivationCodeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
    }
}

extension SendActivationCodeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendActivationCodeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendActivationCodeOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendActivationCodeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendActivationCodeOutputResponse()"}
}

extension SendActivationCodeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SendActivationCodeOutputResponse: Equatable {

    public init() {}
}

struct SendActivationCodeOutputResponseBody: Equatable {
}

extension SendActivationCodeOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)), quotaCode: \(String(describing: quotaCode)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)), serviceCode: \(String(describing: serviceCode)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Request would cause a service quota to be exceeded.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// Service Quotas requirement to identify originating service
    public var quotaCode: String?
    /// Identifier of the resource affected
    public var resourceId: String?
    /// Type of the resource affected
    public var resourceType: String?
    /// Service Quotas requirement to identify originating quota
    public var serviceCode: String?

    public init (
        message: String? = nil,
        quotaCode: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil,
        serviceCode: String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: String?
    public let quotaCode: String?
    public let serviceCode: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension Stage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case durationInMinutes = "DurationInMinutes"
        case targets = "Targets"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationInMinutes = durationInMinutes {
            try encodeContainer.encode(durationInMinutes, forKey: .durationInMinutes)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targetslist0 in targets {
                try targetsContainer.encode(targetslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let durationInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .durationInMinutes)
        durationInMinutes = durationInMinutesDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Target?].self, forKey: .targets)
        var targetsDecoded0:[Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
    }
}

extension Stage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Stage(durationInMinutes: \(String(describing: durationInMinutes)), targets: \(String(describing: targets)))"}
}

/// <p>A set amount of time that an escalation plan or engagement plan engages the specified
///          contacts or contact methods.</p>
public struct Stage: Equatable {
    /// <p>The time to wait until beginning the next stage.</p>
    public let durationInMinutes: Int?
    /// <p>The contacts or contact methods that the escalation plan or engagement plan is
    ///          engaging.</p>
    public let targets: [Target]?

    public init (
        durationInMinutes: Int? = nil,
        targets: [Target]? = nil
    )
    {
        self.durationInMinutes = durationInMinutes
        self.targets = targets
    }
}

public struct StartEngagementInputBodyMiddleware: Middleware {
    public let id: String = "StartEngagementInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartEngagementInput>,
                  next: H) -> Swift.Result<OperationOutput<StartEngagementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartEngagementInput>
    public typealias MOutput = OperationOutput<StartEngagementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartEngagementOutputError>
}

extension StartEngagementInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartEngagementInput(contactId: \(String(describing: contactId)), content: \(String(describing: content)), idempotencyToken: \(String(describing: idempotencyToken)), incidentId: \(String(describing: incidentId)), publicContent: \(String(describing: publicContent)), publicSubject: \(String(describing: publicSubject)), sender: \(String(describing: sender)), subject: \(String(describing: subject)))"}
}

extension StartEngagementInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
        case content = "Content"
        case idempotencyToken = "IdempotencyToken"
        case incidentId = "IncidentId"
        case publicContent = "PublicContent"
        case publicSubject = "PublicSubject"
        case sender = "Sender"
        case subject = "Subject"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let incidentId = incidentId {
            try encodeContainer.encode(incidentId, forKey: .incidentId)
        }
        if let publicContent = publicContent {
            try encodeContainer.encode(publicContent, forKey: .publicContent)
        }
        if let publicSubject = publicSubject {
            try encodeContainer.encode(publicSubject, forKey: .publicSubject)
        }
        if let sender = sender {
            try encodeContainer.encode(sender, forKey: .sender)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
    }
}

public struct StartEngagementInputHeadersMiddleware: Middleware {
    public let id: String = "StartEngagementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartEngagementInput>,
                  next: H) -> Swift.Result<OperationOutput<StartEngagementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartEngagementInput>
    public typealias MOutput = OperationOutput<StartEngagementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartEngagementOutputError>
}

public struct StartEngagementInputQueryItemMiddleware: Middleware {
    public let id: String = "StartEngagementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartEngagementInput>,
                  next: H) -> Swift.Result<OperationOutput<StartEngagementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartEngagementInput>
    public typealias MOutput = OperationOutput<StartEngagementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartEngagementOutputError>
}

public struct StartEngagementInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the contact being engaged.</p>
    public let contactId: String?
    /// <p>The secure content of the message that was sent to the contact. Use this field for
    ///          engagements to <code>VOICE</code> or <code>EMAIL</code>.</p>
    public let content: String?
    /// <p>A token ensuring that the action is called only once with the specified details.</p>
    public var idempotencyToken: String?
    /// <p>The ARN of the incident that the engagement is part of.</p>
    public let incidentId: String?
    /// <p>The insecure content of the message that was sent to the contact. Use this field for
    ///          engagements to <code>SMS</code>.</p>
    public let publicContent: String?
    /// <p>The insecure subject of the message that was sent to the contact. Use this field for
    ///          engagements to <code>SMS</code>.</p>
    public let publicSubject: String?
    /// <p>The user that started the engagement.</p>
    public let sender: String?
    /// <p>The secure subject of the message that was sent to the contact. Use this field for
    ///          engagements to <code>VOICE</code> or <code>EMAIL</code>.</p>
    public let subject: String?

    public init (
        contactId: String? = nil,
        content: String? = nil,
        idempotencyToken: String? = nil,
        incidentId: String? = nil,
        publicContent: String? = nil,
        publicSubject: String? = nil,
        sender: String? = nil,
        subject: String? = nil
    )
    {
        self.contactId = contactId
        self.content = content
        self.idempotencyToken = idempotencyToken
        self.incidentId = incidentId
        self.publicContent = publicContent
        self.publicSubject = publicSubject
        self.sender = sender
        self.subject = subject
    }
}

struct StartEngagementInputBody: Equatable {
    public let contactId: String?
    public let sender: String?
    public let subject: String?
    public let content: String?
    public let publicSubject: String?
    public let publicContent: String?
    public let incidentId: String?
    public let idempotencyToken: String?
}

extension StartEngagementInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
        case content = "Content"
        case idempotencyToken = "IdempotencyToken"
        case incidentId = "IncidentId"
        case publicContent = "PublicContent"
        case publicSubject = "PublicSubject"
        case sender = "Sender"
        case subject = "Subject"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let senderDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sender)
        sender = senderDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subject)
        subject = subjectDecoded
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
        let publicSubjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publicSubject)
        publicSubject = publicSubjectDecoded
        let publicContentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publicContent)
        publicContent = publicContentDecoded
        let incidentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .incidentId)
        incidentId = incidentIdDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension StartEngagementOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartEngagementOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartEngagementOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartEngagementOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartEngagementOutputResponse(engagementArn: \(String(describing: engagementArn)))"}
}

extension StartEngagementOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartEngagementOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.engagementArn = output.engagementArn
        } else {
            self.engagementArn = nil
        }
    }
}

public struct StartEngagementOutputResponse: Equatable {
    /// <p>The ARN of the engagement.</p>
    public let engagementArn: String?

    public init (
        engagementArn: String? = nil
    )
    {
        self.engagementArn = engagementArn
    }
}

struct StartEngagementOutputResponseBody: Equatable {
    public let engagementArn: String?
}

extension StartEngagementOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case engagementArn = "EngagementArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engagementArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engagementArn)
        engagementArn = engagementArnDecoded
    }
}

public struct StopEngagementInputBodyMiddleware: Middleware {
    public let id: String = "StopEngagementInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopEngagementInput>,
                  next: H) -> Swift.Result<OperationOutput<StopEngagementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopEngagementInput>
    public typealias MOutput = OperationOutput<StopEngagementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopEngagementOutputError>
}

extension StopEngagementInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopEngagementInput(engagementId: \(String(describing: engagementId)), reason: \(String(describing: reason)))"}
}

extension StopEngagementInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case engagementId = "EngagementId"
        case reason = "Reason"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engagementId = engagementId {
            try encodeContainer.encode(engagementId, forKey: .engagementId)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }
}

public struct StopEngagementInputHeadersMiddleware: Middleware {
    public let id: String = "StopEngagementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopEngagementInput>,
                  next: H) -> Swift.Result<OperationOutput<StopEngagementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopEngagementInput>
    public typealias MOutput = OperationOutput<StopEngagementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopEngagementOutputError>
}

public struct StopEngagementInputQueryItemMiddleware: Middleware {
    public let id: String = "StopEngagementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopEngagementInput>,
                  next: H) -> Swift.Result<OperationOutput<StopEngagementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopEngagementInput>
    public typealias MOutput = OperationOutput<StopEngagementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopEngagementOutputError>
}

public struct StopEngagementInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the engagement.</p>
    public let engagementId: String?
    /// <p>The reason that you're stopping the engagement. </p>
    public let reason: String?

    public init (
        engagementId: String? = nil,
        reason: String? = nil
    )
    {
        self.engagementId = engagementId
        self.reason = reason
    }
}

struct StopEngagementInputBody: Equatable {
    public let engagementId: String?
    public let reason: String?
}

extension StopEngagementInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case engagementId = "EngagementId"
        case reason = "Reason"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engagementIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engagementId)
        engagementId = engagementIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension StopEngagementOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopEngagementOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopEngagementOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopEngagementOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopEngagementOutputResponse()"}
}

extension StopEngagementOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopEngagementOutputResponse: Equatable {

    public init() {}
}

struct StopEngagementOutputResponseBody: Equatable {
}

extension StopEngagementOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A container of a key-value name pair.</p>
public struct Tag: Equatable {
    /// <p>Name of the
    ///          object
    ///          key.</p>
    public let key: String?
    /// <p>Value of the tag.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceARN: \(String(describing: resourceARN)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagslist0 in tags {
                try tagsContainer.encode(tagslist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the contact or escalation plan.</p>
    public let resourceARN: String?
    /// <p>A list of tags that you are adding to the contact or escalation plan.</p>
    public let tags: [Tag]?

    public init (
        resourceARN: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Target: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channelTargetInfo = "ChannelTargetInfo"
        case contactTargetInfo = "ContactTargetInfo"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelTargetInfo = channelTargetInfo {
            try encodeContainer.encode(channelTargetInfo, forKey: .channelTargetInfo)
        }
        if let contactTargetInfo = contactTargetInfo {
            try encodeContainer.encode(contactTargetInfo, forKey: .contactTargetInfo)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelTargetInfoDecoded = try containerValues.decodeIfPresent(ChannelTargetInfo.self, forKey: .channelTargetInfo)
        channelTargetInfo = channelTargetInfoDecoded
        let contactTargetInfoDecoded = try containerValues.decodeIfPresent(ContactTargetInfo.self, forKey: .contactTargetInfo)
        contactTargetInfo = contactTargetInfoDecoded
    }
}

extension Target: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Target(channelTargetInfo: \(String(describing: channelTargetInfo)), contactTargetInfo: \(String(describing: contactTargetInfo)))"}
}

/// <p>The contact or contact channel that is being engaged.</p>
public struct Target: Equatable {
    /// <p>Information about the contact channel Incident Manager is engaging.</p>
    public let channelTargetInfo: ChannelTargetInfo?
    /// <p>Information about the contact that Incident Manager is engaging.</p>
    public let contactTargetInfo: ContactTargetInfo?

    public init (
        channelTargetInfo: ChannelTargetInfo? = nil,
        contactTargetInfo: ContactTargetInfo? = nil
    )
    {
        self.channelTargetInfo = channelTargetInfo
        self.contactTargetInfo = contactTargetInfo
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)), quotaCode: \(String(describing: quotaCode)), retryAfterSeconds: \(String(describing: retryAfterSeconds)), serviceCode: \(String(describing: serviceCode)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was denied due to request throttling.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// Service Quotas requirement to identify originating service
    public var quotaCode: String?
    /// Advice to clients on when the call can be safely retried
    public var retryAfterSeconds: Int
    /// Service Quotas requirement to identify originating quota
    public var serviceCode: String?

    public init (
        message: String? = nil,
        quotaCode: String? = nil,
        retryAfterSeconds: Int = 0,
        serviceCode: String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.retryAfterSeconds = retryAfterSeconds
        self.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
    public let quotaCode: String?
    public let serviceCode: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension TimeRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension TimeRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TimeRange(endTime: \(String(describing: endTime)), startTime: \(String(describing: startTime)))"}
}

/// <p>A range of between two set times</p>
public struct TimeRange: Equatable {
    /// <p>The end of the time range.</p>
    public let endTime: Date?
    /// <p>The start of the time range.</p>
    public let startTime: Date?

    public init (
        endTime: Date? = nil,
        startTime: Date? = nil
    )
    {
        self.endTime = endTime
        self.startTime = startTime
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceARN: \(String(describing: resourceARN)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the contact or escalation plan.</p>
    public let resourceARN: String?
    /// <p>The key of the tag that you want to remove.</p>
    public let tagKeys: [String]?

    public init (
        resourceARN: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateContactChannelInputBodyMiddleware: Middleware {
    public let id: String = "UpdateContactChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateContactChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateContactChannelInput>
    public typealias MOutput = OperationOutput<UpdateContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateContactChannelOutputError>
}

extension UpdateContactChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateContactChannelInput(contactChannelId: \(String(describing: contactChannelId)), deliveryAddress: \(String(describing: deliveryAddress)), name: \(String(describing: name)))"}
}

extension UpdateContactChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactChannelId = "ContactChannelId"
        case deliveryAddress = "DeliveryAddress"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactChannelId = contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
        if let deliveryAddress = deliveryAddress {
            try encodeContainer.encode(deliveryAddress, forKey: .deliveryAddress)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateContactChannelInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateContactChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateContactChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateContactChannelInput>
    public typealias MOutput = OperationOutput<UpdateContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateContactChannelOutputError>
}

public struct UpdateContactChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateContactChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateContactChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateContactChannelInput>
    public typealias MOutput = OperationOutput<UpdateContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateContactChannelOutputError>
}

public struct UpdateContactChannelInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the contact channel you want to update.</p>
    public let contactChannelId: String?
    /// <p>The details that Incident Manager uses when trying to engage the contact channel. </p>
    public let deliveryAddress: ContactChannelAddress?
    /// <p>The name of the contact channel</p>
    public let name: String?

    public init (
        contactChannelId: String? = nil,
        deliveryAddress: ContactChannelAddress? = nil,
        name: String? = nil
    )
    {
        self.contactChannelId = contactChannelId
        self.deliveryAddress = deliveryAddress
        self.name = name
    }
}

struct UpdateContactChannelInputBody: Equatable {
    public let contactChannelId: String?
    public let name: String?
    public let deliveryAddress: ContactChannelAddress?
}

extension UpdateContactChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactChannelId = "ContactChannelId"
        case deliveryAddress = "DeliveryAddress"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let deliveryAddressDecoded = try containerValues.decodeIfPresent(ContactChannelAddress.self, forKey: .deliveryAddress)
        deliveryAddress = deliveryAddressDecoded
    }
}

extension UpdateContactChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateContactChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateContactChannelOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateContactChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateContactChannelOutputResponse()"}
}

extension UpdateContactChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateContactChannelOutputResponse: Equatable {

    public init() {}
}

struct UpdateContactChannelOutputResponseBody: Equatable {
}

extension UpdateContactChannelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateContactInputBodyMiddleware: Middleware {
    public let id: String = "UpdateContactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateContactInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateContactInput>
    public typealias MOutput = OperationOutput<UpdateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateContactOutputError>
}

extension UpdateContactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateContactInput(contactId: \(String(describing: contactId)), displayName: \(String(describing: displayName)), plan: \(String(describing: plan)))"}
}

extension UpdateContactInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
        case displayName = "DisplayName"
        case plan = "Plan"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let plan = plan {
            try encodeContainer.encode(plan, forKey: .plan)
        }
    }
}

public struct UpdateContactInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateContactInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateContactInput>
    public typealias MOutput = OperationOutput<UpdateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateContactOutputError>
}

public struct UpdateContactInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateContactInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateContactInput>
    public typealias MOutput = OperationOutput<UpdateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateContactOutputError>
}

public struct UpdateContactInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the contact or escalation plan you're updating.</p>
    public let contactId: String?
    /// <p>The full name of the contact or escalation plan.</p>
    public let displayName: String?
    /// <p>A list of stages. A contact has an engagement plan with stages for specified contact
    ///          channels. An escalation plan uses these stages to contact specified contacts. </p>
    public let plan: Plan?

    public init (
        contactId: String? = nil,
        displayName: String? = nil,
        plan: Plan? = nil
    )
    {
        self.contactId = contactId
        self.displayName = displayName
        self.plan = plan
    }
}

struct UpdateContactInputBody: Equatable {
    public let contactId: String?
    public let displayName: String?
    public let plan: Plan?
}

extension UpdateContactInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
        case displayName = "DisplayName"
        case plan = "Plan"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let planDecoded = try containerValues.decodeIfPresent(Plan.self, forKey: .plan)
        plan = planDecoded
    }
}

extension UpdateContactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateContactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateContactOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateContactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateContactOutputResponse()"}
}

extension UpdateContactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateContactOutputResponse: Equatable {

    public init() {}
}

struct UpdateContactOutputResponseBody: Equatable {
}

extension UpdateContactOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(fields: \(String(describing: fields)), message: \(String(describing: message)), reason: \(String(describing: reason)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fields = output.fields
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fields = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The input fails to satisfy the constraints specified by an
///          AWS
///          service.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// The fields that caused the error
    public var fields: [ValidationExceptionField]?
    public var message: String?
    /// Reason the request failed validation
    public var reason: ValidationExceptionReason?

    public init (
        fields: [ValidationExceptionField]? = nil,
        message: String? = nil,
        reason: ValidationExceptionReason? = nil
    )
    {
        self.fields = fields
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
    public let reason: ValidationExceptionReason?
    public let fields: [ValidationExceptionField]?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fields = "Fields"
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension ValidationExceptionField: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationExceptionField: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationExceptionField(message: \(String(describing: message)), name: \(String(describing: name)))"}
}

/// <p>Provides information about which field caused the exception.</p>
public struct ValidationExceptionField: Equatable {
    /// <p>Information about what caused the field to cause an exception.</p>
    public let message: String?
    /// <p>The name of the field that caused the exception.</p>
    public let name: String?

    public init (
        message: String? = nil,
        name: String? = nil
    )
    {
        self.message = message
        self.name = name
    }
}

public enum ValidationExceptionReason {
    case cannotParse
    case fieldValidationFailed
    case other
    case unknownOperation
    case sdkUnknown(String)
}

extension ValidationExceptionReason : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ValidationExceptionReason] {
        return [
            .cannotParse,
            .fieldValidationFailed,
            .other,
            .unknownOperation,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cannotParse: return "CANNOT_PARSE"
        case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
        case .other: return "OTHER"
        case .unknownOperation: return "UNKNOWN_OPERATION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
    }
}
