// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)), resourceType: \(String(describing: resourceType)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have required permissions to access the requested resource.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// Resource type that caused the exception
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceType = resourceType
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
    public let resourceType: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case resourceType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public struct AssociateMemberAccountInputBodyMiddleware: Middleware {
    public let id: String = "AssociateMemberAccountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateMemberAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateMemberAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateMemberAccountInput>
    public typealias MOutput = OperationOutput<AssociateMemberAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateMemberAccountOutputError>
}

extension AssociateMemberAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateMemberAccountInput(memberAccountId: \(String(describing: memberAccountId)))"}
}

extension AssociateMemberAccountInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case memberAccountId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberAccountId = memberAccountId {
            try encodeContainer.encode(memberAccountId, forKey: .memberAccountId)
        }
    }
}

public struct AssociateMemberAccountInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateMemberAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateMemberAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateMemberAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateMemberAccountInput>
    public typealias MOutput = OperationOutput<AssociateMemberAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateMemberAccountOutputError>
}

public struct AssociateMemberAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateMemberAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateMemberAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateMemberAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateMemberAccountInput>
    public typealias MOutput = OperationOutput<AssociateMemberAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateMemberAccountOutputError>
}

public struct AssociateMemberAccountInput: Equatable {
    /// <p>The ID of the AWS account that you want to associate with Amazon Macie Classic as a
    ///       member account.</p>
    public let memberAccountId: String?

    public init (
        memberAccountId: String? = nil
    )
    {
        self.memberAccountId = memberAccountId
    }
}

struct AssociateMemberAccountInputBody: Equatable {
    public let memberAccountId: String?
}

extension AssociateMemberAccountInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case memberAccountId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .memberAccountId)
        memberAccountId = memberAccountIdDecoded
    }
}

extension AssociateMemberAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateMemberAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateMemberAccountOutputError: Equatable {
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateMemberAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateMemberAccountOutputResponse()"}
}

extension AssociateMemberAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateMemberAccountOutputResponse: Equatable {

    public init() {}
}

struct AssociateMemberAccountOutputResponseBody: Equatable {
}

extension AssociateMemberAccountOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AssociateS3ResourcesInputBodyMiddleware: Middleware {
    public let id: String = "AssociateS3ResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateS3ResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateS3ResourcesInput>
    public typealias MOutput = OperationOutput<AssociateS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateS3ResourcesOutputError>
}

extension AssociateS3ResourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateS3ResourcesInput(memberAccountId: \(String(describing: memberAccountId)), s3Resources: \(String(describing: s3Resources)))"}
}

extension AssociateS3ResourcesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case memberAccountId
        case s3Resources
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberAccountId = memberAccountId {
            try encodeContainer.encode(memberAccountId, forKey: .memberAccountId)
        }
        if let s3Resources = s3Resources {
            var s3ResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3Resources)
            for s3resourcesclassification0 in s3Resources {
                try s3ResourcesContainer.encode(s3resourcesclassification0)
            }
        }
    }
}

public struct AssociateS3ResourcesInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateS3ResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateS3ResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateS3ResourcesInput>
    public typealias MOutput = OperationOutput<AssociateS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateS3ResourcesOutputError>
}

public struct AssociateS3ResourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateS3ResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateS3ResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateS3ResourcesInput>
    public typealias MOutput = OperationOutput<AssociateS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateS3ResourcesOutputError>
}

public struct AssociateS3ResourcesInput: Equatable {
    /// <p>The ID of the Amazon Macie Classic member account whose resources you want to associate
    ///       with Macie Classic. </p>
    public let memberAccountId: String?
    /// <p>The S3 resources that you want to associate with Amazon Macie Classic for monitoring
    ///       and data classification. </p>
    public let s3Resources: [S3ResourceClassification]?

    public init (
        memberAccountId: String? = nil,
        s3Resources: [S3ResourceClassification]? = nil
    )
    {
        self.memberAccountId = memberAccountId
        self.s3Resources = s3Resources
    }
}

struct AssociateS3ResourcesInputBody: Equatable {
    public let memberAccountId: String?
    public let s3Resources: [S3ResourceClassification]?
}

extension AssociateS3ResourcesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case memberAccountId
        case s3Resources
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .memberAccountId)
        memberAccountId = memberAccountIdDecoded
        let s3ResourcesContainer = try containerValues.decodeIfPresent([S3ResourceClassification?].self, forKey: .s3Resources)
        var s3ResourcesDecoded0:[S3ResourceClassification]? = nil
        if let s3ResourcesContainer = s3ResourcesContainer {
            s3ResourcesDecoded0 = [S3ResourceClassification]()
            for structure0 in s3ResourcesContainer {
                if let structure0 = structure0 {
                    s3ResourcesDecoded0?.append(structure0)
                }
            }
        }
        s3Resources = s3ResourcesDecoded0
    }
}

extension AssociateS3ResourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateS3ResourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateS3ResourcesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateS3ResourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateS3ResourcesOutputResponse(failedS3Resources: \(String(describing: failedS3Resources)))"}
}

extension AssociateS3ResourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateS3ResourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedS3Resources = output.failedS3Resources
        } else {
            self.failedS3Resources = nil
        }
    }
}

public struct AssociateS3ResourcesOutputResponse: Equatable {
    /// <p>S3 resources that couldn't be associated with Amazon Macie Classic. An error code and
    ///       an error message are provided for each failed item. </p>
    public let failedS3Resources: [FailedS3Resource]?

    public init (
        failedS3Resources: [FailedS3Resource]? = nil
    )
    {
        self.failedS3Resources = failedS3Resources
    }
}

struct AssociateS3ResourcesOutputResponseBody: Equatable {
    public let failedS3Resources: [FailedS3Resource]?
}

extension AssociateS3ResourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedS3Resources
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedS3ResourcesContainer = try containerValues.decodeIfPresent([FailedS3Resource?].self, forKey: .failedS3Resources)
        var failedS3ResourcesDecoded0:[FailedS3Resource]? = nil
        if let failedS3ResourcesContainer = failedS3ResourcesContainer {
            failedS3ResourcesDecoded0 = [FailedS3Resource]()
            for structure0 in failedS3ResourcesContainer {
                if let structure0 = structure0 {
                    failedS3ResourcesDecoded0?.append(structure0)
                }
            }
        }
        failedS3Resources = failedS3ResourcesDecoded0
    }
}

extension ClassificationType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case continuous
        case oneTime
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let continuous = continuous {
            try encodeContainer.encode(continuous.rawValue, forKey: .continuous)
        }
        if let oneTime = oneTime {
            try encodeContainer.encode(oneTime.rawValue, forKey: .oneTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oneTimeDecoded = try containerValues.decodeIfPresent(S3OneTimeClassificationType.self, forKey: .oneTime)
        oneTime = oneTimeDecoded
        let continuousDecoded = try containerValues.decodeIfPresent(S3ContinuousClassificationType.self, forKey: .continuous)
        continuous = continuousDecoded
    }
}

extension ClassificationType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClassificationType(continuous: \(String(describing: continuous)), oneTime: \(String(describing: oneTime)))"}
}

/// <p>The classification type that Amazon Macie Classic applies to the associated S3
///       resources. </p>
public struct ClassificationType: Equatable {
    /// <p>A continuous classification of the objects that are added to a specified S3 bucket.
    ///       Amazon Macie Classic begins performing continuous classification after a bucket is
    ///       successfully associated with Macie Classic. </p>
    public let continuous: S3ContinuousClassificationType?
    /// <p>A one-time classification of all of the existing objects in a specified S3 bucket.
    ///     </p>
    public let oneTime: S3OneTimeClassificationType?

    public init (
        continuous: S3ContinuousClassificationType? = nil,
        oneTime: S3OneTimeClassificationType? = nil
    )
    {
        self.continuous = continuous
        self.oneTime = oneTime
    }
}

extension ClassificationTypeUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case continuous
        case oneTime
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let continuous = continuous {
            try encodeContainer.encode(continuous.rawValue, forKey: .continuous)
        }
        if let oneTime = oneTime {
            try encodeContainer.encode(oneTime.rawValue, forKey: .oneTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oneTimeDecoded = try containerValues.decodeIfPresent(S3OneTimeClassificationType.self, forKey: .oneTime)
        oneTime = oneTimeDecoded
        let continuousDecoded = try containerValues.decodeIfPresent(S3ContinuousClassificationType.self, forKey: .continuous)
        continuous = continuousDecoded
    }
}

extension ClassificationTypeUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClassificationTypeUpdate(continuous: \(String(describing: continuous)), oneTime: \(String(describing: oneTime)))"}
}

/// <p>The classification type that Amazon Macie Classic applies to the associated S3
///       resources. At least one of the classification types (oneTime or continuous) must be specified.
///     </p>
public struct ClassificationTypeUpdate: Equatable {
    /// <p>A continuous classification of the objects that are added to a specified S3 bucket.
    ///       Amazon Macie Classic begins performing continuous classification after a bucket is
    ///       successfully associated with Macie Classic. </p>
    public let continuous: S3ContinuousClassificationType?
    /// <p>A one-time classification of all of the existing objects in a specified S3 bucket.
    ///     </p>
    public let oneTime: S3OneTimeClassificationType?

    public init (
        continuous: S3ContinuousClassificationType? = nil,
        oneTime: S3OneTimeClassificationType? = nil
    )
    {
        self.continuous = continuous
        self.oneTime = oneTime
    }
}

public struct DisassociateMemberAccountInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateMemberAccountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateMemberAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateMemberAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateMemberAccountInput>
    public typealias MOutput = OperationOutput<DisassociateMemberAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateMemberAccountOutputError>
}

extension DisassociateMemberAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateMemberAccountInput(memberAccountId: \(String(describing: memberAccountId)))"}
}

extension DisassociateMemberAccountInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case memberAccountId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberAccountId = memberAccountId {
            try encodeContainer.encode(memberAccountId, forKey: .memberAccountId)
        }
    }
}

public struct DisassociateMemberAccountInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateMemberAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateMemberAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateMemberAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateMemberAccountInput>
    public typealias MOutput = OperationOutput<DisassociateMemberAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateMemberAccountOutputError>
}

public struct DisassociateMemberAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateMemberAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateMemberAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateMemberAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateMemberAccountInput>
    public typealias MOutput = OperationOutput<DisassociateMemberAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateMemberAccountOutputError>
}

public struct DisassociateMemberAccountInput: Equatable {
    /// <p>The ID of the member account that you want to remove from Amazon Macie
    ///       Classic.</p>
    public let memberAccountId: String?

    public init (
        memberAccountId: String? = nil
    )
    {
        self.memberAccountId = memberAccountId
    }
}

struct DisassociateMemberAccountInputBody: Equatable {
    public let memberAccountId: String?
}

extension DisassociateMemberAccountInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case memberAccountId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .memberAccountId)
        memberAccountId = memberAccountIdDecoded
    }
}

extension DisassociateMemberAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateMemberAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateMemberAccountOutputError: Equatable {
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateMemberAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateMemberAccountOutputResponse()"}
}

extension DisassociateMemberAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateMemberAccountOutputResponse: Equatable {

    public init() {}
}

struct DisassociateMemberAccountOutputResponseBody: Equatable {
}

extension DisassociateMemberAccountOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisassociateS3ResourcesInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateS3ResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateS3ResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateS3ResourcesInput>
    public typealias MOutput = OperationOutput<DisassociateS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateS3ResourcesOutputError>
}

extension DisassociateS3ResourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateS3ResourcesInput(associatedS3Resources: \(String(describing: associatedS3Resources)), memberAccountId: \(String(describing: memberAccountId)))"}
}

extension DisassociateS3ResourcesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associatedS3Resources
        case memberAccountId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedS3Resources = associatedS3Resources {
            var associatedS3ResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedS3Resources)
            for s3resources0 in associatedS3Resources {
                try associatedS3ResourcesContainer.encode(s3resources0)
            }
        }
        if let memberAccountId = memberAccountId {
            try encodeContainer.encode(memberAccountId, forKey: .memberAccountId)
        }
    }
}

public struct DisassociateS3ResourcesInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateS3ResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateS3ResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateS3ResourcesInput>
    public typealias MOutput = OperationOutput<DisassociateS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateS3ResourcesOutputError>
}

public struct DisassociateS3ResourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateS3ResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateS3ResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateS3ResourcesInput>
    public typealias MOutput = OperationOutput<DisassociateS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateS3ResourcesOutputError>
}

public struct DisassociateS3ResourcesInput: Equatable {
    /// <p>The S3 resources (buckets or prefixes) that you want to remove from being monitored and
    ///       classified by Amazon Macie Classic. </p>
    public let associatedS3Resources: [S3Resource]?
    /// <p>The ID of the Amazon Macie Classic member account whose resources you want to remove
    ///       from being monitored by Macie Classic. </p>
    public let memberAccountId: String?

    public init (
        associatedS3Resources: [S3Resource]? = nil,
        memberAccountId: String? = nil
    )
    {
        self.associatedS3Resources = associatedS3Resources
        self.memberAccountId = memberAccountId
    }
}

struct DisassociateS3ResourcesInputBody: Equatable {
    public let memberAccountId: String?
    public let associatedS3Resources: [S3Resource]?
}

extension DisassociateS3ResourcesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associatedS3Resources
        case memberAccountId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .memberAccountId)
        memberAccountId = memberAccountIdDecoded
        let associatedS3ResourcesContainer = try containerValues.decodeIfPresent([S3Resource?].self, forKey: .associatedS3Resources)
        var associatedS3ResourcesDecoded0:[S3Resource]? = nil
        if let associatedS3ResourcesContainer = associatedS3ResourcesContainer {
            associatedS3ResourcesDecoded0 = [S3Resource]()
            for structure0 in associatedS3ResourcesContainer {
                if let structure0 = structure0 {
                    associatedS3ResourcesDecoded0?.append(structure0)
                }
            }
        }
        associatedS3Resources = associatedS3ResourcesDecoded0
    }
}

extension DisassociateS3ResourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateS3ResourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateS3ResourcesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateS3ResourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateS3ResourcesOutputResponse(failedS3Resources: \(String(describing: failedS3Resources)))"}
}

extension DisassociateS3ResourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DisassociateS3ResourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedS3Resources = output.failedS3Resources
        } else {
            self.failedS3Resources = nil
        }
    }
}

public struct DisassociateS3ResourcesOutputResponse: Equatable {
    /// <p>S3 resources that couldn't be removed from being monitored and classified by Amazon
    ///       Macie Classic. An error code and an error message are provided for each failed item.
    ///     </p>
    public let failedS3Resources: [FailedS3Resource]?

    public init (
        failedS3Resources: [FailedS3Resource]? = nil
    )
    {
        self.failedS3Resources = failedS3Resources
    }
}

struct DisassociateS3ResourcesOutputResponseBody: Equatable {
    public let failedS3Resources: [FailedS3Resource]?
}

extension DisassociateS3ResourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedS3Resources
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedS3ResourcesContainer = try containerValues.decodeIfPresent([FailedS3Resource?].self, forKey: .failedS3Resources)
        var failedS3ResourcesDecoded0:[FailedS3Resource]? = nil
        if let failedS3ResourcesContainer = failedS3ResourcesContainer {
            failedS3ResourcesDecoded0 = [FailedS3Resource]()
            for structure0 in failedS3ResourcesContainer {
                if let structure0 = structure0 {
                    failedS3ResourcesDecoded0?.append(structure0)
                }
            }
        }
        failedS3Resources = failedS3ResourcesDecoded0
    }
}

extension FailedS3Resource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode
        case errorMessage
        case failedItem
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let failedItem = failedItem {
            try encodeContainer.encode(failedItem, forKey: .failedItem)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedItemDecoded = try containerValues.decodeIfPresent(S3Resource.self, forKey: .failedItem)
        failedItem = failedItemDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension FailedS3Resource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FailedS3Resource(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), failedItem: \(String(describing: failedItem)))"}
}

/// <p>Includes details about the failed S3 resources.</p>
public struct FailedS3Resource: Equatable {
    /// <p>The status code of a failed item.</p>
    public let errorCode: String?
    /// <p>The error message of a failed item.</p>
    public let errorMessage: String?
    /// <p>The failed S3 resources.</p>
    public let failedItem: S3Resource?

    public init (
        errorCode: String? = nil,
        errorMessage: String? = nil,
        failedItem: S3Resource? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.failedItem = failedItem
    }
}

extension InternalException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalException(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension InternalException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Internal server error.</p>
public struct InternalException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// Error code for the exception
    public var errorCode: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct InternalExceptionBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension InternalExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInputException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidInputException(errorCode: \(String(describing: errorCode)), fieldName: \(String(describing: fieldName)), message: \(String(describing: message)))"}
}

extension InvalidInputException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.fieldName = output.fieldName
            self.message = output.message
        } else {
            self.errorCode = nil
            self.fieldName = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because an invalid or out-of-range value was supplied for an
///       input parameter. </p>
public struct InvalidInputException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// Error code for the exception
    public var errorCode: String?
    /// Field that has invalid input
    public var fieldName: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        fieldName: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.fieldName = fieldName
        self.message = message
    }
}

struct InvalidInputExceptionBody: Equatable {
    public let errorCode: String?
    public let message: String?
    public let fieldName: String?
}

extension InvalidInputExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode
        case fieldName
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let fieldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fieldName)
        fieldName = fieldNameDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)), resourceType: \(String(describing: resourceType)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.errorCode = nil
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because it attempted to create resources beyond the current
///       AWS account limits. The error code describes the limit exceeded. </p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// Error code for the exception
    public var errorCode: String?
    public var message: String?
    /// Resource type that caused the exception
    public var resourceType: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil,
        resourceType: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
        self.resourceType = resourceType
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let errorCode: String?
    public let message: String?
    public let resourceType: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode
        case message
        case resourceType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public struct ListMemberAccountsInputBodyMiddleware: Middleware {
    public let id: String = "ListMemberAccountsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMemberAccountsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMemberAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMemberAccountsInput>
    public typealias MOutput = OperationOutput<ListMemberAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMemberAccountsOutputError>
}

extension ListMemberAccountsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMemberAccountsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListMemberAccountsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListMemberAccountsInputHeadersMiddleware: Middleware {
    public let id: String = "ListMemberAccountsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMemberAccountsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMemberAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMemberAccountsInput>
    public typealias MOutput = OperationOutput<ListMemberAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMemberAccountsOutputError>
}

public struct ListMemberAccountsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListMemberAccountsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMemberAccountsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMemberAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMemberAccountsInput>
    public typealias MOutput = OperationOutput<ListMemberAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMemberAccountsOutputError>
}

public struct ListMemberAccountsInput: Equatable {
    /// <p>Use this parameter to indicate the maximum number of items that you want in the
    ///       response. The default value is 250. </p>
    public let maxResults: Int?
    /// <p>Use this parameter when paginating results. Set the value of this parameter to null on
    ///       your first call to the ListMemberAccounts action. Subsequent calls to the action fill
    ///       nextToken in the request with the value of nextToken from the previous response to continue
    ///       listing data. </p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMemberAccountsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListMemberAccountsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListMemberAccountsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMemberAccountsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMemberAccountsOutputError: Equatable {
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMemberAccountsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMemberAccountsOutputResponse(memberAccounts: \(String(describing: memberAccounts)), nextToken: \(String(describing: nextToken)))"}
}

extension ListMemberAccountsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListMemberAccountsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.memberAccounts = output.memberAccounts
            self.nextToken = output.nextToken
        } else {
            self.memberAccounts = nil
            self.nextToken = nil
        }
    }
}

public struct ListMemberAccountsOutputResponse: Equatable {
    /// <p>A list of the Amazon Macie Classic member accounts returned by the action. The current
    ///       Macie Classic administrator account is also included in this list. </p>
    public let memberAccounts: [MemberAccount]?
    /// <p>When a response is generated, if there is more data to be listed, this parameter is
    ///       present in the response and contains the value to use for the nextToken parameter in a
    ///       subsequent pagination request. If there is no more data to be listed, this parameter is set to
    ///       null. </p>
    public let nextToken: String?

    public init (
        memberAccounts: [MemberAccount]? = nil,
        nextToken: String? = nil
    )
    {
        self.memberAccounts = memberAccounts
        self.nextToken = nextToken
    }
}

struct ListMemberAccountsOutputResponseBody: Equatable {
    public let memberAccounts: [MemberAccount]?
    public let nextToken: String?
}

extension ListMemberAccountsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case memberAccounts
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberAccountsContainer = try containerValues.decodeIfPresent([MemberAccount?].self, forKey: .memberAccounts)
        var memberAccountsDecoded0:[MemberAccount]? = nil
        if let memberAccountsContainer = memberAccountsContainer {
            memberAccountsDecoded0 = [MemberAccount]()
            for structure0 in memberAccountsContainer {
                if let structure0 = structure0 {
                    memberAccountsDecoded0?.append(structure0)
                }
            }
        }
        memberAccounts = memberAccountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListS3ResourcesInputBodyMiddleware: Middleware {
    public let id: String = "ListS3ResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListS3ResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListS3ResourcesInput>
    public typealias MOutput = OperationOutput<ListS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListS3ResourcesOutputError>
}

extension ListS3ResourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListS3ResourcesInput(maxResults: \(String(describing: maxResults)), memberAccountId: \(String(describing: memberAccountId)), nextToken: \(String(describing: nextToken)))"}
}

extension ListS3ResourcesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case memberAccountId
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let memberAccountId = memberAccountId {
            try encodeContainer.encode(memberAccountId, forKey: .memberAccountId)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListS3ResourcesInputHeadersMiddleware: Middleware {
    public let id: String = "ListS3ResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListS3ResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListS3ResourcesInput>
    public typealias MOutput = OperationOutput<ListS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListS3ResourcesOutputError>
}

public struct ListS3ResourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListS3ResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListS3ResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListS3ResourcesInput>
    public typealias MOutput = OperationOutput<ListS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListS3ResourcesOutputError>
}

public struct ListS3ResourcesInput: Equatable {
    /// <p>Use this parameter to indicate the maximum number of items that you want in the
    ///       response. The default value is 250. </p>
    public let maxResults: Int?
    /// <p>The Amazon Macie Classic member account ID whose associated S3 resources you want to
    ///       list. </p>
    public let memberAccountId: String?
    /// <p>Use this parameter when paginating results. Set its value to null on your first call to
    ///       the ListS3Resources action. Subsequent calls to the action fill nextToken in the request with
    ///       the value of nextToken from the previous response to continue listing data. </p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        memberAccountId: String? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.memberAccountId = memberAccountId
        self.nextToken = nextToken
    }
}

struct ListS3ResourcesInputBody: Equatable {
    public let memberAccountId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListS3ResourcesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case memberAccountId
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .memberAccountId)
        memberAccountId = memberAccountIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListS3ResourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListS3ResourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListS3ResourcesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListS3ResourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListS3ResourcesOutputResponse(nextToken: \(String(describing: nextToken)), s3Resources: \(String(describing: s3Resources)))"}
}

extension ListS3ResourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListS3ResourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.s3Resources = output.s3Resources
        } else {
            self.nextToken = nil
            self.s3Resources = nil
        }
    }
}

public struct ListS3ResourcesOutputResponse: Equatable {
    /// <p>When a response is generated, if there is more data to be listed, this parameter is
    ///       present in the response and contains the value to use for the nextToken parameter in a
    ///       subsequent pagination request. If there is no more data to be listed, this parameter is set to
    ///       null. </p>
    public let nextToken: String?
    /// <p>A list of the associated S3 resources returned by the action.</p>
    public let s3Resources: [S3ResourceClassification]?

    public init (
        nextToken: String? = nil,
        s3Resources: [S3ResourceClassification]? = nil
    )
    {
        self.nextToken = nextToken
        self.s3Resources = s3Resources
    }
}

struct ListS3ResourcesOutputResponseBody: Equatable {
    public let s3Resources: [S3ResourceClassification]?
    public let nextToken: String?
}

extension ListS3ResourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case s3Resources
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ResourcesContainer = try containerValues.decodeIfPresent([S3ResourceClassification?].self, forKey: .s3Resources)
        var s3ResourcesDecoded0:[S3ResourceClassification]? = nil
        if let s3ResourcesContainer = s3ResourcesContainer {
            s3ResourcesDecoded0 = [S3ResourceClassification]()
            for structure0 in s3ResourcesContainer {
                if let structure0 = structure0 {
                    s3ResourcesDecoded0?.append(structure0)
                }
            }
        }
        s3Resources = s3ResourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MemberAccount: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension MemberAccount: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MemberAccount(accountId: \(String(describing: accountId)))"}
}

/// <p>Contains information about the Amazon Macie Classic member account.</p>
public struct MemberAccount: Equatable {
    /// <p>The AWS account ID of the Amazon Macie Classic member account.</p>
    public let accountId: String?

    public init (
        accountId: String? = nil
    )
    {
        self.accountId = accountId
    }
}

public enum S3ContinuousClassificationType {
    case full
    case sdkUnknown(String)
}

extension S3ContinuousClassificationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [S3ContinuousClassificationType] {
        return [
            .full,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .full: return "FULL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = S3ContinuousClassificationType(rawValue: rawValue) ?? S3ContinuousClassificationType.sdkUnknown(rawValue)
    }
}

public enum S3OneTimeClassificationType {
    case full
    case `none`
    case sdkUnknown(String)
}

extension S3OneTimeClassificationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [S3OneTimeClassificationType] {
        return [
            .full,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .full: return "FULL"
        case .none: return "NONE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = S3OneTimeClassificationType(rawValue: rawValue) ?? S3OneTimeClassificationType.sdkUnknown(rawValue)
    }
}

extension S3Resource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketName
        case prefix
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let prefix = prefix {
            try encodeContainer.encode(prefix, forKey: .prefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
    }
}

extension S3Resource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Resource(bucketName: \(String(describing: bucketName)), prefix: \(String(describing: prefix)))"}
}

/// <p>Contains information about the S3 resource. This data type is used as a request
///       parameter in the DisassociateS3Resources action and can be used as a response parameter in the
///       AssociateS3Resources and UpdateS3Resources actions. </p>
public struct S3Resource: Equatable {
    /// <p>The name of the S3 bucket.</p>
    public let bucketName: String?
    /// <p>The prefix of the S3 bucket. </p>
    public let prefix: String?

    public init (
        bucketName: String? = nil,
        prefix: String? = nil
    )
    {
        self.bucketName = bucketName
        self.prefix = prefix
    }
}

extension S3ResourceClassification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketName
        case classificationType
        case prefix
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let classificationType = classificationType {
            try encodeContainer.encode(classificationType, forKey: .classificationType)
        }
        if let prefix = prefix {
            try encodeContainer.encode(prefix, forKey: .prefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
        let classificationTypeDecoded = try containerValues.decodeIfPresent(ClassificationType.self, forKey: .classificationType)
        classificationType = classificationTypeDecoded
    }
}

extension S3ResourceClassification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3ResourceClassification(bucketName: \(String(describing: bucketName)), classificationType: \(String(describing: classificationType)), prefix: \(String(describing: prefix)))"}
}

/// <p>The S3 resources that you want to associate with Amazon Macie Classic for monitoring
///       and data classification. This data type is used as a request parameter in the
///       AssociateS3Resources action and a response parameter in the ListS3Resources action. </p>
public struct S3ResourceClassification: Equatable {
    /// <p>The name of the S3 bucket that you want to associate with Amazon Macie
    ///       Classic.</p>
    public let bucketName: String?
    /// <p>The classification type that you want to specify for the resource associated with
    ///       Amazon Macie Classic. </p>
    public let classificationType: ClassificationType?
    /// <p>The prefix of the S3 bucket that you want to associate with Amazon Macie
    ///       Classic.</p>
    public let prefix: String?

    public init (
        bucketName: String? = nil,
        classificationType: ClassificationType? = nil,
        prefix: String? = nil
    )
    {
        self.bucketName = bucketName
        self.classificationType = classificationType
        self.prefix = prefix
    }
}

extension S3ResourceClassificationUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketName
        case classificationTypeUpdate
        case prefix
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let classificationTypeUpdate = classificationTypeUpdate {
            try encodeContainer.encode(classificationTypeUpdate, forKey: .classificationTypeUpdate)
        }
        if let prefix = prefix {
            try encodeContainer.encode(prefix, forKey: .prefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
        let classificationTypeUpdateDecoded = try containerValues.decodeIfPresent(ClassificationTypeUpdate.self, forKey: .classificationTypeUpdate)
        classificationTypeUpdate = classificationTypeUpdateDecoded
    }
}

extension S3ResourceClassificationUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3ResourceClassificationUpdate(bucketName: \(String(describing: bucketName)), classificationTypeUpdate: \(String(describing: classificationTypeUpdate)), prefix: \(String(describing: prefix)))"}
}

/// <p>The S3 resources whose classification types you want to update. This data type is used
///       as a request parameter in the UpdateS3Resources action. </p>
public struct S3ResourceClassificationUpdate: Equatable {
    /// <p>The name of the S3 bucket whose classification types you want to update.</p>
    public let bucketName: String?
    /// <p>The classification type that you want to update for the resource associated with Amazon
    ///       Macie Classic. </p>
    public let classificationTypeUpdate: ClassificationTypeUpdate?
    /// <p>The prefix of the S3 bucket whose classification types you want to update.</p>
    public let prefix: String?

    public init (
        bucketName: String? = nil,
        classificationTypeUpdate: ClassificationTypeUpdate? = nil,
        prefix: String? = nil
    )
    {
        self.bucketName = bucketName
        self.classificationTypeUpdate = classificationTypeUpdate
        self.prefix = prefix
    }
}

public struct UpdateS3ResourcesInputBodyMiddleware: Middleware {
    public let id: String = "UpdateS3ResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateS3ResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateS3ResourcesInput>
    public typealias MOutput = OperationOutput<UpdateS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateS3ResourcesOutputError>
}

extension UpdateS3ResourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateS3ResourcesInput(memberAccountId: \(String(describing: memberAccountId)), s3ResourcesUpdate: \(String(describing: s3ResourcesUpdate)))"}
}

extension UpdateS3ResourcesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case memberAccountId
        case s3ResourcesUpdate
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberAccountId = memberAccountId {
            try encodeContainer.encode(memberAccountId, forKey: .memberAccountId)
        }
        if let s3ResourcesUpdate = s3ResourcesUpdate {
            var s3ResourcesUpdateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3ResourcesUpdate)
            for s3resourcesclassificationupdate0 in s3ResourcesUpdate {
                try s3ResourcesUpdateContainer.encode(s3resourcesclassificationupdate0)
            }
        }
    }
}

public struct UpdateS3ResourcesInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateS3ResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateS3ResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateS3ResourcesInput>
    public typealias MOutput = OperationOutput<UpdateS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateS3ResourcesOutputError>
}

public struct UpdateS3ResourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateS3ResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateS3ResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateS3ResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateS3ResourcesInput>
    public typealias MOutput = OperationOutput<UpdateS3ResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateS3ResourcesOutputError>
}

public struct UpdateS3ResourcesInput: Equatable {
    /// <p>The AWS ID of the Amazon Macie Classic member account whose S3 resources'
    ///       classification types you want to update. </p>
    public let memberAccountId: String?
    /// <p>The S3 resources whose classification types you want to update.</p>
    public let s3ResourcesUpdate: [S3ResourceClassificationUpdate]?

    public init (
        memberAccountId: String? = nil,
        s3ResourcesUpdate: [S3ResourceClassificationUpdate]? = nil
    )
    {
        self.memberAccountId = memberAccountId
        self.s3ResourcesUpdate = s3ResourcesUpdate
    }
}

struct UpdateS3ResourcesInputBody: Equatable {
    public let memberAccountId: String?
    public let s3ResourcesUpdate: [S3ResourceClassificationUpdate]?
}

extension UpdateS3ResourcesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case memberAccountId
        case s3ResourcesUpdate
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .memberAccountId)
        memberAccountId = memberAccountIdDecoded
        let s3ResourcesUpdateContainer = try containerValues.decodeIfPresent([S3ResourceClassificationUpdate?].self, forKey: .s3ResourcesUpdate)
        var s3ResourcesUpdateDecoded0:[S3ResourceClassificationUpdate]? = nil
        if let s3ResourcesUpdateContainer = s3ResourcesUpdateContainer {
            s3ResourcesUpdateDecoded0 = [S3ResourceClassificationUpdate]()
            for structure0 in s3ResourcesUpdateContainer {
                if let structure0 = structure0 {
                    s3ResourcesUpdateDecoded0?.append(structure0)
                }
            }
        }
        s3ResourcesUpdate = s3ResourcesUpdateDecoded0
    }
}

extension UpdateS3ResourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateS3ResourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateS3ResourcesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateS3ResourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateS3ResourcesOutputResponse(failedS3Resources: \(String(describing: failedS3Resources)))"}
}

extension UpdateS3ResourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateS3ResourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedS3Resources = output.failedS3Resources
        } else {
            self.failedS3Resources = nil
        }
    }
}

public struct UpdateS3ResourcesOutputResponse: Equatable {
    /// <p>The S3 resources whose classification types can't be updated. An error code and an
    ///       error message are provided for each failed item. </p>
    public let failedS3Resources: [FailedS3Resource]?

    public init (
        failedS3Resources: [FailedS3Resource]? = nil
    )
    {
        self.failedS3Resources = failedS3Resources
    }
}

struct UpdateS3ResourcesOutputResponseBody: Equatable {
    public let failedS3Resources: [FailedS3Resource]?
}

extension UpdateS3ResourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedS3Resources
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedS3ResourcesContainer = try containerValues.decodeIfPresent([FailedS3Resource?].self, forKey: .failedS3Resources)
        var failedS3ResourcesDecoded0:[FailedS3Resource]? = nil
        if let failedS3ResourcesContainer = failedS3ResourcesContainer {
            failedS3ResourcesDecoded0 = [FailedS3Resource]()
            for structure0 in failedS3ResourcesContainer {
                if let structure0 = structure0 {
                    failedS3ResourcesDecoded0?.append(structure0)
                }
            }
        }
        failedS3Resources = failedS3ResourcesDecoded0
    }
}
