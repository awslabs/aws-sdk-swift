// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AcceptDirectConnectGatewayAssociationProposalInputBodyMiddleware: Middleware {
    public let id: String = "AcceptDirectConnectGatewayAssociationProposalInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptDirectConnectGatewayAssociationProposalInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptDirectConnectGatewayAssociationProposalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptDirectConnectGatewayAssociationProposalInput>
    public typealias MOutput = OperationOutput<AcceptDirectConnectGatewayAssociationProposalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptDirectConnectGatewayAssociationProposalOutputError>
}

extension AcceptDirectConnectGatewayAssociationProposalInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptDirectConnectGatewayAssociationProposalInput(associatedGatewayOwnerAccount: \(String(describing: associatedGatewayOwnerAccount)), directConnectGatewayId: \(String(describing: directConnectGatewayId)), overrideAllowedPrefixesToDirectConnectGateway: \(String(describing: overrideAllowedPrefixesToDirectConnectGateway)), proposalId: \(String(describing: proposalId)))"}
}

extension AcceptDirectConnectGatewayAssociationProposalInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associatedGatewayOwnerAccount
        case directConnectGatewayId
        case overrideAllowedPrefixesToDirectConnectGateway
        case proposalId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedGatewayOwnerAccount = associatedGatewayOwnerAccount {
            try encodeContainer.encode(associatedGatewayOwnerAccount, forKey: .associatedGatewayOwnerAccount)
        }
        if let directConnectGatewayId = directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let overrideAllowedPrefixesToDirectConnectGateway = overrideAllowedPrefixesToDirectConnectGateway {
            var overrideAllowedPrefixesToDirectConnectGatewayContainer = encodeContainer.nestedUnkeyedContainer(forKey: .overrideAllowedPrefixesToDirectConnectGateway)
            for routefilterprefixlist0 in overrideAllowedPrefixesToDirectConnectGateway {
                try overrideAllowedPrefixesToDirectConnectGatewayContainer.encode(routefilterprefixlist0)
            }
        }
        if let proposalId = proposalId {
            try encodeContainer.encode(proposalId, forKey: .proposalId)
        }
    }
}

public struct AcceptDirectConnectGatewayAssociationProposalInputHeadersMiddleware: Middleware {
    public let id: String = "AcceptDirectConnectGatewayAssociationProposalInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptDirectConnectGatewayAssociationProposalInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptDirectConnectGatewayAssociationProposalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptDirectConnectGatewayAssociationProposalInput>
    public typealias MOutput = OperationOutput<AcceptDirectConnectGatewayAssociationProposalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptDirectConnectGatewayAssociationProposalOutputError>
}

public struct AcceptDirectConnectGatewayAssociationProposalInputQueryItemMiddleware: Middleware {
    public let id: String = "AcceptDirectConnectGatewayAssociationProposalInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptDirectConnectGatewayAssociationProposalInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptDirectConnectGatewayAssociationProposalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptDirectConnectGatewayAssociationProposalInput>
    public typealias MOutput = OperationOutput<AcceptDirectConnectGatewayAssociationProposalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptDirectConnectGatewayAssociationProposalOutputError>
}

public struct AcceptDirectConnectGatewayAssociationProposalInput: Equatable {
    /// <p>The ID of the AWS account that owns the virtual private gateway or transit gateway.</p>
    public let associatedGatewayOwnerAccount: String?
    /// <p>The ID of the Direct Connect gateway.</p>
    public let directConnectGatewayId: String?
    /// <p>Overrides the Amazon VPC prefixes advertised to the Direct Connect gateway.</p>
    ///          <p>For information about how to set the prefixes, see <a href="https://docs.aws.amazon.com/directconnect/latest/UserGuide/multi-account-associate-vgw.html#allowed-prefixes">Allowed Prefixes</a> in the <i>AWS Direct Connect User Guide</i>.</p>
    public let overrideAllowedPrefixesToDirectConnectGateway: [RouteFilterPrefix]?
    /// <p>The ID of the request proposal.</p>
    public let proposalId: String?

    public init (
        associatedGatewayOwnerAccount: String? = nil,
        directConnectGatewayId: String? = nil,
        overrideAllowedPrefixesToDirectConnectGateway: [RouteFilterPrefix]? = nil,
        proposalId: String? = nil
    )
    {
        self.associatedGatewayOwnerAccount = associatedGatewayOwnerAccount
        self.directConnectGatewayId = directConnectGatewayId
        self.overrideAllowedPrefixesToDirectConnectGateway = overrideAllowedPrefixesToDirectConnectGateway
        self.proposalId = proposalId
    }
}

struct AcceptDirectConnectGatewayAssociationProposalInputBody: Equatable {
    public let directConnectGatewayId: String?
    public let proposalId: String?
    public let associatedGatewayOwnerAccount: String?
    public let overrideAllowedPrefixesToDirectConnectGateway: [RouteFilterPrefix]?
}

extension AcceptDirectConnectGatewayAssociationProposalInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associatedGatewayOwnerAccount
        case directConnectGatewayId
        case overrideAllowedPrefixesToDirectConnectGateway
        case proposalId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let proposalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .proposalId)
        proposalId = proposalIdDecoded
        let associatedGatewayOwnerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associatedGatewayOwnerAccount)
        associatedGatewayOwnerAccount = associatedGatewayOwnerAccountDecoded
        let overrideAllowedPrefixesToDirectConnectGatewayContainer = try containerValues.decodeIfPresent([RouteFilterPrefix?].self, forKey: .overrideAllowedPrefixesToDirectConnectGateway)
        var overrideAllowedPrefixesToDirectConnectGatewayDecoded0:[RouteFilterPrefix]? = nil
        if let overrideAllowedPrefixesToDirectConnectGatewayContainer = overrideAllowedPrefixesToDirectConnectGatewayContainer {
            overrideAllowedPrefixesToDirectConnectGatewayDecoded0 = [RouteFilterPrefix]()
            for structure0 in overrideAllowedPrefixesToDirectConnectGatewayContainer {
                if let structure0 = structure0 {
                    overrideAllowedPrefixesToDirectConnectGatewayDecoded0?.append(structure0)
                }
            }
        }
        overrideAllowedPrefixesToDirectConnectGateway = overrideAllowedPrefixesToDirectConnectGatewayDecoded0
    }
}

extension AcceptDirectConnectGatewayAssociationProposalOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptDirectConnectGatewayAssociationProposalOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcceptDirectConnectGatewayAssociationProposalOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptDirectConnectGatewayAssociationProposalOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptDirectConnectGatewayAssociationProposalOutputResponse(directConnectGatewayAssociation: \(String(describing: directConnectGatewayAssociation)))"}
}

extension AcceptDirectConnectGatewayAssociationProposalOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AcceptDirectConnectGatewayAssociationProposalOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directConnectGatewayAssociation = output.directConnectGatewayAssociation
        } else {
            self.directConnectGatewayAssociation = nil
        }
    }
}

public struct AcceptDirectConnectGatewayAssociationProposalOutputResponse: Equatable {
    /// <p>Information about an association between a Direct Connect gateway and a virtual private gateway or transit gateway.</p>
    public let directConnectGatewayAssociation: DirectConnectGatewayAssociation?

    public init (
        directConnectGatewayAssociation: DirectConnectGatewayAssociation? = nil
    )
    {
        self.directConnectGatewayAssociation = directConnectGatewayAssociation
    }
}

struct AcceptDirectConnectGatewayAssociationProposalOutputResponseBody: Equatable {
    public let directConnectGatewayAssociation: DirectConnectGatewayAssociation?
}

extension AcceptDirectConnectGatewayAssociationProposalOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directConnectGatewayAssociation
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayAssociationDecoded = try containerValues.decodeIfPresent(DirectConnectGatewayAssociation.self, forKey: .directConnectGatewayAssociation)
        directConnectGatewayAssociation = directConnectGatewayAssociationDecoded
    }
}

public enum AddressFamily {
    case ipv4
    case ipv6
    case sdkUnknown(String)
}

extension AddressFamily : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AddressFamily] {
        return [
            .ipv4,
            .ipv6,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ipv4: return "ipv4"
        case .ipv6: return "ipv6"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AddressFamily(rawValue: rawValue) ?? AddressFamily.sdkUnknown(rawValue)
    }
}

public struct AllocateConnectionOnInterconnectInputBodyMiddleware: Middleware {
    public let id: String = "AllocateConnectionOnInterconnectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AllocateConnectionOnInterconnectInput>,
                  next: H) -> Swift.Result<OperationOutput<AllocateConnectionOnInterconnectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AllocateConnectionOnInterconnectInput>
    public typealias MOutput = OperationOutput<AllocateConnectionOnInterconnectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AllocateConnectionOnInterconnectOutputError>
}

extension AllocateConnectionOnInterconnectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AllocateConnectionOnInterconnectInput(bandwidth: \(String(describing: bandwidth)), connectionName: \(String(describing: connectionName)), interconnectId: \(String(describing: interconnectId)), ownerAccount: \(String(describing: ownerAccount)), vlan: \(String(describing: vlan)))"}
}

extension AllocateConnectionOnInterconnectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bandwidth
        case connectionName
        case interconnectId
        case ownerAccount
        case vlan
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidth = bandwidth {
            try encodeContainer.encode(bandwidth, forKey: .bandwidth)
        }
        if let connectionName = connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let interconnectId = interconnectId {
            try encodeContainer.encode(interconnectId, forKey: .interconnectId)
        }
        if let ownerAccount = ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
        if vlan != 0 {
            try encodeContainer.encode(vlan, forKey: .vlan)
        }
    }
}

public struct AllocateConnectionOnInterconnectInputHeadersMiddleware: Middleware {
    public let id: String = "AllocateConnectionOnInterconnectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AllocateConnectionOnInterconnectInput>,
                  next: H) -> Swift.Result<OperationOutput<AllocateConnectionOnInterconnectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AllocateConnectionOnInterconnectInput>
    public typealias MOutput = OperationOutput<AllocateConnectionOnInterconnectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AllocateConnectionOnInterconnectOutputError>
}

public struct AllocateConnectionOnInterconnectInputQueryItemMiddleware: Middleware {
    public let id: String = "AllocateConnectionOnInterconnectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AllocateConnectionOnInterconnectInput>,
                  next: H) -> Swift.Result<OperationOutput<AllocateConnectionOnInterconnectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AllocateConnectionOnInterconnectInput>
    public typealias MOutput = OperationOutput<AllocateConnectionOnInterconnectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AllocateConnectionOnInterconnectOutputError>
}

public struct AllocateConnectionOnInterconnectInput: Equatable {
    /// <p>The bandwidth of the connection. The possible values are 50Mbps, 100Mbps, 200Mbps,
    ///       300Mbps, 400Mbps, 500Mbps, 1Gbps, 2Gbps, 5Gbps, and 10Gbps. Note that only those AWS Direct Connect Partners
    ///       who have met specific requirements
    ///     are allowed to create a 1Gbps, 2Gbps, 5Gbps or 10Gbps hosted connection.</p>
    public let bandwidth: String?
    /// <p>The name of the provisioned connection.</p>
    public let connectionName: String?
    /// <p>The ID of the interconnect on which the connection will be provisioned.</p>
    public let interconnectId: String?
    /// <p>The ID of the AWS account of the customer for whom the connection will be provisioned.</p>
    public let ownerAccount: String?
    /// <p>The dedicated VLAN provisioned to the connection.</p>
    public let vlan: Int

    public init (
        bandwidth: String? = nil,
        connectionName: String? = nil,
        interconnectId: String? = nil,
        ownerAccount: String? = nil,
        vlan: Int = 0
    )
    {
        self.bandwidth = bandwidth
        self.connectionName = connectionName
        self.interconnectId = interconnectId
        self.ownerAccount = ownerAccount
        self.vlan = vlan
    }
}

struct AllocateConnectionOnInterconnectInputBody: Equatable {
    public let bandwidth: String?
    public let connectionName: String?
    public let ownerAccount: String?
    public let interconnectId: String?
    public let vlan: Int
}

extension AllocateConnectionOnInterconnectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bandwidth
        case connectionName
        case interconnectId
        case ownerAccount
        case vlan
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bandwidthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let connectionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let interconnectIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .interconnectId)
        interconnectId = interconnectIdDecoded
        let vlanDecoded = try containerValues.decode(Int.self, forKey: .vlan)
        vlan = vlanDecoded
    }
}

extension AllocateConnectionOnInterconnectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AllocateConnectionOnInterconnectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AllocateConnectionOnInterconnectOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AllocateConnectionOnInterconnectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AllocateConnectionOnInterconnectOutputResponse(awsDevice: \(String(describing: awsDevice)), awsDeviceV2: \(String(describing: awsDeviceV2)), bandwidth: \(String(describing: bandwidth)), connectionId: \(String(describing: connectionId)), connectionName: \(String(describing: connectionName)), connectionState: \(String(describing: connectionState)), encryptionMode: \(String(describing: encryptionMode)), hasLogicalRedundancy: \(String(describing: hasLogicalRedundancy)), jumboFrameCapable: \(String(describing: jumboFrameCapable)), lagId: \(String(describing: lagId)), loaIssueTime: \(String(describing: loaIssueTime)), location: \(String(describing: location)), macSecCapable: \(String(describing: macSecCapable)), macSecKeys: \(String(describing: macSecKeys)), ownerAccount: \(String(describing: ownerAccount)), partnerName: \(String(describing: partnerName)), portEncryptionStatus: \(String(describing: portEncryptionStatus)), providerName: \(String(describing: providerName)), region: \(String(describing: region)), tags: \(String(describing: tags)), vlan: \(String(describing: vlan)))"}
}

extension AllocateConnectionOnInterconnectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AllocateConnectionOnInterconnectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.awsDevice = output.awsDevice
            self.awsDeviceV2 = output.awsDeviceV2
            self.bandwidth = output.bandwidth
            self.connectionId = output.connectionId
            self.connectionName = output.connectionName
            self.connectionState = output.connectionState
            self.encryptionMode = output.encryptionMode
            self.hasLogicalRedundancy = output.hasLogicalRedundancy
            self.jumboFrameCapable = output.jumboFrameCapable
            self.lagId = output.lagId
            self.loaIssueTime = output.loaIssueTime
            self.location = output.location
            self.macSecCapable = output.macSecCapable
            self.macSecKeys = output.macSecKeys
            self.ownerAccount = output.ownerAccount
            self.partnerName = output.partnerName
            self.portEncryptionStatus = output.portEncryptionStatus
            self.providerName = output.providerName
            self.region = output.region
            self.tags = output.tags
            self.vlan = output.vlan
        } else {
            self.awsDevice = nil
            self.awsDeviceV2 = nil
            self.bandwidth = nil
            self.connectionId = nil
            self.connectionName = nil
            self.connectionState = nil
            self.encryptionMode = nil
            self.hasLogicalRedundancy = nil
            self.jumboFrameCapable = nil
            self.lagId = nil
            self.loaIssueTime = nil
            self.location = nil
            self.macSecCapable = nil
            self.macSecKeys = nil
            self.ownerAccount = nil
            self.partnerName = nil
            self.portEncryptionStatus = nil
            self.providerName = nil
            self.region = nil
            self.tags = nil
            self.vlan = 0
        }
    }
}

/// <p>Information about an AWS Direct Connect connection.</p>
public struct AllocateConnectionOnInterconnectOutputResponse: Equatable {
    /// <p>The Direct Connect endpoint on which the physical connection terminates.</p>
    @available(*, deprecated)
    public let awsDevice: String?
    /// <p>The Direct Connect endpoint on which the physical connection terminates.</p>
    public let awsDeviceV2: String?
    /// <p>The bandwidth of the connection.</p>
    public let bandwidth: String?
    /// <p>The ID of the connection.</p>
    public let connectionId: String?
    /// <p>The name of the connection.</p>
    public let connectionName: String?
    /// <p>The state of the connection. The following are the possible values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ordering</code>: The initial state of a hosted connection provisioned on an interconnect. The connection stays in the ordering state until the owner of the hosted connection confirms or declines the connection order.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>requested</code>: The initial state of a standard connection. The connection stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: The connection has been approved and is being initialized.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>available</code>: The network link is up and the connection is ready for use.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>down</code>: The network link is down.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>: The connection is being deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>: The connection has been deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>rejected</code>: A hosted connection in the <code>ordering</code> state enters the <code>rejected</code> state if it is deleted by the customer.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>unknown</code>: The state of the connection is not available.</p>
    ///             </li>
    ///          </ul>
    public let connectionState: ConnectionState?
    /// <p>The MAC Security (MACsec) connection encryption mode.</p>
    ///          <p>The valid values are <code>no_encrypt</code>, <code>should_encrypt</code>, and <code>must_encrypt</code>.</p>
    public let encryptionMode: String?
    /// <p>Indicates whether the connection supports a secondary BGP peer in the same address family (IPv4/IPv6).</p>
    public let hasLogicalRedundancy: HasLogicalRedundancy?
    /// <p>Indicates whether jumbo frames (9001 MTU) are supported.</p>
    public let jumboFrameCapable: Bool?
    /// <p>The ID of the LAG.</p>
    public let lagId: String?
    /// <p>The time of the most recent call to <a>DescribeLoa</a> for this connection.</p>
    public let loaIssueTime: Date?
    /// <p>The location of the connection.</p>
    public let location: String?
    /// <p>Indicates whether the connection supports MAC Security (MACsec).</p>
    public let macSecCapable: Bool?
    /// <p>The MAC Security (MACsec) security keys associated with the connection.</p>
    public let macSecKeys: [MacSecKey]?
    /// <p>The ID of the AWS account that owns the connection.</p>
    public let ownerAccount: String?
    /// <p>The name of the AWS Direct Connect service provider associated with the connection.</p>
    public let partnerName: String?
    /// <p>The MAC Security (MACsec) port link status of the connection.</p>
    ///          <p>The valid values are <code>Encryption Up</code>, which means that there is an active Connection Key Name, or <code>Encryption Down</code>.</p>
    public let portEncryptionStatus: String?
    /// <p>The name of the service provider associated with the connection.</p>
    public let providerName: String?
    /// <p>The AWS Region where the connection is located.</p>
    public let region: String?
    /// <p>The tags associated with the connection.</p>
    public let tags: [Tag]?
    /// <p>The ID of the VLAN.</p>
    public let vlan: Int

    public init (
        awsDevice: String? = nil,
        awsDeviceV2: String? = nil,
        bandwidth: String? = nil,
        connectionId: String? = nil,
        connectionName: String? = nil,
        connectionState: ConnectionState? = nil,
        encryptionMode: String? = nil,
        hasLogicalRedundancy: HasLogicalRedundancy? = nil,
        jumboFrameCapable: Bool? = nil,
        lagId: String? = nil,
        loaIssueTime: Date? = nil,
        location: String? = nil,
        macSecCapable: Bool? = nil,
        macSecKeys: [MacSecKey]? = nil,
        ownerAccount: String? = nil,
        partnerName: String? = nil,
        portEncryptionStatus: String? = nil,
        providerName: String? = nil,
        region: String? = nil,
        tags: [Tag]? = nil,
        vlan: Int = 0
    )
    {
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.bandwidth = bandwidth
        self.connectionId = connectionId
        self.connectionName = connectionName
        self.connectionState = connectionState
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.loaIssueTime = loaIssueTime
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.ownerAccount = ownerAccount
        self.partnerName = partnerName
        self.portEncryptionStatus = portEncryptionStatus
        self.providerName = providerName
        self.region = region
        self.tags = tags
        self.vlan = vlan
    }
}

struct AllocateConnectionOnInterconnectOutputResponseBody: Equatable {
    public let ownerAccount: String?
    public let connectionId: String?
    public let connectionName: String?
    public let connectionState: ConnectionState?
    public let region: String?
    public let location: String?
    public let bandwidth: String?
    public let vlan: Int
    public let partnerName: String?
    public let loaIssueTime: Date?
    public let lagId: String?
    public let awsDevice: String?
    public let jumboFrameCapable: Bool?
    public let awsDeviceV2: String?
    public let hasLogicalRedundancy: HasLogicalRedundancy?
    public let tags: [Tag]?
    public let providerName: String?
    public let macSecCapable: Bool?
    public let portEncryptionStatus: String?
    public let encryptionMode: String?
    public let macSecKeys: [MacSecKey]?
}

extension AllocateConnectionOnInterconnectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case awsDevice
        case awsDeviceV2
        case bandwidth
        case connectionId
        case connectionName
        case connectionState
        case encryptionMode
        case hasLogicalRedundancy
        case jumboFrameCapable
        case lagId
        case loaIssueTime
        case location
        case macSecCapable
        case macSecKeys
        case ownerAccount
        case partnerName
        case portEncryptionStatus
        case providerName
        case region
        case tags
        case vlan
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let vlanDecoded = try containerValues.decode(Int.self, forKey: .vlan)
        vlan = vlanDecoded
        let partnerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .partnerName)
        partnerName = partnerNameDecoded
        let loaIssueTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .loaIssueTime)
        loaIssueTime = loaIssueTimeDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let awsDeviceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDevice)
        awsDevice = awsDeviceDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let hasLogicalRedundancyDecoded = try containerValues.decodeIfPresent(HasLogicalRedundancy.self, forKey: .hasLogicalRedundancy)
        hasLogicalRedundancy = hasLogicalRedundancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let macSecCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .macSecCapable)
        macSecCapable = macSecCapableDecoded
        let portEncryptionStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portEncryptionStatus)
        portEncryptionStatus = portEncryptionStatusDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let macSecKeysContainer = try containerValues.decodeIfPresent([MacSecKey?].self, forKey: .macSecKeys)
        var macSecKeysDecoded0:[MacSecKey]? = nil
        if let macSecKeysContainer = macSecKeysContainer {
            macSecKeysDecoded0 = [MacSecKey]()
            for structure0 in macSecKeysContainer {
                if let structure0 = structure0 {
                    macSecKeysDecoded0?.append(structure0)
                }
            }
        }
        macSecKeys = macSecKeysDecoded0
    }
}

public struct AllocateHostedConnectionInputBodyMiddleware: Middleware {
    public let id: String = "AllocateHostedConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AllocateHostedConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<AllocateHostedConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AllocateHostedConnectionInput>
    public typealias MOutput = OperationOutput<AllocateHostedConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AllocateHostedConnectionOutputError>
}

extension AllocateHostedConnectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AllocateHostedConnectionInput(bandwidth: \(String(describing: bandwidth)), connectionId: \(String(describing: connectionId)), connectionName: \(String(describing: connectionName)), ownerAccount: \(String(describing: ownerAccount)), tags: \(String(describing: tags)), vlan: \(String(describing: vlan)))"}
}

extension AllocateHostedConnectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bandwidth
        case connectionId
        case connectionName
        case ownerAccount
        case tags
        case vlan
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidth = bandwidth {
            try encodeContainer.encode(bandwidth, forKey: .bandwidth)
        }
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let connectionName = connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let ownerAccount = ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if vlan != 0 {
            try encodeContainer.encode(vlan, forKey: .vlan)
        }
    }
}

public struct AllocateHostedConnectionInputHeadersMiddleware: Middleware {
    public let id: String = "AllocateHostedConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AllocateHostedConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<AllocateHostedConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AllocateHostedConnectionInput>
    public typealias MOutput = OperationOutput<AllocateHostedConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AllocateHostedConnectionOutputError>
}

public struct AllocateHostedConnectionInputQueryItemMiddleware: Middleware {
    public let id: String = "AllocateHostedConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AllocateHostedConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<AllocateHostedConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AllocateHostedConnectionInput>
    public typealias MOutput = OperationOutput<AllocateHostedConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AllocateHostedConnectionOutputError>
}

public struct AllocateHostedConnectionInput: Equatable {
    /// <p>The bandwidth of the connection. The possible values are 50Mbps, 100Mbps, 200Mbps, 300Mbps, 400Mbps, 500Mbps, 1Gbps, 2Gbps, 5Gbps, and 10Gbps. Note that only those AWS Direct Connect Partners who have met specific requirements are allowed to create a 1Gbps, 2Gbps, 5Gbps or 10Gbps hosted connection. </p>
    public let bandwidth: String?
    /// <p>The ID of the interconnect or LAG.</p>
    public let connectionId: String?
    /// <p>The name of the hosted connection.</p>
    public let connectionName: String?
    /// <p>The ID of the AWS account ID of the customer for the connection.</p>
    public let ownerAccount: String?
    /// <p>The tags associated with the connection.</p>
    public let tags: [Tag]?
    /// <p>The dedicated VLAN provisioned to the hosted connection.</p>
    public let vlan: Int

    public init (
        bandwidth: String? = nil,
        connectionId: String? = nil,
        connectionName: String? = nil,
        ownerAccount: String? = nil,
        tags: [Tag]? = nil,
        vlan: Int = 0
    )
    {
        self.bandwidth = bandwidth
        self.connectionId = connectionId
        self.connectionName = connectionName
        self.ownerAccount = ownerAccount
        self.tags = tags
        self.vlan = vlan
    }
}

struct AllocateHostedConnectionInputBody: Equatable {
    public let connectionId: String?
    public let ownerAccount: String?
    public let bandwidth: String?
    public let connectionName: String?
    public let vlan: Int
    public let tags: [Tag]?
}

extension AllocateHostedConnectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bandwidth
        case connectionId
        case connectionName
        case ownerAccount
        case tags
        case vlan
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let connectionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let vlanDecoded = try containerValues.decode(Int.self, forKey: .vlan)
        vlan = vlanDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AllocateHostedConnectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AllocateHostedConnectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateTagKeysException" : self = .duplicateTagKeysException(try DuplicateTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AllocateHostedConnectionOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case duplicateTagKeysException(DuplicateTagKeysException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AllocateHostedConnectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AllocateHostedConnectionOutputResponse(awsDevice: \(String(describing: awsDevice)), awsDeviceV2: \(String(describing: awsDeviceV2)), bandwidth: \(String(describing: bandwidth)), connectionId: \(String(describing: connectionId)), connectionName: \(String(describing: connectionName)), connectionState: \(String(describing: connectionState)), encryptionMode: \(String(describing: encryptionMode)), hasLogicalRedundancy: \(String(describing: hasLogicalRedundancy)), jumboFrameCapable: \(String(describing: jumboFrameCapable)), lagId: \(String(describing: lagId)), loaIssueTime: \(String(describing: loaIssueTime)), location: \(String(describing: location)), macSecCapable: \(String(describing: macSecCapable)), macSecKeys: \(String(describing: macSecKeys)), ownerAccount: \(String(describing: ownerAccount)), partnerName: \(String(describing: partnerName)), portEncryptionStatus: \(String(describing: portEncryptionStatus)), providerName: \(String(describing: providerName)), region: \(String(describing: region)), tags: \(String(describing: tags)), vlan: \(String(describing: vlan)))"}
}

extension AllocateHostedConnectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AllocateHostedConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.awsDevice = output.awsDevice
            self.awsDeviceV2 = output.awsDeviceV2
            self.bandwidth = output.bandwidth
            self.connectionId = output.connectionId
            self.connectionName = output.connectionName
            self.connectionState = output.connectionState
            self.encryptionMode = output.encryptionMode
            self.hasLogicalRedundancy = output.hasLogicalRedundancy
            self.jumboFrameCapable = output.jumboFrameCapable
            self.lagId = output.lagId
            self.loaIssueTime = output.loaIssueTime
            self.location = output.location
            self.macSecCapable = output.macSecCapable
            self.macSecKeys = output.macSecKeys
            self.ownerAccount = output.ownerAccount
            self.partnerName = output.partnerName
            self.portEncryptionStatus = output.portEncryptionStatus
            self.providerName = output.providerName
            self.region = output.region
            self.tags = output.tags
            self.vlan = output.vlan
        } else {
            self.awsDevice = nil
            self.awsDeviceV2 = nil
            self.bandwidth = nil
            self.connectionId = nil
            self.connectionName = nil
            self.connectionState = nil
            self.encryptionMode = nil
            self.hasLogicalRedundancy = nil
            self.jumboFrameCapable = nil
            self.lagId = nil
            self.loaIssueTime = nil
            self.location = nil
            self.macSecCapable = nil
            self.macSecKeys = nil
            self.ownerAccount = nil
            self.partnerName = nil
            self.portEncryptionStatus = nil
            self.providerName = nil
            self.region = nil
            self.tags = nil
            self.vlan = 0
        }
    }
}

/// <p>Information about an AWS Direct Connect connection.</p>
public struct AllocateHostedConnectionOutputResponse: Equatable {
    /// <p>The Direct Connect endpoint on which the physical connection terminates.</p>
    @available(*, deprecated)
    public let awsDevice: String?
    /// <p>The Direct Connect endpoint on which the physical connection terminates.</p>
    public let awsDeviceV2: String?
    /// <p>The bandwidth of the connection.</p>
    public let bandwidth: String?
    /// <p>The ID of the connection.</p>
    public let connectionId: String?
    /// <p>The name of the connection.</p>
    public let connectionName: String?
    /// <p>The state of the connection. The following are the possible values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ordering</code>: The initial state of a hosted connection provisioned on an interconnect. The connection stays in the ordering state until the owner of the hosted connection confirms or declines the connection order.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>requested</code>: The initial state of a standard connection. The connection stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: The connection has been approved and is being initialized.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>available</code>: The network link is up and the connection is ready for use.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>down</code>: The network link is down.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>: The connection is being deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>: The connection has been deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>rejected</code>: A hosted connection in the <code>ordering</code> state enters the <code>rejected</code> state if it is deleted by the customer.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>unknown</code>: The state of the connection is not available.</p>
    ///             </li>
    ///          </ul>
    public let connectionState: ConnectionState?
    /// <p>The MAC Security (MACsec) connection encryption mode.</p>
    ///          <p>The valid values are <code>no_encrypt</code>, <code>should_encrypt</code>, and <code>must_encrypt</code>.</p>
    public let encryptionMode: String?
    /// <p>Indicates whether the connection supports a secondary BGP peer in the same address family (IPv4/IPv6).</p>
    public let hasLogicalRedundancy: HasLogicalRedundancy?
    /// <p>Indicates whether jumbo frames (9001 MTU) are supported.</p>
    public let jumboFrameCapable: Bool?
    /// <p>The ID of the LAG.</p>
    public let lagId: String?
    /// <p>The time of the most recent call to <a>DescribeLoa</a> for this connection.</p>
    public let loaIssueTime: Date?
    /// <p>The location of the connection.</p>
    public let location: String?
    /// <p>Indicates whether the connection supports MAC Security (MACsec).</p>
    public let macSecCapable: Bool?
    /// <p>The MAC Security (MACsec) security keys associated with the connection.</p>
    public let macSecKeys: [MacSecKey]?
    /// <p>The ID of the AWS account that owns the connection.</p>
    public let ownerAccount: String?
    /// <p>The name of the AWS Direct Connect service provider associated with the connection.</p>
    public let partnerName: String?
    /// <p>The MAC Security (MACsec) port link status of the connection.</p>
    ///          <p>The valid values are <code>Encryption Up</code>, which means that there is an active Connection Key Name, or <code>Encryption Down</code>.</p>
    public let portEncryptionStatus: String?
    /// <p>The name of the service provider associated with the connection.</p>
    public let providerName: String?
    /// <p>The AWS Region where the connection is located.</p>
    public let region: String?
    /// <p>The tags associated with the connection.</p>
    public let tags: [Tag]?
    /// <p>The ID of the VLAN.</p>
    public let vlan: Int

    public init (
        awsDevice: String? = nil,
        awsDeviceV2: String? = nil,
        bandwidth: String? = nil,
        connectionId: String? = nil,
        connectionName: String? = nil,
        connectionState: ConnectionState? = nil,
        encryptionMode: String? = nil,
        hasLogicalRedundancy: HasLogicalRedundancy? = nil,
        jumboFrameCapable: Bool? = nil,
        lagId: String? = nil,
        loaIssueTime: Date? = nil,
        location: String? = nil,
        macSecCapable: Bool? = nil,
        macSecKeys: [MacSecKey]? = nil,
        ownerAccount: String? = nil,
        partnerName: String? = nil,
        portEncryptionStatus: String? = nil,
        providerName: String? = nil,
        region: String? = nil,
        tags: [Tag]? = nil,
        vlan: Int = 0
    )
    {
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.bandwidth = bandwidth
        self.connectionId = connectionId
        self.connectionName = connectionName
        self.connectionState = connectionState
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.loaIssueTime = loaIssueTime
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.ownerAccount = ownerAccount
        self.partnerName = partnerName
        self.portEncryptionStatus = portEncryptionStatus
        self.providerName = providerName
        self.region = region
        self.tags = tags
        self.vlan = vlan
    }
}

struct AllocateHostedConnectionOutputResponseBody: Equatable {
    public let ownerAccount: String?
    public let connectionId: String?
    public let connectionName: String?
    public let connectionState: ConnectionState?
    public let region: String?
    public let location: String?
    public let bandwidth: String?
    public let vlan: Int
    public let partnerName: String?
    public let loaIssueTime: Date?
    public let lagId: String?
    public let awsDevice: String?
    public let jumboFrameCapable: Bool?
    public let awsDeviceV2: String?
    public let hasLogicalRedundancy: HasLogicalRedundancy?
    public let tags: [Tag]?
    public let providerName: String?
    public let macSecCapable: Bool?
    public let portEncryptionStatus: String?
    public let encryptionMode: String?
    public let macSecKeys: [MacSecKey]?
}

extension AllocateHostedConnectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case awsDevice
        case awsDeviceV2
        case bandwidth
        case connectionId
        case connectionName
        case connectionState
        case encryptionMode
        case hasLogicalRedundancy
        case jumboFrameCapable
        case lagId
        case loaIssueTime
        case location
        case macSecCapable
        case macSecKeys
        case ownerAccount
        case partnerName
        case portEncryptionStatus
        case providerName
        case region
        case tags
        case vlan
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let vlanDecoded = try containerValues.decode(Int.self, forKey: .vlan)
        vlan = vlanDecoded
        let partnerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .partnerName)
        partnerName = partnerNameDecoded
        let loaIssueTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .loaIssueTime)
        loaIssueTime = loaIssueTimeDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let awsDeviceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDevice)
        awsDevice = awsDeviceDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let hasLogicalRedundancyDecoded = try containerValues.decodeIfPresent(HasLogicalRedundancy.self, forKey: .hasLogicalRedundancy)
        hasLogicalRedundancy = hasLogicalRedundancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let macSecCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .macSecCapable)
        macSecCapable = macSecCapableDecoded
        let portEncryptionStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portEncryptionStatus)
        portEncryptionStatus = portEncryptionStatusDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let macSecKeysContainer = try containerValues.decodeIfPresent([MacSecKey?].self, forKey: .macSecKeys)
        var macSecKeysDecoded0:[MacSecKey]? = nil
        if let macSecKeysContainer = macSecKeysContainer {
            macSecKeysDecoded0 = [MacSecKey]()
            for structure0 in macSecKeysContainer {
                if let structure0 = structure0 {
                    macSecKeysDecoded0?.append(structure0)
                }
            }
        }
        macSecKeys = macSecKeysDecoded0
    }
}

public struct AllocatePrivateVirtualInterfaceInputBodyMiddleware: Middleware {
    public let id: String = "AllocatePrivateVirtualInterfaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AllocatePrivateVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<AllocatePrivateVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AllocatePrivateVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<AllocatePrivateVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AllocatePrivateVirtualInterfaceOutputError>
}

extension AllocatePrivateVirtualInterfaceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AllocatePrivateVirtualInterfaceInput(connectionId: \(String(describing: connectionId)), newPrivateVirtualInterfaceAllocation: \(String(describing: newPrivateVirtualInterfaceAllocation)), ownerAccount: \(String(describing: ownerAccount)))"}
}

extension AllocatePrivateVirtualInterfaceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case newPrivateVirtualInterfaceAllocation
        case ownerAccount
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let newPrivateVirtualInterfaceAllocation = newPrivateVirtualInterfaceAllocation {
            try encodeContainer.encode(newPrivateVirtualInterfaceAllocation, forKey: .newPrivateVirtualInterfaceAllocation)
        }
        if let ownerAccount = ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
    }
}

public struct AllocatePrivateVirtualInterfaceInputHeadersMiddleware: Middleware {
    public let id: String = "AllocatePrivateVirtualInterfaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AllocatePrivateVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<AllocatePrivateVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AllocatePrivateVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<AllocatePrivateVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AllocatePrivateVirtualInterfaceOutputError>
}

public struct AllocatePrivateVirtualInterfaceInputQueryItemMiddleware: Middleware {
    public let id: String = "AllocatePrivateVirtualInterfaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AllocatePrivateVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<AllocatePrivateVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AllocatePrivateVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<AllocatePrivateVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AllocatePrivateVirtualInterfaceOutputError>
}

public struct AllocatePrivateVirtualInterfaceInput: Equatable {
    /// <p>The ID of the connection on which the private virtual interface is provisioned.</p>
    public let connectionId: String?
    /// <p>Information about the private virtual interface.</p>
    public let newPrivateVirtualInterfaceAllocation: NewPrivateVirtualInterfaceAllocation?
    /// <p>The ID of the AWS account that owns the virtual private interface.</p>
    public let ownerAccount: String?

    public init (
        connectionId: String? = nil,
        newPrivateVirtualInterfaceAllocation: NewPrivateVirtualInterfaceAllocation? = nil,
        ownerAccount: String? = nil
    )
    {
        self.connectionId = connectionId
        self.newPrivateVirtualInterfaceAllocation = newPrivateVirtualInterfaceAllocation
        self.ownerAccount = ownerAccount
    }
}

struct AllocatePrivateVirtualInterfaceInputBody: Equatable {
    public let connectionId: String?
    public let ownerAccount: String?
    public let newPrivateVirtualInterfaceAllocation: NewPrivateVirtualInterfaceAllocation?
}

extension AllocatePrivateVirtualInterfaceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case newPrivateVirtualInterfaceAllocation
        case ownerAccount
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let newPrivateVirtualInterfaceAllocationDecoded = try containerValues.decodeIfPresent(NewPrivateVirtualInterfaceAllocation.self, forKey: .newPrivateVirtualInterfaceAllocation)
        newPrivateVirtualInterfaceAllocation = newPrivateVirtualInterfaceAllocationDecoded
    }
}

extension AllocatePrivateVirtualInterfaceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AllocatePrivateVirtualInterfaceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateTagKeysException" : self = .duplicateTagKeysException(try DuplicateTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AllocatePrivateVirtualInterfaceOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case duplicateTagKeysException(DuplicateTagKeysException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AllocatePrivateVirtualInterfaceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AllocatePrivateVirtualInterfaceOutputResponse(addressFamily: \(String(describing: addressFamily)), amazonAddress: \(String(describing: amazonAddress)), amazonSideAsn: \(String(describing: amazonSideAsn)), asn: \(String(describing: asn)), authKey: \(String(describing: authKey)), awsDeviceV2: \(String(describing: awsDeviceV2)), bgpPeers: \(String(describing: bgpPeers)), connectionId: \(String(describing: connectionId)), customerAddress: \(String(describing: customerAddress)), customerRouterConfig: \(String(describing: customerRouterConfig)), directConnectGatewayId: \(String(describing: directConnectGatewayId)), jumboFrameCapable: \(String(describing: jumboFrameCapable)), location: \(String(describing: location)), mtu: \(String(describing: mtu)), ownerAccount: \(String(describing: ownerAccount)), region: \(String(describing: region)), routeFilterPrefixes: \(String(describing: routeFilterPrefixes)), tags: \(String(describing: tags)), virtualGatewayId: \(String(describing: virtualGatewayId)), virtualInterfaceId: \(String(describing: virtualInterfaceId)), virtualInterfaceName: \(String(describing: virtualInterfaceName)), virtualInterfaceState: \(String(describing: virtualInterfaceState)), virtualInterfaceType: \(String(describing: virtualInterfaceType)), vlan: \(String(describing: vlan)))"}
}

extension AllocatePrivateVirtualInterfaceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AllocatePrivateVirtualInterfaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.addressFamily = output.addressFamily
            self.amazonAddress = output.amazonAddress
            self.amazonSideAsn = output.amazonSideAsn
            self.asn = output.asn
            self.authKey = output.authKey
            self.awsDeviceV2 = output.awsDeviceV2
            self.bgpPeers = output.bgpPeers
            self.connectionId = output.connectionId
            self.customerAddress = output.customerAddress
            self.customerRouterConfig = output.customerRouterConfig
            self.directConnectGatewayId = output.directConnectGatewayId
            self.jumboFrameCapable = output.jumboFrameCapable
            self.location = output.location
            self.mtu = output.mtu
            self.ownerAccount = output.ownerAccount
            self.region = output.region
            self.routeFilterPrefixes = output.routeFilterPrefixes
            self.tags = output.tags
            self.virtualGatewayId = output.virtualGatewayId
            self.virtualInterfaceId = output.virtualInterfaceId
            self.virtualInterfaceName = output.virtualInterfaceName
            self.virtualInterfaceState = output.virtualInterfaceState
            self.virtualInterfaceType = output.virtualInterfaceType
            self.vlan = output.vlan
        } else {
            self.addressFamily = nil
            self.amazonAddress = nil
            self.amazonSideAsn = nil
            self.asn = 0
            self.authKey = nil
            self.awsDeviceV2 = nil
            self.bgpPeers = nil
            self.connectionId = nil
            self.customerAddress = nil
            self.customerRouterConfig = nil
            self.directConnectGatewayId = nil
            self.jumboFrameCapable = nil
            self.location = nil
            self.mtu = nil
            self.ownerAccount = nil
            self.region = nil
            self.routeFilterPrefixes = nil
            self.tags = nil
            self.virtualGatewayId = nil
            self.virtualInterfaceId = nil
            self.virtualInterfaceName = nil
            self.virtualInterfaceState = nil
            self.virtualInterfaceType = nil
            self.vlan = 0
        }
    }
}

/// <p>Information about a virtual interface.</p>
public struct AllocatePrivateVirtualInterfaceOutputResponse: Equatable {
    /// <p>The address family for the BGP peer.</p>
    public let addressFamily: AddressFamily?
    /// <p>The IP address assigned to the Amazon interface.</p>
    public let amazonAddress: String?
    /// <p>The autonomous system number (ASN) for the Amazon side of the connection.</p>
    public let amazonSideAsn: Int?
    /// <p>The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.</p>
    ///          <p>The valid values are 1-2147483647.</p>
    public let asn: Int
    /// <p>The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.</p>
    public let authKey: String?
    /// <p>The
    ///       Direct Connect endpoint on which the virtual interface terminates.</p>
    public let awsDeviceV2: String?
    /// <p>The BGP peers configured on this virtual interface.</p>
    public let bgpPeers: [BGPPeer]?
    /// <p>The ID of the connection.</p>
    public let connectionId: String?
    /// <p>The IP address assigned to the customer interface.</p>
    public let customerAddress: String?
    /// <p>The customer router configuration.</p>
    public let customerRouterConfig: String?
    /// <p>The ID of the Direct Connect gateway.</p>
    public let directConnectGatewayId: String?
    /// <p>Indicates whether jumbo frames (9001 MTU) are supported.</p>
    public let jumboFrameCapable: Bool?
    /// <p>The location of the connection.</p>
    public let location: String?
    /// <p>The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 9001. The default value is 1500.</p>
    public let mtu: Int?
    /// <p>The ID of the AWS account that owns the virtual interface.</p>
    public let ownerAccount: String?
    /// <p>The AWS Region where the virtual interface is located.</p>
    public let region: String?
    /// <p>The routes to be advertised to the AWS network in this Region. Applies to public virtual interfaces.</p>
    public let routeFilterPrefixes: [RouteFilterPrefix]?
    /// <p>The tags associated with the virtual interface.</p>
    public let tags: [Tag]?
    /// <p>The ID of the virtual private gateway. Applies only to private virtual interfaces.</p>
    public let virtualGatewayId: String?
    /// <p>The ID of the virtual interface.</p>
    public let virtualInterfaceId: String?
    /// <p>The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).</p>
    public let virtualInterfaceName: String?
    /// <p>The state of the virtual interface. The following are the possible values:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>confirming</code>: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>verifying</code>: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>available</code>: A virtual interface that is able to forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>down</code>: A virtual interface that is BGP down.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>: A virtual interface is in this state immediately after calling <a>DeleteVirtualInterface</a> until it can no longer forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>: A virtual interface that cannot forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>rejected</code>: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the <code>Confirming</code> state is deleted by the virtual interface owner, the virtual interface enters the <code>Rejected</code> state.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>unknown</code>: The state of the virtual interface is not available.</p>
    ///             </li>
    ///          </ul>
    public let virtualInterfaceState: VirtualInterfaceState?
    /// <p>The type of virtual interface. The possible values are <code>private</code> and <code>public</code>.</p>
    public let virtualInterfaceType: String?
    /// <p>The ID of the VLAN.</p>
    public let vlan: Int

    public init (
        addressFamily: AddressFamily? = nil,
        amazonAddress: String? = nil,
        amazonSideAsn: Int? = nil,
        asn: Int = 0,
        authKey: String? = nil,
        awsDeviceV2: String? = nil,
        bgpPeers: [BGPPeer]? = nil,
        connectionId: String? = nil,
        customerAddress: String? = nil,
        customerRouterConfig: String? = nil,
        directConnectGatewayId: String? = nil,
        jumboFrameCapable: Bool? = nil,
        location: String? = nil,
        mtu: Int? = nil,
        ownerAccount: String? = nil,
        region: String? = nil,
        routeFilterPrefixes: [RouteFilterPrefix]? = nil,
        tags: [Tag]? = nil,
        virtualGatewayId: String? = nil,
        virtualInterfaceId: String? = nil,
        virtualInterfaceName: String? = nil,
        virtualInterfaceState: VirtualInterfaceState? = nil,
        virtualInterfaceType: String? = nil,
        vlan: Int = 0
    )
    {
        self.addressFamily = addressFamily
        self.amazonAddress = amazonAddress
        self.amazonSideAsn = amazonSideAsn
        self.asn = asn
        self.authKey = authKey
        self.awsDeviceV2 = awsDeviceV2
        self.bgpPeers = bgpPeers
        self.connectionId = connectionId
        self.customerAddress = customerAddress
        self.customerRouterConfig = customerRouterConfig
        self.directConnectGatewayId = directConnectGatewayId
        self.jumboFrameCapable = jumboFrameCapable
        self.location = location
        self.mtu = mtu
        self.ownerAccount = ownerAccount
        self.region = region
        self.routeFilterPrefixes = routeFilterPrefixes
        self.tags = tags
        self.virtualGatewayId = virtualGatewayId
        self.virtualInterfaceId = virtualInterfaceId
        self.virtualInterfaceName = virtualInterfaceName
        self.virtualInterfaceState = virtualInterfaceState
        self.virtualInterfaceType = virtualInterfaceType
        self.vlan = vlan
    }
}

struct AllocatePrivateVirtualInterfaceOutputResponseBody: Equatable {
    public let ownerAccount: String?
    public let virtualInterfaceId: String?
    public let location: String?
    public let connectionId: String?
    public let virtualInterfaceType: String?
    public let virtualInterfaceName: String?
    public let vlan: Int
    public let asn: Int
    public let amazonSideAsn: Int?
    public let authKey: String?
    public let amazonAddress: String?
    public let customerAddress: String?
    public let addressFamily: AddressFamily?
    public let virtualInterfaceState: VirtualInterfaceState?
    public let customerRouterConfig: String?
    public let mtu: Int?
    public let jumboFrameCapable: Bool?
    public let virtualGatewayId: String?
    public let directConnectGatewayId: String?
    public let routeFilterPrefixes: [RouteFilterPrefix]?
    public let bgpPeers: [BGPPeer]?
    public let region: String?
    public let awsDeviceV2: String?
    public let tags: [Tag]?
}

extension AllocatePrivateVirtualInterfaceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case addressFamily
        case amazonAddress
        case amazonSideAsn
        case asn
        case authKey
        case awsDeviceV2
        case bgpPeers
        case connectionId
        case customerAddress
        case customerRouterConfig
        case directConnectGatewayId
        case jumboFrameCapable
        case location
        case mtu
        case ownerAccount
        case region
        case routeFilterPrefixes
        case tags
        case virtualGatewayId
        case virtualInterfaceId
        case virtualInterfaceName
        case virtualInterfaceState
        case virtualInterfaceType
        case vlan
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let virtualInterfaceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceType)
        virtualInterfaceType = virtualInterfaceTypeDecoded
        let virtualInterfaceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceName)
        virtualInterfaceName = virtualInterfaceNameDecoded
        let vlanDecoded = try containerValues.decode(Int.self, forKey: .vlan)
        vlan = vlanDecoded
        let asnDecoded = try containerValues.decode(Int.self, forKey: .asn)
        asn = asnDecoded
        let amazonSideAsnDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .amazonSideAsn)
        amazonSideAsn = amazonSideAsnDecoded
        let authKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authKey)
        authKey = authKeyDecoded
        let amazonAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amazonAddress)
        amazonAddress = amazonAddressDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let virtualInterfaceStateDecoded = try containerValues.decodeIfPresent(VirtualInterfaceState.self, forKey: .virtualInterfaceState)
        virtualInterfaceState = virtualInterfaceStateDecoded
        let customerRouterConfigDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerRouterConfig)
        customerRouterConfig = customerRouterConfigDecoded
        let mtuDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .mtu)
        mtu = mtuDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let virtualGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualGatewayId)
        virtualGatewayId = virtualGatewayIdDecoded
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let routeFilterPrefixesContainer = try containerValues.decodeIfPresent([RouteFilterPrefix?].self, forKey: .routeFilterPrefixes)
        var routeFilterPrefixesDecoded0:[RouteFilterPrefix]? = nil
        if let routeFilterPrefixesContainer = routeFilterPrefixesContainer {
            routeFilterPrefixesDecoded0 = [RouteFilterPrefix]()
            for structure0 in routeFilterPrefixesContainer {
                if let structure0 = structure0 {
                    routeFilterPrefixesDecoded0?.append(structure0)
                }
            }
        }
        routeFilterPrefixes = routeFilterPrefixesDecoded0
        let bgpPeersContainer = try containerValues.decodeIfPresent([BGPPeer?].self, forKey: .bgpPeers)
        var bgpPeersDecoded0:[BGPPeer]? = nil
        if let bgpPeersContainer = bgpPeersContainer {
            bgpPeersDecoded0 = [BGPPeer]()
            for structure0 in bgpPeersContainer {
                if let structure0 = structure0 {
                    bgpPeersDecoded0?.append(structure0)
                }
            }
        }
        bgpPeers = bgpPeersDecoded0
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct AllocatePublicVirtualInterfaceInputBodyMiddleware: Middleware {
    public let id: String = "AllocatePublicVirtualInterfaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AllocatePublicVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<AllocatePublicVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AllocatePublicVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<AllocatePublicVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AllocatePublicVirtualInterfaceOutputError>
}

extension AllocatePublicVirtualInterfaceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AllocatePublicVirtualInterfaceInput(connectionId: \(String(describing: connectionId)), newPublicVirtualInterfaceAllocation: \(String(describing: newPublicVirtualInterfaceAllocation)), ownerAccount: \(String(describing: ownerAccount)))"}
}

extension AllocatePublicVirtualInterfaceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case newPublicVirtualInterfaceAllocation
        case ownerAccount
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let newPublicVirtualInterfaceAllocation = newPublicVirtualInterfaceAllocation {
            try encodeContainer.encode(newPublicVirtualInterfaceAllocation, forKey: .newPublicVirtualInterfaceAllocation)
        }
        if let ownerAccount = ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
    }
}

public struct AllocatePublicVirtualInterfaceInputHeadersMiddleware: Middleware {
    public let id: String = "AllocatePublicVirtualInterfaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AllocatePublicVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<AllocatePublicVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AllocatePublicVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<AllocatePublicVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AllocatePublicVirtualInterfaceOutputError>
}

public struct AllocatePublicVirtualInterfaceInputQueryItemMiddleware: Middleware {
    public let id: String = "AllocatePublicVirtualInterfaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AllocatePublicVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<AllocatePublicVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AllocatePublicVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<AllocatePublicVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AllocatePublicVirtualInterfaceOutputError>
}

public struct AllocatePublicVirtualInterfaceInput: Equatable {
    /// <p>The ID of the connection on which the public virtual interface is provisioned.</p>
    public let connectionId: String?
    /// <p>Information about the public virtual interface.</p>
    public let newPublicVirtualInterfaceAllocation: NewPublicVirtualInterfaceAllocation?
    /// <p>The ID of the AWS account that owns the public virtual interface.</p>
    public let ownerAccount: String?

    public init (
        connectionId: String? = nil,
        newPublicVirtualInterfaceAllocation: NewPublicVirtualInterfaceAllocation? = nil,
        ownerAccount: String? = nil
    )
    {
        self.connectionId = connectionId
        self.newPublicVirtualInterfaceAllocation = newPublicVirtualInterfaceAllocation
        self.ownerAccount = ownerAccount
    }
}

struct AllocatePublicVirtualInterfaceInputBody: Equatable {
    public let connectionId: String?
    public let ownerAccount: String?
    public let newPublicVirtualInterfaceAllocation: NewPublicVirtualInterfaceAllocation?
}

extension AllocatePublicVirtualInterfaceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case newPublicVirtualInterfaceAllocation
        case ownerAccount
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let newPublicVirtualInterfaceAllocationDecoded = try containerValues.decodeIfPresent(NewPublicVirtualInterfaceAllocation.self, forKey: .newPublicVirtualInterfaceAllocation)
        newPublicVirtualInterfaceAllocation = newPublicVirtualInterfaceAllocationDecoded
    }
}

extension AllocatePublicVirtualInterfaceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AllocatePublicVirtualInterfaceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateTagKeysException" : self = .duplicateTagKeysException(try DuplicateTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AllocatePublicVirtualInterfaceOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case duplicateTagKeysException(DuplicateTagKeysException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AllocatePublicVirtualInterfaceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AllocatePublicVirtualInterfaceOutputResponse(addressFamily: \(String(describing: addressFamily)), amazonAddress: \(String(describing: amazonAddress)), amazonSideAsn: \(String(describing: amazonSideAsn)), asn: \(String(describing: asn)), authKey: \(String(describing: authKey)), awsDeviceV2: \(String(describing: awsDeviceV2)), bgpPeers: \(String(describing: bgpPeers)), connectionId: \(String(describing: connectionId)), customerAddress: \(String(describing: customerAddress)), customerRouterConfig: \(String(describing: customerRouterConfig)), directConnectGatewayId: \(String(describing: directConnectGatewayId)), jumboFrameCapable: \(String(describing: jumboFrameCapable)), location: \(String(describing: location)), mtu: \(String(describing: mtu)), ownerAccount: \(String(describing: ownerAccount)), region: \(String(describing: region)), routeFilterPrefixes: \(String(describing: routeFilterPrefixes)), tags: \(String(describing: tags)), virtualGatewayId: \(String(describing: virtualGatewayId)), virtualInterfaceId: \(String(describing: virtualInterfaceId)), virtualInterfaceName: \(String(describing: virtualInterfaceName)), virtualInterfaceState: \(String(describing: virtualInterfaceState)), virtualInterfaceType: \(String(describing: virtualInterfaceType)), vlan: \(String(describing: vlan)))"}
}

extension AllocatePublicVirtualInterfaceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AllocatePublicVirtualInterfaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.addressFamily = output.addressFamily
            self.amazonAddress = output.amazonAddress
            self.amazonSideAsn = output.amazonSideAsn
            self.asn = output.asn
            self.authKey = output.authKey
            self.awsDeviceV2 = output.awsDeviceV2
            self.bgpPeers = output.bgpPeers
            self.connectionId = output.connectionId
            self.customerAddress = output.customerAddress
            self.customerRouterConfig = output.customerRouterConfig
            self.directConnectGatewayId = output.directConnectGatewayId
            self.jumboFrameCapable = output.jumboFrameCapable
            self.location = output.location
            self.mtu = output.mtu
            self.ownerAccount = output.ownerAccount
            self.region = output.region
            self.routeFilterPrefixes = output.routeFilterPrefixes
            self.tags = output.tags
            self.virtualGatewayId = output.virtualGatewayId
            self.virtualInterfaceId = output.virtualInterfaceId
            self.virtualInterfaceName = output.virtualInterfaceName
            self.virtualInterfaceState = output.virtualInterfaceState
            self.virtualInterfaceType = output.virtualInterfaceType
            self.vlan = output.vlan
        } else {
            self.addressFamily = nil
            self.amazonAddress = nil
            self.amazonSideAsn = nil
            self.asn = 0
            self.authKey = nil
            self.awsDeviceV2 = nil
            self.bgpPeers = nil
            self.connectionId = nil
            self.customerAddress = nil
            self.customerRouterConfig = nil
            self.directConnectGatewayId = nil
            self.jumboFrameCapable = nil
            self.location = nil
            self.mtu = nil
            self.ownerAccount = nil
            self.region = nil
            self.routeFilterPrefixes = nil
            self.tags = nil
            self.virtualGatewayId = nil
            self.virtualInterfaceId = nil
            self.virtualInterfaceName = nil
            self.virtualInterfaceState = nil
            self.virtualInterfaceType = nil
            self.vlan = 0
        }
    }
}

/// <p>Information about a virtual interface.</p>
public struct AllocatePublicVirtualInterfaceOutputResponse: Equatable {
    /// <p>The address family for the BGP peer.</p>
    public let addressFamily: AddressFamily?
    /// <p>The IP address assigned to the Amazon interface.</p>
    public let amazonAddress: String?
    /// <p>The autonomous system number (ASN) for the Amazon side of the connection.</p>
    public let amazonSideAsn: Int?
    /// <p>The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.</p>
    ///          <p>The valid values are 1-2147483647.</p>
    public let asn: Int
    /// <p>The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.</p>
    public let authKey: String?
    /// <p>The
    ///       Direct Connect endpoint on which the virtual interface terminates.</p>
    public let awsDeviceV2: String?
    /// <p>The BGP peers configured on this virtual interface.</p>
    public let bgpPeers: [BGPPeer]?
    /// <p>The ID of the connection.</p>
    public let connectionId: String?
    /// <p>The IP address assigned to the customer interface.</p>
    public let customerAddress: String?
    /// <p>The customer router configuration.</p>
    public let customerRouterConfig: String?
    /// <p>The ID of the Direct Connect gateway.</p>
    public let directConnectGatewayId: String?
    /// <p>Indicates whether jumbo frames (9001 MTU) are supported.</p>
    public let jumboFrameCapable: Bool?
    /// <p>The location of the connection.</p>
    public let location: String?
    /// <p>The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 9001. The default value is 1500.</p>
    public let mtu: Int?
    /// <p>The ID of the AWS account that owns the virtual interface.</p>
    public let ownerAccount: String?
    /// <p>The AWS Region where the virtual interface is located.</p>
    public let region: String?
    /// <p>The routes to be advertised to the AWS network in this Region. Applies to public virtual interfaces.</p>
    public let routeFilterPrefixes: [RouteFilterPrefix]?
    /// <p>The tags associated with the virtual interface.</p>
    public let tags: [Tag]?
    /// <p>The ID of the virtual private gateway. Applies only to private virtual interfaces.</p>
    public let virtualGatewayId: String?
    /// <p>The ID of the virtual interface.</p>
    public let virtualInterfaceId: String?
    /// <p>The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).</p>
    public let virtualInterfaceName: String?
    /// <p>The state of the virtual interface. The following are the possible values:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>confirming</code>: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>verifying</code>: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>available</code>: A virtual interface that is able to forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>down</code>: A virtual interface that is BGP down.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>: A virtual interface is in this state immediately after calling <a>DeleteVirtualInterface</a> until it can no longer forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>: A virtual interface that cannot forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>rejected</code>: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the <code>Confirming</code> state is deleted by the virtual interface owner, the virtual interface enters the <code>Rejected</code> state.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>unknown</code>: The state of the virtual interface is not available.</p>
    ///             </li>
    ///          </ul>
    public let virtualInterfaceState: VirtualInterfaceState?
    /// <p>The type of virtual interface. The possible values are <code>private</code> and <code>public</code>.</p>
    public let virtualInterfaceType: String?
    /// <p>The ID of the VLAN.</p>
    public let vlan: Int

    public init (
        addressFamily: AddressFamily? = nil,
        amazonAddress: String? = nil,
        amazonSideAsn: Int? = nil,
        asn: Int = 0,
        authKey: String? = nil,
        awsDeviceV2: String? = nil,
        bgpPeers: [BGPPeer]? = nil,
        connectionId: String? = nil,
        customerAddress: String? = nil,
        customerRouterConfig: String? = nil,
        directConnectGatewayId: String? = nil,
        jumboFrameCapable: Bool? = nil,
        location: String? = nil,
        mtu: Int? = nil,
        ownerAccount: String? = nil,
        region: String? = nil,
        routeFilterPrefixes: [RouteFilterPrefix]? = nil,
        tags: [Tag]? = nil,
        virtualGatewayId: String? = nil,
        virtualInterfaceId: String? = nil,
        virtualInterfaceName: String? = nil,
        virtualInterfaceState: VirtualInterfaceState? = nil,
        virtualInterfaceType: String? = nil,
        vlan: Int = 0
    )
    {
        self.addressFamily = addressFamily
        self.amazonAddress = amazonAddress
        self.amazonSideAsn = amazonSideAsn
        self.asn = asn
        self.authKey = authKey
        self.awsDeviceV2 = awsDeviceV2
        self.bgpPeers = bgpPeers
        self.connectionId = connectionId
        self.customerAddress = customerAddress
        self.customerRouterConfig = customerRouterConfig
        self.directConnectGatewayId = directConnectGatewayId
        self.jumboFrameCapable = jumboFrameCapable
        self.location = location
        self.mtu = mtu
        self.ownerAccount = ownerAccount
        self.region = region
        self.routeFilterPrefixes = routeFilterPrefixes
        self.tags = tags
        self.virtualGatewayId = virtualGatewayId
        self.virtualInterfaceId = virtualInterfaceId
        self.virtualInterfaceName = virtualInterfaceName
        self.virtualInterfaceState = virtualInterfaceState
        self.virtualInterfaceType = virtualInterfaceType
        self.vlan = vlan
    }
}

struct AllocatePublicVirtualInterfaceOutputResponseBody: Equatable {
    public let ownerAccount: String?
    public let virtualInterfaceId: String?
    public let location: String?
    public let connectionId: String?
    public let virtualInterfaceType: String?
    public let virtualInterfaceName: String?
    public let vlan: Int
    public let asn: Int
    public let amazonSideAsn: Int?
    public let authKey: String?
    public let amazonAddress: String?
    public let customerAddress: String?
    public let addressFamily: AddressFamily?
    public let virtualInterfaceState: VirtualInterfaceState?
    public let customerRouterConfig: String?
    public let mtu: Int?
    public let jumboFrameCapable: Bool?
    public let virtualGatewayId: String?
    public let directConnectGatewayId: String?
    public let routeFilterPrefixes: [RouteFilterPrefix]?
    public let bgpPeers: [BGPPeer]?
    public let region: String?
    public let awsDeviceV2: String?
    public let tags: [Tag]?
}

extension AllocatePublicVirtualInterfaceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case addressFamily
        case amazonAddress
        case amazonSideAsn
        case asn
        case authKey
        case awsDeviceV2
        case bgpPeers
        case connectionId
        case customerAddress
        case customerRouterConfig
        case directConnectGatewayId
        case jumboFrameCapable
        case location
        case mtu
        case ownerAccount
        case region
        case routeFilterPrefixes
        case tags
        case virtualGatewayId
        case virtualInterfaceId
        case virtualInterfaceName
        case virtualInterfaceState
        case virtualInterfaceType
        case vlan
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let virtualInterfaceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceType)
        virtualInterfaceType = virtualInterfaceTypeDecoded
        let virtualInterfaceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceName)
        virtualInterfaceName = virtualInterfaceNameDecoded
        let vlanDecoded = try containerValues.decode(Int.self, forKey: .vlan)
        vlan = vlanDecoded
        let asnDecoded = try containerValues.decode(Int.self, forKey: .asn)
        asn = asnDecoded
        let amazonSideAsnDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .amazonSideAsn)
        amazonSideAsn = amazonSideAsnDecoded
        let authKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authKey)
        authKey = authKeyDecoded
        let amazonAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amazonAddress)
        amazonAddress = amazonAddressDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let virtualInterfaceStateDecoded = try containerValues.decodeIfPresent(VirtualInterfaceState.self, forKey: .virtualInterfaceState)
        virtualInterfaceState = virtualInterfaceStateDecoded
        let customerRouterConfigDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerRouterConfig)
        customerRouterConfig = customerRouterConfigDecoded
        let mtuDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .mtu)
        mtu = mtuDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let virtualGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualGatewayId)
        virtualGatewayId = virtualGatewayIdDecoded
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let routeFilterPrefixesContainer = try containerValues.decodeIfPresent([RouteFilterPrefix?].self, forKey: .routeFilterPrefixes)
        var routeFilterPrefixesDecoded0:[RouteFilterPrefix]? = nil
        if let routeFilterPrefixesContainer = routeFilterPrefixesContainer {
            routeFilterPrefixesDecoded0 = [RouteFilterPrefix]()
            for structure0 in routeFilterPrefixesContainer {
                if let structure0 = structure0 {
                    routeFilterPrefixesDecoded0?.append(structure0)
                }
            }
        }
        routeFilterPrefixes = routeFilterPrefixesDecoded0
        let bgpPeersContainer = try containerValues.decodeIfPresent([BGPPeer?].self, forKey: .bgpPeers)
        var bgpPeersDecoded0:[BGPPeer]? = nil
        if let bgpPeersContainer = bgpPeersContainer {
            bgpPeersDecoded0 = [BGPPeer]()
            for structure0 in bgpPeersContainer {
                if let structure0 = structure0 {
                    bgpPeersDecoded0?.append(structure0)
                }
            }
        }
        bgpPeers = bgpPeersDecoded0
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct AllocateTransitVirtualInterfaceInputBodyMiddleware: Middleware {
    public let id: String = "AllocateTransitVirtualInterfaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AllocateTransitVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<AllocateTransitVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AllocateTransitVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<AllocateTransitVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AllocateTransitVirtualInterfaceOutputError>
}

extension AllocateTransitVirtualInterfaceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AllocateTransitVirtualInterfaceInput(connectionId: \(String(describing: connectionId)), newTransitVirtualInterfaceAllocation: \(String(describing: newTransitVirtualInterfaceAllocation)), ownerAccount: \(String(describing: ownerAccount)))"}
}

extension AllocateTransitVirtualInterfaceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case newTransitVirtualInterfaceAllocation
        case ownerAccount
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let newTransitVirtualInterfaceAllocation = newTransitVirtualInterfaceAllocation {
            try encodeContainer.encode(newTransitVirtualInterfaceAllocation, forKey: .newTransitVirtualInterfaceAllocation)
        }
        if let ownerAccount = ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
    }
}

public struct AllocateTransitVirtualInterfaceInputHeadersMiddleware: Middleware {
    public let id: String = "AllocateTransitVirtualInterfaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AllocateTransitVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<AllocateTransitVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AllocateTransitVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<AllocateTransitVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AllocateTransitVirtualInterfaceOutputError>
}

public struct AllocateTransitVirtualInterfaceInputQueryItemMiddleware: Middleware {
    public let id: String = "AllocateTransitVirtualInterfaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AllocateTransitVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<AllocateTransitVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AllocateTransitVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<AllocateTransitVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AllocateTransitVirtualInterfaceOutputError>
}

public struct AllocateTransitVirtualInterfaceInput: Equatable {
    /// <p>The ID of the connection on which the transit virtual interface is provisioned.</p>
    public let connectionId: String?
    /// <p>Information about the transit virtual interface.</p>
    public let newTransitVirtualInterfaceAllocation: NewTransitVirtualInterfaceAllocation?
    /// <p>The ID of the AWS account that owns the transit virtual interface.</p>
    public let ownerAccount: String?

    public init (
        connectionId: String? = nil,
        newTransitVirtualInterfaceAllocation: NewTransitVirtualInterfaceAllocation? = nil,
        ownerAccount: String? = nil
    )
    {
        self.connectionId = connectionId
        self.newTransitVirtualInterfaceAllocation = newTransitVirtualInterfaceAllocation
        self.ownerAccount = ownerAccount
    }
}

struct AllocateTransitVirtualInterfaceInputBody: Equatable {
    public let connectionId: String?
    public let ownerAccount: String?
    public let newTransitVirtualInterfaceAllocation: NewTransitVirtualInterfaceAllocation?
}

extension AllocateTransitVirtualInterfaceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case newTransitVirtualInterfaceAllocation
        case ownerAccount
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let newTransitVirtualInterfaceAllocationDecoded = try containerValues.decodeIfPresent(NewTransitVirtualInterfaceAllocation.self, forKey: .newTransitVirtualInterfaceAllocation)
        newTransitVirtualInterfaceAllocation = newTransitVirtualInterfaceAllocationDecoded
    }
}

extension AllocateTransitVirtualInterfaceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AllocateTransitVirtualInterfaceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateTagKeysException" : self = .duplicateTagKeysException(try DuplicateTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AllocateTransitVirtualInterfaceOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case duplicateTagKeysException(DuplicateTagKeysException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AllocateTransitVirtualInterfaceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AllocateTransitVirtualInterfaceOutputResponse(virtualInterface: \(String(describing: virtualInterface)))"}
}

extension AllocateTransitVirtualInterfaceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AllocateTransitVirtualInterfaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.virtualInterface = output.virtualInterface
        } else {
            self.virtualInterface = nil
        }
    }
}

public struct AllocateTransitVirtualInterfaceOutputResponse: Equatable {
    /// <p>Information about a virtual interface.</p>
    public let virtualInterface: VirtualInterface?

    public init (
        virtualInterface: VirtualInterface? = nil
    )
    {
        self.virtualInterface = virtualInterface
    }
}

struct AllocateTransitVirtualInterfaceOutputResponseBody: Equatable {
    public let virtualInterface: VirtualInterface?
}

extension AllocateTransitVirtualInterfaceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualInterface
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceDecoded = try containerValues.decodeIfPresent(VirtualInterface.self, forKey: .virtualInterface)
        virtualInterface = virtualInterfaceDecoded
    }
}

public struct AssociateConnectionWithLagInputBodyMiddleware: Middleware {
    public let id: String = "AssociateConnectionWithLagInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateConnectionWithLagInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateConnectionWithLagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateConnectionWithLagInput>
    public typealias MOutput = OperationOutput<AssociateConnectionWithLagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateConnectionWithLagOutputError>
}

extension AssociateConnectionWithLagInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateConnectionWithLagInput(connectionId: \(String(describing: connectionId)), lagId: \(String(describing: lagId)))"}
}

extension AssociateConnectionWithLagInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case lagId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let lagId = lagId {
            try encodeContainer.encode(lagId, forKey: .lagId)
        }
    }
}

public struct AssociateConnectionWithLagInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateConnectionWithLagInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateConnectionWithLagInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateConnectionWithLagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateConnectionWithLagInput>
    public typealias MOutput = OperationOutput<AssociateConnectionWithLagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateConnectionWithLagOutputError>
}

public struct AssociateConnectionWithLagInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateConnectionWithLagInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateConnectionWithLagInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateConnectionWithLagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateConnectionWithLagInput>
    public typealias MOutput = OperationOutput<AssociateConnectionWithLagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateConnectionWithLagOutputError>
}

public struct AssociateConnectionWithLagInput: Equatable {
    /// <p>The ID of the connection.</p>
    public let connectionId: String?
    /// <p>The ID of the LAG with which to associate the connection.</p>
    public let lagId: String?

    public init (
        connectionId: String? = nil,
        lagId: String? = nil
    )
    {
        self.connectionId = connectionId
        self.lagId = lagId
    }
}

struct AssociateConnectionWithLagInputBody: Equatable {
    public let connectionId: String?
    public let lagId: String?
}

extension AssociateConnectionWithLagInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case lagId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lagId)
        lagId = lagIdDecoded
    }
}

extension AssociateConnectionWithLagOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateConnectionWithLagOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateConnectionWithLagOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateConnectionWithLagOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateConnectionWithLagOutputResponse(awsDevice: \(String(describing: awsDevice)), awsDeviceV2: \(String(describing: awsDeviceV2)), bandwidth: \(String(describing: bandwidth)), connectionId: \(String(describing: connectionId)), connectionName: \(String(describing: connectionName)), connectionState: \(String(describing: connectionState)), encryptionMode: \(String(describing: encryptionMode)), hasLogicalRedundancy: \(String(describing: hasLogicalRedundancy)), jumboFrameCapable: \(String(describing: jumboFrameCapable)), lagId: \(String(describing: lagId)), loaIssueTime: \(String(describing: loaIssueTime)), location: \(String(describing: location)), macSecCapable: \(String(describing: macSecCapable)), macSecKeys: \(String(describing: macSecKeys)), ownerAccount: \(String(describing: ownerAccount)), partnerName: \(String(describing: partnerName)), portEncryptionStatus: \(String(describing: portEncryptionStatus)), providerName: \(String(describing: providerName)), region: \(String(describing: region)), tags: \(String(describing: tags)), vlan: \(String(describing: vlan)))"}
}

extension AssociateConnectionWithLagOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateConnectionWithLagOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.awsDevice = output.awsDevice
            self.awsDeviceV2 = output.awsDeviceV2
            self.bandwidth = output.bandwidth
            self.connectionId = output.connectionId
            self.connectionName = output.connectionName
            self.connectionState = output.connectionState
            self.encryptionMode = output.encryptionMode
            self.hasLogicalRedundancy = output.hasLogicalRedundancy
            self.jumboFrameCapable = output.jumboFrameCapable
            self.lagId = output.lagId
            self.loaIssueTime = output.loaIssueTime
            self.location = output.location
            self.macSecCapable = output.macSecCapable
            self.macSecKeys = output.macSecKeys
            self.ownerAccount = output.ownerAccount
            self.partnerName = output.partnerName
            self.portEncryptionStatus = output.portEncryptionStatus
            self.providerName = output.providerName
            self.region = output.region
            self.tags = output.tags
            self.vlan = output.vlan
        } else {
            self.awsDevice = nil
            self.awsDeviceV2 = nil
            self.bandwidth = nil
            self.connectionId = nil
            self.connectionName = nil
            self.connectionState = nil
            self.encryptionMode = nil
            self.hasLogicalRedundancy = nil
            self.jumboFrameCapable = nil
            self.lagId = nil
            self.loaIssueTime = nil
            self.location = nil
            self.macSecCapable = nil
            self.macSecKeys = nil
            self.ownerAccount = nil
            self.partnerName = nil
            self.portEncryptionStatus = nil
            self.providerName = nil
            self.region = nil
            self.tags = nil
            self.vlan = 0
        }
    }
}

/// <p>Information about an AWS Direct Connect connection.</p>
public struct AssociateConnectionWithLagOutputResponse: Equatable {
    /// <p>The Direct Connect endpoint on which the physical connection terminates.</p>
    @available(*, deprecated)
    public let awsDevice: String?
    /// <p>The Direct Connect endpoint on which the physical connection terminates.</p>
    public let awsDeviceV2: String?
    /// <p>The bandwidth of the connection.</p>
    public let bandwidth: String?
    /// <p>The ID of the connection.</p>
    public let connectionId: String?
    /// <p>The name of the connection.</p>
    public let connectionName: String?
    /// <p>The state of the connection. The following are the possible values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ordering</code>: The initial state of a hosted connection provisioned on an interconnect. The connection stays in the ordering state until the owner of the hosted connection confirms or declines the connection order.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>requested</code>: The initial state of a standard connection. The connection stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: The connection has been approved and is being initialized.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>available</code>: The network link is up and the connection is ready for use.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>down</code>: The network link is down.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>: The connection is being deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>: The connection has been deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>rejected</code>: A hosted connection in the <code>ordering</code> state enters the <code>rejected</code> state if it is deleted by the customer.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>unknown</code>: The state of the connection is not available.</p>
    ///             </li>
    ///          </ul>
    public let connectionState: ConnectionState?
    /// <p>The MAC Security (MACsec) connection encryption mode.</p>
    ///          <p>The valid values are <code>no_encrypt</code>, <code>should_encrypt</code>, and <code>must_encrypt</code>.</p>
    public let encryptionMode: String?
    /// <p>Indicates whether the connection supports a secondary BGP peer in the same address family (IPv4/IPv6).</p>
    public let hasLogicalRedundancy: HasLogicalRedundancy?
    /// <p>Indicates whether jumbo frames (9001 MTU) are supported.</p>
    public let jumboFrameCapable: Bool?
    /// <p>The ID of the LAG.</p>
    public let lagId: String?
    /// <p>The time of the most recent call to <a>DescribeLoa</a> for this connection.</p>
    public let loaIssueTime: Date?
    /// <p>The location of the connection.</p>
    public let location: String?
    /// <p>Indicates whether the connection supports MAC Security (MACsec).</p>
    public let macSecCapable: Bool?
    /// <p>The MAC Security (MACsec) security keys associated with the connection.</p>
    public let macSecKeys: [MacSecKey]?
    /// <p>The ID of the AWS account that owns the connection.</p>
    public let ownerAccount: String?
    /// <p>The name of the AWS Direct Connect service provider associated with the connection.</p>
    public let partnerName: String?
    /// <p>The MAC Security (MACsec) port link status of the connection.</p>
    ///          <p>The valid values are <code>Encryption Up</code>, which means that there is an active Connection Key Name, or <code>Encryption Down</code>.</p>
    public let portEncryptionStatus: String?
    /// <p>The name of the service provider associated with the connection.</p>
    public let providerName: String?
    /// <p>The AWS Region where the connection is located.</p>
    public let region: String?
    /// <p>The tags associated with the connection.</p>
    public let tags: [Tag]?
    /// <p>The ID of the VLAN.</p>
    public let vlan: Int

    public init (
        awsDevice: String? = nil,
        awsDeviceV2: String? = nil,
        bandwidth: String? = nil,
        connectionId: String? = nil,
        connectionName: String? = nil,
        connectionState: ConnectionState? = nil,
        encryptionMode: String? = nil,
        hasLogicalRedundancy: HasLogicalRedundancy? = nil,
        jumboFrameCapable: Bool? = nil,
        lagId: String? = nil,
        loaIssueTime: Date? = nil,
        location: String? = nil,
        macSecCapable: Bool? = nil,
        macSecKeys: [MacSecKey]? = nil,
        ownerAccount: String? = nil,
        partnerName: String? = nil,
        portEncryptionStatus: String? = nil,
        providerName: String? = nil,
        region: String? = nil,
        tags: [Tag]? = nil,
        vlan: Int = 0
    )
    {
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.bandwidth = bandwidth
        self.connectionId = connectionId
        self.connectionName = connectionName
        self.connectionState = connectionState
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.loaIssueTime = loaIssueTime
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.ownerAccount = ownerAccount
        self.partnerName = partnerName
        self.portEncryptionStatus = portEncryptionStatus
        self.providerName = providerName
        self.region = region
        self.tags = tags
        self.vlan = vlan
    }
}

struct AssociateConnectionWithLagOutputResponseBody: Equatable {
    public let ownerAccount: String?
    public let connectionId: String?
    public let connectionName: String?
    public let connectionState: ConnectionState?
    public let region: String?
    public let location: String?
    public let bandwidth: String?
    public let vlan: Int
    public let partnerName: String?
    public let loaIssueTime: Date?
    public let lagId: String?
    public let awsDevice: String?
    public let jumboFrameCapable: Bool?
    public let awsDeviceV2: String?
    public let hasLogicalRedundancy: HasLogicalRedundancy?
    public let tags: [Tag]?
    public let providerName: String?
    public let macSecCapable: Bool?
    public let portEncryptionStatus: String?
    public let encryptionMode: String?
    public let macSecKeys: [MacSecKey]?
}

extension AssociateConnectionWithLagOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case awsDevice
        case awsDeviceV2
        case bandwidth
        case connectionId
        case connectionName
        case connectionState
        case encryptionMode
        case hasLogicalRedundancy
        case jumboFrameCapable
        case lagId
        case loaIssueTime
        case location
        case macSecCapable
        case macSecKeys
        case ownerAccount
        case partnerName
        case portEncryptionStatus
        case providerName
        case region
        case tags
        case vlan
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let vlanDecoded = try containerValues.decode(Int.self, forKey: .vlan)
        vlan = vlanDecoded
        let partnerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .partnerName)
        partnerName = partnerNameDecoded
        let loaIssueTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .loaIssueTime)
        loaIssueTime = loaIssueTimeDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let awsDeviceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDevice)
        awsDevice = awsDeviceDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let hasLogicalRedundancyDecoded = try containerValues.decodeIfPresent(HasLogicalRedundancy.self, forKey: .hasLogicalRedundancy)
        hasLogicalRedundancy = hasLogicalRedundancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let macSecCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .macSecCapable)
        macSecCapable = macSecCapableDecoded
        let portEncryptionStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portEncryptionStatus)
        portEncryptionStatus = portEncryptionStatusDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let macSecKeysContainer = try containerValues.decodeIfPresent([MacSecKey?].self, forKey: .macSecKeys)
        var macSecKeysDecoded0:[MacSecKey]? = nil
        if let macSecKeysContainer = macSecKeysContainer {
            macSecKeysDecoded0 = [MacSecKey]()
            for structure0 in macSecKeysContainer {
                if let structure0 = structure0 {
                    macSecKeysDecoded0?.append(structure0)
                }
            }
        }
        macSecKeys = macSecKeysDecoded0
    }
}

public struct AssociateHostedConnectionInputBodyMiddleware: Middleware {
    public let id: String = "AssociateHostedConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateHostedConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateHostedConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateHostedConnectionInput>
    public typealias MOutput = OperationOutput<AssociateHostedConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateHostedConnectionOutputError>
}

extension AssociateHostedConnectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateHostedConnectionInput(connectionId: \(String(describing: connectionId)), parentConnectionId: \(String(describing: parentConnectionId)))"}
}

extension AssociateHostedConnectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case parentConnectionId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let parentConnectionId = parentConnectionId {
            try encodeContainer.encode(parentConnectionId, forKey: .parentConnectionId)
        }
    }
}

public struct AssociateHostedConnectionInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateHostedConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateHostedConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateHostedConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateHostedConnectionInput>
    public typealias MOutput = OperationOutput<AssociateHostedConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateHostedConnectionOutputError>
}

public struct AssociateHostedConnectionInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateHostedConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateHostedConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateHostedConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateHostedConnectionInput>
    public typealias MOutput = OperationOutput<AssociateHostedConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateHostedConnectionOutputError>
}

public struct AssociateHostedConnectionInput: Equatable {
    /// <p>The ID of the hosted connection.</p>
    public let connectionId: String?
    /// <p>The ID of the interconnect or the LAG.</p>
    public let parentConnectionId: String?

    public init (
        connectionId: String? = nil,
        parentConnectionId: String? = nil
    )
    {
        self.connectionId = connectionId
        self.parentConnectionId = parentConnectionId
    }
}

struct AssociateHostedConnectionInputBody: Equatable {
    public let connectionId: String?
    public let parentConnectionId: String?
}

extension AssociateHostedConnectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case parentConnectionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let parentConnectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentConnectionId)
        parentConnectionId = parentConnectionIdDecoded
    }
}

extension AssociateHostedConnectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateHostedConnectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateHostedConnectionOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateHostedConnectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateHostedConnectionOutputResponse(awsDevice: \(String(describing: awsDevice)), awsDeviceV2: \(String(describing: awsDeviceV2)), bandwidth: \(String(describing: bandwidth)), connectionId: \(String(describing: connectionId)), connectionName: \(String(describing: connectionName)), connectionState: \(String(describing: connectionState)), encryptionMode: \(String(describing: encryptionMode)), hasLogicalRedundancy: \(String(describing: hasLogicalRedundancy)), jumboFrameCapable: \(String(describing: jumboFrameCapable)), lagId: \(String(describing: lagId)), loaIssueTime: \(String(describing: loaIssueTime)), location: \(String(describing: location)), macSecCapable: \(String(describing: macSecCapable)), macSecKeys: \(String(describing: macSecKeys)), ownerAccount: \(String(describing: ownerAccount)), partnerName: \(String(describing: partnerName)), portEncryptionStatus: \(String(describing: portEncryptionStatus)), providerName: \(String(describing: providerName)), region: \(String(describing: region)), tags: \(String(describing: tags)), vlan: \(String(describing: vlan)))"}
}

extension AssociateHostedConnectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateHostedConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.awsDevice = output.awsDevice
            self.awsDeviceV2 = output.awsDeviceV2
            self.bandwidth = output.bandwidth
            self.connectionId = output.connectionId
            self.connectionName = output.connectionName
            self.connectionState = output.connectionState
            self.encryptionMode = output.encryptionMode
            self.hasLogicalRedundancy = output.hasLogicalRedundancy
            self.jumboFrameCapable = output.jumboFrameCapable
            self.lagId = output.lagId
            self.loaIssueTime = output.loaIssueTime
            self.location = output.location
            self.macSecCapable = output.macSecCapable
            self.macSecKeys = output.macSecKeys
            self.ownerAccount = output.ownerAccount
            self.partnerName = output.partnerName
            self.portEncryptionStatus = output.portEncryptionStatus
            self.providerName = output.providerName
            self.region = output.region
            self.tags = output.tags
            self.vlan = output.vlan
        } else {
            self.awsDevice = nil
            self.awsDeviceV2 = nil
            self.bandwidth = nil
            self.connectionId = nil
            self.connectionName = nil
            self.connectionState = nil
            self.encryptionMode = nil
            self.hasLogicalRedundancy = nil
            self.jumboFrameCapable = nil
            self.lagId = nil
            self.loaIssueTime = nil
            self.location = nil
            self.macSecCapable = nil
            self.macSecKeys = nil
            self.ownerAccount = nil
            self.partnerName = nil
            self.portEncryptionStatus = nil
            self.providerName = nil
            self.region = nil
            self.tags = nil
            self.vlan = 0
        }
    }
}

/// <p>Information about an AWS Direct Connect connection.</p>
public struct AssociateHostedConnectionOutputResponse: Equatable {
    /// <p>The Direct Connect endpoint on which the physical connection terminates.</p>
    @available(*, deprecated)
    public let awsDevice: String?
    /// <p>The Direct Connect endpoint on which the physical connection terminates.</p>
    public let awsDeviceV2: String?
    /// <p>The bandwidth of the connection.</p>
    public let bandwidth: String?
    /// <p>The ID of the connection.</p>
    public let connectionId: String?
    /// <p>The name of the connection.</p>
    public let connectionName: String?
    /// <p>The state of the connection. The following are the possible values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ordering</code>: The initial state of a hosted connection provisioned on an interconnect. The connection stays in the ordering state until the owner of the hosted connection confirms or declines the connection order.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>requested</code>: The initial state of a standard connection. The connection stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: The connection has been approved and is being initialized.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>available</code>: The network link is up and the connection is ready for use.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>down</code>: The network link is down.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>: The connection is being deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>: The connection has been deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>rejected</code>: A hosted connection in the <code>ordering</code> state enters the <code>rejected</code> state if it is deleted by the customer.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>unknown</code>: The state of the connection is not available.</p>
    ///             </li>
    ///          </ul>
    public let connectionState: ConnectionState?
    /// <p>The MAC Security (MACsec) connection encryption mode.</p>
    ///          <p>The valid values are <code>no_encrypt</code>, <code>should_encrypt</code>, and <code>must_encrypt</code>.</p>
    public let encryptionMode: String?
    /// <p>Indicates whether the connection supports a secondary BGP peer in the same address family (IPv4/IPv6).</p>
    public let hasLogicalRedundancy: HasLogicalRedundancy?
    /// <p>Indicates whether jumbo frames (9001 MTU) are supported.</p>
    public let jumboFrameCapable: Bool?
    /// <p>The ID of the LAG.</p>
    public let lagId: String?
    /// <p>The time of the most recent call to <a>DescribeLoa</a> for this connection.</p>
    public let loaIssueTime: Date?
    /// <p>The location of the connection.</p>
    public let location: String?
    /// <p>Indicates whether the connection supports MAC Security (MACsec).</p>
    public let macSecCapable: Bool?
    /// <p>The MAC Security (MACsec) security keys associated with the connection.</p>
    public let macSecKeys: [MacSecKey]?
    /// <p>The ID of the AWS account that owns the connection.</p>
    public let ownerAccount: String?
    /// <p>The name of the AWS Direct Connect service provider associated with the connection.</p>
    public let partnerName: String?
    /// <p>The MAC Security (MACsec) port link status of the connection.</p>
    ///          <p>The valid values are <code>Encryption Up</code>, which means that there is an active Connection Key Name, or <code>Encryption Down</code>.</p>
    public let portEncryptionStatus: String?
    /// <p>The name of the service provider associated with the connection.</p>
    public let providerName: String?
    /// <p>The AWS Region where the connection is located.</p>
    public let region: String?
    /// <p>The tags associated with the connection.</p>
    public let tags: [Tag]?
    /// <p>The ID of the VLAN.</p>
    public let vlan: Int

    public init (
        awsDevice: String? = nil,
        awsDeviceV2: String? = nil,
        bandwidth: String? = nil,
        connectionId: String? = nil,
        connectionName: String? = nil,
        connectionState: ConnectionState? = nil,
        encryptionMode: String? = nil,
        hasLogicalRedundancy: HasLogicalRedundancy? = nil,
        jumboFrameCapable: Bool? = nil,
        lagId: String? = nil,
        loaIssueTime: Date? = nil,
        location: String? = nil,
        macSecCapable: Bool? = nil,
        macSecKeys: [MacSecKey]? = nil,
        ownerAccount: String? = nil,
        partnerName: String? = nil,
        portEncryptionStatus: String? = nil,
        providerName: String? = nil,
        region: String? = nil,
        tags: [Tag]? = nil,
        vlan: Int = 0
    )
    {
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.bandwidth = bandwidth
        self.connectionId = connectionId
        self.connectionName = connectionName
        self.connectionState = connectionState
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.loaIssueTime = loaIssueTime
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.ownerAccount = ownerAccount
        self.partnerName = partnerName
        self.portEncryptionStatus = portEncryptionStatus
        self.providerName = providerName
        self.region = region
        self.tags = tags
        self.vlan = vlan
    }
}

struct AssociateHostedConnectionOutputResponseBody: Equatable {
    public let ownerAccount: String?
    public let connectionId: String?
    public let connectionName: String?
    public let connectionState: ConnectionState?
    public let region: String?
    public let location: String?
    public let bandwidth: String?
    public let vlan: Int
    public let partnerName: String?
    public let loaIssueTime: Date?
    public let lagId: String?
    public let awsDevice: String?
    public let jumboFrameCapable: Bool?
    public let awsDeviceV2: String?
    public let hasLogicalRedundancy: HasLogicalRedundancy?
    public let tags: [Tag]?
    public let providerName: String?
    public let macSecCapable: Bool?
    public let portEncryptionStatus: String?
    public let encryptionMode: String?
    public let macSecKeys: [MacSecKey]?
}

extension AssociateHostedConnectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case awsDevice
        case awsDeviceV2
        case bandwidth
        case connectionId
        case connectionName
        case connectionState
        case encryptionMode
        case hasLogicalRedundancy
        case jumboFrameCapable
        case lagId
        case loaIssueTime
        case location
        case macSecCapable
        case macSecKeys
        case ownerAccount
        case partnerName
        case portEncryptionStatus
        case providerName
        case region
        case tags
        case vlan
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let vlanDecoded = try containerValues.decode(Int.self, forKey: .vlan)
        vlan = vlanDecoded
        let partnerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .partnerName)
        partnerName = partnerNameDecoded
        let loaIssueTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .loaIssueTime)
        loaIssueTime = loaIssueTimeDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let awsDeviceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDevice)
        awsDevice = awsDeviceDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let hasLogicalRedundancyDecoded = try containerValues.decodeIfPresent(HasLogicalRedundancy.self, forKey: .hasLogicalRedundancy)
        hasLogicalRedundancy = hasLogicalRedundancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let macSecCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .macSecCapable)
        macSecCapable = macSecCapableDecoded
        let portEncryptionStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portEncryptionStatus)
        portEncryptionStatus = portEncryptionStatusDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let macSecKeysContainer = try containerValues.decodeIfPresent([MacSecKey?].self, forKey: .macSecKeys)
        var macSecKeysDecoded0:[MacSecKey]? = nil
        if let macSecKeysContainer = macSecKeysContainer {
            macSecKeysDecoded0 = [MacSecKey]()
            for structure0 in macSecKeysContainer {
                if let structure0 = structure0 {
                    macSecKeysDecoded0?.append(structure0)
                }
            }
        }
        macSecKeys = macSecKeysDecoded0
    }
}

public struct AssociateMacSecKeyInputBodyMiddleware: Middleware {
    public let id: String = "AssociateMacSecKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateMacSecKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateMacSecKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateMacSecKeyInput>
    public typealias MOutput = OperationOutput<AssociateMacSecKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateMacSecKeyOutputError>
}

extension AssociateMacSecKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateMacSecKeyInput(cak: \(String(describing: cak)), ckn: \(String(describing: ckn)), connectionId: \(String(describing: connectionId)), secretARN: \(String(describing: secretARN)))"}
}

extension AssociateMacSecKeyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cak
        case ckn
        case connectionId
        case secretARN
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cak = cak {
            try encodeContainer.encode(cak, forKey: .cak)
        }
        if let ckn = ckn {
            try encodeContainer.encode(ckn, forKey: .ckn)
        }
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let secretARN = secretARN {
            try encodeContainer.encode(secretARN, forKey: .secretARN)
        }
    }
}

public struct AssociateMacSecKeyInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateMacSecKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateMacSecKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateMacSecKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateMacSecKeyInput>
    public typealias MOutput = OperationOutput<AssociateMacSecKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateMacSecKeyOutputError>
}

public struct AssociateMacSecKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateMacSecKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateMacSecKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateMacSecKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateMacSecKeyInput>
    public typealias MOutput = OperationOutput<AssociateMacSecKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateMacSecKeyOutputError>
}

public struct AssociateMacSecKeyInput: Equatable {
    /// <p>The MAC Security (MACsec) CAK to associate with the dedicated connection.</p>
    ///          <p>You can create the CKN/CAK pair using an industry standard tool.</p>
    ///          <p> The valid values are 64 hexadecimal characters (0-9, A-E).</p>
    ///          <p>If you use this request parameter, you must use the <code>ckn</code> request parameter and not use the <code>secretARN</code> request parameter.</p>
    public let cak: String?
    /// <p>The MAC Security (MACsec) CKN to associate with the dedicated connection.</p>
    ///          <p>You can create the CKN/CAK pair using an industry standard tool.</p>
    ///          <p> The valid values are 64 hexadecimal characters (0-9, A-E).</p>
    ///          <p>If you use this request parameter, you must use the <code>cak</code> request parameter and not use the <code>secretARN</code> request parameter.</p>
    public let ckn: String?
    /// <p>The ID of the dedicated connection (dxcon-xxxx), or the ID of the LAG (dxlag-xxxx).</p>
    ///          <p>You can use <a>DescribeConnections</a> or <a>DescribeLags</a> to retrieve connection ID.</p>
    public let connectionId: String?
    /// <p>The Amazon Resource Name (ARN) of the MAC Security (MACsec) secret key to associate with the dedicated connection.</p>
    ///          <p>You can use <a>DescribeConnections</a> or <a>DescribeLags</a> to retrieve the MAC Security (MACsec) secret key.</p>
    ///          <p>If you use this request parameter, you do not use the <code>ckn</code> and <code>cak</code> request parameters.</p>
    public let secretARN: String?

    public init (
        cak: String? = nil,
        ckn: String? = nil,
        connectionId: String? = nil,
        secretARN: String? = nil
    )
    {
        self.cak = cak
        self.ckn = ckn
        self.connectionId = connectionId
        self.secretARN = secretARN
    }
}

struct AssociateMacSecKeyInputBody: Equatable {
    public let connectionId: String?
    public let secretARN: String?
    public let ckn: String?
    public let cak: String?
}

extension AssociateMacSecKeyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cak
        case ckn
        case connectionId
        case secretARN
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let secretARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretARN)
        secretARN = secretARNDecoded
        let cknDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ckn)
        ckn = cknDecoded
        let cakDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cak)
        cak = cakDecoded
    }
}

extension AssociateMacSecKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateMacSecKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateMacSecKeyOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateMacSecKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateMacSecKeyOutputResponse(connectionId: \(String(describing: connectionId)), macSecKeys: \(String(describing: macSecKeys)))"}
}

extension AssociateMacSecKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateMacSecKeyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectionId = output.connectionId
            self.macSecKeys = output.macSecKeys
        } else {
            self.connectionId = nil
            self.macSecKeys = nil
        }
    }
}

public struct AssociateMacSecKeyOutputResponse: Equatable {
    /// <p>The ID of the dedicated connection (dxcon-xxxx), or the ID of the LAG (dxlag-xxxx).</p>
    public let connectionId: String?
    /// <p>The MAC Security (MACsec) security keys associated with the dedicated connection.</p>
    public let macSecKeys: [MacSecKey]?

    public init (
        connectionId: String? = nil,
        macSecKeys: [MacSecKey]? = nil
    )
    {
        self.connectionId = connectionId
        self.macSecKeys = macSecKeys
    }
}

struct AssociateMacSecKeyOutputResponseBody: Equatable {
    public let connectionId: String?
    public let macSecKeys: [MacSecKey]?
}

extension AssociateMacSecKeyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case macSecKeys
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let macSecKeysContainer = try containerValues.decodeIfPresent([MacSecKey?].self, forKey: .macSecKeys)
        var macSecKeysDecoded0:[MacSecKey]? = nil
        if let macSecKeysContainer = macSecKeysContainer {
            macSecKeysDecoded0 = [MacSecKey]()
            for structure0 in macSecKeysContainer {
                if let structure0 = structure0 {
                    macSecKeysDecoded0?.append(structure0)
                }
            }
        }
        macSecKeys = macSecKeysDecoded0
    }
}

public struct AssociateVirtualInterfaceInputBodyMiddleware: Middleware {
    public let id: String = "AssociateVirtualInterfaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<AssociateVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateVirtualInterfaceOutputError>
}

extension AssociateVirtualInterfaceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateVirtualInterfaceInput(connectionId: \(String(describing: connectionId)), virtualInterfaceId: \(String(describing: virtualInterfaceId)))"}
}

extension AssociateVirtualInterfaceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case virtualInterfaceId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let virtualInterfaceId = virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
    }
}

public struct AssociateVirtualInterfaceInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateVirtualInterfaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<AssociateVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateVirtualInterfaceOutputError>
}

public struct AssociateVirtualInterfaceInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateVirtualInterfaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<AssociateVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateVirtualInterfaceOutputError>
}

public struct AssociateVirtualInterfaceInput: Equatable {
    /// <p>The ID of the LAG or connection.</p>
    public let connectionId: String?
    /// <p>The ID of the virtual interface.</p>
    public let virtualInterfaceId: String?

    public init (
        connectionId: String? = nil,
        virtualInterfaceId: String? = nil
    )
    {
        self.connectionId = connectionId
        self.virtualInterfaceId = virtualInterfaceId
    }
}

struct AssociateVirtualInterfaceInputBody: Equatable {
    public let virtualInterfaceId: String?
    public let connectionId: String?
}

extension AssociateVirtualInterfaceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case virtualInterfaceId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
    }
}

extension AssociateVirtualInterfaceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateVirtualInterfaceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateVirtualInterfaceOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateVirtualInterfaceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateVirtualInterfaceOutputResponse(addressFamily: \(String(describing: addressFamily)), amazonAddress: \(String(describing: amazonAddress)), amazonSideAsn: \(String(describing: amazonSideAsn)), asn: \(String(describing: asn)), authKey: \(String(describing: authKey)), awsDeviceV2: \(String(describing: awsDeviceV2)), bgpPeers: \(String(describing: bgpPeers)), connectionId: \(String(describing: connectionId)), customerAddress: \(String(describing: customerAddress)), customerRouterConfig: \(String(describing: customerRouterConfig)), directConnectGatewayId: \(String(describing: directConnectGatewayId)), jumboFrameCapable: \(String(describing: jumboFrameCapable)), location: \(String(describing: location)), mtu: \(String(describing: mtu)), ownerAccount: \(String(describing: ownerAccount)), region: \(String(describing: region)), routeFilterPrefixes: \(String(describing: routeFilterPrefixes)), tags: \(String(describing: tags)), virtualGatewayId: \(String(describing: virtualGatewayId)), virtualInterfaceId: \(String(describing: virtualInterfaceId)), virtualInterfaceName: \(String(describing: virtualInterfaceName)), virtualInterfaceState: \(String(describing: virtualInterfaceState)), virtualInterfaceType: \(String(describing: virtualInterfaceType)), vlan: \(String(describing: vlan)))"}
}

extension AssociateVirtualInterfaceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateVirtualInterfaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.addressFamily = output.addressFamily
            self.amazonAddress = output.amazonAddress
            self.amazonSideAsn = output.amazonSideAsn
            self.asn = output.asn
            self.authKey = output.authKey
            self.awsDeviceV2 = output.awsDeviceV2
            self.bgpPeers = output.bgpPeers
            self.connectionId = output.connectionId
            self.customerAddress = output.customerAddress
            self.customerRouterConfig = output.customerRouterConfig
            self.directConnectGatewayId = output.directConnectGatewayId
            self.jumboFrameCapable = output.jumboFrameCapable
            self.location = output.location
            self.mtu = output.mtu
            self.ownerAccount = output.ownerAccount
            self.region = output.region
            self.routeFilterPrefixes = output.routeFilterPrefixes
            self.tags = output.tags
            self.virtualGatewayId = output.virtualGatewayId
            self.virtualInterfaceId = output.virtualInterfaceId
            self.virtualInterfaceName = output.virtualInterfaceName
            self.virtualInterfaceState = output.virtualInterfaceState
            self.virtualInterfaceType = output.virtualInterfaceType
            self.vlan = output.vlan
        } else {
            self.addressFamily = nil
            self.amazonAddress = nil
            self.amazonSideAsn = nil
            self.asn = 0
            self.authKey = nil
            self.awsDeviceV2 = nil
            self.bgpPeers = nil
            self.connectionId = nil
            self.customerAddress = nil
            self.customerRouterConfig = nil
            self.directConnectGatewayId = nil
            self.jumboFrameCapable = nil
            self.location = nil
            self.mtu = nil
            self.ownerAccount = nil
            self.region = nil
            self.routeFilterPrefixes = nil
            self.tags = nil
            self.virtualGatewayId = nil
            self.virtualInterfaceId = nil
            self.virtualInterfaceName = nil
            self.virtualInterfaceState = nil
            self.virtualInterfaceType = nil
            self.vlan = 0
        }
    }
}

/// <p>Information about a virtual interface.</p>
public struct AssociateVirtualInterfaceOutputResponse: Equatable {
    /// <p>The address family for the BGP peer.</p>
    public let addressFamily: AddressFamily?
    /// <p>The IP address assigned to the Amazon interface.</p>
    public let amazonAddress: String?
    /// <p>The autonomous system number (ASN) for the Amazon side of the connection.</p>
    public let amazonSideAsn: Int?
    /// <p>The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.</p>
    ///          <p>The valid values are 1-2147483647.</p>
    public let asn: Int
    /// <p>The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.</p>
    public let authKey: String?
    /// <p>The
    ///       Direct Connect endpoint on which the virtual interface terminates.</p>
    public let awsDeviceV2: String?
    /// <p>The BGP peers configured on this virtual interface.</p>
    public let bgpPeers: [BGPPeer]?
    /// <p>The ID of the connection.</p>
    public let connectionId: String?
    /// <p>The IP address assigned to the customer interface.</p>
    public let customerAddress: String?
    /// <p>The customer router configuration.</p>
    public let customerRouterConfig: String?
    /// <p>The ID of the Direct Connect gateway.</p>
    public let directConnectGatewayId: String?
    /// <p>Indicates whether jumbo frames (9001 MTU) are supported.</p>
    public let jumboFrameCapable: Bool?
    /// <p>The location of the connection.</p>
    public let location: String?
    /// <p>The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 9001. The default value is 1500.</p>
    public let mtu: Int?
    /// <p>The ID of the AWS account that owns the virtual interface.</p>
    public let ownerAccount: String?
    /// <p>The AWS Region where the virtual interface is located.</p>
    public let region: String?
    /// <p>The routes to be advertised to the AWS network in this Region. Applies to public virtual interfaces.</p>
    public let routeFilterPrefixes: [RouteFilterPrefix]?
    /// <p>The tags associated with the virtual interface.</p>
    public let tags: [Tag]?
    /// <p>The ID of the virtual private gateway. Applies only to private virtual interfaces.</p>
    public let virtualGatewayId: String?
    /// <p>The ID of the virtual interface.</p>
    public let virtualInterfaceId: String?
    /// <p>The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).</p>
    public let virtualInterfaceName: String?
    /// <p>The state of the virtual interface. The following are the possible values:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>confirming</code>: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>verifying</code>: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>available</code>: A virtual interface that is able to forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>down</code>: A virtual interface that is BGP down.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>: A virtual interface is in this state immediately after calling <a>DeleteVirtualInterface</a> until it can no longer forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>: A virtual interface that cannot forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>rejected</code>: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the <code>Confirming</code> state is deleted by the virtual interface owner, the virtual interface enters the <code>Rejected</code> state.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>unknown</code>: The state of the virtual interface is not available.</p>
    ///             </li>
    ///          </ul>
    public let virtualInterfaceState: VirtualInterfaceState?
    /// <p>The type of virtual interface. The possible values are <code>private</code> and <code>public</code>.</p>
    public let virtualInterfaceType: String?
    /// <p>The ID of the VLAN.</p>
    public let vlan: Int

    public init (
        addressFamily: AddressFamily? = nil,
        amazonAddress: String? = nil,
        amazonSideAsn: Int? = nil,
        asn: Int = 0,
        authKey: String? = nil,
        awsDeviceV2: String? = nil,
        bgpPeers: [BGPPeer]? = nil,
        connectionId: String? = nil,
        customerAddress: String? = nil,
        customerRouterConfig: String? = nil,
        directConnectGatewayId: String? = nil,
        jumboFrameCapable: Bool? = nil,
        location: String? = nil,
        mtu: Int? = nil,
        ownerAccount: String? = nil,
        region: String? = nil,
        routeFilterPrefixes: [RouteFilterPrefix]? = nil,
        tags: [Tag]? = nil,
        virtualGatewayId: String? = nil,
        virtualInterfaceId: String? = nil,
        virtualInterfaceName: String? = nil,
        virtualInterfaceState: VirtualInterfaceState? = nil,
        virtualInterfaceType: String? = nil,
        vlan: Int = 0
    )
    {
        self.addressFamily = addressFamily
        self.amazonAddress = amazonAddress
        self.amazonSideAsn = amazonSideAsn
        self.asn = asn
        self.authKey = authKey
        self.awsDeviceV2 = awsDeviceV2
        self.bgpPeers = bgpPeers
        self.connectionId = connectionId
        self.customerAddress = customerAddress
        self.customerRouterConfig = customerRouterConfig
        self.directConnectGatewayId = directConnectGatewayId
        self.jumboFrameCapable = jumboFrameCapable
        self.location = location
        self.mtu = mtu
        self.ownerAccount = ownerAccount
        self.region = region
        self.routeFilterPrefixes = routeFilterPrefixes
        self.tags = tags
        self.virtualGatewayId = virtualGatewayId
        self.virtualInterfaceId = virtualInterfaceId
        self.virtualInterfaceName = virtualInterfaceName
        self.virtualInterfaceState = virtualInterfaceState
        self.virtualInterfaceType = virtualInterfaceType
        self.vlan = vlan
    }
}

struct AssociateVirtualInterfaceOutputResponseBody: Equatable {
    public let ownerAccount: String?
    public let virtualInterfaceId: String?
    public let location: String?
    public let connectionId: String?
    public let virtualInterfaceType: String?
    public let virtualInterfaceName: String?
    public let vlan: Int
    public let asn: Int
    public let amazonSideAsn: Int?
    public let authKey: String?
    public let amazonAddress: String?
    public let customerAddress: String?
    public let addressFamily: AddressFamily?
    public let virtualInterfaceState: VirtualInterfaceState?
    public let customerRouterConfig: String?
    public let mtu: Int?
    public let jumboFrameCapable: Bool?
    public let virtualGatewayId: String?
    public let directConnectGatewayId: String?
    public let routeFilterPrefixes: [RouteFilterPrefix]?
    public let bgpPeers: [BGPPeer]?
    public let region: String?
    public let awsDeviceV2: String?
    public let tags: [Tag]?
}

extension AssociateVirtualInterfaceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case addressFamily
        case amazonAddress
        case amazonSideAsn
        case asn
        case authKey
        case awsDeviceV2
        case bgpPeers
        case connectionId
        case customerAddress
        case customerRouterConfig
        case directConnectGatewayId
        case jumboFrameCapable
        case location
        case mtu
        case ownerAccount
        case region
        case routeFilterPrefixes
        case tags
        case virtualGatewayId
        case virtualInterfaceId
        case virtualInterfaceName
        case virtualInterfaceState
        case virtualInterfaceType
        case vlan
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let virtualInterfaceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceType)
        virtualInterfaceType = virtualInterfaceTypeDecoded
        let virtualInterfaceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceName)
        virtualInterfaceName = virtualInterfaceNameDecoded
        let vlanDecoded = try containerValues.decode(Int.self, forKey: .vlan)
        vlan = vlanDecoded
        let asnDecoded = try containerValues.decode(Int.self, forKey: .asn)
        asn = asnDecoded
        let amazonSideAsnDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .amazonSideAsn)
        amazonSideAsn = amazonSideAsnDecoded
        let authKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authKey)
        authKey = authKeyDecoded
        let amazonAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amazonAddress)
        amazonAddress = amazonAddressDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let virtualInterfaceStateDecoded = try containerValues.decodeIfPresent(VirtualInterfaceState.self, forKey: .virtualInterfaceState)
        virtualInterfaceState = virtualInterfaceStateDecoded
        let customerRouterConfigDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerRouterConfig)
        customerRouterConfig = customerRouterConfigDecoded
        let mtuDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .mtu)
        mtu = mtuDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let virtualGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualGatewayId)
        virtualGatewayId = virtualGatewayIdDecoded
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let routeFilterPrefixesContainer = try containerValues.decodeIfPresent([RouteFilterPrefix?].self, forKey: .routeFilterPrefixes)
        var routeFilterPrefixesDecoded0:[RouteFilterPrefix]? = nil
        if let routeFilterPrefixesContainer = routeFilterPrefixesContainer {
            routeFilterPrefixesDecoded0 = [RouteFilterPrefix]()
            for structure0 in routeFilterPrefixesContainer {
                if let structure0 = structure0 {
                    routeFilterPrefixesDecoded0?.append(structure0)
                }
            }
        }
        routeFilterPrefixes = routeFilterPrefixesDecoded0
        let bgpPeersContainer = try containerValues.decodeIfPresent([BGPPeer?].self, forKey: .bgpPeers)
        var bgpPeersDecoded0:[BGPPeer]? = nil
        if let bgpPeersContainer = bgpPeersContainer {
            bgpPeersDecoded0 = [BGPPeer]()
            for structure0 in bgpPeersContainer {
                if let structure0 = structure0 {
                    bgpPeersDecoded0?.append(structure0)
                }
            }
        }
        bgpPeers = bgpPeersDecoded0
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AssociatedGateway: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
        case ownerAccount
        case region
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let ownerAccount = ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(GatewayType.self, forKey: .type)
        type = typeDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
    }
}

extension AssociatedGateway: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociatedGateway(id: \(String(describing: id)), ownerAccount: \(String(describing: ownerAccount)), region: \(String(describing: region)), type: \(String(describing: type)))"}
}

/// <p>Information about the associated gateway.</p>
public struct AssociatedGateway: Equatable {
    /// <p>The ID of the associated gateway.</p>
    public let id: String?
    /// <p>The ID of the AWS account that owns the associated virtual private gateway or transit gateway.</p>
    public let ownerAccount: String?
    /// <p>The Region where the associated gateway is located.</p>
    public let region: String?
    /// <p>The type of associated gateway.</p>
    public let type: GatewayType?

    public init (
        id: String? = nil,
        ownerAccount: String? = nil,
        region: String? = nil,
        type: GatewayType? = nil
    )
    {
        self.id = id
        self.ownerAccount = ownerAccount
        self.region = region
        self.type = type
    }
}

extension BGPPeer: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addressFamily
        case amazonAddress
        case asn
        case authKey
        case awsDeviceV2
        case bgpPeerId
        case bgpPeerState
        case bgpStatus
        case customerAddress
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressFamily = addressFamily {
            try encodeContainer.encode(addressFamily.rawValue, forKey: .addressFamily)
        }
        if let amazonAddress = amazonAddress {
            try encodeContainer.encode(amazonAddress, forKey: .amazonAddress)
        }
        if asn != 0 {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let authKey = authKey {
            try encodeContainer.encode(authKey, forKey: .authKey)
        }
        if let awsDeviceV2 = awsDeviceV2 {
            try encodeContainer.encode(awsDeviceV2, forKey: .awsDeviceV2)
        }
        if let bgpPeerId = bgpPeerId {
            try encodeContainer.encode(bgpPeerId, forKey: .bgpPeerId)
        }
        if let bgpPeerState = bgpPeerState {
            try encodeContainer.encode(bgpPeerState.rawValue, forKey: .bgpPeerState)
        }
        if let bgpStatus = bgpStatus {
            try encodeContainer.encode(bgpStatus.rawValue, forKey: .bgpStatus)
        }
        if let customerAddress = customerAddress {
            try encodeContainer.encode(customerAddress, forKey: .customerAddress)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bgpPeerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bgpPeerId)
        bgpPeerId = bgpPeerIdDecoded
        let asnDecoded = try containerValues.decode(Int.self, forKey: .asn)
        asn = asnDecoded
        let authKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authKey)
        authKey = authKeyDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let amazonAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amazonAddress)
        amazonAddress = amazonAddressDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
        let bgpPeerStateDecoded = try containerValues.decodeIfPresent(BGPPeerState.self, forKey: .bgpPeerState)
        bgpPeerState = bgpPeerStateDecoded
        let bgpStatusDecoded = try containerValues.decodeIfPresent(BGPStatus.self, forKey: .bgpStatus)
        bgpStatus = bgpStatusDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
    }
}

extension BGPPeer: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BGPPeer(addressFamily: \(String(describing: addressFamily)), amazonAddress: \(String(describing: amazonAddress)), asn: \(String(describing: asn)), authKey: \(String(describing: authKey)), awsDeviceV2: \(String(describing: awsDeviceV2)), bgpPeerId: \(String(describing: bgpPeerId)), bgpPeerState: \(String(describing: bgpPeerState)), bgpStatus: \(String(describing: bgpStatus)), customerAddress: \(String(describing: customerAddress)))"}
}

/// <p>Information about a BGP peer.</p>
public struct BGPPeer: Equatable {
    /// <p>The address family for the BGP peer.</p>
    public let addressFamily: AddressFamily?
    /// <p>The IP address assigned to the Amazon interface.</p>
    public let amazonAddress: String?
    /// <p>The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.</p>
    public let asn: Int
    /// <p>The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.</p>
    public let authKey: String?
    /// <p>The Direct Connect endpoint on which the BGP peer terminates.</p>
    public let awsDeviceV2: String?
    /// <p>The ID of the BGP peer.</p>
    public let bgpPeerId: String?
    /// <p>The state of the BGP peer. The following are the possible values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>verifying</code>: The BGP peering addresses or ASN require validation before the BGP peer can be created. This state applies only to public virtual interfaces.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: The BGP peer is created, and remains in this state until it is ready to be established.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>available</code>: The BGP peer is ready to be established.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>:  The BGP peer is being deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>:  The BGP peer is deleted and cannot be established.</p>
    ///             </li>
    ///          </ul>
    public let bgpPeerState: BGPPeerState?
    /// <p>The status of the BGP peer. The following are the possible values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>up</code>: The BGP peer is established. This state does not indicate the
    ///         state of the routing function. Ensure that you are receiving routes over the BGP session.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>down</code>: The BGP peer is down.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>unknown</code>: The BGP peer status is not available.</p>
    ///             </li>
    ///          </ul>
    public let bgpStatus: BGPStatus?
    /// <p>The IP address assigned to the customer interface.</p>
    public let customerAddress: String?

    public init (
        addressFamily: AddressFamily? = nil,
        amazonAddress: String? = nil,
        asn: Int = 0,
        authKey: String? = nil,
        awsDeviceV2: String? = nil,
        bgpPeerId: String? = nil,
        bgpPeerState: BGPPeerState? = nil,
        bgpStatus: BGPStatus? = nil,
        customerAddress: String? = nil
    )
    {
        self.addressFamily = addressFamily
        self.amazonAddress = amazonAddress
        self.asn = asn
        self.authKey = authKey
        self.awsDeviceV2 = awsDeviceV2
        self.bgpPeerId = bgpPeerId
        self.bgpPeerState = bgpPeerState
        self.bgpStatus = bgpStatus
        self.customerAddress = customerAddress
    }
}

public enum BGPPeerState {
    case available
    case deleted
    case deleting
    case pending
    case verifying
    case sdkUnknown(String)
}

extension BGPPeerState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BGPPeerState] {
        return [
            .available,
            .deleted,
            .deleting,
            .pending,
            .verifying,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "available"
        case .deleted: return "deleted"
        case .deleting: return "deleting"
        case .pending: return "pending"
        case .verifying: return "verifying"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BGPPeerState(rawValue: rawValue) ?? BGPPeerState.sdkUnknown(rawValue)
    }
}

public enum BGPStatus {
    case down
    case unknown
    case up
    case sdkUnknown(String)
}

extension BGPStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BGPStatus] {
        return [
            .down,
            .unknown,
            .up,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .down: return "down"
        case .unknown: return "unknown"
        case .up: return "up"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BGPStatus(rawValue: rawValue) ?? BGPStatus.sdkUnknown(rawValue)
    }
}

public struct ConfirmConnectionInputBodyMiddleware: Middleware {
    public let id: String = "ConfirmConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfirmConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfirmConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfirmConnectionInput>
    public typealias MOutput = OperationOutput<ConfirmConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfirmConnectionOutputError>
}

extension ConfirmConnectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfirmConnectionInput(connectionId: \(String(describing: connectionId)))"}
}

extension ConfirmConnectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
    }
}

public struct ConfirmConnectionInputHeadersMiddleware: Middleware {
    public let id: String = "ConfirmConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfirmConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfirmConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfirmConnectionInput>
    public typealias MOutput = OperationOutput<ConfirmConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfirmConnectionOutputError>
}

public struct ConfirmConnectionInputQueryItemMiddleware: Middleware {
    public let id: String = "ConfirmConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfirmConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfirmConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfirmConnectionInput>
    public typealias MOutput = OperationOutput<ConfirmConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfirmConnectionOutputError>
}

public struct ConfirmConnectionInput: Equatable {
    /// <p>The ID of the hosted connection.</p>
    public let connectionId: String?

    public init (
        connectionId: String? = nil
    )
    {
        self.connectionId = connectionId
    }
}

struct ConfirmConnectionInputBody: Equatable {
    public let connectionId: String?
}

extension ConfirmConnectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
    }
}

extension ConfirmConnectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ConfirmConnectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ConfirmConnectionOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ConfirmConnectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfirmConnectionOutputResponse(connectionState: \(String(describing: connectionState)))"}
}

extension ConfirmConnectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConfirmConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectionState = output.connectionState
        } else {
            self.connectionState = nil
        }
    }
}

public struct ConfirmConnectionOutputResponse: Equatable {
    /// <p>The state of the connection. The following are the possible values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ordering</code>: The initial state of a hosted connection provisioned on an interconnect. The connection stays in the ordering state until the owner of the hosted connection confirms or declines the connection order.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>requested</code>: The initial state of a standard connection. The connection stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: The connection has been approved and is being initialized.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>available</code>: The network link is up and the connection is ready for use.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>down</code>: The network link is down.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>: The connection is being deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>: The connection has been deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>rejected</code>: A hosted connection in the <code>ordering</code> state enters the <code>rejected</code> state if it is deleted by the customer.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>unknown</code>: The state of the connection is not available.</p>
    ///             </li>
    ///          </ul>
    public let connectionState: ConnectionState?

    public init (
        connectionState: ConnectionState? = nil
    )
    {
        self.connectionState = connectionState
    }
}

struct ConfirmConnectionOutputResponseBody: Equatable {
    public let connectionState: ConnectionState?
}

extension ConfirmConnectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionState
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionStateDecoded = try containerValues.decodeIfPresent(ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
    }
}

public struct ConfirmPrivateVirtualInterfaceInputBodyMiddleware: Middleware {
    public let id: String = "ConfirmPrivateVirtualInterfaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfirmPrivateVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfirmPrivateVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfirmPrivateVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<ConfirmPrivateVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfirmPrivateVirtualInterfaceOutputError>
}

extension ConfirmPrivateVirtualInterfaceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfirmPrivateVirtualInterfaceInput(directConnectGatewayId: \(String(describing: directConnectGatewayId)), virtualGatewayId: \(String(describing: virtualGatewayId)), virtualInterfaceId: \(String(describing: virtualInterfaceId)))"}
}

extension ConfirmPrivateVirtualInterfaceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directConnectGatewayId
        case virtualGatewayId
        case virtualInterfaceId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directConnectGatewayId = directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let virtualGatewayId = virtualGatewayId {
            try encodeContainer.encode(virtualGatewayId, forKey: .virtualGatewayId)
        }
        if let virtualInterfaceId = virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
    }
}

public struct ConfirmPrivateVirtualInterfaceInputHeadersMiddleware: Middleware {
    public let id: String = "ConfirmPrivateVirtualInterfaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfirmPrivateVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfirmPrivateVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfirmPrivateVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<ConfirmPrivateVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfirmPrivateVirtualInterfaceOutputError>
}

public struct ConfirmPrivateVirtualInterfaceInputQueryItemMiddleware: Middleware {
    public let id: String = "ConfirmPrivateVirtualInterfaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfirmPrivateVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfirmPrivateVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfirmPrivateVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<ConfirmPrivateVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfirmPrivateVirtualInterfaceOutputError>
}

public struct ConfirmPrivateVirtualInterfaceInput: Equatable {
    /// <p>The ID of the Direct Connect gateway.</p>
    public let directConnectGatewayId: String?
    /// <p>The ID of the virtual private gateway.</p>
    public let virtualGatewayId: String?
    /// <p>The ID of the virtual interface.</p>
    public let virtualInterfaceId: String?

    public init (
        directConnectGatewayId: String? = nil,
        virtualGatewayId: String? = nil,
        virtualInterfaceId: String? = nil
    )
    {
        self.directConnectGatewayId = directConnectGatewayId
        self.virtualGatewayId = virtualGatewayId
        self.virtualInterfaceId = virtualInterfaceId
    }
}

struct ConfirmPrivateVirtualInterfaceInputBody: Equatable {
    public let virtualInterfaceId: String?
    public let virtualGatewayId: String?
    public let directConnectGatewayId: String?
}

extension ConfirmPrivateVirtualInterfaceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directConnectGatewayId
        case virtualGatewayId
        case virtualInterfaceId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let virtualGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualGatewayId)
        virtualGatewayId = virtualGatewayIdDecoded
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
    }
}

extension ConfirmPrivateVirtualInterfaceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ConfirmPrivateVirtualInterfaceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ConfirmPrivateVirtualInterfaceOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ConfirmPrivateVirtualInterfaceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfirmPrivateVirtualInterfaceOutputResponse(virtualInterfaceState: \(String(describing: virtualInterfaceState)))"}
}

extension ConfirmPrivateVirtualInterfaceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConfirmPrivateVirtualInterfaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.virtualInterfaceState = output.virtualInterfaceState
        } else {
            self.virtualInterfaceState = nil
        }
    }
}

public struct ConfirmPrivateVirtualInterfaceOutputResponse: Equatable {
    /// <p>The state of the virtual interface. The following are the possible values:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>confirming</code>: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>verifying</code>: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>available</code>: A virtual interface that is able to forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>down</code>: A virtual interface that is BGP down.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>: A virtual interface is in this state immediately after calling <a>DeleteVirtualInterface</a> until it can no longer forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>: A virtual interface that cannot forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>rejected</code>: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the <code>Confirming</code> state is deleted by the virtual interface owner, the virtual interface enters the <code>Rejected</code> state.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>unknown</code>: The state of the virtual interface is not available.</p>
    ///             </li>
    ///          </ul>
    public let virtualInterfaceState: VirtualInterfaceState?

    public init (
        virtualInterfaceState: VirtualInterfaceState? = nil
    )
    {
        self.virtualInterfaceState = virtualInterfaceState
    }
}

struct ConfirmPrivateVirtualInterfaceOutputResponseBody: Equatable {
    public let virtualInterfaceState: VirtualInterfaceState?
}

extension ConfirmPrivateVirtualInterfaceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualInterfaceState
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceStateDecoded = try containerValues.decodeIfPresent(VirtualInterfaceState.self, forKey: .virtualInterfaceState)
        virtualInterfaceState = virtualInterfaceStateDecoded
    }
}

public struct ConfirmPublicVirtualInterfaceInputBodyMiddleware: Middleware {
    public let id: String = "ConfirmPublicVirtualInterfaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfirmPublicVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfirmPublicVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfirmPublicVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<ConfirmPublicVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfirmPublicVirtualInterfaceOutputError>
}

extension ConfirmPublicVirtualInterfaceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfirmPublicVirtualInterfaceInput(virtualInterfaceId: \(String(describing: virtualInterfaceId)))"}
}

extension ConfirmPublicVirtualInterfaceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case virtualInterfaceId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let virtualInterfaceId = virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
    }
}

public struct ConfirmPublicVirtualInterfaceInputHeadersMiddleware: Middleware {
    public let id: String = "ConfirmPublicVirtualInterfaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfirmPublicVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfirmPublicVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfirmPublicVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<ConfirmPublicVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfirmPublicVirtualInterfaceOutputError>
}

public struct ConfirmPublicVirtualInterfaceInputQueryItemMiddleware: Middleware {
    public let id: String = "ConfirmPublicVirtualInterfaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfirmPublicVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfirmPublicVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfirmPublicVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<ConfirmPublicVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfirmPublicVirtualInterfaceOutputError>
}

public struct ConfirmPublicVirtualInterfaceInput: Equatable {
    /// <p>The ID of the virtual interface.</p>
    public let virtualInterfaceId: String?

    public init (
        virtualInterfaceId: String? = nil
    )
    {
        self.virtualInterfaceId = virtualInterfaceId
    }
}

struct ConfirmPublicVirtualInterfaceInputBody: Equatable {
    public let virtualInterfaceId: String?
}

extension ConfirmPublicVirtualInterfaceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualInterfaceId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
    }
}

extension ConfirmPublicVirtualInterfaceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ConfirmPublicVirtualInterfaceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ConfirmPublicVirtualInterfaceOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ConfirmPublicVirtualInterfaceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfirmPublicVirtualInterfaceOutputResponse(virtualInterfaceState: \(String(describing: virtualInterfaceState)))"}
}

extension ConfirmPublicVirtualInterfaceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConfirmPublicVirtualInterfaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.virtualInterfaceState = output.virtualInterfaceState
        } else {
            self.virtualInterfaceState = nil
        }
    }
}

public struct ConfirmPublicVirtualInterfaceOutputResponse: Equatable {
    /// <p>The state of the virtual interface. The following are the possible values:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>confirming</code>: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>verifying</code>: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>available</code>: A virtual interface that is able to forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>down</code>: A virtual interface that is BGP down.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>: A virtual interface is in this state immediately after calling <a>DeleteVirtualInterface</a> until it can no longer forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>: A virtual interface that cannot forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>rejected</code>: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the <code>Confirming</code> state is deleted by the virtual interface owner, the virtual interface enters the <code>Rejected</code> state.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>unknown</code>: The state of the virtual interface is not available.</p>
    ///             </li>
    ///          </ul>
    public let virtualInterfaceState: VirtualInterfaceState?

    public init (
        virtualInterfaceState: VirtualInterfaceState? = nil
    )
    {
        self.virtualInterfaceState = virtualInterfaceState
    }
}

struct ConfirmPublicVirtualInterfaceOutputResponseBody: Equatable {
    public let virtualInterfaceState: VirtualInterfaceState?
}

extension ConfirmPublicVirtualInterfaceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualInterfaceState
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceStateDecoded = try containerValues.decodeIfPresent(VirtualInterfaceState.self, forKey: .virtualInterfaceState)
        virtualInterfaceState = virtualInterfaceStateDecoded
    }
}

public struct ConfirmTransitVirtualInterfaceInputBodyMiddleware: Middleware {
    public let id: String = "ConfirmTransitVirtualInterfaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfirmTransitVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfirmTransitVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfirmTransitVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<ConfirmTransitVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfirmTransitVirtualInterfaceOutputError>
}

extension ConfirmTransitVirtualInterfaceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfirmTransitVirtualInterfaceInput(directConnectGatewayId: \(String(describing: directConnectGatewayId)), virtualInterfaceId: \(String(describing: virtualInterfaceId)))"}
}

extension ConfirmTransitVirtualInterfaceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directConnectGatewayId
        case virtualInterfaceId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directConnectGatewayId = directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let virtualInterfaceId = virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
    }
}

public struct ConfirmTransitVirtualInterfaceInputHeadersMiddleware: Middleware {
    public let id: String = "ConfirmTransitVirtualInterfaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfirmTransitVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfirmTransitVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfirmTransitVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<ConfirmTransitVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfirmTransitVirtualInterfaceOutputError>
}

public struct ConfirmTransitVirtualInterfaceInputQueryItemMiddleware: Middleware {
    public let id: String = "ConfirmTransitVirtualInterfaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfirmTransitVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfirmTransitVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfirmTransitVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<ConfirmTransitVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfirmTransitVirtualInterfaceOutputError>
}

public struct ConfirmTransitVirtualInterfaceInput: Equatable {
    /// <p>The ID of the Direct Connect gateway.</p>
    public let directConnectGatewayId: String?
    /// <p>The ID of the virtual interface.</p>
    public let virtualInterfaceId: String?

    public init (
        directConnectGatewayId: String? = nil,
        virtualInterfaceId: String? = nil
    )
    {
        self.directConnectGatewayId = directConnectGatewayId
        self.virtualInterfaceId = virtualInterfaceId
    }
}

struct ConfirmTransitVirtualInterfaceInputBody: Equatable {
    public let virtualInterfaceId: String?
    public let directConnectGatewayId: String?
}

extension ConfirmTransitVirtualInterfaceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directConnectGatewayId
        case virtualInterfaceId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
    }
}

extension ConfirmTransitVirtualInterfaceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ConfirmTransitVirtualInterfaceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ConfirmTransitVirtualInterfaceOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ConfirmTransitVirtualInterfaceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfirmTransitVirtualInterfaceOutputResponse(virtualInterfaceState: \(String(describing: virtualInterfaceState)))"}
}

extension ConfirmTransitVirtualInterfaceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConfirmTransitVirtualInterfaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.virtualInterfaceState = output.virtualInterfaceState
        } else {
            self.virtualInterfaceState = nil
        }
    }
}

public struct ConfirmTransitVirtualInterfaceOutputResponse: Equatable {
    /// <p>The state of the virtual interface. The following are the possible values:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>confirming</code>: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>verifying</code>: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>available</code>: A virtual interface that is able to forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>down</code>: A virtual interface that is BGP down.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>: A virtual interface is in this state immediately after calling <a>DeleteVirtualInterface</a> until it can no longer forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>: A virtual interface that cannot forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>rejected</code>: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the <code>Confirming</code> state is deleted by the virtual interface owner, the virtual interface enters the <code>Rejected</code> state.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>unknown</code>: The state of the virtual interface is not available.</p>
    ///             </li>
    ///          </ul>
    public let virtualInterfaceState: VirtualInterfaceState?

    public init (
        virtualInterfaceState: VirtualInterfaceState? = nil
    )
    {
        self.virtualInterfaceState = virtualInterfaceState
    }
}

struct ConfirmTransitVirtualInterfaceOutputResponseBody: Equatable {
    public let virtualInterfaceState: VirtualInterfaceState?
}

extension ConfirmTransitVirtualInterfaceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualInterfaceState
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceStateDecoded = try containerValues.decodeIfPresent(VirtualInterfaceState.self, forKey: .virtualInterfaceState)
        virtualInterfaceState = virtualInterfaceStateDecoded
    }
}

extension Connection: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsDevice
        case awsDeviceV2
        case bandwidth
        case connectionId
        case connectionName
        case connectionState
        case encryptionMode
        case hasLogicalRedundancy
        case jumboFrameCapable
        case lagId
        case loaIssueTime
        case location
        case macSecCapable
        case macSecKeys
        case ownerAccount
        case partnerName
        case portEncryptionStatus
        case providerName
        case region
        case tags
        case vlan
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsDevice = awsDevice {
            try encodeContainer.encode(awsDevice, forKey: .awsDevice)
        }
        if let awsDeviceV2 = awsDeviceV2 {
            try encodeContainer.encode(awsDeviceV2, forKey: .awsDeviceV2)
        }
        if let bandwidth = bandwidth {
            try encodeContainer.encode(bandwidth, forKey: .bandwidth)
        }
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let connectionName = connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let connectionState = connectionState {
            try encodeContainer.encode(connectionState.rawValue, forKey: .connectionState)
        }
        if let encryptionMode = encryptionMode {
            try encodeContainer.encode(encryptionMode, forKey: .encryptionMode)
        }
        if let hasLogicalRedundancy = hasLogicalRedundancy {
            try encodeContainer.encode(hasLogicalRedundancy.rawValue, forKey: .hasLogicalRedundancy)
        }
        if let jumboFrameCapable = jumboFrameCapable {
            try encodeContainer.encode(jumboFrameCapable, forKey: .jumboFrameCapable)
        }
        if let lagId = lagId {
            try encodeContainer.encode(lagId, forKey: .lagId)
        }
        if let loaIssueTime = loaIssueTime {
            try encodeContainer.encode(loaIssueTime.timeIntervalSince1970, forKey: .loaIssueTime)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let macSecCapable = macSecCapable {
            try encodeContainer.encode(macSecCapable, forKey: .macSecCapable)
        }
        if let macSecKeys = macSecKeys {
            var macSecKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .macSecKeys)
            for macseckeylist0 in macSecKeys {
                try macSecKeysContainer.encode(macseckeylist0)
            }
        }
        if let ownerAccount = ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
        if let partnerName = partnerName {
            try encodeContainer.encode(partnerName, forKey: .partnerName)
        }
        if let portEncryptionStatus = portEncryptionStatus {
            try encodeContainer.encode(portEncryptionStatus, forKey: .portEncryptionStatus)
        }
        if let providerName = providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if vlan != 0 {
            try encodeContainer.encode(vlan, forKey: .vlan)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let vlanDecoded = try containerValues.decode(Int.self, forKey: .vlan)
        vlan = vlanDecoded
        let partnerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .partnerName)
        partnerName = partnerNameDecoded
        let loaIssueTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .loaIssueTime)
        loaIssueTime = loaIssueTimeDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let awsDeviceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDevice)
        awsDevice = awsDeviceDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let hasLogicalRedundancyDecoded = try containerValues.decodeIfPresent(HasLogicalRedundancy.self, forKey: .hasLogicalRedundancy)
        hasLogicalRedundancy = hasLogicalRedundancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let macSecCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .macSecCapable)
        macSecCapable = macSecCapableDecoded
        let portEncryptionStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portEncryptionStatus)
        portEncryptionStatus = portEncryptionStatusDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let macSecKeysContainer = try containerValues.decodeIfPresent([MacSecKey?].self, forKey: .macSecKeys)
        var macSecKeysDecoded0:[MacSecKey]? = nil
        if let macSecKeysContainer = macSecKeysContainer {
            macSecKeysDecoded0 = [MacSecKey]()
            for structure0 in macSecKeysContainer {
                if let structure0 = structure0 {
                    macSecKeysDecoded0?.append(structure0)
                }
            }
        }
        macSecKeys = macSecKeysDecoded0
    }
}

extension Connection: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Connection(awsDevice: \(String(describing: awsDevice)), awsDeviceV2: \(String(describing: awsDeviceV2)), bandwidth: \(String(describing: bandwidth)), connectionId: \(String(describing: connectionId)), connectionName: \(String(describing: connectionName)), connectionState: \(String(describing: connectionState)), encryptionMode: \(String(describing: encryptionMode)), hasLogicalRedundancy: \(String(describing: hasLogicalRedundancy)), jumboFrameCapable: \(String(describing: jumboFrameCapable)), lagId: \(String(describing: lagId)), loaIssueTime: \(String(describing: loaIssueTime)), location: \(String(describing: location)), macSecCapable: \(String(describing: macSecCapable)), macSecKeys: \(String(describing: macSecKeys)), ownerAccount: \(String(describing: ownerAccount)), partnerName: \(String(describing: partnerName)), portEncryptionStatus: \(String(describing: portEncryptionStatus)), providerName: \(String(describing: providerName)), region: \(String(describing: region)), tags: \(String(describing: tags)), vlan: \(String(describing: vlan)))"}
}

/// <p>Information about an AWS Direct Connect connection.</p>
public struct Connection: Equatable {
    /// <p>The Direct Connect endpoint on which the physical connection terminates.</p>
    @available(*, deprecated)
    public let awsDevice: String?
    /// <p>The Direct Connect endpoint on which the physical connection terminates.</p>
    public let awsDeviceV2: String?
    /// <p>The bandwidth of the connection.</p>
    public let bandwidth: String?
    /// <p>The ID of the connection.</p>
    public let connectionId: String?
    /// <p>The name of the connection.</p>
    public let connectionName: String?
    /// <p>The state of the connection. The following are the possible values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ordering</code>: The initial state of a hosted connection provisioned on an interconnect. The connection stays in the ordering state until the owner of the hosted connection confirms or declines the connection order.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>requested</code>: The initial state of a standard connection. The connection stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: The connection has been approved and is being initialized.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>available</code>: The network link is up and the connection is ready for use.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>down</code>: The network link is down.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>: The connection is being deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>: The connection has been deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>rejected</code>: A hosted connection in the <code>ordering</code> state enters the <code>rejected</code> state if it is deleted by the customer.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>unknown</code>: The state of the connection is not available.</p>
    ///             </li>
    ///          </ul>
    public let connectionState: ConnectionState?
    /// <p>The MAC Security (MACsec) connection encryption mode.</p>
    ///          <p>The valid values are <code>no_encrypt</code>, <code>should_encrypt</code>, and <code>must_encrypt</code>.</p>
    public let encryptionMode: String?
    /// <p>Indicates whether the connection supports a secondary BGP peer in the same address family (IPv4/IPv6).</p>
    public let hasLogicalRedundancy: HasLogicalRedundancy?
    /// <p>Indicates whether jumbo frames (9001 MTU) are supported.</p>
    public let jumboFrameCapable: Bool?
    /// <p>The ID of the LAG.</p>
    public let lagId: String?
    /// <p>The time of the most recent call to <a>DescribeLoa</a> for this connection.</p>
    public let loaIssueTime: Date?
    /// <p>The location of the connection.</p>
    public let location: String?
    /// <p>Indicates whether the connection supports MAC Security (MACsec).</p>
    public let macSecCapable: Bool?
    /// <p>The MAC Security (MACsec) security keys associated with the connection.</p>
    public let macSecKeys: [MacSecKey]?
    /// <p>The ID of the AWS account that owns the connection.</p>
    public let ownerAccount: String?
    /// <p>The name of the AWS Direct Connect service provider associated with the connection.</p>
    public let partnerName: String?
    /// <p>The MAC Security (MACsec) port link status of the connection.</p>
    ///          <p>The valid values are <code>Encryption Up</code>, which means that there is an active Connection Key Name, or <code>Encryption Down</code>.</p>
    public let portEncryptionStatus: String?
    /// <p>The name of the service provider associated with the connection.</p>
    public let providerName: String?
    /// <p>The AWS Region where the connection is located.</p>
    public let region: String?
    /// <p>The tags associated with the connection.</p>
    public let tags: [Tag]?
    /// <p>The ID of the VLAN.</p>
    public let vlan: Int

    public init (
        awsDevice: String? = nil,
        awsDeviceV2: String? = nil,
        bandwidth: String? = nil,
        connectionId: String? = nil,
        connectionName: String? = nil,
        connectionState: ConnectionState? = nil,
        encryptionMode: String? = nil,
        hasLogicalRedundancy: HasLogicalRedundancy? = nil,
        jumboFrameCapable: Bool? = nil,
        lagId: String? = nil,
        loaIssueTime: Date? = nil,
        location: String? = nil,
        macSecCapable: Bool? = nil,
        macSecKeys: [MacSecKey]? = nil,
        ownerAccount: String? = nil,
        partnerName: String? = nil,
        portEncryptionStatus: String? = nil,
        providerName: String? = nil,
        region: String? = nil,
        tags: [Tag]? = nil,
        vlan: Int = 0
    )
    {
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.bandwidth = bandwidth
        self.connectionId = connectionId
        self.connectionName = connectionName
        self.connectionState = connectionState
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.loaIssueTime = loaIssueTime
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.ownerAccount = ownerAccount
        self.partnerName = partnerName
        self.portEncryptionStatus = portEncryptionStatus
        self.providerName = providerName
        self.region = region
        self.tags = tags
        self.vlan = vlan
    }
}

public enum ConnectionState {
    case available
    case deleted
    case deleting
    case down
    case ordering
    case pending
    case rejected
    case requested
    case unknown
    case sdkUnknown(String)
}

extension ConnectionState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConnectionState] {
        return [
            .available,
            .deleted,
            .deleting,
            .down,
            .ordering,
            .pending,
            .rejected,
            .requested,
            .unknown,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "available"
        case .deleted: return "deleted"
        case .deleting: return "deleting"
        case .down: return "down"
        case .ordering: return "ordering"
        case .pending: return "pending"
        case .rejected: return "rejected"
        case .requested: return "requested"
        case .unknown: return "unknown"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConnectionState(rawValue: rawValue) ?? ConnectionState.sdkUnknown(rawValue)
    }
}

public struct CreateBGPPeerInputBodyMiddleware: Middleware {
    public let id: String = "CreateBGPPeerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBGPPeerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBGPPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBGPPeerInput>
    public typealias MOutput = OperationOutput<CreateBGPPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBGPPeerOutputError>
}

extension CreateBGPPeerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBGPPeerInput(newBGPPeer: \(String(describing: newBGPPeer)), virtualInterfaceId: \(String(describing: virtualInterfaceId)))"}
}

extension CreateBGPPeerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case newBGPPeer
        case virtualInterfaceId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let newBGPPeer = newBGPPeer {
            try encodeContainer.encode(newBGPPeer, forKey: .newBGPPeer)
        }
        if let virtualInterfaceId = virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
    }
}

public struct CreateBGPPeerInputHeadersMiddleware: Middleware {
    public let id: String = "CreateBGPPeerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBGPPeerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBGPPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBGPPeerInput>
    public typealias MOutput = OperationOutput<CreateBGPPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBGPPeerOutputError>
}

public struct CreateBGPPeerInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateBGPPeerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBGPPeerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBGPPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBGPPeerInput>
    public typealias MOutput = OperationOutput<CreateBGPPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBGPPeerOutputError>
}

public struct CreateBGPPeerInput: Equatable {
    /// <p>Information about the BGP peer.</p>
    public let newBGPPeer: NewBGPPeer?
    /// <p>The ID of the virtual interface.</p>
    public let virtualInterfaceId: String?

    public init (
        newBGPPeer: NewBGPPeer? = nil,
        virtualInterfaceId: String? = nil
    )
    {
        self.newBGPPeer = newBGPPeer
        self.virtualInterfaceId = virtualInterfaceId
    }
}

struct CreateBGPPeerInputBody: Equatable {
    public let virtualInterfaceId: String?
    public let newBGPPeer: NewBGPPeer?
}

extension CreateBGPPeerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case newBGPPeer
        case virtualInterfaceId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let newBGPPeerDecoded = try containerValues.decodeIfPresent(NewBGPPeer.self, forKey: .newBGPPeer)
        newBGPPeer = newBGPPeerDecoded
    }
}

extension CreateBGPPeerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBGPPeerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBGPPeerOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBGPPeerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBGPPeerOutputResponse(virtualInterface: \(String(describing: virtualInterface)))"}
}

extension CreateBGPPeerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateBGPPeerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.virtualInterface = output.virtualInterface
        } else {
            self.virtualInterface = nil
        }
    }
}

public struct CreateBGPPeerOutputResponse: Equatable {
    /// <p>The virtual interface.</p>
    public let virtualInterface: VirtualInterface?

    public init (
        virtualInterface: VirtualInterface? = nil
    )
    {
        self.virtualInterface = virtualInterface
    }
}

struct CreateBGPPeerOutputResponseBody: Equatable {
    public let virtualInterface: VirtualInterface?
}

extension CreateBGPPeerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualInterface
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceDecoded = try containerValues.decodeIfPresent(VirtualInterface.self, forKey: .virtualInterface)
        virtualInterface = virtualInterfaceDecoded
    }
}

public struct CreateConnectionInputBodyMiddleware: Middleware {
    public let id: String = "CreateConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConnectionOutputError>
}

extension CreateConnectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConnectionInput(bandwidth: \(String(describing: bandwidth)), connectionName: \(String(describing: connectionName)), lagId: \(String(describing: lagId)), location: \(String(describing: location)), providerName: \(String(describing: providerName)), requestMACSec: \(String(describing: requestMACSec)), tags: \(String(describing: tags)))"}
}

extension CreateConnectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bandwidth
        case connectionName
        case lagId
        case location
        case providerName
        case requestMACSec
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidth = bandwidth {
            try encodeContainer.encode(bandwidth, forKey: .bandwidth)
        }
        if let connectionName = connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let lagId = lagId {
            try encodeContainer.encode(lagId, forKey: .lagId)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let providerName = providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if let requestMACSec = requestMACSec {
            try encodeContainer.encode(requestMACSec, forKey: .requestMACSec)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateConnectionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConnectionOutputError>
}

public struct CreateConnectionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConnectionOutputError>
}

public struct CreateConnectionInput: Equatable {
    /// <p>The bandwidth of the connection.</p>
    public let bandwidth: String?
    /// <p>The name of the connection.</p>
    public let connectionName: String?
    /// <p>The ID of the LAG.</p>
    public let lagId: String?
    /// <p>The location of the connection.</p>
    public let location: String?
    /// <p>The name of the service provider associated with the requested connection.</p>
    public let providerName: String?
    /// <p>Indicates whether you want the connection to support MAC Security (MACsec).</p>
    ///          <p>MAC Security (MACsec) is only available on dedicated connections. For information about MAC Security (MACsec) prerequisties, see  <a href="https://docs.aws.amazon.com/directconnect/latest/UserGuide/direct-connect-mac-sec-getting-started.html#mac-sec-prerequisites">MACsec prerequisties</a> in the <i>AWS Direct Connect User Guide</i>.</p>
    public let requestMACSec: Bool?
    /// <p>The tags to associate with the lag.</p>
    public let tags: [Tag]?

    public init (
        bandwidth: String? = nil,
        connectionName: String? = nil,
        lagId: String? = nil,
        location: String? = nil,
        providerName: String? = nil,
        requestMACSec: Bool? = nil,
        tags: [Tag]? = nil
    )
    {
        self.bandwidth = bandwidth
        self.connectionName = connectionName
        self.lagId = lagId
        self.location = location
        self.providerName = providerName
        self.requestMACSec = requestMACSec
        self.tags = tags
    }
}

struct CreateConnectionInputBody: Equatable {
    public let location: String?
    public let bandwidth: String?
    public let connectionName: String?
    public let lagId: String?
    public let tags: [Tag]?
    public let providerName: String?
    public let requestMACSec: Bool?
}

extension CreateConnectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bandwidth
        case connectionName
        case lagId
        case location
        case providerName
        case requestMACSec
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let connectionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let requestMACSecDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .requestMACSec)
        requestMACSec = requestMACSecDecoded
    }
}

extension CreateConnectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateTagKeysException" : self = .duplicateTagKeysException(try DuplicateTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConnectionOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case duplicateTagKeysException(DuplicateTagKeysException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConnectionOutputResponse(awsDevice: \(String(describing: awsDevice)), awsDeviceV2: \(String(describing: awsDeviceV2)), bandwidth: \(String(describing: bandwidth)), connectionId: \(String(describing: connectionId)), connectionName: \(String(describing: connectionName)), connectionState: \(String(describing: connectionState)), encryptionMode: \(String(describing: encryptionMode)), hasLogicalRedundancy: \(String(describing: hasLogicalRedundancy)), jumboFrameCapable: \(String(describing: jumboFrameCapable)), lagId: \(String(describing: lagId)), loaIssueTime: \(String(describing: loaIssueTime)), location: \(String(describing: location)), macSecCapable: \(String(describing: macSecCapable)), macSecKeys: \(String(describing: macSecKeys)), ownerAccount: \(String(describing: ownerAccount)), partnerName: \(String(describing: partnerName)), portEncryptionStatus: \(String(describing: portEncryptionStatus)), providerName: \(String(describing: providerName)), region: \(String(describing: region)), tags: \(String(describing: tags)), vlan: \(String(describing: vlan)))"}
}

extension CreateConnectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.awsDevice = output.awsDevice
            self.awsDeviceV2 = output.awsDeviceV2
            self.bandwidth = output.bandwidth
            self.connectionId = output.connectionId
            self.connectionName = output.connectionName
            self.connectionState = output.connectionState
            self.encryptionMode = output.encryptionMode
            self.hasLogicalRedundancy = output.hasLogicalRedundancy
            self.jumboFrameCapable = output.jumboFrameCapable
            self.lagId = output.lagId
            self.loaIssueTime = output.loaIssueTime
            self.location = output.location
            self.macSecCapable = output.macSecCapable
            self.macSecKeys = output.macSecKeys
            self.ownerAccount = output.ownerAccount
            self.partnerName = output.partnerName
            self.portEncryptionStatus = output.portEncryptionStatus
            self.providerName = output.providerName
            self.region = output.region
            self.tags = output.tags
            self.vlan = output.vlan
        } else {
            self.awsDevice = nil
            self.awsDeviceV2 = nil
            self.bandwidth = nil
            self.connectionId = nil
            self.connectionName = nil
            self.connectionState = nil
            self.encryptionMode = nil
            self.hasLogicalRedundancy = nil
            self.jumboFrameCapable = nil
            self.lagId = nil
            self.loaIssueTime = nil
            self.location = nil
            self.macSecCapable = nil
            self.macSecKeys = nil
            self.ownerAccount = nil
            self.partnerName = nil
            self.portEncryptionStatus = nil
            self.providerName = nil
            self.region = nil
            self.tags = nil
            self.vlan = 0
        }
    }
}

/// <p>Information about an AWS Direct Connect connection.</p>
public struct CreateConnectionOutputResponse: Equatable {
    /// <p>The Direct Connect endpoint on which the physical connection terminates.</p>
    @available(*, deprecated)
    public let awsDevice: String?
    /// <p>The Direct Connect endpoint on which the physical connection terminates.</p>
    public let awsDeviceV2: String?
    /// <p>The bandwidth of the connection.</p>
    public let bandwidth: String?
    /// <p>The ID of the connection.</p>
    public let connectionId: String?
    /// <p>The name of the connection.</p>
    public let connectionName: String?
    /// <p>The state of the connection. The following are the possible values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ordering</code>: The initial state of a hosted connection provisioned on an interconnect. The connection stays in the ordering state until the owner of the hosted connection confirms or declines the connection order.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>requested</code>: The initial state of a standard connection. The connection stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: The connection has been approved and is being initialized.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>available</code>: The network link is up and the connection is ready for use.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>down</code>: The network link is down.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>: The connection is being deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>: The connection has been deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>rejected</code>: A hosted connection in the <code>ordering</code> state enters the <code>rejected</code> state if it is deleted by the customer.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>unknown</code>: The state of the connection is not available.</p>
    ///             </li>
    ///          </ul>
    public let connectionState: ConnectionState?
    /// <p>The MAC Security (MACsec) connection encryption mode.</p>
    ///          <p>The valid values are <code>no_encrypt</code>, <code>should_encrypt</code>, and <code>must_encrypt</code>.</p>
    public let encryptionMode: String?
    /// <p>Indicates whether the connection supports a secondary BGP peer in the same address family (IPv4/IPv6).</p>
    public let hasLogicalRedundancy: HasLogicalRedundancy?
    /// <p>Indicates whether jumbo frames (9001 MTU) are supported.</p>
    public let jumboFrameCapable: Bool?
    /// <p>The ID of the LAG.</p>
    public let lagId: String?
    /// <p>The time of the most recent call to <a>DescribeLoa</a> for this connection.</p>
    public let loaIssueTime: Date?
    /// <p>The location of the connection.</p>
    public let location: String?
    /// <p>Indicates whether the connection supports MAC Security (MACsec).</p>
    public let macSecCapable: Bool?
    /// <p>The MAC Security (MACsec) security keys associated with the connection.</p>
    public let macSecKeys: [MacSecKey]?
    /// <p>The ID of the AWS account that owns the connection.</p>
    public let ownerAccount: String?
    /// <p>The name of the AWS Direct Connect service provider associated with the connection.</p>
    public let partnerName: String?
    /// <p>The MAC Security (MACsec) port link status of the connection.</p>
    ///          <p>The valid values are <code>Encryption Up</code>, which means that there is an active Connection Key Name, or <code>Encryption Down</code>.</p>
    public let portEncryptionStatus: String?
    /// <p>The name of the service provider associated with the connection.</p>
    public let providerName: String?
    /// <p>The AWS Region where the connection is located.</p>
    public let region: String?
    /// <p>The tags associated with the connection.</p>
    public let tags: [Tag]?
    /// <p>The ID of the VLAN.</p>
    public let vlan: Int

    public init (
        awsDevice: String? = nil,
        awsDeviceV2: String? = nil,
        bandwidth: String? = nil,
        connectionId: String? = nil,
        connectionName: String? = nil,
        connectionState: ConnectionState? = nil,
        encryptionMode: String? = nil,
        hasLogicalRedundancy: HasLogicalRedundancy? = nil,
        jumboFrameCapable: Bool? = nil,
        lagId: String? = nil,
        loaIssueTime: Date? = nil,
        location: String? = nil,
        macSecCapable: Bool? = nil,
        macSecKeys: [MacSecKey]? = nil,
        ownerAccount: String? = nil,
        partnerName: String? = nil,
        portEncryptionStatus: String? = nil,
        providerName: String? = nil,
        region: String? = nil,
        tags: [Tag]? = nil,
        vlan: Int = 0
    )
    {
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.bandwidth = bandwidth
        self.connectionId = connectionId
        self.connectionName = connectionName
        self.connectionState = connectionState
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.loaIssueTime = loaIssueTime
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.ownerAccount = ownerAccount
        self.partnerName = partnerName
        self.portEncryptionStatus = portEncryptionStatus
        self.providerName = providerName
        self.region = region
        self.tags = tags
        self.vlan = vlan
    }
}

struct CreateConnectionOutputResponseBody: Equatable {
    public let ownerAccount: String?
    public let connectionId: String?
    public let connectionName: String?
    public let connectionState: ConnectionState?
    public let region: String?
    public let location: String?
    public let bandwidth: String?
    public let vlan: Int
    public let partnerName: String?
    public let loaIssueTime: Date?
    public let lagId: String?
    public let awsDevice: String?
    public let jumboFrameCapable: Bool?
    public let awsDeviceV2: String?
    public let hasLogicalRedundancy: HasLogicalRedundancy?
    public let tags: [Tag]?
    public let providerName: String?
    public let macSecCapable: Bool?
    public let portEncryptionStatus: String?
    public let encryptionMode: String?
    public let macSecKeys: [MacSecKey]?
}

extension CreateConnectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case awsDevice
        case awsDeviceV2
        case bandwidth
        case connectionId
        case connectionName
        case connectionState
        case encryptionMode
        case hasLogicalRedundancy
        case jumboFrameCapable
        case lagId
        case loaIssueTime
        case location
        case macSecCapable
        case macSecKeys
        case ownerAccount
        case partnerName
        case portEncryptionStatus
        case providerName
        case region
        case tags
        case vlan
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let vlanDecoded = try containerValues.decode(Int.self, forKey: .vlan)
        vlan = vlanDecoded
        let partnerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .partnerName)
        partnerName = partnerNameDecoded
        let loaIssueTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .loaIssueTime)
        loaIssueTime = loaIssueTimeDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let awsDeviceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDevice)
        awsDevice = awsDeviceDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let hasLogicalRedundancyDecoded = try containerValues.decodeIfPresent(HasLogicalRedundancy.self, forKey: .hasLogicalRedundancy)
        hasLogicalRedundancy = hasLogicalRedundancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let macSecCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .macSecCapable)
        macSecCapable = macSecCapableDecoded
        let portEncryptionStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portEncryptionStatus)
        portEncryptionStatus = portEncryptionStatusDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let macSecKeysContainer = try containerValues.decodeIfPresent([MacSecKey?].self, forKey: .macSecKeys)
        var macSecKeysDecoded0:[MacSecKey]? = nil
        if let macSecKeysContainer = macSecKeysContainer {
            macSecKeysDecoded0 = [MacSecKey]()
            for structure0 in macSecKeysContainer {
                if let structure0 = structure0 {
                    macSecKeysDecoded0?.append(structure0)
                }
            }
        }
        macSecKeys = macSecKeysDecoded0
    }
}

public struct CreateDirectConnectGatewayAssociationInputBodyMiddleware: Middleware {
    public let id: String = "CreateDirectConnectGatewayAssociationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDirectConnectGatewayAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDirectConnectGatewayAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDirectConnectGatewayAssociationInput>
    public typealias MOutput = OperationOutput<CreateDirectConnectGatewayAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDirectConnectGatewayAssociationOutputError>
}

extension CreateDirectConnectGatewayAssociationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDirectConnectGatewayAssociationInput(addAllowedPrefixesToDirectConnectGateway: \(String(describing: addAllowedPrefixesToDirectConnectGateway)), directConnectGatewayId: \(String(describing: directConnectGatewayId)), gatewayId: \(String(describing: gatewayId)), virtualGatewayId: \(String(describing: virtualGatewayId)))"}
}

extension CreateDirectConnectGatewayAssociationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addAllowedPrefixesToDirectConnectGateway
        case directConnectGatewayId
        case gatewayId
        case virtualGatewayId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addAllowedPrefixesToDirectConnectGateway = addAllowedPrefixesToDirectConnectGateway {
            var addAllowedPrefixesToDirectConnectGatewayContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addAllowedPrefixesToDirectConnectGateway)
            for routefilterprefixlist0 in addAllowedPrefixesToDirectConnectGateway {
                try addAllowedPrefixesToDirectConnectGatewayContainer.encode(routefilterprefixlist0)
            }
        }
        if let directConnectGatewayId = directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let gatewayId = gatewayId {
            try encodeContainer.encode(gatewayId, forKey: .gatewayId)
        }
        if let virtualGatewayId = virtualGatewayId {
            try encodeContainer.encode(virtualGatewayId, forKey: .virtualGatewayId)
        }
    }
}

public struct CreateDirectConnectGatewayAssociationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDirectConnectGatewayAssociationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDirectConnectGatewayAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDirectConnectGatewayAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDirectConnectGatewayAssociationInput>
    public typealias MOutput = OperationOutput<CreateDirectConnectGatewayAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDirectConnectGatewayAssociationOutputError>
}

public struct CreateDirectConnectGatewayAssociationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDirectConnectGatewayAssociationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDirectConnectGatewayAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDirectConnectGatewayAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDirectConnectGatewayAssociationInput>
    public typealias MOutput = OperationOutput<CreateDirectConnectGatewayAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDirectConnectGatewayAssociationOutputError>
}

public struct CreateDirectConnectGatewayAssociationInput: Equatable {
    /// <p>The Amazon VPC prefixes to advertise to the Direct Connect gateway</p>
    ///          <p>This parameter is required when you create an association to a transit gateway.</p>
    ///          <p>For information about how to set the prefixes, see <a href="https://docs.aws.amazon.com/directconnect/latest/UserGuide/multi-account-associate-vgw.html#allowed-prefixes">Allowed Prefixes</a> in the <i>AWS Direct Connect User Guide</i>.</p>
    public let addAllowedPrefixesToDirectConnectGateway: [RouteFilterPrefix]?
    /// <p>The ID of the Direct Connect gateway.</p>
    public let directConnectGatewayId: String?
    /// <p>The ID of the virtual private gateway or transit gateway.</p>
    public let gatewayId: String?
    /// <p>The ID of the virtual private gateway.</p>
    public let virtualGatewayId: String?

    public init (
        addAllowedPrefixesToDirectConnectGateway: [RouteFilterPrefix]? = nil,
        directConnectGatewayId: String? = nil,
        gatewayId: String? = nil,
        virtualGatewayId: String? = nil
    )
    {
        self.addAllowedPrefixesToDirectConnectGateway = addAllowedPrefixesToDirectConnectGateway
        self.directConnectGatewayId = directConnectGatewayId
        self.gatewayId = gatewayId
        self.virtualGatewayId = virtualGatewayId
    }
}

struct CreateDirectConnectGatewayAssociationInputBody: Equatable {
    public let directConnectGatewayId: String?
    public let gatewayId: String?
    public let addAllowedPrefixesToDirectConnectGateway: [RouteFilterPrefix]?
    public let virtualGatewayId: String?
}

extension CreateDirectConnectGatewayAssociationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case addAllowedPrefixesToDirectConnectGateway
        case directConnectGatewayId
        case gatewayId
        case virtualGatewayId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let gatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let addAllowedPrefixesToDirectConnectGatewayContainer = try containerValues.decodeIfPresent([RouteFilterPrefix?].self, forKey: .addAllowedPrefixesToDirectConnectGateway)
        var addAllowedPrefixesToDirectConnectGatewayDecoded0:[RouteFilterPrefix]? = nil
        if let addAllowedPrefixesToDirectConnectGatewayContainer = addAllowedPrefixesToDirectConnectGatewayContainer {
            addAllowedPrefixesToDirectConnectGatewayDecoded0 = [RouteFilterPrefix]()
            for structure0 in addAllowedPrefixesToDirectConnectGatewayContainer {
                if let structure0 = structure0 {
                    addAllowedPrefixesToDirectConnectGatewayDecoded0?.append(structure0)
                }
            }
        }
        addAllowedPrefixesToDirectConnectGateway = addAllowedPrefixesToDirectConnectGatewayDecoded0
        let virtualGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualGatewayId)
        virtualGatewayId = virtualGatewayIdDecoded
    }
}

extension CreateDirectConnectGatewayAssociationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDirectConnectGatewayAssociationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDirectConnectGatewayAssociationOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDirectConnectGatewayAssociationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDirectConnectGatewayAssociationOutputResponse(directConnectGatewayAssociation: \(String(describing: directConnectGatewayAssociation)))"}
}

extension CreateDirectConnectGatewayAssociationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDirectConnectGatewayAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directConnectGatewayAssociation = output.directConnectGatewayAssociation
        } else {
            self.directConnectGatewayAssociation = nil
        }
    }
}

public struct CreateDirectConnectGatewayAssociationOutputResponse: Equatable {
    /// <p>The association to be created.</p>
    public let directConnectGatewayAssociation: DirectConnectGatewayAssociation?

    public init (
        directConnectGatewayAssociation: DirectConnectGatewayAssociation? = nil
    )
    {
        self.directConnectGatewayAssociation = directConnectGatewayAssociation
    }
}

struct CreateDirectConnectGatewayAssociationOutputResponseBody: Equatable {
    public let directConnectGatewayAssociation: DirectConnectGatewayAssociation?
}

extension CreateDirectConnectGatewayAssociationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directConnectGatewayAssociation
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayAssociationDecoded = try containerValues.decodeIfPresent(DirectConnectGatewayAssociation.self, forKey: .directConnectGatewayAssociation)
        directConnectGatewayAssociation = directConnectGatewayAssociationDecoded
    }
}

public struct CreateDirectConnectGatewayAssociationProposalInputBodyMiddleware: Middleware {
    public let id: String = "CreateDirectConnectGatewayAssociationProposalInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDirectConnectGatewayAssociationProposalInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDirectConnectGatewayAssociationProposalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDirectConnectGatewayAssociationProposalInput>
    public typealias MOutput = OperationOutput<CreateDirectConnectGatewayAssociationProposalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDirectConnectGatewayAssociationProposalOutputError>
}

extension CreateDirectConnectGatewayAssociationProposalInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDirectConnectGatewayAssociationProposalInput(addAllowedPrefixesToDirectConnectGateway: \(String(describing: addAllowedPrefixesToDirectConnectGateway)), directConnectGatewayId: \(String(describing: directConnectGatewayId)), directConnectGatewayOwnerAccount: \(String(describing: directConnectGatewayOwnerAccount)), gatewayId: \(String(describing: gatewayId)), removeAllowedPrefixesToDirectConnectGateway: \(String(describing: removeAllowedPrefixesToDirectConnectGateway)))"}
}

extension CreateDirectConnectGatewayAssociationProposalInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addAllowedPrefixesToDirectConnectGateway
        case directConnectGatewayId
        case directConnectGatewayOwnerAccount
        case gatewayId
        case removeAllowedPrefixesToDirectConnectGateway
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addAllowedPrefixesToDirectConnectGateway = addAllowedPrefixesToDirectConnectGateway {
            var addAllowedPrefixesToDirectConnectGatewayContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addAllowedPrefixesToDirectConnectGateway)
            for routefilterprefixlist0 in addAllowedPrefixesToDirectConnectGateway {
                try addAllowedPrefixesToDirectConnectGatewayContainer.encode(routefilterprefixlist0)
            }
        }
        if let directConnectGatewayId = directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let directConnectGatewayOwnerAccount = directConnectGatewayOwnerAccount {
            try encodeContainer.encode(directConnectGatewayOwnerAccount, forKey: .directConnectGatewayOwnerAccount)
        }
        if let gatewayId = gatewayId {
            try encodeContainer.encode(gatewayId, forKey: .gatewayId)
        }
        if let removeAllowedPrefixesToDirectConnectGateway = removeAllowedPrefixesToDirectConnectGateway {
            var removeAllowedPrefixesToDirectConnectGatewayContainer = encodeContainer.nestedUnkeyedContainer(forKey: .removeAllowedPrefixesToDirectConnectGateway)
            for routefilterprefixlist0 in removeAllowedPrefixesToDirectConnectGateway {
                try removeAllowedPrefixesToDirectConnectGatewayContainer.encode(routefilterprefixlist0)
            }
        }
    }
}

public struct CreateDirectConnectGatewayAssociationProposalInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDirectConnectGatewayAssociationProposalInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDirectConnectGatewayAssociationProposalInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDirectConnectGatewayAssociationProposalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDirectConnectGatewayAssociationProposalInput>
    public typealias MOutput = OperationOutput<CreateDirectConnectGatewayAssociationProposalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDirectConnectGatewayAssociationProposalOutputError>
}

public struct CreateDirectConnectGatewayAssociationProposalInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDirectConnectGatewayAssociationProposalInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDirectConnectGatewayAssociationProposalInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDirectConnectGatewayAssociationProposalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDirectConnectGatewayAssociationProposalInput>
    public typealias MOutput = OperationOutput<CreateDirectConnectGatewayAssociationProposalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDirectConnectGatewayAssociationProposalOutputError>
}

public struct CreateDirectConnectGatewayAssociationProposalInput: Equatable {
    /// <p>The Amazon VPC prefixes to advertise to the Direct Connect gateway.</p>
    public let addAllowedPrefixesToDirectConnectGateway: [RouteFilterPrefix]?
    /// <p>The ID of the Direct Connect gateway.</p>
    public let directConnectGatewayId: String?
    /// <p>The ID of the AWS account that owns the Direct Connect gateway.</p>
    public let directConnectGatewayOwnerAccount: String?
    /// <p>The ID of the virtual private gateway or transit gateway.</p>
    public let gatewayId: String?
    /// <p>The Amazon VPC prefixes to no longer advertise to the Direct Connect gateway.</p>
    public let removeAllowedPrefixesToDirectConnectGateway: [RouteFilterPrefix]?

    public init (
        addAllowedPrefixesToDirectConnectGateway: [RouteFilterPrefix]? = nil,
        directConnectGatewayId: String? = nil,
        directConnectGatewayOwnerAccount: String? = nil,
        gatewayId: String? = nil,
        removeAllowedPrefixesToDirectConnectGateway: [RouteFilterPrefix]? = nil
    )
    {
        self.addAllowedPrefixesToDirectConnectGateway = addAllowedPrefixesToDirectConnectGateway
        self.directConnectGatewayId = directConnectGatewayId
        self.directConnectGatewayOwnerAccount = directConnectGatewayOwnerAccount
        self.gatewayId = gatewayId
        self.removeAllowedPrefixesToDirectConnectGateway = removeAllowedPrefixesToDirectConnectGateway
    }
}

struct CreateDirectConnectGatewayAssociationProposalInputBody: Equatable {
    public let directConnectGatewayId: String?
    public let directConnectGatewayOwnerAccount: String?
    public let gatewayId: String?
    public let addAllowedPrefixesToDirectConnectGateway: [RouteFilterPrefix]?
    public let removeAllowedPrefixesToDirectConnectGateway: [RouteFilterPrefix]?
}

extension CreateDirectConnectGatewayAssociationProposalInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case addAllowedPrefixesToDirectConnectGateway
        case directConnectGatewayId
        case directConnectGatewayOwnerAccount
        case gatewayId
        case removeAllowedPrefixesToDirectConnectGateway
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let directConnectGatewayOwnerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directConnectGatewayOwnerAccount)
        directConnectGatewayOwnerAccount = directConnectGatewayOwnerAccountDecoded
        let gatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let addAllowedPrefixesToDirectConnectGatewayContainer = try containerValues.decodeIfPresent([RouteFilterPrefix?].self, forKey: .addAllowedPrefixesToDirectConnectGateway)
        var addAllowedPrefixesToDirectConnectGatewayDecoded0:[RouteFilterPrefix]? = nil
        if let addAllowedPrefixesToDirectConnectGatewayContainer = addAllowedPrefixesToDirectConnectGatewayContainer {
            addAllowedPrefixesToDirectConnectGatewayDecoded0 = [RouteFilterPrefix]()
            for structure0 in addAllowedPrefixesToDirectConnectGatewayContainer {
                if let structure0 = structure0 {
                    addAllowedPrefixesToDirectConnectGatewayDecoded0?.append(structure0)
                }
            }
        }
        addAllowedPrefixesToDirectConnectGateway = addAllowedPrefixesToDirectConnectGatewayDecoded0
        let removeAllowedPrefixesToDirectConnectGatewayContainer = try containerValues.decodeIfPresent([RouteFilterPrefix?].self, forKey: .removeAllowedPrefixesToDirectConnectGateway)
        var removeAllowedPrefixesToDirectConnectGatewayDecoded0:[RouteFilterPrefix]? = nil
        if let removeAllowedPrefixesToDirectConnectGatewayContainer = removeAllowedPrefixesToDirectConnectGatewayContainer {
            removeAllowedPrefixesToDirectConnectGatewayDecoded0 = [RouteFilterPrefix]()
            for structure0 in removeAllowedPrefixesToDirectConnectGatewayContainer {
                if let structure0 = structure0 {
                    removeAllowedPrefixesToDirectConnectGatewayDecoded0?.append(structure0)
                }
            }
        }
        removeAllowedPrefixesToDirectConnectGateway = removeAllowedPrefixesToDirectConnectGatewayDecoded0
    }
}

extension CreateDirectConnectGatewayAssociationProposalOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDirectConnectGatewayAssociationProposalOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDirectConnectGatewayAssociationProposalOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDirectConnectGatewayAssociationProposalOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDirectConnectGatewayAssociationProposalOutputResponse(directConnectGatewayAssociationProposal: \(String(describing: directConnectGatewayAssociationProposal)))"}
}

extension CreateDirectConnectGatewayAssociationProposalOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDirectConnectGatewayAssociationProposalOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directConnectGatewayAssociationProposal = output.directConnectGatewayAssociationProposal
        } else {
            self.directConnectGatewayAssociationProposal = nil
        }
    }
}

public struct CreateDirectConnectGatewayAssociationProposalOutputResponse: Equatable {
    /// <p>Information about the Direct Connect gateway proposal.</p>
    public let directConnectGatewayAssociationProposal: DirectConnectGatewayAssociationProposal?

    public init (
        directConnectGatewayAssociationProposal: DirectConnectGatewayAssociationProposal? = nil
    )
    {
        self.directConnectGatewayAssociationProposal = directConnectGatewayAssociationProposal
    }
}

struct CreateDirectConnectGatewayAssociationProposalOutputResponseBody: Equatable {
    public let directConnectGatewayAssociationProposal: DirectConnectGatewayAssociationProposal?
}

extension CreateDirectConnectGatewayAssociationProposalOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directConnectGatewayAssociationProposal
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayAssociationProposalDecoded = try containerValues.decodeIfPresent(DirectConnectGatewayAssociationProposal.self, forKey: .directConnectGatewayAssociationProposal)
        directConnectGatewayAssociationProposal = directConnectGatewayAssociationProposalDecoded
    }
}

public struct CreateDirectConnectGatewayInputBodyMiddleware: Middleware {
    public let id: String = "CreateDirectConnectGatewayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDirectConnectGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDirectConnectGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDirectConnectGatewayInput>
    public typealias MOutput = OperationOutput<CreateDirectConnectGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDirectConnectGatewayOutputError>
}

extension CreateDirectConnectGatewayInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDirectConnectGatewayInput(amazonSideAsn: \(String(describing: amazonSideAsn)), directConnectGatewayName: \(String(describing: directConnectGatewayName)))"}
}

extension CreateDirectConnectGatewayInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amazonSideAsn
        case directConnectGatewayName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonSideAsn = amazonSideAsn {
            try encodeContainer.encode(amazonSideAsn, forKey: .amazonSideAsn)
        }
        if let directConnectGatewayName = directConnectGatewayName {
            try encodeContainer.encode(directConnectGatewayName, forKey: .directConnectGatewayName)
        }
    }
}

public struct CreateDirectConnectGatewayInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDirectConnectGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDirectConnectGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDirectConnectGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDirectConnectGatewayInput>
    public typealias MOutput = OperationOutput<CreateDirectConnectGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDirectConnectGatewayOutputError>
}

public struct CreateDirectConnectGatewayInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDirectConnectGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDirectConnectGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDirectConnectGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDirectConnectGatewayInput>
    public typealias MOutput = OperationOutput<CreateDirectConnectGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDirectConnectGatewayOutputError>
}

public struct CreateDirectConnectGatewayInput: Equatable {
    /// <p>The autonomous system number (ASN) for Border Gateway Protocol (BGP) to be configured
    ///       on the Amazon side of the connection. The ASN must be in the private range of 64,512 to
    ///       65,534 or 4,200,000,000 to 4,294,967,294. The default is 64512.</p>
    public let amazonSideAsn: Int?
    /// <p>The name of the Direct Connect gateway.</p>
    public let directConnectGatewayName: String?

    public init (
        amazonSideAsn: Int? = nil,
        directConnectGatewayName: String? = nil
    )
    {
        self.amazonSideAsn = amazonSideAsn
        self.directConnectGatewayName = directConnectGatewayName
    }
}

struct CreateDirectConnectGatewayInputBody: Equatable {
    public let directConnectGatewayName: String?
    public let amazonSideAsn: Int?
}

extension CreateDirectConnectGatewayInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case amazonSideAsn
        case directConnectGatewayName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directConnectGatewayName)
        directConnectGatewayName = directConnectGatewayNameDecoded
        let amazonSideAsnDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .amazonSideAsn)
        amazonSideAsn = amazonSideAsnDecoded
    }
}

extension CreateDirectConnectGatewayOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDirectConnectGatewayOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDirectConnectGatewayOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDirectConnectGatewayOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDirectConnectGatewayOutputResponse(directConnectGateway: \(String(describing: directConnectGateway)))"}
}

extension CreateDirectConnectGatewayOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDirectConnectGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directConnectGateway = output.directConnectGateway
        } else {
            self.directConnectGateway = nil
        }
    }
}

public struct CreateDirectConnectGatewayOutputResponse: Equatable {
    /// <p>The Direct Connect gateway.</p>
    public let directConnectGateway: DirectConnectGateway?

    public init (
        directConnectGateway: DirectConnectGateway? = nil
    )
    {
        self.directConnectGateway = directConnectGateway
    }
}

struct CreateDirectConnectGatewayOutputResponseBody: Equatable {
    public let directConnectGateway: DirectConnectGateway?
}

extension CreateDirectConnectGatewayOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directConnectGateway
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayDecoded = try containerValues.decodeIfPresent(DirectConnectGateway.self, forKey: .directConnectGateway)
        directConnectGateway = directConnectGatewayDecoded
    }
}

public struct CreateInterconnectInputBodyMiddleware: Middleware {
    public let id: String = "CreateInterconnectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInterconnectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInterconnectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInterconnectInput>
    public typealias MOutput = OperationOutput<CreateInterconnectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInterconnectOutputError>
}

extension CreateInterconnectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateInterconnectInput(bandwidth: \(String(describing: bandwidth)), interconnectName: \(String(describing: interconnectName)), lagId: \(String(describing: lagId)), location: \(String(describing: location)), providerName: \(String(describing: providerName)), tags: \(String(describing: tags)))"}
}

extension CreateInterconnectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bandwidth
        case interconnectName
        case lagId
        case location
        case providerName
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidth = bandwidth {
            try encodeContainer.encode(bandwidth, forKey: .bandwidth)
        }
        if let interconnectName = interconnectName {
            try encodeContainer.encode(interconnectName, forKey: .interconnectName)
        }
        if let lagId = lagId {
            try encodeContainer.encode(lagId, forKey: .lagId)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let providerName = providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateInterconnectInputHeadersMiddleware: Middleware {
    public let id: String = "CreateInterconnectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInterconnectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInterconnectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInterconnectInput>
    public typealias MOutput = OperationOutput<CreateInterconnectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInterconnectOutputError>
}

public struct CreateInterconnectInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateInterconnectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInterconnectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInterconnectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInterconnectInput>
    public typealias MOutput = OperationOutput<CreateInterconnectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInterconnectOutputError>
}

public struct CreateInterconnectInput: Equatable {
    /// <p>The port bandwidth, in Gbps. The possible values are 1 and 10.</p>
    public let bandwidth: String?
    /// <p>The name of the interconnect.</p>
    public let interconnectName: String?
    /// <p>The ID of the LAG.</p>
    public let lagId: String?
    /// <p>The location of the interconnect.</p>
    public let location: String?
    /// <p>The name of the service provider associated with the interconnect.</p>
    public let providerName: String?
    /// <p>The tags to associate with the interconnect.</p>
    public let tags: [Tag]?

    public init (
        bandwidth: String? = nil,
        interconnectName: String? = nil,
        lagId: String? = nil,
        location: String? = nil,
        providerName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.bandwidth = bandwidth
        self.interconnectName = interconnectName
        self.lagId = lagId
        self.location = location
        self.providerName = providerName
        self.tags = tags
    }
}

struct CreateInterconnectInputBody: Equatable {
    public let interconnectName: String?
    public let bandwidth: String?
    public let location: String?
    public let lagId: String?
    public let tags: [Tag]?
    public let providerName: String?
}

extension CreateInterconnectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bandwidth
        case interconnectName
        case lagId
        case location
        case providerName
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interconnectNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .interconnectName)
        interconnectName = interconnectNameDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
    }
}

extension CreateInterconnectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateInterconnectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateTagKeysException" : self = .duplicateTagKeysException(try DuplicateTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateInterconnectOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case duplicateTagKeysException(DuplicateTagKeysException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateInterconnectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateInterconnectOutputResponse(awsDevice: \(String(describing: awsDevice)), awsDeviceV2: \(String(describing: awsDeviceV2)), bandwidth: \(String(describing: bandwidth)), hasLogicalRedundancy: \(String(describing: hasLogicalRedundancy)), interconnectId: \(String(describing: interconnectId)), interconnectName: \(String(describing: interconnectName)), interconnectState: \(String(describing: interconnectState)), jumboFrameCapable: \(String(describing: jumboFrameCapable)), lagId: \(String(describing: lagId)), loaIssueTime: \(String(describing: loaIssueTime)), location: \(String(describing: location)), providerName: \(String(describing: providerName)), region: \(String(describing: region)), tags: \(String(describing: tags)))"}
}

extension CreateInterconnectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateInterconnectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.awsDevice = output.awsDevice
            self.awsDeviceV2 = output.awsDeviceV2
            self.bandwidth = output.bandwidth
            self.hasLogicalRedundancy = output.hasLogicalRedundancy
            self.interconnectId = output.interconnectId
            self.interconnectName = output.interconnectName
            self.interconnectState = output.interconnectState
            self.jumboFrameCapable = output.jumboFrameCapable
            self.lagId = output.lagId
            self.loaIssueTime = output.loaIssueTime
            self.location = output.location
            self.providerName = output.providerName
            self.region = output.region
            self.tags = output.tags
        } else {
            self.awsDevice = nil
            self.awsDeviceV2 = nil
            self.bandwidth = nil
            self.hasLogicalRedundancy = nil
            self.interconnectId = nil
            self.interconnectName = nil
            self.interconnectState = nil
            self.jumboFrameCapable = nil
            self.lagId = nil
            self.loaIssueTime = nil
            self.location = nil
            self.providerName = nil
            self.region = nil
            self.tags = nil
        }
    }
}

/// <p>Information about an interconnect.</p>
public struct CreateInterconnectOutputResponse: Equatable {
    /// <p>The Direct Connect endpoint on which the physical connection terminates.</p>
    @available(*, deprecated)
    public let awsDevice: String?
    /// <p>The Direct Connect endpoint on which the physical connection terminates.</p>
    public let awsDeviceV2: String?
    /// <p>The bandwidth of the connection.</p>
    public let bandwidth: String?
    /// <p>Indicates whether the interconnect supports a secondary BGP in the same address family (IPv4/IPv6).</p>
    public let hasLogicalRedundancy: HasLogicalRedundancy?
    /// <p>The ID of the interconnect.</p>
    public let interconnectId: String?
    /// <p>The name of the interconnect.</p>
    public let interconnectName: String?
    /// <p>The state of the interconnect. The following are the possible values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>requested</code>: The initial state of an interconnect. The interconnect stays in the
    ///         requested state until the Letter of Authorization (LOA) is sent to the customer.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: The interconnect is approved, and is being initialized.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>available</code>: The network link is up, and the interconnect is ready for use.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>down</code>: The network link is down.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>: The interconnect is being deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>: The interconnect is deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>unknown</code>: The state of the interconnect is not available.</p>
    ///             </li>
    ///          </ul>
    public let interconnectState: InterconnectState?
    /// <p>Indicates whether jumbo frames (9001 MTU) are supported.</p>
    public let jumboFrameCapable: Bool?
    /// <p>The ID of the LAG.</p>
    public let lagId: String?
    /// <p>The time of the most recent call to <a>DescribeLoa</a> for this connection.</p>
    public let loaIssueTime: Date?
    /// <p>The location of the connection.</p>
    public let location: String?
    /// <p>The name of the service provider associated with the interconnect.</p>
    public let providerName: String?
    /// <p>The AWS Region where the connection is located.</p>
    public let region: String?
    /// <p>The tags associated with the interconnect.</p>
    public let tags: [Tag]?

    public init (
        awsDevice: String? = nil,
        awsDeviceV2: String? = nil,
        bandwidth: String? = nil,
        hasLogicalRedundancy: HasLogicalRedundancy? = nil,
        interconnectId: String? = nil,
        interconnectName: String? = nil,
        interconnectState: InterconnectState? = nil,
        jumboFrameCapable: Bool? = nil,
        lagId: String? = nil,
        loaIssueTime: Date? = nil,
        location: String? = nil,
        providerName: String? = nil,
        region: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.bandwidth = bandwidth
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.interconnectId = interconnectId
        self.interconnectName = interconnectName
        self.interconnectState = interconnectState
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.loaIssueTime = loaIssueTime
        self.location = location
        self.providerName = providerName
        self.region = region
        self.tags = tags
    }
}

struct CreateInterconnectOutputResponseBody: Equatable {
    public let interconnectId: String?
    public let interconnectName: String?
    public let interconnectState: InterconnectState?
    public let region: String?
    public let location: String?
    public let bandwidth: String?
    public let loaIssueTime: Date?
    public let lagId: String?
    public let awsDevice: String?
    public let jumboFrameCapable: Bool?
    public let awsDeviceV2: String?
    public let hasLogicalRedundancy: HasLogicalRedundancy?
    public let tags: [Tag]?
    public let providerName: String?
}

extension CreateInterconnectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case awsDevice
        case awsDeviceV2
        case bandwidth
        case hasLogicalRedundancy
        case interconnectId
        case interconnectName
        case interconnectState
        case jumboFrameCapable
        case lagId
        case loaIssueTime
        case location
        case providerName
        case region
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interconnectIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .interconnectId)
        interconnectId = interconnectIdDecoded
        let interconnectNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .interconnectName)
        interconnectName = interconnectNameDecoded
        let interconnectStateDecoded = try containerValues.decodeIfPresent(InterconnectState.self, forKey: .interconnectState)
        interconnectState = interconnectStateDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let loaIssueTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .loaIssueTime)
        loaIssueTime = loaIssueTimeDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let awsDeviceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDevice)
        awsDevice = awsDeviceDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let hasLogicalRedundancyDecoded = try containerValues.decodeIfPresent(HasLogicalRedundancy.self, forKey: .hasLogicalRedundancy)
        hasLogicalRedundancy = hasLogicalRedundancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
    }
}

public struct CreateLagInputBodyMiddleware: Middleware {
    public let id: String = "CreateLagInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLagInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLagInput>
    public typealias MOutput = OperationOutput<CreateLagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLagOutputError>
}

extension CreateLagInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLagInput(childConnectionTags: \(String(describing: childConnectionTags)), connectionId: \(String(describing: connectionId)), connectionsBandwidth: \(String(describing: connectionsBandwidth)), lagName: \(String(describing: lagName)), location: \(String(describing: location)), numberOfConnections: \(String(describing: numberOfConnections)), providerName: \(String(describing: providerName)), requestMACSec: \(String(describing: requestMACSec)), tags: \(String(describing: tags)))"}
}

extension CreateLagInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case childConnectionTags
        case connectionId
        case connectionsBandwidth
        case lagName
        case location
        case numberOfConnections
        case providerName
        case requestMACSec
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childConnectionTags = childConnectionTags {
            var childConnectionTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .childConnectionTags)
            for taglist0 in childConnectionTags {
                try childConnectionTagsContainer.encode(taglist0)
            }
        }
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let connectionsBandwidth = connectionsBandwidth {
            try encodeContainer.encode(connectionsBandwidth, forKey: .connectionsBandwidth)
        }
        if let lagName = lagName {
            try encodeContainer.encode(lagName, forKey: .lagName)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if numberOfConnections != 0 {
            try encodeContainer.encode(numberOfConnections, forKey: .numberOfConnections)
        }
        if let providerName = providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if let requestMACSec = requestMACSec {
            try encodeContainer.encode(requestMACSec, forKey: .requestMACSec)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateLagInputHeadersMiddleware: Middleware {
    public let id: String = "CreateLagInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLagInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLagInput>
    public typealias MOutput = OperationOutput<CreateLagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLagOutputError>
}

public struct CreateLagInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateLagInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLagInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLagInput>
    public typealias MOutput = OperationOutput<CreateLagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLagOutputError>
}

public struct CreateLagInput: Equatable {
    /// <p>The tags to associate with the automtically created LAGs.</p>
    public let childConnectionTags: [Tag]?
    /// <p>The ID of an existing dedicated connection to migrate to the LAG.</p>
    public let connectionId: String?
    /// <p>The bandwidth of the individual physical dedicated connections bundled by the LAG. The
    ///       possible values are 1Gbps and 10Gbps. </p>
    public let connectionsBandwidth: String?
    /// <p>The name of the LAG.</p>
    public let lagName: String?
    /// <p>The location for the LAG.</p>
    public let location: String?
    /// <p>The number of physical dedicated connections initially provisioned and bundled by the
    ///       LAG.</p>
    public let numberOfConnections: Int
    /// <p>The name of the service provider associated with the LAG.</p>
    public let providerName: String?
    /// <p>Indicates whether the connection will support MAC Security (MACsec).</p>
    ///          <note>
    ///             <p>All connections in the LAG must be capable of  supporting MAC Security (MACsec). For information about MAC Security (MACsec) prerequisties, see  <a href="https://docs.aws.amazon.com/directconnect/latest/UserGuide/direct-connect-mac-sec-getting-started.html#mac-sec-prerequisites">MACsec prerequisties</a> in the <i>AWS Direct Connect User Guide</i>.</p>
    ///          </note>
    public let requestMACSec: Bool?
    /// <p>The tags to associate with the LAG.</p>
    public let tags: [Tag]?

    public init (
        childConnectionTags: [Tag]? = nil,
        connectionId: String? = nil,
        connectionsBandwidth: String? = nil,
        lagName: String? = nil,
        location: String? = nil,
        numberOfConnections: Int = 0,
        providerName: String? = nil,
        requestMACSec: Bool? = nil,
        tags: [Tag]? = nil
    )
    {
        self.childConnectionTags = childConnectionTags
        self.connectionId = connectionId
        self.connectionsBandwidth = connectionsBandwidth
        self.lagName = lagName
        self.location = location
        self.numberOfConnections = numberOfConnections
        self.providerName = providerName
        self.requestMACSec = requestMACSec
        self.tags = tags
    }
}

struct CreateLagInputBody: Equatable {
    public let numberOfConnections: Int
    public let location: String?
    public let connectionsBandwidth: String?
    public let lagName: String?
    public let connectionId: String?
    public let tags: [Tag]?
    public let childConnectionTags: [Tag]?
    public let providerName: String?
    public let requestMACSec: Bool?
}

extension CreateLagInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case childConnectionTags
        case connectionId
        case connectionsBandwidth
        case lagName
        case location
        case numberOfConnections
        case providerName
        case requestMACSec
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberOfConnectionsDecoded = try containerValues.decode(Int.self, forKey: .numberOfConnections)
        numberOfConnections = numberOfConnectionsDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let connectionsBandwidthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionsBandwidth)
        connectionsBandwidth = connectionsBandwidthDecoded
        let lagNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lagName)
        lagName = lagNameDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let childConnectionTagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .childConnectionTags)
        var childConnectionTagsDecoded0:[Tag]? = nil
        if let childConnectionTagsContainer = childConnectionTagsContainer {
            childConnectionTagsDecoded0 = [Tag]()
            for structure0 in childConnectionTagsContainer {
                if let structure0 = structure0 {
                    childConnectionTagsDecoded0?.append(structure0)
                }
            }
        }
        childConnectionTags = childConnectionTagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let requestMACSecDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .requestMACSec)
        requestMACSec = requestMACSecDecoded
    }
}

extension CreateLagOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLagOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateTagKeysException" : self = .duplicateTagKeysException(try DuplicateTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLagOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case duplicateTagKeysException(DuplicateTagKeysException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLagOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLagOutputResponse(allowsHostedConnections: \(String(describing: allowsHostedConnections)), awsDevice: \(String(describing: awsDevice)), awsDeviceV2: \(String(describing: awsDeviceV2)), connections: \(String(describing: connections)), connectionsBandwidth: \(String(describing: connectionsBandwidth)), encryptionMode: \(String(describing: encryptionMode)), hasLogicalRedundancy: \(String(describing: hasLogicalRedundancy)), jumboFrameCapable: \(String(describing: jumboFrameCapable)), lagId: \(String(describing: lagId)), lagName: \(String(describing: lagName)), lagState: \(String(describing: lagState)), location: \(String(describing: location)), macSecCapable: \(String(describing: macSecCapable)), macSecKeys: \(String(describing: macSecKeys)), minimumLinks: \(String(describing: minimumLinks)), numberOfConnections: \(String(describing: numberOfConnections)), ownerAccount: \(String(describing: ownerAccount)), providerName: \(String(describing: providerName)), region: \(String(describing: region)), tags: \(String(describing: tags)))"}
}

extension CreateLagOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateLagOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.allowsHostedConnections = output.allowsHostedConnections
            self.awsDevice = output.awsDevice
            self.awsDeviceV2 = output.awsDeviceV2
            self.connections = output.connections
            self.connectionsBandwidth = output.connectionsBandwidth
            self.encryptionMode = output.encryptionMode
            self.hasLogicalRedundancy = output.hasLogicalRedundancy
            self.jumboFrameCapable = output.jumboFrameCapable
            self.lagId = output.lagId
            self.lagName = output.lagName
            self.lagState = output.lagState
            self.location = output.location
            self.macSecCapable = output.macSecCapable
            self.macSecKeys = output.macSecKeys
            self.minimumLinks = output.minimumLinks
            self.numberOfConnections = output.numberOfConnections
            self.ownerAccount = output.ownerAccount
            self.providerName = output.providerName
            self.region = output.region
            self.tags = output.tags
        } else {
            self.allowsHostedConnections = false
            self.awsDevice = nil
            self.awsDeviceV2 = nil
            self.connections = nil
            self.connectionsBandwidth = nil
            self.encryptionMode = nil
            self.hasLogicalRedundancy = nil
            self.jumboFrameCapable = nil
            self.lagId = nil
            self.lagName = nil
            self.lagState = nil
            self.location = nil
            self.macSecCapable = nil
            self.macSecKeys = nil
            self.minimumLinks = 0
            self.numberOfConnections = 0
            self.ownerAccount = nil
            self.providerName = nil
            self.region = nil
            self.tags = nil
        }
    }
}

/// <p>Information about a link aggregation group (LAG).</p>
public struct CreateLagOutputResponse: Equatable {
    /// <p>Indicates whether the LAG can host other connections.</p>
    public let allowsHostedConnections: Bool
    /// <p>The AWS Direct Connect endpoint that hosts the LAG.</p>
    @available(*, deprecated)
    public let awsDevice: String?
    /// <p>The AWS Direct Connect endpoint that hosts the LAG.</p>
    public let awsDeviceV2: String?
    /// <p>The connections bundled by the LAG.</p>
    public let connections: [Connection]?
    /// <p>The individual bandwidth of the physical connections bundled by the LAG. The possible
    ///       values are 1Gbps and 10Gbps. </p>
    public let connectionsBandwidth: String?
    /// <p>The LAG MAC Security (MACsec) encryption mode.</p>
    ///          <p>The valid values are <code>no_encrypt</code>, <code>should_encrypt</code>, and <code>must_encrypt</code>.</p>
    public let encryptionMode: String?
    /// <p>Indicates whether the LAG supports a secondary BGP peer in the same address family (IPv4/IPv6).</p>
    public let hasLogicalRedundancy: HasLogicalRedundancy?
    /// <p>Indicates whether jumbo frames (9001 MTU) are supported.</p>
    public let jumboFrameCapable: Bool?
    /// <p>The ID of the LAG.</p>
    public let lagId: String?
    /// <p>The name of the LAG.</p>
    public let lagName: String?
    /// <p>The state of the LAG. The following are the possible values:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>requested</code>: The initial state of a LAG. The LAG stays in the
    ///                 requested state until the Letter of Authorization (LOA) is available.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: The LAG has been approved and is being initialized.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>available</code>: The network link is established and the LAG is ready for use.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>down</code>: The network link is down.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>: The LAG is being deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>: The LAG is deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>unknown</code>: The state of the LAG is not available.</p>
    ///             </li>
    ///          </ul>
    public let lagState: LagState?
    /// <p>The location of the LAG.</p>
    public let location: String?
    /// <p>Indicates whether the LAG supports MAC Security (MACsec).</p>
    public let macSecCapable: Bool?
    /// <p>The MAC Security (MACsec) security keys associated with the LAG.</p>
    public let macSecKeys: [MacSecKey]?
    /// <p>The minimum number of physical dedicated connections that must be operational for the LAG itself to be operational.</p>
    public let minimumLinks: Int
    /// <p>The number of physical dedicated connections bundled by the LAG, up to a maximum of 10.</p>
    public let numberOfConnections: Int
    /// <p>The ID of the AWS account that owns the LAG.</p>
    public let ownerAccount: String?
    /// <p>The name of the service provider associated with the LAG.</p>
    public let providerName: String?
    /// <p>The AWS Region where the connection is located.</p>
    public let region: String?
    /// <p>The tags associated with the LAG.</p>
    public let tags: [Tag]?

    public init (
        allowsHostedConnections: Bool = false,
        awsDevice: String? = nil,
        awsDeviceV2: String? = nil,
        connections: [Connection]? = nil,
        connectionsBandwidth: String? = nil,
        encryptionMode: String? = nil,
        hasLogicalRedundancy: HasLogicalRedundancy? = nil,
        jumboFrameCapable: Bool? = nil,
        lagId: String? = nil,
        lagName: String? = nil,
        lagState: LagState? = nil,
        location: String? = nil,
        macSecCapable: Bool? = nil,
        macSecKeys: [MacSecKey]? = nil,
        minimumLinks: Int = 0,
        numberOfConnections: Int = 0,
        ownerAccount: String? = nil,
        providerName: String? = nil,
        region: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.allowsHostedConnections = allowsHostedConnections
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.connections = connections
        self.connectionsBandwidth = connectionsBandwidth
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.lagName = lagName
        self.lagState = lagState
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.minimumLinks = minimumLinks
        self.numberOfConnections = numberOfConnections
        self.ownerAccount = ownerAccount
        self.providerName = providerName
        self.region = region
        self.tags = tags
    }
}

struct CreateLagOutputResponseBody: Equatable {
    public let connectionsBandwidth: String?
    public let numberOfConnections: Int
    public let lagId: String?
    public let ownerAccount: String?
    public let lagName: String?
    public let lagState: LagState?
    public let location: String?
    public let region: String?
    public let minimumLinks: Int
    public let awsDevice: String?
    public let awsDeviceV2: String?
    public let connections: [Connection]?
    public let allowsHostedConnections: Bool
    public let jumboFrameCapable: Bool?
    public let hasLogicalRedundancy: HasLogicalRedundancy?
    public let tags: [Tag]?
    public let providerName: String?
    public let macSecCapable: Bool?
    public let encryptionMode: String?
    public let macSecKeys: [MacSecKey]?
}

extension CreateLagOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allowsHostedConnections
        case awsDevice
        case awsDeviceV2
        case connections
        case connectionsBandwidth
        case encryptionMode
        case hasLogicalRedundancy
        case jumboFrameCapable
        case lagId
        case lagName
        case lagState
        case location
        case macSecCapable
        case macSecKeys
        case minimumLinks
        case numberOfConnections
        case ownerAccount
        case providerName
        case region
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionsBandwidthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionsBandwidth)
        connectionsBandwidth = connectionsBandwidthDecoded
        let numberOfConnectionsDecoded = try containerValues.decode(Int.self, forKey: .numberOfConnections)
        numberOfConnections = numberOfConnectionsDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let lagNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lagName)
        lagName = lagNameDecoded
        let lagStateDecoded = try containerValues.decodeIfPresent(LagState.self, forKey: .lagState)
        lagState = lagStateDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let minimumLinksDecoded = try containerValues.decode(Int.self, forKey: .minimumLinks)
        minimumLinks = minimumLinksDecoded
        let awsDeviceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDevice)
        awsDevice = awsDeviceDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let connectionsContainer = try containerValues.decodeIfPresent([Connection?].self, forKey: .connections)
        var connectionsDecoded0:[Connection]? = nil
        if let connectionsContainer = connectionsContainer {
            connectionsDecoded0 = [Connection]()
            for structure0 in connectionsContainer {
                if let structure0 = structure0 {
                    connectionsDecoded0?.append(structure0)
                }
            }
        }
        connections = connectionsDecoded0
        let allowsHostedConnectionsDecoded = try containerValues.decode(Bool.self, forKey: .allowsHostedConnections)
        allowsHostedConnections = allowsHostedConnectionsDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let hasLogicalRedundancyDecoded = try containerValues.decodeIfPresent(HasLogicalRedundancy.self, forKey: .hasLogicalRedundancy)
        hasLogicalRedundancy = hasLogicalRedundancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let macSecCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .macSecCapable)
        macSecCapable = macSecCapableDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let macSecKeysContainer = try containerValues.decodeIfPresent([MacSecKey?].self, forKey: .macSecKeys)
        var macSecKeysDecoded0:[MacSecKey]? = nil
        if let macSecKeysContainer = macSecKeysContainer {
            macSecKeysDecoded0 = [MacSecKey]()
            for structure0 in macSecKeysContainer {
                if let structure0 = structure0 {
                    macSecKeysDecoded0?.append(structure0)
                }
            }
        }
        macSecKeys = macSecKeysDecoded0
    }
}

public struct CreatePrivateVirtualInterfaceInputBodyMiddleware: Middleware {
    public let id: String = "CreatePrivateVirtualInterfaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePrivateVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePrivateVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePrivateVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<CreatePrivateVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePrivateVirtualInterfaceOutputError>
}

extension CreatePrivateVirtualInterfaceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePrivateVirtualInterfaceInput(connectionId: \(String(describing: connectionId)), newPrivateVirtualInterface: \(String(describing: newPrivateVirtualInterface)))"}
}

extension CreatePrivateVirtualInterfaceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case newPrivateVirtualInterface
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let newPrivateVirtualInterface = newPrivateVirtualInterface {
            try encodeContainer.encode(newPrivateVirtualInterface, forKey: .newPrivateVirtualInterface)
        }
    }
}

public struct CreatePrivateVirtualInterfaceInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePrivateVirtualInterfaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePrivateVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePrivateVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePrivateVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<CreatePrivateVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePrivateVirtualInterfaceOutputError>
}

public struct CreatePrivateVirtualInterfaceInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePrivateVirtualInterfaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePrivateVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePrivateVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePrivateVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<CreatePrivateVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePrivateVirtualInterfaceOutputError>
}

public struct CreatePrivateVirtualInterfaceInput: Equatable {
    /// <p>The ID of the connection.</p>
    public let connectionId: String?
    /// <p>Information about the private virtual interface.</p>
    public let newPrivateVirtualInterface: NewPrivateVirtualInterface?

    public init (
        connectionId: String? = nil,
        newPrivateVirtualInterface: NewPrivateVirtualInterface? = nil
    )
    {
        self.connectionId = connectionId
        self.newPrivateVirtualInterface = newPrivateVirtualInterface
    }
}

struct CreatePrivateVirtualInterfaceInputBody: Equatable {
    public let connectionId: String?
    public let newPrivateVirtualInterface: NewPrivateVirtualInterface?
}

extension CreatePrivateVirtualInterfaceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case newPrivateVirtualInterface
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let newPrivateVirtualInterfaceDecoded = try containerValues.decodeIfPresent(NewPrivateVirtualInterface.self, forKey: .newPrivateVirtualInterface)
        newPrivateVirtualInterface = newPrivateVirtualInterfaceDecoded
    }
}

extension CreatePrivateVirtualInterfaceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePrivateVirtualInterfaceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateTagKeysException" : self = .duplicateTagKeysException(try DuplicateTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePrivateVirtualInterfaceOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case duplicateTagKeysException(DuplicateTagKeysException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePrivateVirtualInterfaceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePrivateVirtualInterfaceOutputResponse(addressFamily: \(String(describing: addressFamily)), amazonAddress: \(String(describing: amazonAddress)), amazonSideAsn: \(String(describing: amazonSideAsn)), asn: \(String(describing: asn)), authKey: \(String(describing: authKey)), awsDeviceV2: \(String(describing: awsDeviceV2)), bgpPeers: \(String(describing: bgpPeers)), connectionId: \(String(describing: connectionId)), customerAddress: \(String(describing: customerAddress)), customerRouterConfig: \(String(describing: customerRouterConfig)), directConnectGatewayId: \(String(describing: directConnectGatewayId)), jumboFrameCapable: \(String(describing: jumboFrameCapable)), location: \(String(describing: location)), mtu: \(String(describing: mtu)), ownerAccount: \(String(describing: ownerAccount)), region: \(String(describing: region)), routeFilterPrefixes: \(String(describing: routeFilterPrefixes)), tags: \(String(describing: tags)), virtualGatewayId: \(String(describing: virtualGatewayId)), virtualInterfaceId: \(String(describing: virtualInterfaceId)), virtualInterfaceName: \(String(describing: virtualInterfaceName)), virtualInterfaceState: \(String(describing: virtualInterfaceState)), virtualInterfaceType: \(String(describing: virtualInterfaceType)), vlan: \(String(describing: vlan)))"}
}

extension CreatePrivateVirtualInterfaceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePrivateVirtualInterfaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.addressFamily = output.addressFamily
            self.amazonAddress = output.amazonAddress
            self.amazonSideAsn = output.amazonSideAsn
            self.asn = output.asn
            self.authKey = output.authKey
            self.awsDeviceV2 = output.awsDeviceV2
            self.bgpPeers = output.bgpPeers
            self.connectionId = output.connectionId
            self.customerAddress = output.customerAddress
            self.customerRouterConfig = output.customerRouterConfig
            self.directConnectGatewayId = output.directConnectGatewayId
            self.jumboFrameCapable = output.jumboFrameCapable
            self.location = output.location
            self.mtu = output.mtu
            self.ownerAccount = output.ownerAccount
            self.region = output.region
            self.routeFilterPrefixes = output.routeFilterPrefixes
            self.tags = output.tags
            self.virtualGatewayId = output.virtualGatewayId
            self.virtualInterfaceId = output.virtualInterfaceId
            self.virtualInterfaceName = output.virtualInterfaceName
            self.virtualInterfaceState = output.virtualInterfaceState
            self.virtualInterfaceType = output.virtualInterfaceType
            self.vlan = output.vlan
        } else {
            self.addressFamily = nil
            self.amazonAddress = nil
            self.amazonSideAsn = nil
            self.asn = 0
            self.authKey = nil
            self.awsDeviceV2 = nil
            self.bgpPeers = nil
            self.connectionId = nil
            self.customerAddress = nil
            self.customerRouterConfig = nil
            self.directConnectGatewayId = nil
            self.jumboFrameCapable = nil
            self.location = nil
            self.mtu = nil
            self.ownerAccount = nil
            self.region = nil
            self.routeFilterPrefixes = nil
            self.tags = nil
            self.virtualGatewayId = nil
            self.virtualInterfaceId = nil
            self.virtualInterfaceName = nil
            self.virtualInterfaceState = nil
            self.virtualInterfaceType = nil
            self.vlan = 0
        }
    }
}

/// <p>Information about a virtual interface.</p>
public struct CreatePrivateVirtualInterfaceOutputResponse: Equatable {
    /// <p>The address family for the BGP peer.</p>
    public let addressFamily: AddressFamily?
    /// <p>The IP address assigned to the Amazon interface.</p>
    public let amazonAddress: String?
    /// <p>The autonomous system number (ASN) for the Amazon side of the connection.</p>
    public let amazonSideAsn: Int?
    /// <p>The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.</p>
    ///          <p>The valid values are 1-2147483647.</p>
    public let asn: Int
    /// <p>The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.</p>
    public let authKey: String?
    /// <p>The
    ///       Direct Connect endpoint on which the virtual interface terminates.</p>
    public let awsDeviceV2: String?
    /// <p>The BGP peers configured on this virtual interface.</p>
    public let bgpPeers: [BGPPeer]?
    /// <p>The ID of the connection.</p>
    public let connectionId: String?
    /// <p>The IP address assigned to the customer interface.</p>
    public let customerAddress: String?
    /// <p>The customer router configuration.</p>
    public let customerRouterConfig: String?
    /// <p>The ID of the Direct Connect gateway.</p>
    public let directConnectGatewayId: String?
    /// <p>Indicates whether jumbo frames (9001 MTU) are supported.</p>
    public let jumboFrameCapable: Bool?
    /// <p>The location of the connection.</p>
    public let location: String?
    /// <p>The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 9001. The default value is 1500.</p>
    public let mtu: Int?
    /// <p>The ID of the AWS account that owns the virtual interface.</p>
    public let ownerAccount: String?
    /// <p>The AWS Region where the virtual interface is located.</p>
    public let region: String?
    /// <p>The routes to be advertised to the AWS network in this Region. Applies to public virtual interfaces.</p>
    public let routeFilterPrefixes: [RouteFilterPrefix]?
    /// <p>The tags associated with the virtual interface.</p>
    public let tags: [Tag]?
    /// <p>The ID of the virtual private gateway. Applies only to private virtual interfaces.</p>
    public let virtualGatewayId: String?
    /// <p>The ID of the virtual interface.</p>
    public let virtualInterfaceId: String?
    /// <p>The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).</p>
    public let virtualInterfaceName: String?
    /// <p>The state of the virtual interface. The following are the possible values:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>confirming</code>: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>verifying</code>: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>available</code>: A virtual interface that is able to forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>down</code>: A virtual interface that is BGP down.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>: A virtual interface is in this state immediately after calling <a>DeleteVirtualInterface</a> until it can no longer forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>: A virtual interface that cannot forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>rejected</code>: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the <code>Confirming</code> state is deleted by the virtual interface owner, the virtual interface enters the <code>Rejected</code> state.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>unknown</code>: The state of the virtual interface is not available.</p>
    ///             </li>
    ///          </ul>
    public let virtualInterfaceState: VirtualInterfaceState?
    /// <p>The type of virtual interface. The possible values are <code>private</code> and <code>public</code>.</p>
    public let virtualInterfaceType: String?
    /// <p>The ID of the VLAN.</p>
    public let vlan: Int

    public init (
        addressFamily: AddressFamily? = nil,
        amazonAddress: String? = nil,
        amazonSideAsn: Int? = nil,
        asn: Int = 0,
        authKey: String? = nil,
        awsDeviceV2: String? = nil,
        bgpPeers: [BGPPeer]? = nil,
        connectionId: String? = nil,
        customerAddress: String? = nil,
        customerRouterConfig: String? = nil,
        directConnectGatewayId: String? = nil,
        jumboFrameCapable: Bool? = nil,
        location: String? = nil,
        mtu: Int? = nil,
        ownerAccount: String? = nil,
        region: String? = nil,
        routeFilterPrefixes: [RouteFilterPrefix]? = nil,
        tags: [Tag]? = nil,
        virtualGatewayId: String? = nil,
        virtualInterfaceId: String? = nil,
        virtualInterfaceName: String? = nil,
        virtualInterfaceState: VirtualInterfaceState? = nil,
        virtualInterfaceType: String? = nil,
        vlan: Int = 0
    )
    {
        self.addressFamily = addressFamily
        self.amazonAddress = amazonAddress
        self.amazonSideAsn = amazonSideAsn
        self.asn = asn
        self.authKey = authKey
        self.awsDeviceV2 = awsDeviceV2
        self.bgpPeers = bgpPeers
        self.connectionId = connectionId
        self.customerAddress = customerAddress
        self.customerRouterConfig = customerRouterConfig
        self.directConnectGatewayId = directConnectGatewayId
        self.jumboFrameCapable = jumboFrameCapable
        self.location = location
        self.mtu = mtu
        self.ownerAccount = ownerAccount
        self.region = region
        self.routeFilterPrefixes = routeFilterPrefixes
        self.tags = tags
        self.virtualGatewayId = virtualGatewayId
        self.virtualInterfaceId = virtualInterfaceId
        self.virtualInterfaceName = virtualInterfaceName
        self.virtualInterfaceState = virtualInterfaceState
        self.virtualInterfaceType = virtualInterfaceType
        self.vlan = vlan
    }
}

struct CreatePrivateVirtualInterfaceOutputResponseBody: Equatable {
    public let ownerAccount: String?
    public let virtualInterfaceId: String?
    public let location: String?
    public let connectionId: String?
    public let virtualInterfaceType: String?
    public let virtualInterfaceName: String?
    public let vlan: Int
    public let asn: Int
    public let amazonSideAsn: Int?
    public let authKey: String?
    public let amazonAddress: String?
    public let customerAddress: String?
    public let addressFamily: AddressFamily?
    public let virtualInterfaceState: VirtualInterfaceState?
    public let customerRouterConfig: String?
    public let mtu: Int?
    public let jumboFrameCapable: Bool?
    public let virtualGatewayId: String?
    public let directConnectGatewayId: String?
    public let routeFilterPrefixes: [RouteFilterPrefix]?
    public let bgpPeers: [BGPPeer]?
    public let region: String?
    public let awsDeviceV2: String?
    public let tags: [Tag]?
}

extension CreatePrivateVirtualInterfaceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case addressFamily
        case amazonAddress
        case amazonSideAsn
        case asn
        case authKey
        case awsDeviceV2
        case bgpPeers
        case connectionId
        case customerAddress
        case customerRouterConfig
        case directConnectGatewayId
        case jumboFrameCapable
        case location
        case mtu
        case ownerAccount
        case region
        case routeFilterPrefixes
        case tags
        case virtualGatewayId
        case virtualInterfaceId
        case virtualInterfaceName
        case virtualInterfaceState
        case virtualInterfaceType
        case vlan
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let virtualInterfaceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceType)
        virtualInterfaceType = virtualInterfaceTypeDecoded
        let virtualInterfaceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceName)
        virtualInterfaceName = virtualInterfaceNameDecoded
        let vlanDecoded = try containerValues.decode(Int.self, forKey: .vlan)
        vlan = vlanDecoded
        let asnDecoded = try containerValues.decode(Int.self, forKey: .asn)
        asn = asnDecoded
        let amazonSideAsnDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .amazonSideAsn)
        amazonSideAsn = amazonSideAsnDecoded
        let authKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authKey)
        authKey = authKeyDecoded
        let amazonAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amazonAddress)
        amazonAddress = amazonAddressDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let virtualInterfaceStateDecoded = try containerValues.decodeIfPresent(VirtualInterfaceState.self, forKey: .virtualInterfaceState)
        virtualInterfaceState = virtualInterfaceStateDecoded
        let customerRouterConfigDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerRouterConfig)
        customerRouterConfig = customerRouterConfigDecoded
        let mtuDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .mtu)
        mtu = mtuDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let virtualGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualGatewayId)
        virtualGatewayId = virtualGatewayIdDecoded
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let routeFilterPrefixesContainer = try containerValues.decodeIfPresent([RouteFilterPrefix?].self, forKey: .routeFilterPrefixes)
        var routeFilterPrefixesDecoded0:[RouteFilterPrefix]? = nil
        if let routeFilterPrefixesContainer = routeFilterPrefixesContainer {
            routeFilterPrefixesDecoded0 = [RouteFilterPrefix]()
            for structure0 in routeFilterPrefixesContainer {
                if let structure0 = structure0 {
                    routeFilterPrefixesDecoded0?.append(structure0)
                }
            }
        }
        routeFilterPrefixes = routeFilterPrefixesDecoded0
        let bgpPeersContainer = try containerValues.decodeIfPresent([BGPPeer?].self, forKey: .bgpPeers)
        var bgpPeersDecoded0:[BGPPeer]? = nil
        if let bgpPeersContainer = bgpPeersContainer {
            bgpPeersDecoded0 = [BGPPeer]()
            for structure0 in bgpPeersContainer {
                if let structure0 = structure0 {
                    bgpPeersDecoded0?.append(structure0)
                }
            }
        }
        bgpPeers = bgpPeersDecoded0
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreatePublicVirtualInterfaceInputBodyMiddleware: Middleware {
    public let id: String = "CreatePublicVirtualInterfaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePublicVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePublicVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePublicVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<CreatePublicVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePublicVirtualInterfaceOutputError>
}

extension CreatePublicVirtualInterfaceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePublicVirtualInterfaceInput(connectionId: \(String(describing: connectionId)), newPublicVirtualInterface: \(String(describing: newPublicVirtualInterface)))"}
}

extension CreatePublicVirtualInterfaceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case newPublicVirtualInterface
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let newPublicVirtualInterface = newPublicVirtualInterface {
            try encodeContainer.encode(newPublicVirtualInterface, forKey: .newPublicVirtualInterface)
        }
    }
}

public struct CreatePublicVirtualInterfaceInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePublicVirtualInterfaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePublicVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePublicVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePublicVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<CreatePublicVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePublicVirtualInterfaceOutputError>
}

public struct CreatePublicVirtualInterfaceInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePublicVirtualInterfaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePublicVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePublicVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePublicVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<CreatePublicVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePublicVirtualInterfaceOutputError>
}

public struct CreatePublicVirtualInterfaceInput: Equatable {
    /// <p>The ID of the connection.</p>
    public let connectionId: String?
    /// <p>Information about the public virtual interface.</p>
    public let newPublicVirtualInterface: NewPublicVirtualInterface?

    public init (
        connectionId: String? = nil,
        newPublicVirtualInterface: NewPublicVirtualInterface? = nil
    )
    {
        self.connectionId = connectionId
        self.newPublicVirtualInterface = newPublicVirtualInterface
    }
}

struct CreatePublicVirtualInterfaceInputBody: Equatable {
    public let connectionId: String?
    public let newPublicVirtualInterface: NewPublicVirtualInterface?
}

extension CreatePublicVirtualInterfaceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case newPublicVirtualInterface
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let newPublicVirtualInterfaceDecoded = try containerValues.decodeIfPresent(NewPublicVirtualInterface.self, forKey: .newPublicVirtualInterface)
        newPublicVirtualInterface = newPublicVirtualInterfaceDecoded
    }
}

extension CreatePublicVirtualInterfaceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePublicVirtualInterfaceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateTagKeysException" : self = .duplicateTagKeysException(try DuplicateTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePublicVirtualInterfaceOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case duplicateTagKeysException(DuplicateTagKeysException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePublicVirtualInterfaceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePublicVirtualInterfaceOutputResponse(addressFamily: \(String(describing: addressFamily)), amazonAddress: \(String(describing: amazonAddress)), amazonSideAsn: \(String(describing: amazonSideAsn)), asn: \(String(describing: asn)), authKey: \(String(describing: authKey)), awsDeviceV2: \(String(describing: awsDeviceV2)), bgpPeers: \(String(describing: bgpPeers)), connectionId: \(String(describing: connectionId)), customerAddress: \(String(describing: customerAddress)), customerRouterConfig: \(String(describing: customerRouterConfig)), directConnectGatewayId: \(String(describing: directConnectGatewayId)), jumboFrameCapable: \(String(describing: jumboFrameCapable)), location: \(String(describing: location)), mtu: \(String(describing: mtu)), ownerAccount: \(String(describing: ownerAccount)), region: \(String(describing: region)), routeFilterPrefixes: \(String(describing: routeFilterPrefixes)), tags: \(String(describing: tags)), virtualGatewayId: \(String(describing: virtualGatewayId)), virtualInterfaceId: \(String(describing: virtualInterfaceId)), virtualInterfaceName: \(String(describing: virtualInterfaceName)), virtualInterfaceState: \(String(describing: virtualInterfaceState)), virtualInterfaceType: \(String(describing: virtualInterfaceType)), vlan: \(String(describing: vlan)))"}
}

extension CreatePublicVirtualInterfaceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePublicVirtualInterfaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.addressFamily = output.addressFamily
            self.amazonAddress = output.amazonAddress
            self.amazonSideAsn = output.amazonSideAsn
            self.asn = output.asn
            self.authKey = output.authKey
            self.awsDeviceV2 = output.awsDeviceV2
            self.bgpPeers = output.bgpPeers
            self.connectionId = output.connectionId
            self.customerAddress = output.customerAddress
            self.customerRouterConfig = output.customerRouterConfig
            self.directConnectGatewayId = output.directConnectGatewayId
            self.jumboFrameCapable = output.jumboFrameCapable
            self.location = output.location
            self.mtu = output.mtu
            self.ownerAccount = output.ownerAccount
            self.region = output.region
            self.routeFilterPrefixes = output.routeFilterPrefixes
            self.tags = output.tags
            self.virtualGatewayId = output.virtualGatewayId
            self.virtualInterfaceId = output.virtualInterfaceId
            self.virtualInterfaceName = output.virtualInterfaceName
            self.virtualInterfaceState = output.virtualInterfaceState
            self.virtualInterfaceType = output.virtualInterfaceType
            self.vlan = output.vlan
        } else {
            self.addressFamily = nil
            self.amazonAddress = nil
            self.amazonSideAsn = nil
            self.asn = 0
            self.authKey = nil
            self.awsDeviceV2 = nil
            self.bgpPeers = nil
            self.connectionId = nil
            self.customerAddress = nil
            self.customerRouterConfig = nil
            self.directConnectGatewayId = nil
            self.jumboFrameCapable = nil
            self.location = nil
            self.mtu = nil
            self.ownerAccount = nil
            self.region = nil
            self.routeFilterPrefixes = nil
            self.tags = nil
            self.virtualGatewayId = nil
            self.virtualInterfaceId = nil
            self.virtualInterfaceName = nil
            self.virtualInterfaceState = nil
            self.virtualInterfaceType = nil
            self.vlan = 0
        }
    }
}

/// <p>Information about a virtual interface.</p>
public struct CreatePublicVirtualInterfaceOutputResponse: Equatable {
    /// <p>The address family for the BGP peer.</p>
    public let addressFamily: AddressFamily?
    /// <p>The IP address assigned to the Amazon interface.</p>
    public let amazonAddress: String?
    /// <p>The autonomous system number (ASN) for the Amazon side of the connection.</p>
    public let amazonSideAsn: Int?
    /// <p>The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.</p>
    ///          <p>The valid values are 1-2147483647.</p>
    public let asn: Int
    /// <p>The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.</p>
    public let authKey: String?
    /// <p>The
    ///       Direct Connect endpoint on which the virtual interface terminates.</p>
    public let awsDeviceV2: String?
    /// <p>The BGP peers configured on this virtual interface.</p>
    public let bgpPeers: [BGPPeer]?
    /// <p>The ID of the connection.</p>
    public let connectionId: String?
    /// <p>The IP address assigned to the customer interface.</p>
    public let customerAddress: String?
    /// <p>The customer router configuration.</p>
    public let customerRouterConfig: String?
    /// <p>The ID of the Direct Connect gateway.</p>
    public let directConnectGatewayId: String?
    /// <p>Indicates whether jumbo frames (9001 MTU) are supported.</p>
    public let jumboFrameCapable: Bool?
    /// <p>The location of the connection.</p>
    public let location: String?
    /// <p>The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 9001. The default value is 1500.</p>
    public let mtu: Int?
    /// <p>The ID of the AWS account that owns the virtual interface.</p>
    public let ownerAccount: String?
    /// <p>The AWS Region where the virtual interface is located.</p>
    public let region: String?
    /// <p>The routes to be advertised to the AWS network in this Region. Applies to public virtual interfaces.</p>
    public let routeFilterPrefixes: [RouteFilterPrefix]?
    /// <p>The tags associated with the virtual interface.</p>
    public let tags: [Tag]?
    /// <p>The ID of the virtual private gateway. Applies only to private virtual interfaces.</p>
    public let virtualGatewayId: String?
    /// <p>The ID of the virtual interface.</p>
    public let virtualInterfaceId: String?
    /// <p>The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).</p>
    public let virtualInterfaceName: String?
    /// <p>The state of the virtual interface. The following are the possible values:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>confirming</code>: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>verifying</code>: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>available</code>: A virtual interface that is able to forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>down</code>: A virtual interface that is BGP down.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>: A virtual interface is in this state immediately after calling <a>DeleteVirtualInterface</a> until it can no longer forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>: A virtual interface that cannot forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>rejected</code>: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the <code>Confirming</code> state is deleted by the virtual interface owner, the virtual interface enters the <code>Rejected</code> state.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>unknown</code>: The state of the virtual interface is not available.</p>
    ///             </li>
    ///          </ul>
    public let virtualInterfaceState: VirtualInterfaceState?
    /// <p>The type of virtual interface. The possible values are <code>private</code> and <code>public</code>.</p>
    public let virtualInterfaceType: String?
    /// <p>The ID of the VLAN.</p>
    public let vlan: Int

    public init (
        addressFamily: AddressFamily? = nil,
        amazonAddress: String? = nil,
        amazonSideAsn: Int? = nil,
        asn: Int = 0,
        authKey: String? = nil,
        awsDeviceV2: String? = nil,
        bgpPeers: [BGPPeer]? = nil,
        connectionId: String? = nil,
        customerAddress: String? = nil,
        customerRouterConfig: String? = nil,
        directConnectGatewayId: String? = nil,
        jumboFrameCapable: Bool? = nil,
        location: String? = nil,
        mtu: Int? = nil,
        ownerAccount: String? = nil,
        region: String? = nil,
        routeFilterPrefixes: [RouteFilterPrefix]? = nil,
        tags: [Tag]? = nil,
        virtualGatewayId: String? = nil,
        virtualInterfaceId: String? = nil,
        virtualInterfaceName: String? = nil,
        virtualInterfaceState: VirtualInterfaceState? = nil,
        virtualInterfaceType: String? = nil,
        vlan: Int = 0
    )
    {
        self.addressFamily = addressFamily
        self.amazonAddress = amazonAddress
        self.amazonSideAsn = amazonSideAsn
        self.asn = asn
        self.authKey = authKey
        self.awsDeviceV2 = awsDeviceV2
        self.bgpPeers = bgpPeers
        self.connectionId = connectionId
        self.customerAddress = customerAddress
        self.customerRouterConfig = customerRouterConfig
        self.directConnectGatewayId = directConnectGatewayId
        self.jumboFrameCapable = jumboFrameCapable
        self.location = location
        self.mtu = mtu
        self.ownerAccount = ownerAccount
        self.region = region
        self.routeFilterPrefixes = routeFilterPrefixes
        self.tags = tags
        self.virtualGatewayId = virtualGatewayId
        self.virtualInterfaceId = virtualInterfaceId
        self.virtualInterfaceName = virtualInterfaceName
        self.virtualInterfaceState = virtualInterfaceState
        self.virtualInterfaceType = virtualInterfaceType
        self.vlan = vlan
    }
}

struct CreatePublicVirtualInterfaceOutputResponseBody: Equatable {
    public let ownerAccount: String?
    public let virtualInterfaceId: String?
    public let location: String?
    public let connectionId: String?
    public let virtualInterfaceType: String?
    public let virtualInterfaceName: String?
    public let vlan: Int
    public let asn: Int
    public let amazonSideAsn: Int?
    public let authKey: String?
    public let amazonAddress: String?
    public let customerAddress: String?
    public let addressFamily: AddressFamily?
    public let virtualInterfaceState: VirtualInterfaceState?
    public let customerRouterConfig: String?
    public let mtu: Int?
    public let jumboFrameCapable: Bool?
    public let virtualGatewayId: String?
    public let directConnectGatewayId: String?
    public let routeFilterPrefixes: [RouteFilterPrefix]?
    public let bgpPeers: [BGPPeer]?
    public let region: String?
    public let awsDeviceV2: String?
    public let tags: [Tag]?
}

extension CreatePublicVirtualInterfaceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case addressFamily
        case amazonAddress
        case amazonSideAsn
        case asn
        case authKey
        case awsDeviceV2
        case bgpPeers
        case connectionId
        case customerAddress
        case customerRouterConfig
        case directConnectGatewayId
        case jumboFrameCapable
        case location
        case mtu
        case ownerAccount
        case region
        case routeFilterPrefixes
        case tags
        case virtualGatewayId
        case virtualInterfaceId
        case virtualInterfaceName
        case virtualInterfaceState
        case virtualInterfaceType
        case vlan
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let virtualInterfaceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceType)
        virtualInterfaceType = virtualInterfaceTypeDecoded
        let virtualInterfaceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceName)
        virtualInterfaceName = virtualInterfaceNameDecoded
        let vlanDecoded = try containerValues.decode(Int.self, forKey: .vlan)
        vlan = vlanDecoded
        let asnDecoded = try containerValues.decode(Int.self, forKey: .asn)
        asn = asnDecoded
        let amazonSideAsnDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .amazonSideAsn)
        amazonSideAsn = amazonSideAsnDecoded
        let authKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authKey)
        authKey = authKeyDecoded
        let amazonAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amazonAddress)
        amazonAddress = amazonAddressDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let virtualInterfaceStateDecoded = try containerValues.decodeIfPresent(VirtualInterfaceState.self, forKey: .virtualInterfaceState)
        virtualInterfaceState = virtualInterfaceStateDecoded
        let customerRouterConfigDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerRouterConfig)
        customerRouterConfig = customerRouterConfigDecoded
        let mtuDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .mtu)
        mtu = mtuDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let virtualGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualGatewayId)
        virtualGatewayId = virtualGatewayIdDecoded
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let routeFilterPrefixesContainer = try containerValues.decodeIfPresent([RouteFilterPrefix?].self, forKey: .routeFilterPrefixes)
        var routeFilterPrefixesDecoded0:[RouteFilterPrefix]? = nil
        if let routeFilterPrefixesContainer = routeFilterPrefixesContainer {
            routeFilterPrefixesDecoded0 = [RouteFilterPrefix]()
            for structure0 in routeFilterPrefixesContainer {
                if let structure0 = structure0 {
                    routeFilterPrefixesDecoded0?.append(structure0)
                }
            }
        }
        routeFilterPrefixes = routeFilterPrefixesDecoded0
        let bgpPeersContainer = try containerValues.decodeIfPresent([BGPPeer?].self, forKey: .bgpPeers)
        var bgpPeersDecoded0:[BGPPeer]? = nil
        if let bgpPeersContainer = bgpPeersContainer {
            bgpPeersDecoded0 = [BGPPeer]()
            for structure0 in bgpPeersContainer {
                if let structure0 = structure0 {
                    bgpPeersDecoded0?.append(structure0)
                }
            }
        }
        bgpPeers = bgpPeersDecoded0
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateTransitVirtualInterfaceInputBodyMiddleware: Middleware {
    public let id: String = "CreateTransitVirtualInterfaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTransitVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTransitVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTransitVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<CreateTransitVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTransitVirtualInterfaceOutputError>
}

extension CreateTransitVirtualInterfaceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTransitVirtualInterfaceInput(connectionId: \(String(describing: connectionId)), newTransitVirtualInterface: \(String(describing: newTransitVirtualInterface)))"}
}

extension CreateTransitVirtualInterfaceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case newTransitVirtualInterface
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let newTransitVirtualInterface = newTransitVirtualInterface {
            try encodeContainer.encode(newTransitVirtualInterface, forKey: .newTransitVirtualInterface)
        }
    }
}

public struct CreateTransitVirtualInterfaceInputHeadersMiddleware: Middleware {
    public let id: String = "CreateTransitVirtualInterfaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTransitVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTransitVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTransitVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<CreateTransitVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTransitVirtualInterfaceOutputError>
}

public struct CreateTransitVirtualInterfaceInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateTransitVirtualInterfaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTransitVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTransitVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTransitVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<CreateTransitVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTransitVirtualInterfaceOutputError>
}

public struct CreateTransitVirtualInterfaceInput: Equatable {
    /// <p>The ID of the connection.</p>
    public let connectionId: String?
    /// <p>Information about the transit virtual interface.</p>
    public let newTransitVirtualInterface: NewTransitVirtualInterface?

    public init (
        connectionId: String? = nil,
        newTransitVirtualInterface: NewTransitVirtualInterface? = nil
    )
    {
        self.connectionId = connectionId
        self.newTransitVirtualInterface = newTransitVirtualInterface
    }
}

struct CreateTransitVirtualInterfaceInputBody: Equatable {
    public let connectionId: String?
    public let newTransitVirtualInterface: NewTransitVirtualInterface?
}

extension CreateTransitVirtualInterfaceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case newTransitVirtualInterface
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let newTransitVirtualInterfaceDecoded = try containerValues.decodeIfPresent(NewTransitVirtualInterface.self, forKey: .newTransitVirtualInterface)
        newTransitVirtualInterface = newTransitVirtualInterfaceDecoded
    }
}

extension CreateTransitVirtualInterfaceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTransitVirtualInterfaceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateTagKeysException" : self = .duplicateTagKeysException(try DuplicateTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTransitVirtualInterfaceOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case duplicateTagKeysException(DuplicateTagKeysException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTransitVirtualInterfaceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTransitVirtualInterfaceOutputResponse(virtualInterface: \(String(describing: virtualInterface)))"}
}

extension CreateTransitVirtualInterfaceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateTransitVirtualInterfaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.virtualInterface = output.virtualInterface
        } else {
            self.virtualInterface = nil
        }
    }
}

public struct CreateTransitVirtualInterfaceOutputResponse: Equatable {
    /// <p>Information about a virtual interface.</p>
    public let virtualInterface: VirtualInterface?

    public init (
        virtualInterface: VirtualInterface? = nil
    )
    {
        self.virtualInterface = virtualInterface
    }
}

struct CreateTransitVirtualInterfaceOutputResponseBody: Equatable {
    public let virtualInterface: VirtualInterface?
}

extension CreateTransitVirtualInterfaceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualInterface
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceDecoded = try containerValues.decodeIfPresent(VirtualInterface.self, forKey: .virtualInterface)
        virtualInterface = virtualInterfaceDecoded
    }
}

public struct DeleteBGPPeerInputBodyMiddleware: Middleware {
    public let id: String = "DeleteBGPPeerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBGPPeerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBGPPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBGPPeerInput>
    public typealias MOutput = OperationOutput<DeleteBGPPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBGPPeerOutputError>
}

extension DeleteBGPPeerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBGPPeerInput(asn: \(String(describing: asn)), bgpPeerId: \(String(describing: bgpPeerId)), customerAddress: \(String(describing: customerAddress)), virtualInterfaceId: \(String(describing: virtualInterfaceId)))"}
}

extension DeleteBGPPeerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case asn
        case bgpPeerId
        case customerAddress
        case virtualInterfaceId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if asn != 0 {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let bgpPeerId = bgpPeerId {
            try encodeContainer.encode(bgpPeerId, forKey: .bgpPeerId)
        }
        if let customerAddress = customerAddress {
            try encodeContainer.encode(customerAddress, forKey: .customerAddress)
        }
        if let virtualInterfaceId = virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
    }
}

public struct DeleteBGPPeerInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBGPPeerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBGPPeerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBGPPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBGPPeerInput>
    public typealias MOutput = OperationOutput<DeleteBGPPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBGPPeerOutputError>
}

public struct DeleteBGPPeerInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBGPPeerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBGPPeerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBGPPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBGPPeerInput>
    public typealias MOutput = OperationOutput<DeleteBGPPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBGPPeerOutputError>
}

public struct DeleteBGPPeerInput: Equatable {
    /// <p>The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.</p>
    public let asn: Int
    /// <p>The ID of the BGP peer.</p>
    public let bgpPeerId: String?
    /// <p>The IP address assigned to the customer interface.</p>
    public let customerAddress: String?
    /// <p>The ID of the virtual interface.</p>
    public let virtualInterfaceId: String?

    public init (
        asn: Int = 0,
        bgpPeerId: String? = nil,
        customerAddress: String? = nil,
        virtualInterfaceId: String? = nil
    )
    {
        self.asn = asn
        self.bgpPeerId = bgpPeerId
        self.customerAddress = customerAddress
        self.virtualInterfaceId = virtualInterfaceId
    }
}

struct DeleteBGPPeerInputBody: Equatable {
    public let virtualInterfaceId: String?
    public let asn: Int
    public let customerAddress: String?
    public let bgpPeerId: String?
}

extension DeleteBGPPeerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case asn
        case bgpPeerId
        case customerAddress
        case virtualInterfaceId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let asnDecoded = try containerValues.decode(Int.self, forKey: .asn)
        asn = asnDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
        let bgpPeerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bgpPeerId)
        bgpPeerId = bgpPeerIdDecoded
    }
}

extension DeleteBGPPeerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBGPPeerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBGPPeerOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBGPPeerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBGPPeerOutputResponse(virtualInterface: \(String(describing: virtualInterface)))"}
}

extension DeleteBGPPeerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteBGPPeerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.virtualInterface = output.virtualInterface
        } else {
            self.virtualInterface = nil
        }
    }
}

public struct DeleteBGPPeerOutputResponse: Equatable {
    /// <p>The virtual interface.</p>
    public let virtualInterface: VirtualInterface?

    public init (
        virtualInterface: VirtualInterface? = nil
    )
    {
        self.virtualInterface = virtualInterface
    }
}

struct DeleteBGPPeerOutputResponseBody: Equatable {
    public let virtualInterface: VirtualInterface?
}

extension DeleteBGPPeerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualInterface
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceDecoded = try containerValues.decodeIfPresent(VirtualInterface.self, forKey: .virtualInterface)
        virtualInterface = virtualInterfaceDecoded
    }
}

public struct DeleteConnectionInputBodyMiddleware: Middleware {
    public let id: String = "DeleteConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConnectionOutputError>
}

extension DeleteConnectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConnectionInput(connectionId: \(String(describing: connectionId)))"}
}

extension DeleteConnectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
    }
}

public struct DeleteConnectionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConnectionOutputError>
}

public struct DeleteConnectionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConnectionOutputError>
}

public struct DeleteConnectionInput: Equatable {
    /// <p>The ID of the connection.</p>
    public let connectionId: String?

    public init (
        connectionId: String? = nil
    )
    {
        self.connectionId = connectionId
    }
}

struct DeleteConnectionInputBody: Equatable {
    public let connectionId: String?
}

extension DeleteConnectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
    }
}

extension DeleteConnectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConnectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConnectionOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConnectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConnectionOutputResponse(awsDevice: \(String(describing: awsDevice)), awsDeviceV2: \(String(describing: awsDeviceV2)), bandwidth: \(String(describing: bandwidth)), connectionId: \(String(describing: connectionId)), connectionName: \(String(describing: connectionName)), connectionState: \(String(describing: connectionState)), encryptionMode: \(String(describing: encryptionMode)), hasLogicalRedundancy: \(String(describing: hasLogicalRedundancy)), jumboFrameCapable: \(String(describing: jumboFrameCapable)), lagId: \(String(describing: lagId)), loaIssueTime: \(String(describing: loaIssueTime)), location: \(String(describing: location)), macSecCapable: \(String(describing: macSecCapable)), macSecKeys: \(String(describing: macSecKeys)), ownerAccount: \(String(describing: ownerAccount)), partnerName: \(String(describing: partnerName)), portEncryptionStatus: \(String(describing: portEncryptionStatus)), providerName: \(String(describing: providerName)), region: \(String(describing: region)), tags: \(String(describing: tags)), vlan: \(String(describing: vlan)))"}
}

extension DeleteConnectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.awsDevice = output.awsDevice
            self.awsDeviceV2 = output.awsDeviceV2
            self.bandwidth = output.bandwidth
            self.connectionId = output.connectionId
            self.connectionName = output.connectionName
            self.connectionState = output.connectionState
            self.encryptionMode = output.encryptionMode
            self.hasLogicalRedundancy = output.hasLogicalRedundancy
            self.jumboFrameCapable = output.jumboFrameCapable
            self.lagId = output.lagId
            self.loaIssueTime = output.loaIssueTime
            self.location = output.location
            self.macSecCapable = output.macSecCapable
            self.macSecKeys = output.macSecKeys
            self.ownerAccount = output.ownerAccount
            self.partnerName = output.partnerName
            self.portEncryptionStatus = output.portEncryptionStatus
            self.providerName = output.providerName
            self.region = output.region
            self.tags = output.tags
            self.vlan = output.vlan
        } else {
            self.awsDevice = nil
            self.awsDeviceV2 = nil
            self.bandwidth = nil
            self.connectionId = nil
            self.connectionName = nil
            self.connectionState = nil
            self.encryptionMode = nil
            self.hasLogicalRedundancy = nil
            self.jumboFrameCapable = nil
            self.lagId = nil
            self.loaIssueTime = nil
            self.location = nil
            self.macSecCapable = nil
            self.macSecKeys = nil
            self.ownerAccount = nil
            self.partnerName = nil
            self.portEncryptionStatus = nil
            self.providerName = nil
            self.region = nil
            self.tags = nil
            self.vlan = 0
        }
    }
}

/// <p>Information about an AWS Direct Connect connection.</p>
public struct DeleteConnectionOutputResponse: Equatable {
    /// <p>The Direct Connect endpoint on which the physical connection terminates.</p>
    @available(*, deprecated)
    public let awsDevice: String?
    /// <p>The Direct Connect endpoint on which the physical connection terminates.</p>
    public let awsDeviceV2: String?
    /// <p>The bandwidth of the connection.</p>
    public let bandwidth: String?
    /// <p>The ID of the connection.</p>
    public let connectionId: String?
    /// <p>The name of the connection.</p>
    public let connectionName: String?
    /// <p>The state of the connection. The following are the possible values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ordering</code>: The initial state of a hosted connection provisioned on an interconnect. The connection stays in the ordering state until the owner of the hosted connection confirms or declines the connection order.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>requested</code>: The initial state of a standard connection. The connection stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: The connection has been approved and is being initialized.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>available</code>: The network link is up and the connection is ready for use.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>down</code>: The network link is down.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>: The connection is being deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>: The connection has been deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>rejected</code>: A hosted connection in the <code>ordering</code> state enters the <code>rejected</code> state if it is deleted by the customer.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>unknown</code>: The state of the connection is not available.</p>
    ///             </li>
    ///          </ul>
    public let connectionState: ConnectionState?
    /// <p>The MAC Security (MACsec) connection encryption mode.</p>
    ///          <p>The valid values are <code>no_encrypt</code>, <code>should_encrypt</code>, and <code>must_encrypt</code>.</p>
    public let encryptionMode: String?
    /// <p>Indicates whether the connection supports a secondary BGP peer in the same address family (IPv4/IPv6).</p>
    public let hasLogicalRedundancy: HasLogicalRedundancy?
    /// <p>Indicates whether jumbo frames (9001 MTU) are supported.</p>
    public let jumboFrameCapable: Bool?
    /// <p>The ID of the LAG.</p>
    public let lagId: String?
    /// <p>The time of the most recent call to <a>DescribeLoa</a> for this connection.</p>
    public let loaIssueTime: Date?
    /// <p>The location of the connection.</p>
    public let location: String?
    /// <p>Indicates whether the connection supports MAC Security (MACsec).</p>
    public let macSecCapable: Bool?
    /// <p>The MAC Security (MACsec) security keys associated with the connection.</p>
    public let macSecKeys: [MacSecKey]?
    /// <p>The ID of the AWS account that owns the connection.</p>
    public let ownerAccount: String?
    /// <p>The name of the AWS Direct Connect service provider associated with the connection.</p>
    public let partnerName: String?
    /// <p>The MAC Security (MACsec) port link status of the connection.</p>
    ///          <p>The valid values are <code>Encryption Up</code>, which means that there is an active Connection Key Name, or <code>Encryption Down</code>.</p>
    public let portEncryptionStatus: String?
    /// <p>The name of the service provider associated with the connection.</p>
    public let providerName: String?
    /// <p>The AWS Region where the connection is located.</p>
    public let region: String?
    /// <p>The tags associated with the connection.</p>
    public let tags: [Tag]?
    /// <p>The ID of the VLAN.</p>
    public let vlan: Int

    public init (
        awsDevice: String? = nil,
        awsDeviceV2: String? = nil,
        bandwidth: String? = nil,
        connectionId: String? = nil,
        connectionName: String? = nil,
        connectionState: ConnectionState? = nil,
        encryptionMode: String? = nil,
        hasLogicalRedundancy: HasLogicalRedundancy? = nil,
        jumboFrameCapable: Bool? = nil,
        lagId: String? = nil,
        loaIssueTime: Date? = nil,
        location: String? = nil,
        macSecCapable: Bool? = nil,
        macSecKeys: [MacSecKey]? = nil,
        ownerAccount: String? = nil,
        partnerName: String? = nil,
        portEncryptionStatus: String? = nil,
        providerName: String? = nil,
        region: String? = nil,
        tags: [Tag]? = nil,
        vlan: Int = 0
    )
    {
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.bandwidth = bandwidth
        self.connectionId = connectionId
        self.connectionName = connectionName
        self.connectionState = connectionState
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.loaIssueTime = loaIssueTime
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.ownerAccount = ownerAccount
        self.partnerName = partnerName
        self.portEncryptionStatus = portEncryptionStatus
        self.providerName = providerName
        self.region = region
        self.tags = tags
        self.vlan = vlan
    }
}

struct DeleteConnectionOutputResponseBody: Equatable {
    public let ownerAccount: String?
    public let connectionId: String?
    public let connectionName: String?
    public let connectionState: ConnectionState?
    public let region: String?
    public let location: String?
    public let bandwidth: String?
    public let vlan: Int
    public let partnerName: String?
    public let loaIssueTime: Date?
    public let lagId: String?
    public let awsDevice: String?
    public let jumboFrameCapable: Bool?
    public let awsDeviceV2: String?
    public let hasLogicalRedundancy: HasLogicalRedundancy?
    public let tags: [Tag]?
    public let providerName: String?
    public let macSecCapable: Bool?
    public let portEncryptionStatus: String?
    public let encryptionMode: String?
    public let macSecKeys: [MacSecKey]?
}

extension DeleteConnectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case awsDevice
        case awsDeviceV2
        case bandwidth
        case connectionId
        case connectionName
        case connectionState
        case encryptionMode
        case hasLogicalRedundancy
        case jumboFrameCapable
        case lagId
        case loaIssueTime
        case location
        case macSecCapable
        case macSecKeys
        case ownerAccount
        case partnerName
        case portEncryptionStatus
        case providerName
        case region
        case tags
        case vlan
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let vlanDecoded = try containerValues.decode(Int.self, forKey: .vlan)
        vlan = vlanDecoded
        let partnerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .partnerName)
        partnerName = partnerNameDecoded
        let loaIssueTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .loaIssueTime)
        loaIssueTime = loaIssueTimeDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let awsDeviceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDevice)
        awsDevice = awsDeviceDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let hasLogicalRedundancyDecoded = try containerValues.decodeIfPresent(HasLogicalRedundancy.self, forKey: .hasLogicalRedundancy)
        hasLogicalRedundancy = hasLogicalRedundancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let macSecCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .macSecCapable)
        macSecCapable = macSecCapableDecoded
        let portEncryptionStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portEncryptionStatus)
        portEncryptionStatus = portEncryptionStatusDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let macSecKeysContainer = try containerValues.decodeIfPresent([MacSecKey?].self, forKey: .macSecKeys)
        var macSecKeysDecoded0:[MacSecKey]? = nil
        if let macSecKeysContainer = macSecKeysContainer {
            macSecKeysDecoded0 = [MacSecKey]()
            for structure0 in macSecKeysContainer {
                if let structure0 = structure0 {
                    macSecKeysDecoded0?.append(structure0)
                }
            }
        }
        macSecKeys = macSecKeysDecoded0
    }
}

public struct DeleteDirectConnectGatewayAssociationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDirectConnectGatewayAssociationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDirectConnectGatewayAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDirectConnectGatewayAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDirectConnectGatewayAssociationInput>
    public typealias MOutput = OperationOutput<DeleteDirectConnectGatewayAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDirectConnectGatewayAssociationOutputError>
}

extension DeleteDirectConnectGatewayAssociationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDirectConnectGatewayAssociationInput(associationId: \(String(describing: associationId)), directConnectGatewayId: \(String(describing: directConnectGatewayId)), virtualGatewayId: \(String(describing: virtualGatewayId)))"}
}

extension DeleteDirectConnectGatewayAssociationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associationId
        case directConnectGatewayId
        case virtualGatewayId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let directConnectGatewayId = directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let virtualGatewayId = virtualGatewayId {
            try encodeContainer.encode(virtualGatewayId, forKey: .virtualGatewayId)
        }
    }
}

public struct DeleteDirectConnectGatewayAssociationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDirectConnectGatewayAssociationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDirectConnectGatewayAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDirectConnectGatewayAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDirectConnectGatewayAssociationInput>
    public typealias MOutput = OperationOutput<DeleteDirectConnectGatewayAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDirectConnectGatewayAssociationOutputError>
}

public struct DeleteDirectConnectGatewayAssociationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDirectConnectGatewayAssociationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDirectConnectGatewayAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDirectConnectGatewayAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDirectConnectGatewayAssociationInput>
    public typealias MOutput = OperationOutput<DeleteDirectConnectGatewayAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDirectConnectGatewayAssociationOutputError>
}

public struct DeleteDirectConnectGatewayAssociationInput: Equatable {
    /// <p>The ID of the Direct Connect gateway association.</p>
    public let associationId: String?
    /// <p>The ID of the Direct Connect gateway.</p>
    public let directConnectGatewayId: String?
    /// <p>The ID of the virtual private gateway.</p>
    public let virtualGatewayId: String?

    public init (
        associationId: String? = nil,
        directConnectGatewayId: String? = nil,
        virtualGatewayId: String? = nil
    )
    {
        self.associationId = associationId
        self.directConnectGatewayId = directConnectGatewayId
        self.virtualGatewayId = virtualGatewayId
    }
}

struct DeleteDirectConnectGatewayAssociationInputBody: Equatable {
    public let associationId: String?
    public let directConnectGatewayId: String?
    public let virtualGatewayId: String?
}

extension DeleteDirectConnectGatewayAssociationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associationId
        case directConnectGatewayId
        case virtualGatewayId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let virtualGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualGatewayId)
        virtualGatewayId = virtualGatewayIdDecoded
    }
}

extension DeleteDirectConnectGatewayAssociationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDirectConnectGatewayAssociationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDirectConnectGatewayAssociationOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDirectConnectGatewayAssociationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDirectConnectGatewayAssociationOutputResponse(directConnectGatewayAssociation: \(String(describing: directConnectGatewayAssociation)))"}
}

extension DeleteDirectConnectGatewayAssociationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDirectConnectGatewayAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directConnectGatewayAssociation = output.directConnectGatewayAssociation
        } else {
            self.directConnectGatewayAssociation = nil
        }
    }
}

public struct DeleteDirectConnectGatewayAssociationOutputResponse: Equatable {
    /// <p>Information about the deleted association.</p>
    public let directConnectGatewayAssociation: DirectConnectGatewayAssociation?

    public init (
        directConnectGatewayAssociation: DirectConnectGatewayAssociation? = nil
    )
    {
        self.directConnectGatewayAssociation = directConnectGatewayAssociation
    }
}

struct DeleteDirectConnectGatewayAssociationOutputResponseBody: Equatable {
    public let directConnectGatewayAssociation: DirectConnectGatewayAssociation?
}

extension DeleteDirectConnectGatewayAssociationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directConnectGatewayAssociation
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayAssociationDecoded = try containerValues.decodeIfPresent(DirectConnectGatewayAssociation.self, forKey: .directConnectGatewayAssociation)
        directConnectGatewayAssociation = directConnectGatewayAssociationDecoded
    }
}

public struct DeleteDirectConnectGatewayAssociationProposalInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDirectConnectGatewayAssociationProposalInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDirectConnectGatewayAssociationProposalInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDirectConnectGatewayAssociationProposalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDirectConnectGatewayAssociationProposalInput>
    public typealias MOutput = OperationOutput<DeleteDirectConnectGatewayAssociationProposalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDirectConnectGatewayAssociationProposalOutputError>
}

extension DeleteDirectConnectGatewayAssociationProposalInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDirectConnectGatewayAssociationProposalInput(proposalId: \(String(describing: proposalId)))"}
}

extension DeleteDirectConnectGatewayAssociationProposalInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case proposalId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let proposalId = proposalId {
            try encodeContainer.encode(proposalId, forKey: .proposalId)
        }
    }
}

public struct DeleteDirectConnectGatewayAssociationProposalInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDirectConnectGatewayAssociationProposalInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDirectConnectGatewayAssociationProposalInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDirectConnectGatewayAssociationProposalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDirectConnectGatewayAssociationProposalInput>
    public typealias MOutput = OperationOutput<DeleteDirectConnectGatewayAssociationProposalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDirectConnectGatewayAssociationProposalOutputError>
}

public struct DeleteDirectConnectGatewayAssociationProposalInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDirectConnectGatewayAssociationProposalInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDirectConnectGatewayAssociationProposalInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDirectConnectGatewayAssociationProposalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDirectConnectGatewayAssociationProposalInput>
    public typealias MOutput = OperationOutput<DeleteDirectConnectGatewayAssociationProposalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDirectConnectGatewayAssociationProposalOutputError>
}

public struct DeleteDirectConnectGatewayAssociationProposalInput: Equatable {
    /// <p>The ID of the proposal.</p>
    public let proposalId: String?

    public init (
        proposalId: String? = nil
    )
    {
        self.proposalId = proposalId
    }
}

struct DeleteDirectConnectGatewayAssociationProposalInputBody: Equatable {
    public let proposalId: String?
}

extension DeleteDirectConnectGatewayAssociationProposalInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case proposalId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proposalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .proposalId)
        proposalId = proposalIdDecoded
    }
}

extension DeleteDirectConnectGatewayAssociationProposalOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDirectConnectGatewayAssociationProposalOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDirectConnectGatewayAssociationProposalOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDirectConnectGatewayAssociationProposalOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDirectConnectGatewayAssociationProposalOutputResponse(directConnectGatewayAssociationProposal: \(String(describing: directConnectGatewayAssociationProposal)))"}
}

extension DeleteDirectConnectGatewayAssociationProposalOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDirectConnectGatewayAssociationProposalOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directConnectGatewayAssociationProposal = output.directConnectGatewayAssociationProposal
        } else {
            self.directConnectGatewayAssociationProposal = nil
        }
    }
}

public struct DeleteDirectConnectGatewayAssociationProposalOutputResponse: Equatable {
    /// <p>The ID of the associated gateway.</p>
    public let directConnectGatewayAssociationProposal: DirectConnectGatewayAssociationProposal?

    public init (
        directConnectGatewayAssociationProposal: DirectConnectGatewayAssociationProposal? = nil
    )
    {
        self.directConnectGatewayAssociationProposal = directConnectGatewayAssociationProposal
    }
}

struct DeleteDirectConnectGatewayAssociationProposalOutputResponseBody: Equatable {
    public let directConnectGatewayAssociationProposal: DirectConnectGatewayAssociationProposal?
}

extension DeleteDirectConnectGatewayAssociationProposalOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directConnectGatewayAssociationProposal
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayAssociationProposalDecoded = try containerValues.decodeIfPresent(DirectConnectGatewayAssociationProposal.self, forKey: .directConnectGatewayAssociationProposal)
        directConnectGatewayAssociationProposal = directConnectGatewayAssociationProposalDecoded
    }
}

public struct DeleteDirectConnectGatewayInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDirectConnectGatewayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDirectConnectGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDirectConnectGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDirectConnectGatewayInput>
    public typealias MOutput = OperationOutput<DeleteDirectConnectGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDirectConnectGatewayOutputError>
}

extension DeleteDirectConnectGatewayInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDirectConnectGatewayInput(directConnectGatewayId: \(String(describing: directConnectGatewayId)))"}
}

extension DeleteDirectConnectGatewayInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directConnectGatewayId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directConnectGatewayId = directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
    }
}

public struct DeleteDirectConnectGatewayInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDirectConnectGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDirectConnectGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDirectConnectGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDirectConnectGatewayInput>
    public typealias MOutput = OperationOutput<DeleteDirectConnectGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDirectConnectGatewayOutputError>
}

public struct DeleteDirectConnectGatewayInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDirectConnectGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDirectConnectGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDirectConnectGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDirectConnectGatewayInput>
    public typealias MOutput = OperationOutput<DeleteDirectConnectGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDirectConnectGatewayOutputError>
}

public struct DeleteDirectConnectGatewayInput: Equatable {
    /// <p>The ID of the Direct Connect gateway.</p>
    public let directConnectGatewayId: String?

    public init (
        directConnectGatewayId: String? = nil
    )
    {
        self.directConnectGatewayId = directConnectGatewayId
    }
}

struct DeleteDirectConnectGatewayInputBody: Equatable {
    public let directConnectGatewayId: String?
}

extension DeleteDirectConnectGatewayInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directConnectGatewayId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
    }
}

extension DeleteDirectConnectGatewayOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDirectConnectGatewayOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDirectConnectGatewayOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDirectConnectGatewayOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDirectConnectGatewayOutputResponse(directConnectGateway: \(String(describing: directConnectGateway)))"}
}

extension DeleteDirectConnectGatewayOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDirectConnectGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directConnectGateway = output.directConnectGateway
        } else {
            self.directConnectGateway = nil
        }
    }
}

public struct DeleteDirectConnectGatewayOutputResponse: Equatable {
    /// <p>The Direct Connect gateway.</p>
    public let directConnectGateway: DirectConnectGateway?

    public init (
        directConnectGateway: DirectConnectGateway? = nil
    )
    {
        self.directConnectGateway = directConnectGateway
    }
}

struct DeleteDirectConnectGatewayOutputResponseBody: Equatable {
    public let directConnectGateway: DirectConnectGateway?
}

extension DeleteDirectConnectGatewayOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directConnectGateway
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayDecoded = try containerValues.decodeIfPresent(DirectConnectGateway.self, forKey: .directConnectGateway)
        directConnectGateway = directConnectGatewayDecoded
    }
}

public struct DeleteInterconnectInputBodyMiddleware: Middleware {
    public let id: String = "DeleteInterconnectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInterconnectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInterconnectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInterconnectInput>
    public typealias MOutput = OperationOutput<DeleteInterconnectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInterconnectOutputError>
}

extension DeleteInterconnectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInterconnectInput(interconnectId: \(String(describing: interconnectId)))"}
}

extension DeleteInterconnectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case interconnectId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let interconnectId = interconnectId {
            try encodeContainer.encode(interconnectId, forKey: .interconnectId)
        }
    }
}

public struct DeleteInterconnectInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteInterconnectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInterconnectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInterconnectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInterconnectInput>
    public typealias MOutput = OperationOutput<DeleteInterconnectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInterconnectOutputError>
}

public struct DeleteInterconnectInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteInterconnectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInterconnectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInterconnectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInterconnectInput>
    public typealias MOutput = OperationOutput<DeleteInterconnectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInterconnectOutputError>
}

public struct DeleteInterconnectInput: Equatable {
    /// <p>The ID of the interconnect.</p>
    public let interconnectId: String?

    public init (
        interconnectId: String? = nil
    )
    {
        self.interconnectId = interconnectId
    }
}

struct DeleteInterconnectInputBody: Equatable {
    public let interconnectId: String?
}

extension DeleteInterconnectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case interconnectId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interconnectIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .interconnectId)
        interconnectId = interconnectIdDecoded
    }
}

extension DeleteInterconnectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInterconnectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteInterconnectOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInterconnectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInterconnectOutputResponse(interconnectState: \(String(describing: interconnectState)))"}
}

extension DeleteInterconnectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteInterconnectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.interconnectState = output.interconnectState
        } else {
            self.interconnectState = nil
        }
    }
}

public struct DeleteInterconnectOutputResponse: Equatable {
    /// <p>The state of the interconnect. The following are the possible values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>requested</code>: The initial state of an interconnect. The interconnect stays in the
    ///         requested state until the Letter of Authorization (LOA) is sent to the customer.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: The interconnect is approved, and is being initialized.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>available</code>: The network link is up, and the interconnect is ready for use.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>down</code>: The network link is down.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>: The interconnect is being deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>: The interconnect is deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>unknown</code>: The state of the interconnect is not available.</p>
    ///             </li>
    ///          </ul>
    public let interconnectState: InterconnectState?

    public init (
        interconnectState: InterconnectState? = nil
    )
    {
        self.interconnectState = interconnectState
    }
}

struct DeleteInterconnectOutputResponseBody: Equatable {
    public let interconnectState: InterconnectState?
}

extension DeleteInterconnectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case interconnectState
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interconnectStateDecoded = try containerValues.decodeIfPresent(InterconnectState.self, forKey: .interconnectState)
        interconnectState = interconnectStateDecoded
    }
}

public struct DeleteLagInputBodyMiddleware: Middleware {
    public let id: String = "DeleteLagInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLagInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLagInput>
    public typealias MOutput = OperationOutput<DeleteLagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLagOutputError>
}

extension DeleteLagInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLagInput(lagId: \(String(describing: lagId)))"}
}

extension DeleteLagInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lagId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lagId = lagId {
            try encodeContainer.encode(lagId, forKey: .lagId)
        }
    }
}

public struct DeleteLagInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteLagInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLagInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLagInput>
    public typealias MOutput = OperationOutput<DeleteLagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLagOutputError>
}

public struct DeleteLagInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteLagInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLagInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLagInput>
    public typealias MOutput = OperationOutput<DeleteLagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLagOutputError>
}

public struct DeleteLagInput: Equatable {
    /// <p>The ID of the LAG.</p>
    public let lagId: String?

    public init (
        lagId: String? = nil
    )
    {
        self.lagId = lagId
    }
}

struct DeleteLagInputBody: Equatable {
    public let lagId: String?
}

extension DeleteLagInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lagId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lagIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lagId)
        lagId = lagIdDecoded
    }
}

extension DeleteLagOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLagOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLagOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLagOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLagOutputResponse(allowsHostedConnections: \(String(describing: allowsHostedConnections)), awsDevice: \(String(describing: awsDevice)), awsDeviceV2: \(String(describing: awsDeviceV2)), connections: \(String(describing: connections)), connectionsBandwidth: \(String(describing: connectionsBandwidth)), encryptionMode: \(String(describing: encryptionMode)), hasLogicalRedundancy: \(String(describing: hasLogicalRedundancy)), jumboFrameCapable: \(String(describing: jumboFrameCapable)), lagId: \(String(describing: lagId)), lagName: \(String(describing: lagName)), lagState: \(String(describing: lagState)), location: \(String(describing: location)), macSecCapable: \(String(describing: macSecCapable)), macSecKeys: \(String(describing: macSecKeys)), minimumLinks: \(String(describing: minimumLinks)), numberOfConnections: \(String(describing: numberOfConnections)), ownerAccount: \(String(describing: ownerAccount)), providerName: \(String(describing: providerName)), region: \(String(describing: region)), tags: \(String(describing: tags)))"}
}

extension DeleteLagOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteLagOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.allowsHostedConnections = output.allowsHostedConnections
            self.awsDevice = output.awsDevice
            self.awsDeviceV2 = output.awsDeviceV2
            self.connections = output.connections
            self.connectionsBandwidth = output.connectionsBandwidth
            self.encryptionMode = output.encryptionMode
            self.hasLogicalRedundancy = output.hasLogicalRedundancy
            self.jumboFrameCapable = output.jumboFrameCapable
            self.lagId = output.lagId
            self.lagName = output.lagName
            self.lagState = output.lagState
            self.location = output.location
            self.macSecCapable = output.macSecCapable
            self.macSecKeys = output.macSecKeys
            self.minimumLinks = output.minimumLinks
            self.numberOfConnections = output.numberOfConnections
            self.ownerAccount = output.ownerAccount
            self.providerName = output.providerName
            self.region = output.region
            self.tags = output.tags
        } else {
            self.allowsHostedConnections = false
            self.awsDevice = nil
            self.awsDeviceV2 = nil
            self.connections = nil
            self.connectionsBandwidth = nil
            self.encryptionMode = nil
            self.hasLogicalRedundancy = nil
            self.jumboFrameCapable = nil
            self.lagId = nil
            self.lagName = nil
            self.lagState = nil
            self.location = nil
            self.macSecCapable = nil
            self.macSecKeys = nil
            self.minimumLinks = 0
            self.numberOfConnections = 0
            self.ownerAccount = nil
            self.providerName = nil
            self.region = nil
            self.tags = nil
        }
    }
}

/// <p>Information about a link aggregation group (LAG).</p>
public struct DeleteLagOutputResponse: Equatable {
    /// <p>Indicates whether the LAG can host other connections.</p>
    public let allowsHostedConnections: Bool
    /// <p>The AWS Direct Connect endpoint that hosts the LAG.</p>
    @available(*, deprecated)
    public let awsDevice: String?
    /// <p>The AWS Direct Connect endpoint that hosts the LAG.</p>
    public let awsDeviceV2: String?
    /// <p>The connections bundled by the LAG.</p>
    public let connections: [Connection]?
    /// <p>The individual bandwidth of the physical connections bundled by the LAG. The possible
    ///       values are 1Gbps and 10Gbps. </p>
    public let connectionsBandwidth: String?
    /// <p>The LAG MAC Security (MACsec) encryption mode.</p>
    ///          <p>The valid values are <code>no_encrypt</code>, <code>should_encrypt</code>, and <code>must_encrypt</code>.</p>
    public let encryptionMode: String?
    /// <p>Indicates whether the LAG supports a secondary BGP peer in the same address family (IPv4/IPv6).</p>
    public let hasLogicalRedundancy: HasLogicalRedundancy?
    /// <p>Indicates whether jumbo frames (9001 MTU) are supported.</p>
    public let jumboFrameCapable: Bool?
    /// <p>The ID of the LAG.</p>
    public let lagId: String?
    /// <p>The name of the LAG.</p>
    public let lagName: String?
    /// <p>The state of the LAG. The following are the possible values:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>requested</code>: The initial state of a LAG. The LAG stays in the
    ///                 requested state until the Letter of Authorization (LOA) is available.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: The LAG has been approved and is being initialized.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>available</code>: The network link is established and the LAG is ready for use.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>down</code>: The network link is down.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>: The LAG is being deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>: The LAG is deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>unknown</code>: The state of the LAG is not available.</p>
    ///             </li>
    ///          </ul>
    public let lagState: LagState?
    /// <p>The location of the LAG.</p>
    public let location: String?
    /// <p>Indicates whether the LAG supports MAC Security (MACsec).</p>
    public let macSecCapable: Bool?
    /// <p>The MAC Security (MACsec) security keys associated with the LAG.</p>
    public let macSecKeys: [MacSecKey]?
    /// <p>The minimum number of physical dedicated connections that must be operational for the LAG itself to be operational.</p>
    public let minimumLinks: Int
    /// <p>The number of physical dedicated connections bundled by the LAG, up to a maximum of 10.</p>
    public let numberOfConnections: Int
    /// <p>The ID of the AWS account that owns the LAG.</p>
    public let ownerAccount: String?
    /// <p>The name of the service provider associated with the LAG.</p>
    public let providerName: String?
    /// <p>The AWS Region where the connection is located.</p>
    public let region: String?
    /// <p>The tags associated with the LAG.</p>
    public let tags: [Tag]?

    public init (
        allowsHostedConnections: Bool = false,
        awsDevice: String? = nil,
        awsDeviceV2: String? = nil,
        connections: [Connection]? = nil,
        connectionsBandwidth: String? = nil,
        encryptionMode: String? = nil,
        hasLogicalRedundancy: HasLogicalRedundancy? = nil,
        jumboFrameCapable: Bool? = nil,
        lagId: String? = nil,
        lagName: String? = nil,
        lagState: LagState? = nil,
        location: String? = nil,
        macSecCapable: Bool? = nil,
        macSecKeys: [MacSecKey]? = nil,
        minimumLinks: Int = 0,
        numberOfConnections: Int = 0,
        ownerAccount: String? = nil,
        providerName: String? = nil,
        region: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.allowsHostedConnections = allowsHostedConnections
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.connections = connections
        self.connectionsBandwidth = connectionsBandwidth
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.lagName = lagName
        self.lagState = lagState
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.minimumLinks = minimumLinks
        self.numberOfConnections = numberOfConnections
        self.ownerAccount = ownerAccount
        self.providerName = providerName
        self.region = region
        self.tags = tags
    }
}

struct DeleteLagOutputResponseBody: Equatable {
    public let connectionsBandwidth: String?
    public let numberOfConnections: Int
    public let lagId: String?
    public let ownerAccount: String?
    public let lagName: String?
    public let lagState: LagState?
    public let location: String?
    public let region: String?
    public let minimumLinks: Int
    public let awsDevice: String?
    public let awsDeviceV2: String?
    public let connections: [Connection]?
    public let allowsHostedConnections: Bool
    public let jumboFrameCapable: Bool?
    public let hasLogicalRedundancy: HasLogicalRedundancy?
    public let tags: [Tag]?
    public let providerName: String?
    public let macSecCapable: Bool?
    public let encryptionMode: String?
    public let macSecKeys: [MacSecKey]?
}

extension DeleteLagOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allowsHostedConnections
        case awsDevice
        case awsDeviceV2
        case connections
        case connectionsBandwidth
        case encryptionMode
        case hasLogicalRedundancy
        case jumboFrameCapable
        case lagId
        case lagName
        case lagState
        case location
        case macSecCapable
        case macSecKeys
        case minimumLinks
        case numberOfConnections
        case ownerAccount
        case providerName
        case region
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionsBandwidthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionsBandwidth)
        connectionsBandwidth = connectionsBandwidthDecoded
        let numberOfConnectionsDecoded = try containerValues.decode(Int.self, forKey: .numberOfConnections)
        numberOfConnections = numberOfConnectionsDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let lagNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lagName)
        lagName = lagNameDecoded
        let lagStateDecoded = try containerValues.decodeIfPresent(LagState.self, forKey: .lagState)
        lagState = lagStateDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let minimumLinksDecoded = try containerValues.decode(Int.self, forKey: .minimumLinks)
        minimumLinks = minimumLinksDecoded
        let awsDeviceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDevice)
        awsDevice = awsDeviceDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let connectionsContainer = try containerValues.decodeIfPresent([Connection?].self, forKey: .connections)
        var connectionsDecoded0:[Connection]? = nil
        if let connectionsContainer = connectionsContainer {
            connectionsDecoded0 = [Connection]()
            for structure0 in connectionsContainer {
                if let structure0 = structure0 {
                    connectionsDecoded0?.append(structure0)
                }
            }
        }
        connections = connectionsDecoded0
        let allowsHostedConnectionsDecoded = try containerValues.decode(Bool.self, forKey: .allowsHostedConnections)
        allowsHostedConnections = allowsHostedConnectionsDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let hasLogicalRedundancyDecoded = try containerValues.decodeIfPresent(HasLogicalRedundancy.self, forKey: .hasLogicalRedundancy)
        hasLogicalRedundancy = hasLogicalRedundancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let macSecCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .macSecCapable)
        macSecCapable = macSecCapableDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let macSecKeysContainer = try containerValues.decodeIfPresent([MacSecKey?].self, forKey: .macSecKeys)
        var macSecKeysDecoded0:[MacSecKey]? = nil
        if let macSecKeysContainer = macSecKeysContainer {
            macSecKeysDecoded0 = [MacSecKey]()
            for structure0 in macSecKeysContainer {
                if let structure0 = structure0 {
                    macSecKeysDecoded0?.append(structure0)
                }
            }
        }
        macSecKeys = macSecKeysDecoded0
    }
}

public struct DeleteVirtualInterfaceInputBodyMiddleware: Middleware {
    public let id: String = "DeleteVirtualInterfaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<DeleteVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVirtualInterfaceOutputError>
}

extension DeleteVirtualInterfaceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVirtualInterfaceInput(virtualInterfaceId: \(String(describing: virtualInterfaceId)))"}
}

extension DeleteVirtualInterfaceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case virtualInterfaceId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let virtualInterfaceId = virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
    }
}

public struct DeleteVirtualInterfaceInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteVirtualInterfaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<DeleteVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVirtualInterfaceOutputError>
}

public struct DeleteVirtualInterfaceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteVirtualInterfaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVirtualInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVirtualInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVirtualInterfaceInput>
    public typealias MOutput = OperationOutput<DeleteVirtualInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVirtualInterfaceOutputError>
}

public struct DeleteVirtualInterfaceInput: Equatable {
    /// <p>The ID of the virtual interface.</p>
    public let virtualInterfaceId: String?

    public init (
        virtualInterfaceId: String? = nil
    )
    {
        self.virtualInterfaceId = virtualInterfaceId
    }
}

struct DeleteVirtualInterfaceInputBody: Equatable {
    public let virtualInterfaceId: String?
}

extension DeleteVirtualInterfaceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualInterfaceId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
    }
}

extension DeleteVirtualInterfaceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVirtualInterfaceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVirtualInterfaceOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVirtualInterfaceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVirtualInterfaceOutputResponse(virtualInterfaceState: \(String(describing: virtualInterfaceState)))"}
}

extension DeleteVirtualInterfaceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteVirtualInterfaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.virtualInterfaceState = output.virtualInterfaceState
        } else {
            self.virtualInterfaceState = nil
        }
    }
}

public struct DeleteVirtualInterfaceOutputResponse: Equatable {
    /// <p>The state of the virtual interface. The following are the possible values:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>confirming</code>: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>verifying</code>: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>available</code>: A virtual interface that is able to forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>down</code>: A virtual interface that is BGP down.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>: A virtual interface is in this state immediately after calling <a>DeleteVirtualInterface</a> until it can no longer forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>: A virtual interface that cannot forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>rejected</code>: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the <code>Confirming</code> state is deleted by the virtual interface owner, the virtual interface enters the <code>Rejected</code> state.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>unknown</code>: The state of the virtual interface is not available.</p>
    ///             </li>
    ///          </ul>
    public let virtualInterfaceState: VirtualInterfaceState?

    public init (
        virtualInterfaceState: VirtualInterfaceState? = nil
    )
    {
        self.virtualInterfaceState = virtualInterfaceState
    }
}

struct DeleteVirtualInterfaceOutputResponseBody: Equatable {
    public let virtualInterfaceState: VirtualInterfaceState?
}

extension DeleteVirtualInterfaceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualInterfaceState
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceStateDecoded = try containerValues.decodeIfPresent(VirtualInterfaceState.self, forKey: .virtualInterfaceState)
        virtualInterfaceState = virtualInterfaceStateDecoded
    }
}

public struct DescribeConnectionLoaInputBodyMiddleware: Middleware {
    public let id: String = "DescribeConnectionLoaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConnectionLoaInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConnectionLoaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConnectionLoaInput>
    public typealias MOutput = OperationOutput<DescribeConnectionLoaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConnectionLoaOutputError>
}

extension DescribeConnectionLoaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConnectionLoaInput(connectionId: \(String(describing: connectionId)), loaContentType: \(String(describing: loaContentType)), providerName: \(String(describing: providerName)))"}
}

extension DescribeConnectionLoaInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case loaContentType
        case providerName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let loaContentType = loaContentType {
            try encodeContainer.encode(loaContentType.rawValue, forKey: .loaContentType)
        }
        if let providerName = providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
    }
}

public struct DescribeConnectionLoaInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeConnectionLoaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConnectionLoaInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConnectionLoaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConnectionLoaInput>
    public typealias MOutput = OperationOutput<DescribeConnectionLoaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConnectionLoaOutputError>
}

public struct DescribeConnectionLoaInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeConnectionLoaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConnectionLoaInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConnectionLoaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConnectionLoaInput>
    public typealias MOutput = OperationOutput<DescribeConnectionLoaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConnectionLoaOutputError>
}

public struct DescribeConnectionLoaInput: Equatable {
    /// <p>The ID of the connection.</p>
    public let connectionId: String?
    /// <p>The standard media type for the LOA-CFA document. The only supported value is application/pdf.</p>
    public let loaContentType: LoaContentType?
    /// <p>The name of the APN partner or service provider who establishes connectivity on your behalf. If you specify this parameter,
    ///       the LOA-CFA lists the provider name alongside your company name as the requester of the cross connect.</p>
    public let providerName: String?

    public init (
        connectionId: String? = nil,
        loaContentType: LoaContentType? = nil,
        providerName: String? = nil
    )
    {
        self.connectionId = connectionId
        self.loaContentType = loaContentType
        self.providerName = providerName
    }
}

struct DescribeConnectionLoaInputBody: Equatable {
    public let connectionId: String?
    public let providerName: String?
    public let loaContentType: LoaContentType?
}

extension DescribeConnectionLoaInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case loaContentType
        case providerName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let loaContentTypeDecoded = try containerValues.decodeIfPresent(LoaContentType.self, forKey: .loaContentType)
        loaContentType = loaContentTypeDecoded
    }
}

extension DescribeConnectionLoaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConnectionLoaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConnectionLoaOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConnectionLoaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConnectionLoaOutputResponse(loa: \(String(describing: loa)))"}
}

extension DescribeConnectionLoaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeConnectionLoaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loa = output.loa
        } else {
            self.loa = nil
        }
    }
}

public struct DescribeConnectionLoaOutputResponse: Equatable {
    /// <p>The Letter of Authorization - Connecting Facility Assignment (LOA-CFA).</p>
    public let loa: Loa?

    public init (
        loa: Loa? = nil
    )
    {
        self.loa = loa
    }
}

struct DescribeConnectionLoaOutputResponseBody: Equatable {
    public let loa: Loa?
}

extension DescribeConnectionLoaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case loa
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loaDecoded = try containerValues.decodeIfPresent(Loa.self, forKey: .loa)
        loa = loaDecoded
    }
}

public struct DescribeConnectionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeConnectionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConnectionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConnectionsInput>
    public typealias MOutput = OperationOutput<DescribeConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConnectionsOutputError>
}

extension DescribeConnectionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConnectionsInput(connectionId: \(String(describing: connectionId)))"}
}

extension DescribeConnectionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
    }
}

public struct DescribeConnectionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeConnectionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConnectionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConnectionsInput>
    public typealias MOutput = OperationOutput<DescribeConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConnectionsOutputError>
}

public struct DescribeConnectionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeConnectionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConnectionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConnectionsInput>
    public typealias MOutput = OperationOutput<DescribeConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConnectionsOutputError>
}

public struct DescribeConnectionsInput: Equatable {
    /// <p>The ID of the connection.</p>
    public let connectionId: String?

    public init (
        connectionId: String? = nil
    )
    {
        self.connectionId = connectionId
    }
}

struct DescribeConnectionsInputBody: Equatable {
    public let connectionId: String?
}

extension DescribeConnectionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
    }
}

public struct DescribeConnectionsOnInterconnectInputBodyMiddleware: Middleware {
    public let id: String = "DescribeConnectionsOnInterconnectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConnectionsOnInterconnectInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConnectionsOnInterconnectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConnectionsOnInterconnectInput>
    public typealias MOutput = OperationOutput<DescribeConnectionsOnInterconnectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConnectionsOnInterconnectOutputError>
}

extension DescribeConnectionsOnInterconnectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConnectionsOnInterconnectInput(interconnectId: \(String(describing: interconnectId)))"}
}

extension DescribeConnectionsOnInterconnectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case interconnectId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let interconnectId = interconnectId {
            try encodeContainer.encode(interconnectId, forKey: .interconnectId)
        }
    }
}

public struct DescribeConnectionsOnInterconnectInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeConnectionsOnInterconnectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConnectionsOnInterconnectInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConnectionsOnInterconnectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConnectionsOnInterconnectInput>
    public typealias MOutput = OperationOutput<DescribeConnectionsOnInterconnectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConnectionsOnInterconnectOutputError>
}

public struct DescribeConnectionsOnInterconnectInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeConnectionsOnInterconnectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConnectionsOnInterconnectInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConnectionsOnInterconnectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConnectionsOnInterconnectInput>
    public typealias MOutput = OperationOutput<DescribeConnectionsOnInterconnectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConnectionsOnInterconnectOutputError>
}

public struct DescribeConnectionsOnInterconnectInput: Equatable {
    /// <p>The ID of the interconnect.</p>
    public let interconnectId: String?

    public init (
        interconnectId: String? = nil
    )
    {
        self.interconnectId = interconnectId
    }
}

struct DescribeConnectionsOnInterconnectInputBody: Equatable {
    public let interconnectId: String?
}

extension DescribeConnectionsOnInterconnectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case interconnectId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interconnectIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .interconnectId)
        interconnectId = interconnectIdDecoded
    }
}

extension DescribeConnectionsOnInterconnectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConnectionsOnInterconnectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConnectionsOnInterconnectOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConnectionsOnInterconnectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConnectionsOnInterconnectOutputResponse(connections: \(String(describing: connections)))"}
}

extension DescribeConnectionsOnInterconnectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeConnectionsOnInterconnectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connections = output.connections
        } else {
            self.connections = nil
        }
    }
}

public struct DescribeConnectionsOnInterconnectOutputResponse: Equatable {
    /// <p>The connections.</p>
    public let connections: [Connection]?

    public init (
        connections: [Connection]? = nil
    )
    {
        self.connections = connections
    }
}

struct DescribeConnectionsOnInterconnectOutputResponseBody: Equatable {
    public let connections: [Connection]?
}

extension DescribeConnectionsOnInterconnectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connections
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionsContainer = try containerValues.decodeIfPresent([Connection?].self, forKey: .connections)
        var connectionsDecoded0:[Connection]? = nil
        if let connectionsContainer = connectionsContainer {
            connectionsDecoded0 = [Connection]()
            for structure0 in connectionsContainer {
                if let structure0 = structure0 {
                    connectionsDecoded0?.append(structure0)
                }
            }
        }
        connections = connectionsDecoded0
    }
}

extension DescribeConnectionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConnectionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConnectionsOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConnectionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConnectionsOutputResponse(connections: \(String(describing: connections)))"}
}

extension DescribeConnectionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeConnectionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connections = output.connections
        } else {
            self.connections = nil
        }
    }
}

public struct DescribeConnectionsOutputResponse: Equatable {
    /// <p>The connections.</p>
    public let connections: [Connection]?

    public init (
        connections: [Connection]? = nil
    )
    {
        self.connections = connections
    }
}

struct DescribeConnectionsOutputResponseBody: Equatable {
    public let connections: [Connection]?
}

extension DescribeConnectionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connections
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionsContainer = try containerValues.decodeIfPresent([Connection?].self, forKey: .connections)
        var connectionsDecoded0:[Connection]? = nil
        if let connectionsContainer = connectionsContainer {
            connectionsDecoded0 = [Connection]()
            for structure0 in connectionsContainer {
                if let structure0 = structure0 {
                    connectionsDecoded0?.append(structure0)
                }
            }
        }
        connections = connectionsDecoded0
    }
}

public struct DescribeDirectConnectGatewayAssociationProposalsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDirectConnectGatewayAssociationProposalsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDirectConnectGatewayAssociationProposalsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDirectConnectGatewayAssociationProposalsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDirectConnectGatewayAssociationProposalsInput>
    public typealias MOutput = OperationOutput<DescribeDirectConnectGatewayAssociationProposalsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDirectConnectGatewayAssociationProposalsOutputError>
}

extension DescribeDirectConnectGatewayAssociationProposalsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDirectConnectGatewayAssociationProposalsInput(associatedGatewayId: \(String(describing: associatedGatewayId)), directConnectGatewayId: \(String(describing: directConnectGatewayId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), proposalId: \(String(describing: proposalId)))"}
}

extension DescribeDirectConnectGatewayAssociationProposalsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associatedGatewayId
        case directConnectGatewayId
        case maxResults
        case nextToken
        case proposalId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedGatewayId = associatedGatewayId {
            try encodeContainer.encode(associatedGatewayId, forKey: .associatedGatewayId)
        }
        if let directConnectGatewayId = directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let proposalId = proposalId {
            try encodeContainer.encode(proposalId, forKey: .proposalId)
        }
    }
}

public struct DescribeDirectConnectGatewayAssociationProposalsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDirectConnectGatewayAssociationProposalsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDirectConnectGatewayAssociationProposalsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDirectConnectGatewayAssociationProposalsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDirectConnectGatewayAssociationProposalsInput>
    public typealias MOutput = OperationOutput<DescribeDirectConnectGatewayAssociationProposalsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDirectConnectGatewayAssociationProposalsOutputError>
}

public struct DescribeDirectConnectGatewayAssociationProposalsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDirectConnectGatewayAssociationProposalsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDirectConnectGatewayAssociationProposalsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDirectConnectGatewayAssociationProposalsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDirectConnectGatewayAssociationProposalsInput>
    public typealias MOutput = OperationOutput<DescribeDirectConnectGatewayAssociationProposalsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDirectConnectGatewayAssociationProposalsOutputError>
}

public struct DescribeDirectConnectGatewayAssociationProposalsInput: Equatable {
    /// <p>The ID of the associated gateway.</p>
    public let associatedGatewayId: String?
    /// <p>The ID of the Direct Connect gateway.</p>
    public let directConnectGatewayId: String?
    /// <p>The maximum number of results to return with a single call.
    /// 	To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    /// 	        <p>If <code>MaxResults</code> is given a value larger than 100, only 100 results are
    ///       returned.</p>
    public let maxResults: Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?
    /// <p>The ID of the proposal.</p>
    public let proposalId: String?

    public init (
        associatedGatewayId: String? = nil,
        directConnectGatewayId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        proposalId: String? = nil
    )
    {
        self.associatedGatewayId = associatedGatewayId
        self.directConnectGatewayId = directConnectGatewayId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.proposalId = proposalId
    }
}

struct DescribeDirectConnectGatewayAssociationProposalsInputBody: Equatable {
    public let directConnectGatewayId: String?
    public let proposalId: String?
    public let associatedGatewayId: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeDirectConnectGatewayAssociationProposalsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associatedGatewayId
        case directConnectGatewayId
        case maxResults
        case nextToken
        case proposalId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let proposalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .proposalId)
        proposalId = proposalIdDecoded
        let associatedGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associatedGatewayId)
        associatedGatewayId = associatedGatewayIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDirectConnectGatewayAssociationProposalsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDirectConnectGatewayAssociationProposalsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDirectConnectGatewayAssociationProposalsOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDirectConnectGatewayAssociationProposalsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDirectConnectGatewayAssociationProposalsOutputResponse(directConnectGatewayAssociationProposals: \(String(describing: directConnectGatewayAssociationProposals)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeDirectConnectGatewayAssociationProposalsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDirectConnectGatewayAssociationProposalsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directConnectGatewayAssociationProposals = output.directConnectGatewayAssociationProposals
            self.nextToken = output.nextToken
        } else {
            self.directConnectGatewayAssociationProposals = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeDirectConnectGatewayAssociationProposalsOutputResponse: Equatable {
    /// <p>Describes the Direct Connect gateway association proposals.</p>
    public let directConnectGatewayAssociationProposals: [DirectConnectGatewayAssociationProposal]?
    /// <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: String?

    public init (
        directConnectGatewayAssociationProposals: [DirectConnectGatewayAssociationProposal]? = nil,
        nextToken: String? = nil
    )
    {
        self.directConnectGatewayAssociationProposals = directConnectGatewayAssociationProposals
        self.nextToken = nextToken
    }
}

struct DescribeDirectConnectGatewayAssociationProposalsOutputResponseBody: Equatable {
    public let directConnectGatewayAssociationProposals: [DirectConnectGatewayAssociationProposal]?
    public let nextToken: String?
}

extension DescribeDirectConnectGatewayAssociationProposalsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directConnectGatewayAssociationProposals
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayAssociationProposalsContainer = try containerValues.decodeIfPresent([DirectConnectGatewayAssociationProposal?].self, forKey: .directConnectGatewayAssociationProposals)
        var directConnectGatewayAssociationProposalsDecoded0:[DirectConnectGatewayAssociationProposal]? = nil
        if let directConnectGatewayAssociationProposalsContainer = directConnectGatewayAssociationProposalsContainer {
            directConnectGatewayAssociationProposalsDecoded0 = [DirectConnectGatewayAssociationProposal]()
            for structure0 in directConnectGatewayAssociationProposalsContainer {
                if let structure0 = structure0 {
                    directConnectGatewayAssociationProposalsDecoded0?.append(structure0)
                }
            }
        }
        directConnectGatewayAssociationProposals = directConnectGatewayAssociationProposalsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeDirectConnectGatewayAssociationsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDirectConnectGatewayAssociationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDirectConnectGatewayAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDirectConnectGatewayAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDirectConnectGatewayAssociationsInput>
    public typealias MOutput = OperationOutput<DescribeDirectConnectGatewayAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDirectConnectGatewayAssociationsOutputError>
}

extension DescribeDirectConnectGatewayAssociationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDirectConnectGatewayAssociationsInput(associatedGatewayId: \(String(describing: associatedGatewayId)), associationId: \(String(describing: associationId)), directConnectGatewayId: \(String(describing: directConnectGatewayId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), virtualGatewayId: \(String(describing: virtualGatewayId)))"}
}

extension DescribeDirectConnectGatewayAssociationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associatedGatewayId
        case associationId
        case directConnectGatewayId
        case maxResults
        case nextToken
        case virtualGatewayId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedGatewayId = associatedGatewayId {
            try encodeContainer.encode(associatedGatewayId, forKey: .associatedGatewayId)
        }
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let directConnectGatewayId = directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let virtualGatewayId = virtualGatewayId {
            try encodeContainer.encode(virtualGatewayId, forKey: .virtualGatewayId)
        }
    }
}

public struct DescribeDirectConnectGatewayAssociationsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDirectConnectGatewayAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDirectConnectGatewayAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDirectConnectGatewayAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDirectConnectGatewayAssociationsInput>
    public typealias MOutput = OperationOutput<DescribeDirectConnectGatewayAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDirectConnectGatewayAssociationsOutputError>
}

public struct DescribeDirectConnectGatewayAssociationsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDirectConnectGatewayAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDirectConnectGatewayAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDirectConnectGatewayAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDirectConnectGatewayAssociationsInput>
    public typealias MOutput = OperationOutput<DescribeDirectConnectGatewayAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDirectConnectGatewayAssociationsOutputError>
}

public struct DescribeDirectConnectGatewayAssociationsInput: Equatable {
    /// <p>The ID of the associated gateway.</p>
    public let associatedGatewayId: String?
    /// <p>The ID of the Direct Connect gateway association.</p>
    public let associationId: String?
    /// <p>The ID of the Direct Connect gateway.</p>
    public let directConnectGatewayId: String?
    /// <p>The maximum number of results to return with a single call.
    /// 	To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    /// 	        <p>If <code>MaxResults</code> is given a value larger than 100, only 100 results are
    ///       returned.</p>
    public let maxResults: Int?
    /// <p>The token provided in the previous call to retrieve the next page.</p>
    public let nextToken: String?
    /// <p>The ID of the virtual private gateway or transit gateway.</p>
    public let virtualGatewayId: String?

    public init (
        associatedGatewayId: String? = nil,
        associationId: String? = nil,
        directConnectGatewayId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        virtualGatewayId: String? = nil
    )
    {
        self.associatedGatewayId = associatedGatewayId
        self.associationId = associationId
        self.directConnectGatewayId = directConnectGatewayId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.virtualGatewayId = virtualGatewayId
    }
}

struct DescribeDirectConnectGatewayAssociationsInputBody: Equatable {
    public let associationId: String?
    public let associatedGatewayId: String?
    public let directConnectGatewayId: String?
    public let maxResults: Int?
    public let nextToken: String?
    public let virtualGatewayId: String?
}

extension DescribeDirectConnectGatewayAssociationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associatedGatewayId
        case associationId
        case directConnectGatewayId
        case maxResults
        case nextToken
        case virtualGatewayId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let associatedGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associatedGatewayId)
        associatedGatewayId = associatedGatewayIdDecoded
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let virtualGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualGatewayId)
        virtualGatewayId = virtualGatewayIdDecoded
    }
}

extension DescribeDirectConnectGatewayAssociationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDirectConnectGatewayAssociationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDirectConnectGatewayAssociationsOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDirectConnectGatewayAssociationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDirectConnectGatewayAssociationsOutputResponse(directConnectGatewayAssociations: \(String(describing: directConnectGatewayAssociations)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeDirectConnectGatewayAssociationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDirectConnectGatewayAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directConnectGatewayAssociations = output.directConnectGatewayAssociations
            self.nextToken = output.nextToken
        } else {
            self.directConnectGatewayAssociations = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeDirectConnectGatewayAssociationsOutputResponse: Equatable {
    /// <p>Information about the associations.</p>
    public let directConnectGatewayAssociations: [DirectConnectGatewayAssociation]?
    /// <p>The token to retrieve the next page.</p>
    public let nextToken: String?

    public init (
        directConnectGatewayAssociations: [DirectConnectGatewayAssociation]? = nil,
        nextToken: String? = nil
    )
    {
        self.directConnectGatewayAssociations = directConnectGatewayAssociations
        self.nextToken = nextToken
    }
}

struct DescribeDirectConnectGatewayAssociationsOutputResponseBody: Equatable {
    public let directConnectGatewayAssociations: [DirectConnectGatewayAssociation]?
    public let nextToken: String?
}

extension DescribeDirectConnectGatewayAssociationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directConnectGatewayAssociations
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayAssociationsContainer = try containerValues.decodeIfPresent([DirectConnectGatewayAssociation?].self, forKey: .directConnectGatewayAssociations)
        var directConnectGatewayAssociationsDecoded0:[DirectConnectGatewayAssociation]? = nil
        if let directConnectGatewayAssociationsContainer = directConnectGatewayAssociationsContainer {
            directConnectGatewayAssociationsDecoded0 = [DirectConnectGatewayAssociation]()
            for structure0 in directConnectGatewayAssociationsContainer {
                if let structure0 = structure0 {
                    directConnectGatewayAssociationsDecoded0?.append(structure0)
                }
            }
        }
        directConnectGatewayAssociations = directConnectGatewayAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeDirectConnectGatewayAttachmentsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDirectConnectGatewayAttachmentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDirectConnectGatewayAttachmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDirectConnectGatewayAttachmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDirectConnectGatewayAttachmentsInput>
    public typealias MOutput = OperationOutput<DescribeDirectConnectGatewayAttachmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDirectConnectGatewayAttachmentsOutputError>
}

extension DescribeDirectConnectGatewayAttachmentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDirectConnectGatewayAttachmentsInput(directConnectGatewayId: \(String(describing: directConnectGatewayId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), virtualInterfaceId: \(String(describing: virtualInterfaceId)))"}
}

extension DescribeDirectConnectGatewayAttachmentsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directConnectGatewayId
        case maxResults
        case nextToken
        case virtualInterfaceId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directConnectGatewayId = directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let virtualInterfaceId = virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
    }
}

public struct DescribeDirectConnectGatewayAttachmentsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDirectConnectGatewayAttachmentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDirectConnectGatewayAttachmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDirectConnectGatewayAttachmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDirectConnectGatewayAttachmentsInput>
    public typealias MOutput = OperationOutput<DescribeDirectConnectGatewayAttachmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDirectConnectGatewayAttachmentsOutputError>
}

public struct DescribeDirectConnectGatewayAttachmentsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDirectConnectGatewayAttachmentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDirectConnectGatewayAttachmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDirectConnectGatewayAttachmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDirectConnectGatewayAttachmentsInput>
    public typealias MOutput = OperationOutput<DescribeDirectConnectGatewayAttachmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDirectConnectGatewayAttachmentsOutputError>
}

public struct DescribeDirectConnectGatewayAttachmentsInput: Equatable {
    /// <p>The ID of the Direct Connect gateway.</p>
    public let directConnectGatewayId: String?
    /// <p>The maximum number of results to return with a single call.
    /// 	To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    /// 	        <p>If <code>MaxResults</code> is given a value larger than 100, only 100 results are
    ///       returned.</p>
    public let maxResults: Int?
    /// <p>The token provided in the previous call to retrieve the next page.</p>
    public let nextToken: String?
    /// <p>The ID of the virtual interface.</p>
    public let virtualInterfaceId: String?

    public init (
        directConnectGatewayId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        virtualInterfaceId: String? = nil
    )
    {
        self.directConnectGatewayId = directConnectGatewayId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.virtualInterfaceId = virtualInterfaceId
    }
}

struct DescribeDirectConnectGatewayAttachmentsInputBody: Equatable {
    public let directConnectGatewayId: String?
    public let virtualInterfaceId: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeDirectConnectGatewayAttachmentsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directConnectGatewayId
        case maxResults
        case nextToken
        case virtualInterfaceId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDirectConnectGatewayAttachmentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDirectConnectGatewayAttachmentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDirectConnectGatewayAttachmentsOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDirectConnectGatewayAttachmentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDirectConnectGatewayAttachmentsOutputResponse(directConnectGatewayAttachments: \(String(describing: directConnectGatewayAttachments)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeDirectConnectGatewayAttachmentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDirectConnectGatewayAttachmentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directConnectGatewayAttachments = output.directConnectGatewayAttachments
            self.nextToken = output.nextToken
        } else {
            self.directConnectGatewayAttachments = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeDirectConnectGatewayAttachmentsOutputResponse: Equatable {
    /// <p>The attachments.</p>
    public let directConnectGatewayAttachments: [DirectConnectGatewayAttachment]?
    /// <p>The token to retrieve the next page.</p>
    public let nextToken: String?

    public init (
        directConnectGatewayAttachments: [DirectConnectGatewayAttachment]? = nil,
        nextToken: String? = nil
    )
    {
        self.directConnectGatewayAttachments = directConnectGatewayAttachments
        self.nextToken = nextToken
    }
}

struct DescribeDirectConnectGatewayAttachmentsOutputResponseBody: Equatable {
    public let directConnectGatewayAttachments: [DirectConnectGatewayAttachment]?
    public let nextToken: String?
}

extension DescribeDirectConnectGatewayAttachmentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directConnectGatewayAttachments
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayAttachmentsContainer = try containerValues.decodeIfPresent([DirectConnectGatewayAttachment?].self, forKey: .directConnectGatewayAttachments)
        var directConnectGatewayAttachmentsDecoded0:[DirectConnectGatewayAttachment]? = nil
        if let directConnectGatewayAttachmentsContainer = directConnectGatewayAttachmentsContainer {
            directConnectGatewayAttachmentsDecoded0 = [DirectConnectGatewayAttachment]()
            for structure0 in directConnectGatewayAttachmentsContainer {
                if let structure0 = structure0 {
                    directConnectGatewayAttachmentsDecoded0?.append(structure0)
                }
            }
        }
        directConnectGatewayAttachments = directConnectGatewayAttachmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeDirectConnectGatewaysInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDirectConnectGatewaysInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDirectConnectGatewaysInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDirectConnectGatewaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDirectConnectGatewaysInput>
    public typealias MOutput = OperationOutput<DescribeDirectConnectGatewaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDirectConnectGatewaysOutputError>
}

extension DescribeDirectConnectGatewaysInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDirectConnectGatewaysInput(directConnectGatewayId: \(String(describing: directConnectGatewayId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeDirectConnectGatewaysInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directConnectGatewayId
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directConnectGatewayId = directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeDirectConnectGatewaysInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDirectConnectGatewaysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDirectConnectGatewaysInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDirectConnectGatewaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDirectConnectGatewaysInput>
    public typealias MOutput = OperationOutput<DescribeDirectConnectGatewaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDirectConnectGatewaysOutputError>
}

public struct DescribeDirectConnectGatewaysInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDirectConnectGatewaysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDirectConnectGatewaysInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDirectConnectGatewaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDirectConnectGatewaysInput>
    public typealias MOutput = OperationOutput<DescribeDirectConnectGatewaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDirectConnectGatewaysOutputError>
}

public struct DescribeDirectConnectGatewaysInput: Equatable {
    /// <p>The ID of the Direct Connect gateway.</p>
    public let directConnectGatewayId: String?
    /// <p>The maximum number of results to return with a single call.
    /// 	To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    /// 	        <p>If <code>MaxResults</code> is given a value larger than 100, only 100 results are
    ///       returned.</p>
    public let maxResults: Int?
    /// <p>The token provided in the previous call to retrieve the next page.</p>
    public let nextToken: String?

    public init (
        directConnectGatewayId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.directConnectGatewayId = directConnectGatewayId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeDirectConnectGatewaysInputBody: Equatable {
    public let directConnectGatewayId: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeDirectConnectGatewaysInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directConnectGatewayId
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDirectConnectGatewaysOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDirectConnectGatewaysOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDirectConnectGatewaysOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDirectConnectGatewaysOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDirectConnectGatewaysOutputResponse(directConnectGateways: \(String(describing: directConnectGateways)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeDirectConnectGatewaysOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDirectConnectGatewaysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directConnectGateways = output.directConnectGateways
            self.nextToken = output.nextToken
        } else {
            self.directConnectGateways = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeDirectConnectGatewaysOutputResponse: Equatable {
    /// <p>The Direct Connect gateways.</p>
    public let directConnectGateways: [DirectConnectGateway]?
    /// <p>The token to retrieve the next page.</p>
    public let nextToken: String?

    public init (
        directConnectGateways: [DirectConnectGateway]? = nil,
        nextToken: String? = nil
    )
    {
        self.directConnectGateways = directConnectGateways
        self.nextToken = nextToken
    }
}

struct DescribeDirectConnectGatewaysOutputResponseBody: Equatable {
    public let directConnectGateways: [DirectConnectGateway]?
    public let nextToken: String?
}

extension DescribeDirectConnectGatewaysOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directConnectGateways
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewaysContainer = try containerValues.decodeIfPresent([DirectConnectGateway?].self, forKey: .directConnectGateways)
        var directConnectGatewaysDecoded0:[DirectConnectGateway]? = nil
        if let directConnectGatewaysContainer = directConnectGatewaysContainer {
            directConnectGatewaysDecoded0 = [DirectConnectGateway]()
            for structure0 in directConnectGatewaysContainer {
                if let structure0 = structure0 {
                    directConnectGatewaysDecoded0?.append(structure0)
                }
            }
        }
        directConnectGateways = directConnectGatewaysDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeHostedConnectionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeHostedConnectionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeHostedConnectionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeHostedConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeHostedConnectionsInput>
    public typealias MOutput = OperationOutput<DescribeHostedConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeHostedConnectionsOutputError>
}

extension DescribeHostedConnectionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeHostedConnectionsInput(connectionId: \(String(describing: connectionId)))"}
}

extension DescribeHostedConnectionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
    }
}

public struct DescribeHostedConnectionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeHostedConnectionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeHostedConnectionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeHostedConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeHostedConnectionsInput>
    public typealias MOutput = OperationOutput<DescribeHostedConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeHostedConnectionsOutputError>
}

public struct DescribeHostedConnectionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeHostedConnectionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeHostedConnectionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeHostedConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeHostedConnectionsInput>
    public typealias MOutput = OperationOutput<DescribeHostedConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeHostedConnectionsOutputError>
}

public struct DescribeHostedConnectionsInput: Equatable {
    /// <p>The ID of the interconnect or LAG.</p>
    public let connectionId: String?

    public init (
        connectionId: String? = nil
    )
    {
        self.connectionId = connectionId
    }
}

struct DescribeHostedConnectionsInputBody: Equatable {
    public let connectionId: String?
}

extension DescribeHostedConnectionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
    }
}

extension DescribeHostedConnectionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeHostedConnectionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeHostedConnectionsOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeHostedConnectionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeHostedConnectionsOutputResponse(connections: \(String(describing: connections)))"}
}

extension DescribeHostedConnectionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeHostedConnectionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connections = output.connections
        } else {
            self.connections = nil
        }
    }
}

public struct DescribeHostedConnectionsOutputResponse: Equatable {
    /// <p>The connections.</p>
    public let connections: [Connection]?

    public init (
        connections: [Connection]? = nil
    )
    {
        self.connections = connections
    }
}

struct DescribeHostedConnectionsOutputResponseBody: Equatable {
    public let connections: [Connection]?
}

extension DescribeHostedConnectionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connections
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionsContainer = try containerValues.decodeIfPresent([Connection?].self, forKey: .connections)
        var connectionsDecoded0:[Connection]? = nil
        if let connectionsContainer = connectionsContainer {
            connectionsDecoded0 = [Connection]()
            for structure0 in connectionsContainer {
                if let structure0 = structure0 {
                    connectionsDecoded0?.append(structure0)
                }
            }
        }
        connections = connectionsDecoded0
    }
}

public struct DescribeInterconnectLoaInputBodyMiddleware: Middleware {
    public let id: String = "DescribeInterconnectLoaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInterconnectLoaInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInterconnectLoaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInterconnectLoaInput>
    public typealias MOutput = OperationOutput<DescribeInterconnectLoaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInterconnectLoaOutputError>
}

extension DescribeInterconnectLoaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInterconnectLoaInput(interconnectId: \(String(describing: interconnectId)), loaContentType: \(String(describing: loaContentType)), providerName: \(String(describing: providerName)))"}
}

extension DescribeInterconnectLoaInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case interconnectId
        case loaContentType
        case providerName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let interconnectId = interconnectId {
            try encodeContainer.encode(interconnectId, forKey: .interconnectId)
        }
        if let loaContentType = loaContentType {
            try encodeContainer.encode(loaContentType.rawValue, forKey: .loaContentType)
        }
        if let providerName = providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
    }
}

public struct DescribeInterconnectLoaInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeInterconnectLoaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInterconnectLoaInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInterconnectLoaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInterconnectLoaInput>
    public typealias MOutput = OperationOutput<DescribeInterconnectLoaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInterconnectLoaOutputError>
}

public struct DescribeInterconnectLoaInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeInterconnectLoaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInterconnectLoaInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInterconnectLoaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInterconnectLoaInput>
    public typealias MOutput = OperationOutput<DescribeInterconnectLoaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInterconnectLoaOutputError>
}

public struct DescribeInterconnectLoaInput: Equatable {
    /// <p>The ID of the interconnect.</p>
    public let interconnectId: String?
    /// <p>The standard media type for the LOA-CFA document. The only supported value is application/pdf.</p>
    public let loaContentType: LoaContentType?
    /// <p>The name of the service provider who establishes connectivity on your behalf. If you supply this parameter, the LOA-CFA lists the provider name alongside your company name as the requester of the cross connect.</p>
    public let providerName: String?

    public init (
        interconnectId: String? = nil,
        loaContentType: LoaContentType? = nil,
        providerName: String? = nil
    )
    {
        self.interconnectId = interconnectId
        self.loaContentType = loaContentType
        self.providerName = providerName
    }
}

struct DescribeInterconnectLoaInputBody: Equatable {
    public let interconnectId: String?
    public let providerName: String?
    public let loaContentType: LoaContentType?
}

extension DescribeInterconnectLoaInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case interconnectId
        case loaContentType
        case providerName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interconnectIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .interconnectId)
        interconnectId = interconnectIdDecoded
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let loaContentTypeDecoded = try containerValues.decodeIfPresent(LoaContentType.self, forKey: .loaContentType)
        loaContentType = loaContentTypeDecoded
    }
}

extension DescribeInterconnectLoaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInterconnectLoaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInterconnectLoaOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInterconnectLoaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInterconnectLoaOutputResponse(loa: \(String(describing: loa)))"}
}

extension DescribeInterconnectLoaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeInterconnectLoaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loa = output.loa
        } else {
            self.loa = nil
        }
    }
}

public struct DescribeInterconnectLoaOutputResponse: Equatable {
    /// <p>The Letter of Authorization - Connecting Facility Assignment (LOA-CFA).</p>
    public let loa: Loa?

    public init (
        loa: Loa? = nil
    )
    {
        self.loa = loa
    }
}

struct DescribeInterconnectLoaOutputResponseBody: Equatable {
    public let loa: Loa?
}

extension DescribeInterconnectLoaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case loa
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loaDecoded = try containerValues.decodeIfPresent(Loa.self, forKey: .loa)
        loa = loaDecoded
    }
}

public struct DescribeInterconnectsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeInterconnectsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInterconnectsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInterconnectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInterconnectsInput>
    public typealias MOutput = OperationOutput<DescribeInterconnectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInterconnectsOutputError>
}

extension DescribeInterconnectsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInterconnectsInput(interconnectId: \(String(describing: interconnectId)))"}
}

extension DescribeInterconnectsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case interconnectId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let interconnectId = interconnectId {
            try encodeContainer.encode(interconnectId, forKey: .interconnectId)
        }
    }
}

public struct DescribeInterconnectsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeInterconnectsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInterconnectsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInterconnectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInterconnectsInput>
    public typealias MOutput = OperationOutput<DescribeInterconnectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInterconnectsOutputError>
}

public struct DescribeInterconnectsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeInterconnectsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInterconnectsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInterconnectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInterconnectsInput>
    public typealias MOutput = OperationOutput<DescribeInterconnectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInterconnectsOutputError>
}

public struct DescribeInterconnectsInput: Equatable {
    /// <p>The ID of the interconnect.</p>
    public let interconnectId: String?

    public init (
        interconnectId: String? = nil
    )
    {
        self.interconnectId = interconnectId
    }
}

struct DescribeInterconnectsInputBody: Equatable {
    public let interconnectId: String?
}

extension DescribeInterconnectsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case interconnectId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interconnectIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .interconnectId)
        interconnectId = interconnectIdDecoded
    }
}

extension DescribeInterconnectsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInterconnectsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInterconnectsOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInterconnectsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInterconnectsOutputResponse(interconnects: \(String(describing: interconnects)))"}
}

extension DescribeInterconnectsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeInterconnectsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.interconnects = output.interconnects
        } else {
            self.interconnects = nil
        }
    }
}

public struct DescribeInterconnectsOutputResponse: Equatable {
    /// <p>The interconnects.</p>
    public let interconnects: [Interconnect]?

    public init (
        interconnects: [Interconnect]? = nil
    )
    {
        self.interconnects = interconnects
    }
}

struct DescribeInterconnectsOutputResponseBody: Equatable {
    public let interconnects: [Interconnect]?
}

extension DescribeInterconnectsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case interconnects
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interconnectsContainer = try containerValues.decodeIfPresent([Interconnect?].self, forKey: .interconnects)
        var interconnectsDecoded0:[Interconnect]? = nil
        if let interconnectsContainer = interconnectsContainer {
            interconnectsDecoded0 = [Interconnect]()
            for structure0 in interconnectsContainer {
                if let structure0 = structure0 {
                    interconnectsDecoded0?.append(structure0)
                }
            }
        }
        interconnects = interconnectsDecoded0
    }
}

public struct DescribeLagsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeLagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLagsInput>
    public typealias MOutput = OperationOutput<DescribeLagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLagsOutputError>
}

extension DescribeLagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLagsInput(lagId: \(String(describing: lagId)))"}
}

extension DescribeLagsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lagId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lagId = lagId {
            try encodeContainer.encode(lagId, forKey: .lagId)
        }
    }
}

public struct DescribeLagsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeLagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLagsInput>
    public typealias MOutput = OperationOutput<DescribeLagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLagsOutputError>
}

public struct DescribeLagsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeLagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLagsInput>
    public typealias MOutput = OperationOutput<DescribeLagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLagsOutputError>
}

public struct DescribeLagsInput: Equatable {
    /// <p>The ID of the LAG.</p>
    public let lagId: String?

    public init (
        lagId: String? = nil
    )
    {
        self.lagId = lagId
    }
}

struct DescribeLagsInputBody: Equatable {
    public let lagId: String?
}

extension DescribeLagsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lagId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lagIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lagId)
        lagId = lagIdDecoded
    }
}

extension DescribeLagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLagsOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLagsOutputResponse(lags: \(String(describing: lags)))"}
}

extension DescribeLagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeLagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lags = output.lags
        } else {
            self.lags = nil
        }
    }
}

public struct DescribeLagsOutputResponse: Equatable {
    /// <p>The LAGs.</p>
    public let lags: [Lag]?

    public init (
        lags: [Lag]? = nil
    )
    {
        self.lags = lags
    }
}

struct DescribeLagsOutputResponseBody: Equatable {
    public let lags: [Lag]?
}

extension DescribeLagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lagsContainer = try containerValues.decodeIfPresent([Lag?].self, forKey: .lags)
        var lagsDecoded0:[Lag]? = nil
        if let lagsContainer = lagsContainer {
            lagsDecoded0 = [Lag]()
            for structure0 in lagsContainer {
                if let structure0 = structure0 {
                    lagsDecoded0?.append(structure0)
                }
            }
        }
        lags = lagsDecoded0
    }
}

public struct DescribeLoaInputBodyMiddleware: Middleware {
    public let id: String = "DescribeLoaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoaInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoaInput>
    public typealias MOutput = OperationOutput<DescribeLoaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoaOutputError>
}

extension DescribeLoaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLoaInput(connectionId: \(String(describing: connectionId)), loaContentType: \(String(describing: loaContentType)), providerName: \(String(describing: providerName)))"}
}

extension DescribeLoaInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case loaContentType
        case providerName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let loaContentType = loaContentType {
            try encodeContainer.encode(loaContentType.rawValue, forKey: .loaContentType)
        }
        if let providerName = providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
    }
}

public struct DescribeLoaInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeLoaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoaInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoaInput>
    public typealias MOutput = OperationOutput<DescribeLoaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoaOutputError>
}

public struct DescribeLoaInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeLoaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoaInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoaInput>
    public typealias MOutput = OperationOutput<DescribeLoaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoaOutputError>
}

public struct DescribeLoaInput: Equatable {
    /// <p>The ID of a connection, LAG, or interconnect.</p>
    public let connectionId: String?
    /// <p>The standard media type for the LOA-CFA document. The only supported value is application/pdf.</p>
    public let loaContentType: LoaContentType?
    /// <p>The name of the service provider who establishes connectivity on your behalf. If you specify this parameter, the
    ///       LOA-CFA lists the provider name alongside your company name as the requester of the cross connect.</p>
    public let providerName: String?

    public init (
        connectionId: String? = nil,
        loaContentType: LoaContentType? = nil,
        providerName: String? = nil
    )
    {
        self.connectionId = connectionId
        self.loaContentType = loaContentType
        self.providerName = providerName
    }
}

struct DescribeLoaInputBody: Equatable {
    public let connectionId: String?
    public let providerName: String?
    public let loaContentType: LoaContentType?
}

extension DescribeLoaInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case loaContentType
        case providerName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let loaContentTypeDecoded = try containerValues.decodeIfPresent(LoaContentType.self, forKey: .loaContentType)
        loaContentType = loaContentTypeDecoded
    }
}

extension DescribeLoaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLoaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLoaOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLoaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLoaOutputResponse(loaContent: \(String(describing: loaContent)), loaContentType: \(String(describing: loaContentType)))"}
}

extension DescribeLoaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeLoaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loaContent = output.loaContent
            self.loaContentType = output.loaContentType
        } else {
            self.loaContent = nil
            self.loaContentType = nil
        }
    }
}

/// <p>Information about a Letter of Authorization - Connecting Facility Assignment (LOA-CFA) for a connection.</p>
public struct DescribeLoaOutputResponse: Equatable {
    /// <p>The binary contents of the LOA-CFA document.</p>
    public let loaContent: Data?
    /// <p>The standard media type for the LOA-CFA document. The only supported value is application/pdf.</p>
    public let loaContentType: LoaContentType?

    public init (
        loaContent: Data? = nil,
        loaContentType: LoaContentType? = nil
    )
    {
        self.loaContent = loaContent
        self.loaContentType = loaContentType
    }
}

struct DescribeLoaOutputResponseBody: Equatable {
    public let loaContent: Data?
    public let loaContentType: LoaContentType?
}

extension DescribeLoaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case loaContent
        case loaContentType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loaContentDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .loaContent)
        loaContent = loaContentDecoded
        let loaContentTypeDecoded = try containerValues.decodeIfPresent(LoaContentType.self, forKey: .loaContentType)
        loaContentType = loaContentTypeDecoded
    }
}

extension DescribeLocationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLocationsInput()"}
}

extension DescribeLocationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeLocationsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeLocationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLocationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLocationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLocationsInput>
    public typealias MOutput = OperationOutput<DescribeLocationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLocationsOutputError>
}

public struct DescribeLocationsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeLocationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLocationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLocationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLocationsInput>
    public typealias MOutput = OperationOutput<DescribeLocationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLocationsOutputError>
}

public struct DescribeLocationsInput: Equatable {

    public init() {}
}

struct DescribeLocationsInputBody: Equatable {
}

extension DescribeLocationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeLocationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLocationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLocationsOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLocationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLocationsOutputResponse(locations: \(String(describing: locations)))"}
}

extension DescribeLocationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeLocationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.locations = output.locations
        } else {
            self.locations = nil
        }
    }
}

public struct DescribeLocationsOutputResponse: Equatable {
    /// <p>The locations.</p>
    public let locations: [Location]?

    public init (
        locations: [Location]? = nil
    )
    {
        self.locations = locations
    }
}

struct DescribeLocationsOutputResponseBody: Equatable {
    public let locations: [Location]?
}

extension DescribeLocationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case locations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationsContainer = try containerValues.decodeIfPresent([Location?].self, forKey: .locations)
        var locationsDecoded0:[Location]? = nil
        if let locationsContainer = locationsContainer {
            locationsDecoded0 = [Location]()
            for structure0 in locationsContainer {
                if let structure0 = structure0 {
                    locationsDecoded0?.append(structure0)
                }
            }
        }
        locations = locationsDecoded0
    }
}

public struct DescribeTagsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTagsInput>
    public typealias MOutput = OperationOutput<DescribeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTagsOutputError>
}

extension DescribeTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTagsInput(resourceArns: \(String(describing: resourceArns)))"}
}

extension DescribeTagsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArns
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnlist0)
            }
        }
    }
}

public struct DescribeTagsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTagsInput>
    public typealias MOutput = OperationOutput<DescribeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTagsOutputError>
}

public struct DescribeTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTagsInput>
    public typealias MOutput = OperationOutput<DescribeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTagsOutputError>
}

public struct DescribeTagsInput: Equatable {
    /// <p>The Amazon Resource Names (ARNs) of the resources.</p>
    public let resourceArns: [String]?

    public init (
        resourceArns: [String]? = nil
    )
    {
        self.resourceArns = resourceArns
    }
}

struct DescribeTagsInputBody: Equatable {
    public let resourceArns: [String]?
}

extension DescribeTagsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArns
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
    }
}

extension DescribeTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTagsOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTagsOutputResponse(resourceTags: \(String(describing: resourceTags)))"}
}

extension DescribeTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceTags = output.resourceTags
        } else {
            self.resourceTags = nil
        }
    }
}

public struct DescribeTagsOutputResponse: Equatable {
    /// <p>Information about the tags.</p>
    public let resourceTags: [ResourceTag]?

    public init (
        resourceTags: [ResourceTag]? = nil
    )
    {
        self.resourceTags = resourceTags
    }
}

struct DescribeTagsOutputResponseBody: Equatable {
    public let resourceTags: [ResourceTag]?
}

extension DescribeTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceTags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTagsContainer = try containerValues.decodeIfPresent([ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
    }
}

extension DescribeVirtualGatewaysInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeVirtualGatewaysInput()"}
}

extension DescribeVirtualGatewaysInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeVirtualGatewaysInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeVirtualGatewaysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeVirtualGatewaysInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeVirtualGatewaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeVirtualGatewaysInput>
    public typealias MOutput = OperationOutput<DescribeVirtualGatewaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeVirtualGatewaysOutputError>
}

public struct DescribeVirtualGatewaysInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeVirtualGatewaysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeVirtualGatewaysInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeVirtualGatewaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeVirtualGatewaysInput>
    public typealias MOutput = OperationOutput<DescribeVirtualGatewaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeVirtualGatewaysOutputError>
}

public struct DescribeVirtualGatewaysInput: Equatable {

    public init() {}
}

struct DescribeVirtualGatewaysInputBody: Equatable {
}

extension DescribeVirtualGatewaysInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeVirtualGatewaysOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVirtualGatewaysOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeVirtualGatewaysOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVirtualGatewaysOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeVirtualGatewaysOutputResponse(virtualGateways: \(String(describing: virtualGateways)))"}
}

extension DescribeVirtualGatewaysOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeVirtualGatewaysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.virtualGateways = output.virtualGateways
        } else {
            self.virtualGateways = nil
        }
    }
}

public struct DescribeVirtualGatewaysOutputResponse: Equatable {
    /// <p>The virtual private gateways.</p>
    public let virtualGateways: [VirtualGateway]?

    public init (
        virtualGateways: [VirtualGateway]? = nil
    )
    {
        self.virtualGateways = virtualGateways
    }
}

struct DescribeVirtualGatewaysOutputResponseBody: Equatable {
    public let virtualGateways: [VirtualGateway]?
}

extension DescribeVirtualGatewaysOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualGateways
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualGatewaysContainer = try containerValues.decodeIfPresent([VirtualGateway?].self, forKey: .virtualGateways)
        var virtualGatewaysDecoded0:[VirtualGateway]? = nil
        if let virtualGatewaysContainer = virtualGatewaysContainer {
            virtualGatewaysDecoded0 = [VirtualGateway]()
            for structure0 in virtualGatewaysContainer {
                if let structure0 = structure0 {
                    virtualGatewaysDecoded0?.append(structure0)
                }
            }
        }
        virtualGateways = virtualGatewaysDecoded0
    }
}

public struct DescribeVirtualInterfacesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeVirtualInterfacesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeVirtualInterfacesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeVirtualInterfacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeVirtualInterfacesInput>
    public typealias MOutput = OperationOutput<DescribeVirtualInterfacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeVirtualInterfacesOutputError>
}

extension DescribeVirtualInterfacesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeVirtualInterfacesInput(connectionId: \(String(describing: connectionId)), virtualInterfaceId: \(String(describing: virtualInterfaceId)))"}
}

extension DescribeVirtualInterfacesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case virtualInterfaceId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let virtualInterfaceId = virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
    }
}

public struct DescribeVirtualInterfacesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeVirtualInterfacesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeVirtualInterfacesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeVirtualInterfacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeVirtualInterfacesInput>
    public typealias MOutput = OperationOutput<DescribeVirtualInterfacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeVirtualInterfacesOutputError>
}

public struct DescribeVirtualInterfacesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeVirtualInterfacesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeVirtualInterfacesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeVirtualInterfacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeVirtualInterfacesInput>
    public typealias MOutput = OperationOutput<DescribeVirtualInterfacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeVirtualInterfacesOutputError>
}

public struct DescribeVirtualInterfacesInput: Equatable {
    /// <p>The ID of the connection.</p>
    public let connectionId: String?
    /// <p>The ID of the virtual interface.</p>
    public let virtualInterfaceId: String?

    public init (
        connectionId: String? = nil,
        virtualInterfaceId: String? = nil
    )
    {
        self.connectionId = connectionId
        self.virtualInterfaceId = virtualInterfaceId
    }
}

struct DescribeVirtualInterfacesInputBody: Equatable {
    public let connectionId: String?
    public let virtualInterfaceId: String?
}

extension DescribeVirtualInterfacesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case virtualInterfaceId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
    }
}

extension DescribeVirtualInterfacesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVirtualInterfacesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeVirtualInterfacesOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVirtualInterfacesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeVirtualInterfacesOutputResponse(virtualInterfaces: \(String(describing: virtualInterfaces)))"}
}

extension DescribeVirtualInterfacesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeVirtualInterfacesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.virtualInterfaces = output.virtualInterfaces
        } else {
            self.virtualInterfaces = nil
        }
    }
}

public struct DescribeVirtualInterfacesOutputResponse: Equatable {
    /// <p>The virtual interfaces</p>
    public let virtualInterfaces: [VirtualInterface]?

    public init (
        virtualInterfaces: [VirtualInterface]? = nil
    )
    {
        self.virtualInterfaces = virtualInterfaces
    }
}

struct DescribeVirtualInterfacesOutputResponseBody: Equatable {
    public let virtualInterfaces: [VirtualInterface]?
}

extension DescribeVirtualInterfacesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualInterfaces
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfacesContainer = try containerValues.decodeIfPresent([VirtualInterface?].self, forKey: .virtualInterfaces)
        var virtualInterfacesDecoded0:[VirtualInterface]? = nil
        if let virtualInterfacesContainer = virtualInterfacesContainer {
            virtualInterfacesDecoded0 = [VirtualInterface]()
            for structure0 in virtualInterfacesContainer {
                if let structure0 = structure0 {
                    virtualInterfacesDecoded0?.append(structure0)
                }
            }
        }
        virtualInterfaces = virtualInterfacesDecoded0
    }
}

extension DirectConnectClientException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DirectConnectClientException(message: \(String(describing: message)))"}
}

extension DirectConnectClientException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DirectConnectClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more parameters are not valid.</p>
public struct DirectConnectClientException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DirectConnectClientExceptionBody: Equatable {
    public let message: String?
}

extension DirectConnectClientExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DirectConnectGateway: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amazonSideAsn
        case directConnectGatewayId
        case directConnectGatewayName
        case directConnectGatewayState
        case ownerAccount
        case stateChangeError
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonSideAsn = amazonSideAsn {
            try encodeContainer.encode(amazonSideAsn, forKey: .amazonSideAsn)
        }
        if let directConnectGatewayId = directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let directConnectGatewayName = directConnectGatewayName {
            try encodeContainer.encode(directConnectGatewayName, forKey: .directConnectGatewayName)
        }
        if let directConnectGatewayState = directConnectGatewayState {
            try encodeContainer.encode(directConnectGatewayState.rawValue, forKey: .directConnectGatewayState)
        }
        if let ownerAccount = ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
        if let stateChangeError = stateChangeError {
            try encodeContainer.encode(stateChangeError, forKey: .stateChangeError)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let directConnectGatewayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directConnectGatewayName)
        directConnectGatewayName = directConnectGatewayNameDecoded
        let amazonSideAsnDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .amazonSideAsn)
        amazonSideAsn = amazonSideAsnDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let directConnectGatewayStateDecoded = try containerValues.decodeIfPresent(DirectConnectGatewayState.self, forKey: .directConnectGatewayState)
        directConnectGatewayState = directConnectGatewayStateDecoded
        let stateChangeErrorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateChangeError)
        stateChangeError = stateChangeErrorDecoded
    }
}

extension DirectConnectGateway: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DirectConnectGateway(amazonSideAsn: \(String(describing: amazonSideAsn)), directConnectGatewayId: \(String(describing: directConnectGatewayId)), directConnectGatewayName: \(String(describing: directConnectGatewayName)), directConnectGatewayState: \(String(describing: directConnectGatewayState)), ownerAccount: \(String(describing: ownerAccount)), stateChangeError: \(String(describing: stateChangeError)))"}
}

/// <p>Information about a Direct Connect gateway, which enables you to connect virtual interfaces and virtual private gateway or transit gateways.</p>
public struct DirectConnectGateway: Equatable {
    /// <p>The autonomous system number (ASN) for the Amazon side of the connection.</p>
    public let amazonSideAsn: Int?
    /// <p>The ID of the Direct Connect gateway.</p>
    public let directConnectGatewayId: String?
    /// <p>The name of the Direct Connect gateway.</p>
    public let directConnectGatewayName: String?
    /// <p>The state of the Direct Connect gateway. The following are the possible values:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: The initial state after calling <a>CreateDirectConnectGateway</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>available</code>: The Direct Connect gateway is ready for use.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>: The initial state after calling <a>DeleteDirectConnectGateway</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>: The Direct Connect gateway is deleted and cannot pass traffic.</p>
    ///             </li>
    ///          </ul>
    public let directConnectGatewayState: DirectConnectGatewayState?
    /// <p>The ID of the AWS account that owns the Direct Connect gateway.</p>
    public let ownerAccount: String?
    /// <p>The error message if the state of an object failed to advance.</p>
    public let stateChangeError: String?

    public init (
        amazonSideAsn: Int? = nil,
        directConnectGatewayId: String? = nil,
        directConnectGatewayName: String? = nil,
        directConnectGatewayState: DirectConnectGatewayState? = nil,
        ownerAccount: String? = nil,
        stateChangeError: String? = nil
    )
    {
        self.amazonSideAsn = amazonSideAsn
        self.directConnectGatewayId = directConnectGatewayId
        self.directConnectGatewayName = directConnectGatewayName
        self.directConnectGatewayState = directConnectGatewayState
        self.ownerAccount = ownerAccount
        self.stateChangeError = stateChangeError
    }
}

extension DirectConnectGatewayAssociation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedPrefixesToDirectConnectGateway
        case associatedGateway
        case associationId
        case associationState
        case directConnectGatewayId
        case directConnectGatewayOwnerAccount
        case stateChangeError
        case virtualGatewayId
        case virtualGatewayOwnerAccount
        case virtualGatewayRegion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedPrefixesToDirectConnectGateway = allowedPrefixesToDirectConnectGateway {
            var allowedPrefixesToDirectConnectGatewayContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedPrefixesToDirectConnectGateway)
            for routefilterprefixlist0 in allowedPrefixesToDirectConnectGateway {
                try allowedPrefixesToDirectConnectGatewayContainer.encode(routefilterprefixlist0)
            }
        }
        if let associatedGateway = associatedGateway {
            try encodeContainer.encode(associatedGateway, forKey: .associatedGateway)
        }
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationState = associationState {
            try encodeContainer.encode(associationState.rawValue, forKey: .associationState)
        }
        if let directConnectGatewayId = directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let directConnectGatewayOwnerAccount = directConnectGatewayOwnerAccount {
            try encodeContainer.encode(directConnectGatewayOwnerAccount, forKey: .directConnectGatewayOwnerAccount)
        }
        if let stateChangeError = stateChangeError {
            try encodeContainer.encode(stateChangeError, forKey: .stateChangeError)
        }
        if let virtualGatewayId = virtualGatewayId {
            try encodeContainer.encode(virtualGatewayId, forKey: .virtualGatewayId)
        }
        if let virtualGatewayOwnerAccount = virtualGatewayOwnerAccount {
            try encodeContainer.encode(virtualGatewayOwnerAccount, forKey: .virtualGatewayOwnerAccount)
        }
        if let virtualGatewayRegion = virtualGatewayRegion {
            try encodeContainer.encode(virtualGatewayRegion, forKey: .virtualGatewayRegion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let directConnectGatewayOwnerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directConnectGatewayOwnerAccount)
        directConnectGatewayOwnerAccount = directConnectGatewayOwnerAccountDecoded
        let associationStateDecoded = try containerValues.decodeIfPresent(DirectConnectGatewayAssociationState.self, forKey: .associationState)
        associationState = associationStateDecoded
        let stateChangeErrorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateChangeError)
        stateChangeError = stateChangeErrorDecoded
        let associatedGatewayDecoded = try containerValues.decodeIfPresent(AssociatedGateway.self, forKey: .associatedGateway)
        associatedGateway = associatedGatewayDecoded
        let associationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let allowedPrefixesToDirectConnectGatewayContainer = try containerValues.decodeIfPresent([RouteFilterPrefix?].self, forKey: .allowedPrefixesToDirectConnectGateway)
        var allowedPrefixesToDirectConnectGatewayDecoded0:[RouteFilterPrefix]? = nil
        if let allowedPrefixesToDirectConnectGatewayContainer = allowedPrefixesToDirectConnectGatewayContainer {
            allowedPrefixesToDirectConnectGatewayDecoded0 = [RouteFilterPrefix]()
            for structure0 in allowedPrefixesToDirectConnectGatewayContainer {
                if let structure0 = structure0 {
                    allowedPrefixesToDirectConnectGatewayDecoded0?.append(structure0)
                }
            }
        }
        allowedPrefixesToDirectConnectGateway = allowedPrefixesToDirectConnectGatewayDecoded0
        let virtualGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualGatewayId)
        virtualGatewayId = virtualGatewayIdDecoded
        let virtualGatewayRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualGatewayRegion)
        virtualGatewayRegion = virtualGatewayRegionDecoded
        let virtualGatewayOwnerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualGatewayOwnerAccount)
        virtualGatewayOwnerAccount = virtualGatewayOwnerAccountDecoded
    }
}

extension DirectConnectGatewayAssociation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DirectConnectGatewayAssociation(allowedPrefixesToDirectConnectGateway: \(String(describing: allowedPrefixesToDirectConnectGateway)), associatedGateway: \(String(describing: associatedGateway)), associationId: \(String(describing: associationId)), associationState: \(String(describing: associationState)), directConnectGatewayId: \(String(describing: directConnectGatewayId)), directConnectGatewayOwnerAccount: \(String(describing: directConnectGatewayOwnerAccount)), stateChangeError: \(String(describing: stateChangeError)), virtualGatewayId: \(String(describing: virtualGatewayId)), virtualGatewayOwnerAccount: \(String(describing: virtualGatewayOwnerAccount)), virtualGatewayRegion: \(String(describing: virtualGatewayRegion)))"}
}

/// <p>Information about an association between a Direct Connect gateway and a virtual private gateway or transit gateway.</p>
public struct DirectConnectGatewayAssociation: Equatable {
    /// <p>The Amazon VPC prefixes to advertise to the Direct Connect gateway.</p>
    public let allowedPrefixesToDirectConnectGateway: [RouteFilterPrefix]?
    /// <p>Information about the associated gateway.</p>
    public let associatedGateway: AssociatedGateway?
    /// <p>The ID of the Direct Connect gateway association.</p>
    public let associationId: String?
    /// <p>The state of the association. The following are the possible values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>associating</code>: The initial state after calling <a>CreateDirectConnectGatewayAssociation</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>associated</code>: The Direct Connect gateway and virtual private gateway or transit gateway are successfully associated and ready to pass traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>disassociating</code>: The initial state after calling <a>DeleteDirectConnectGatewayAssociation</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>disassociated</code>: The virtual private gateway or transit gateway is disassociated from the Direct Connect gateway. Traffic flow between the Direct Connect gateway and virtual private gateway or transit gateway is stopped.</p>
    ///             </li>
    ///          </ul>
    public let associationState: DirectConnectGatewayAssociationState?
    /// <p>The ID of the Direct Connect gateway.</p>
    public let directConnectGatewayId: String?
    /// <p>The ID of the AWS account that owns the associated gateway.</p>
    public let directConnectGatewayOwnerAccount: String?
    /// <p>The error message if the state of an object failed to advance.</p>
    public let stateChangeError: String?
    /// <p>The ID of the virtual private gateway. Applies only to private virtual interfaces.</p>
    public let virtualGatewayId: String?
    /// <p>The ID of the AWS account that owns the virtual private gateway.</p>
    public let virtualGatewayOwnerAccount: String?
    /// <p>The AWS Region where the virtual private gateway is located.</p>
    @available(*, deprecated)
    public let virtualGatewayRegion: String?

    public init (
        allowedPrefixesToDirectConnectGateway: [RouteFilterPrefix]? = nil,
        associatedGateway: AssociatedGateway? = nil,
        associationId: String? = nil,
        associationState: DirectConnectGatewayAssociationState? = nil,
        directConnectGatewayId: String? = nil,
        directConnectGatewayOwnerAccount: String? = nil,
        stateChangeError: String? = nil,
        virtualGatewayId: String? = nil,
        virtualGatewayOwnerAccount: String? = nil,
        virtualGatewayRegion: String? = nil
    )
    {
        self.allowedPrefixesToDirectConnectGateway = allowedPrefixesToDirectConnectGateway
        self.associatedGateway = associatedGateway
        self.associationId = associationId
        self.associationState = associationState
        self.directConnectGatewayId = directConnectGatewayId
        self.directConnectGatewayOwnerAccount = directConnectGatewayOwnerAccount
        self.stateChangeError = stateChangeError
        self.virtualGatewayId = virtualGatewayId
        self.virtualGatewayOwnerAccount = virtualGatewayOwnerAccount
        self.virtualGatewayRegion = virtualGatewayRegion
    }
}

extension DirectConnectGatewayAssociationProposal: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associatedGateway
        case directConnectGatewayId
        case directConnectGatewayOwnerAccount
        case existingAllowedPrefixesToDirectConnectGateway
        case proposalId
        case proposalState
        case requestedAllowedPrefixesToDirectConnectGateway
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedGateway = associatedGateway {
            try encodeContainer.encode(associatedGateway, forKey: .associatedGateway)
        }
        if let directConnectGatewayId = directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let directConnectGatewayOwnerAccount = directConnectGatewayOwnerAccount {
            try encodeContainer.encode(directConnectGatewayOwnerAccount, forKey: .directConnectGatewayOwnerAccount)
        }
        if let existingAllowedPrefixesToDirectConnectGateway = existingAllowedPrefixesToDirectConnectGateway {
            var existingAllowedPrefixesToDirectConnectGatewayContainer = encodeContainer.nestedUnkeyedContainer(forKey: .existingAllowedPrefixesToDirectConnectGateway)
            for routefilterprefixlist0 in existingAllowedPrefixesToDirectConnectGateway {
                try existingAllowedPrefixesToDirectConnectGatewayContainer.encode(routefilterprefixlist0)
            }
        }
        if let proposalId = proposalId {
            try encodeContainer.encode(proposalId, forKey: .proposalId)
        }
        if let proposalState = proposalState {
            try encodeContainer.encode(proposalState.rawValue, forKey: .proposalState)
        }
        if let requestedAllowedPrefixesToDirectConnectGateway = requestedAllowedPrefixesToDirectConnectGateway {
            var requestedAllowedPrefixesToDirectConnectGatewayContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requestedAllowedPrefixesToDirectConnectGateway)
            for routefilterprefixlist0 in requestedAllowedPrefixesToDirectConnectGateway {
                try requestedAllowedPrefixesToDirectConnectGatewayContainer.encode(routefilterprefixlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proposalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .proposalId)
        proposalId = proposalIdDecoded
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let directConnectGatewayOwnerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directConnectGatewayOwnerAccount)
        directConnectGatewayOwnerAccount = directConnectGatewayOwnerAccountDecoded
        let proposalStateDecoded = try containerValues.decodeIfPresent(DirectConnectGatewayAssociationProposalState.self, forKey: .proposalState)
        proposalState = proposalStateDecoded
        let associatedGatewayDecoded = try containerValues.decodeIfPresent(AssociatedGateway.self, forKey: .associatedGateway)
        associatedGateway = associatedGatewayDecoded
        let existingAllowedPrefixesToDirectConnectGatewayContainer = try containerValues.decodeIfPresent([RouteFilterPrefix?].self, forKey: .existingAllowedPrefixesToDirectConnectGateway)
        var existingAllowedPrefixesToDirectConnectGatewayDecoded0:[RouteFilterPrefix]? = nil
        if let existingAllowedPrefixesToDirectConnectGatewayContainer = existingAllowedPrefixesToDirectConnectGatewayContainer {
            existingAllowedPrefixesToDirectConnectGatewayDecoded0 = [RouteFilterPrefix]()
            for structure0 in existingAllowedPrefixesToDirectConnectGatewayContainer {
                if let structure0 = structure0 {
                    existingAllowedPrefixesToDirectConnectGatewayDecoded0?.append(structure0)
                }
            }
        }
        existingAllowedPrefixesToDirectConnectGateway = existingAllowedPrefixesToDirectConnectGatewayDecoded0
        let requestedAllowedPrefixesToDirectConnectGatewayContainer = try containerValues.decodeIfPresent([RouteFilterPrefix?].self, forKey: .requestedAllowedPrefixesToDirectConnectGateway)
        var requestedAllowedPrefixesToDirectConnectGatewayDecoded0:[RouteFilterPrefix]? = nil
        if let requestedAllowedPrefixesToDirectConnectGatewayContainer = requestedAllowedPrefixesToDirectConnectGatewayContainer {
            requestedAllowedPrefixesToDirectConnectGatewayDecoded0 = [RouteFilterPrefix]()
            for structure0 in requestedAllowedPrefixesToDirectConnectGatewayContainer {
                if let structure0 = structure0 {
                    requestedAllowedPrefixesToDirectConnectGatewayDecoded0?.append(structure0)
                }
            }
        }
        requestedAllowedPrefixesToDirectConnectGateway = requestedAllowedPrefixesToDirectConnectGatewayDecoded0
    }
}

extension DirectConnectGatewayAssociationProposal: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DirectConnectGatewayAssociationProposal(associatedGateway: \(String(describing: associatedGateway)), directConnectGatewayId: \(String(describing: directConnectGatewayId)), directConnectGatewayOwnerAccount: \(String(describing: directConnectGatewayOwnerAccount)), existingAllowedPrefixesToDirectConnectGateway: \(String(describing: existingAllowedPrefixesToDirectConnectGateway)), proposalId: \(String(describing: proposalId)), proposalState: \(String(describing: proposalState)), requestedAllowedPrefixesToDirectConnectGateway: \(String(describing: requestedAllowedPrefixesToDirectConnectGateway)))"}
}

/// <p>Information about the  proposal request to attach a virtual private gateway to a Direct Connect gateway. </p>
public struct DirectConnectGatewayAssociationProposal: Equatable {
    /// <p>Information about the associated gateway.</p>
    public let associatedGateway: AssociatedGateway?
    /// <p>The ID of the Direct Connect gateway.</p>
    public let directConnectGatewayId: String?
    /// <p>The ID of the AWS account that owns the Direct Connect gateway.</p>
    public let directConnectGatewayOwnerAccount: String?
    /// <p>The existing Amazon VPC prefixes advertised to the Direct Connect gateway.</p>
    public let existingAllowedPrefixesToDirectConnectGateway: [RouteFilterPrefix]?
    /// <p>The ID of the association proposal.</p>
    public let proposalId: String?
    /// <p>The state of the proposal. The following are possible values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>accepted</code>: The proposal has been accepted. The Direct Connect gateway association is available to use in this state.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>: The proposal has been deleted by the owner that made the proposal.  The Direct Connect gateway association cannot be used in this state.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>requested</code>: The proposal has been requested. The Direct Connect gateway association cannot be used in this state.</p>
    ///             </li>
    ///          </ul>
    public let proposalState: DirectConnectGatewayAssociationProposalState?
    /// <p>The Amazon VPC prefixes to advertise to the Direct Connect gateway.</p>
    public let requestedAllowedPrefixesToDirectConnectGateway: [RouteFilterPrefix]?

    public init (
        associatedGateway: AssociatedGateway? = nil,
        directConnectGatewayId: String? = nil,
        directConnectGatewayOwnerAccount: String? = nil,
        existingAllowedPrefixesToDirectConnectGateway: [RouteFilterPrefix]? = nil,
        proposalId: String? = nil,
        proposalState: DirectConnectGatewayAssociationProposalState? = nil,
        requestedAllowedPrefixesToDirectConnectGateway: [RouteFilterPrefix]? = nil
    )
    {
        self.associatedGateway = associatedGateway
        self.directConnectGatewayId = directConnectGatewayId
        self.directConnectGatewayOwnerAccount = directConnectGatewayOwnerAccount
        self.existingAllowedPrefixesToDirectConnectGateway = existingAllowedPrefixesToDirectConnectGateway
        self.proposalId = proposalId
        self.proposalState = proposalState
        self.requestedAllowedPrefixesToDirectConnectGateway = requestedAllowedPrefixesToDirectConnectGateway
    }
}

public enum DirectConnectGatewayAssociationProposalState {
    case accepted
    case deleted
    case requested
    case sdkUnknown(String)
}

extension DirectConnectGatewayAssociationProposalState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DirectConnectGatewayAssociationProposalState] {
        return [
            .accepted,
            .deleted,
            .requested,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accepted: return "accepted"
        case .deleted: return "deleted"
        case .requested: return "requested"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DirectConnectGatewayAssociationProposalState(rawValue: rawValue) ?? DirectConnectGatewayAssociationProposalState.sdkUnknown(rawValue)
    }
}

public enum DirectConnectGatewayAssociationState {
    case associated
    case associating
    case disassociated
    case disassociating
    case updating
    case sdkUnknown(String)
}

extension DirectConnectGatewayAssociationState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DirectConnectGatewayAssociationState] {
        return [
            .associated,
            .associating,
            .disassociated,
            .disassociating,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .associated: return "associated"
        case .associating: return "associating"
        case .disassociated: return "disassociated"
        case .disassociating: return "disassociating"
        case .updating: return "updating"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DirectConnectGatewayAssociationState(rawValue: rawValue) ?? DirectConnectGatewayAssociationState.sdkUnknown(rawValue)
    }
}

extension DirectConnectGatewayAttachment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attachmentState
        case attachmentType
        case directConnectGatewayId
        case stateChangeError
        case virtualInterfaceId
        case virtualInterfaceOwnerAccount
        case virtualInterfaceRegion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentState = attachmentState {
            try encodeContainer.encode(attachmentState.rawValue, forKey: .attachmentState)
        }
        if let attachmentType = attachmentType {
            try encodeContainer.encode(attachmentType.rawValue, forKey: .attachmentType)
        }
        if let directConnectGatewayId = directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let stateChangeError = stateChangeError {
            try encodeContainer.encode(stateChangeError, forKey: .stateChangeError)
        }
        if let virtualInterfaceId = virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
        if let virtualInterfaceOwnerAccount = virtualInterfaceOwnerAccount {
            try encodeContainer.encode(virtualInterfaceOwnerAccount, forKey: .virtualInterfaceOwnerAccount)
        }
        if let virtualInterfaceRegion = virtualInterfaceRegion {
            try encodeContainer.encode(virtualInterfaceRegion, forKey: .virtualInterfaceRegion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let virtualInterfaceRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceRegion)
        virtualInterfaceRegion = virtualInterfaceRegionDecoded
        let virtualInterfaceOwnerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceOwnerAccount)
        virtualInterfaceOwnerAccount = virtualInterfaceOwnerAccountDecoded
        let attachmentStateDecoded = try containerValues.decodeIfPresent(DirectConnectGatewayAttachmentState.self, forKey: .attachmentState)
        attachmentState = attachmentStateDecoded
        let attachmentTypeDecoded = try containerValues.decodeIfPresent(DirectConnectGatewayAttachmentType.self, forKey: .attachmentType)
        attachmentType = attachmentTypeDecoded
        let stateChangeErrorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateChangeError)
        stateChangeError = stateChangeErrorDecoded
    }
}

extension DirectConnectGatewayAttachment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DirectConnectGatewayAttachment(attachmentState: \(String(describing: attachmentState)), attachmentType: \(String(describing: attachmentType)), directConnectGatewayId: \(String(describing: directConnectGatewayId)), stateChangeError: \(String(describing: stateChangeError)), virtualInterfaceId: \(String(describing: virtualInterfaceId)), virtualInterfaceOwnerAccount: \(String(describing: virtualInterfaceOwnerAccount)), virtualInterfaceRegion: \(String(describing: virtualInterfaceRegion)))"}
}

/// <p>Information about an attachment between a Direct Connect gateway and a virtual interface.</p>
public struct DirectConnectGatewayAttachment: Equatable {
    /// <p>The state of the attachment. The following are the possible values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>attaching</code>: The initial state after a virtual interface is created using the Direct Connect gateway.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>attached</code>: The Direct Connect gateway and virtual interface are attached and ready to pass traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>detaching</code>: The initial state after calling <a>DeleteVirtualInterface</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>detached</code>: The virtual interface is detached from the Direct Connect gateway. Traffic flow between the Direct Connect gateway and virtual interface is stopped.</p>
    ///             </li>
    ///          </ul>
    public let attachmentState: DirectConnectGatewayAttachmentState?
    /// <p>The type of attachment.</p>
    public let attachmentType: DirectConnectGatewayAttachmentType?
    /// <p>The ID of the Direct Connect gateway.</p>
    public let directConnectGatewayId: String?
    /// <p>The error message if the state of an object failed to advance.</p>
    public let stateChangeError: String?
    /// <p>The ID of the virtual interface.</p>
    public let virtualInterfaceId: String?
    /// <p>The ID of the AWS account that owns the virtual interface.</p>
    public let virtualInterfaceOwnerAccount: String?
    /// <p>The AWS Region where the virtual interface is located.</p>
    public let virtualInterfaceRegion: String?

    public init (
        attachmentState: DirectConnectGatewayAttachmentState? = nil,
        attachmentType: DirectConnectGatewayAttachmentType? = nil,
        directConnectGatewayId: String? = nil,
        stateChangeError: String? = nil,
        virtualInterfaceId: String? = nil,
        virtualInterfaceOwnerAccount: String? = nil,
        virtualInterfaceRegion: String? = nil
    )
    {
        self.attachmentState = attachmentState
        self.attachmentType = attachmentType
        self.directConnectGatewayId = directConnectGatewayId
        self.stateChangeError = stateChangeError
        self.virtualInterfaceId = virtualInterfaceId
        self.virtualInterfaceOwnerAccount = virtualInterfaceOwnerAccount
        self.virtualInterfaceRegion = virtualInterfaceRegion
    }
}

public enum DirectConnectGatewayAttachmentState {
    case attached
    case attaching
    case detached
    case detaching
    case sdkUnknown(String)
}

extension DirectConnectGatewayAttachmentState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DirectConnectGatewayAttachmentState] {
        return [
            .attached,
            .attaching,
            .detached,
            .detaching,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .attached: return "attached"
        case .attaching: return "attaching"
        case .detached: return "detached"
        case .detaching: return "detaching"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DirectConnectGatewayAttachmentState(rawValue: rawValue) ?? DirectConnectGatewayAttachmentState.sdkUnknown(rawValue)
    }
}

public enum DirectConnectGatewayAttachmentType {
    case privatevirtualinterface
    case transitvirtualinterface
    case sdkUnknown(String)
}

extension DirectConnectGatewayAttachmentType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DirectConnectGatewayAttachmentType] {
        return [
            .privatevirtualinterface,
            .transitvirtualinterface,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .privatevirtualinterface: return "PrivateVirtualInterface"
        case .transitvirtualinterface: return "TransitVirtualInterface"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DirectConnectGatewayAttachmentType(rawValue: rawValue) ?? DirectConnectGatewayAttachmentType.sdkUnknown(rawValue)
    }
}

public enum DirectConnectGatewayState {
    case available
    case deleted
    case deleting
    case pending
    case sdkUnknown(String)
}

extension DirectConnectGatewayState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DirectConnectGatewayState] {
        return [
            .available,
            .deleted,
            .deleting,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "available"
        case .deleted: return "deleted"
        case .deleting: return "deleting"
        case .pending: return "pending"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DirectConnectGatewayState(rawValue: rawValue) ?? DirectConnectGatewayState.sdkUnknown(rawValue)
    }
}

extension DirectConnectServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DirectConnectServerException(message: \(String(describing: message)))"}
}

extension DirectConnectServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DirectConnectServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A server-side error occurred.</p>
public struct DirectConnectServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DirectConnectServerExceptionBody: Equatable {
    public let message: String?
}

extension DirectConnectServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct DisassociateConnectionFromLagInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateConnectionFromLagInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateConnectionFromLagInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateConnectionFromLagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateConnectionFromLagInput>
    public typealias MOutput = OperationOutput<DisassociateConnectionFromLagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateConnectionFromLagOutputError>
}

extension DisassociateConnectionFromLagInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateConnectionFromLagInput(connectionId: \(String(describing: connectionId)), lagId: \(String(describing: lagId)))"}
}

extension DisassociateConnectionFromLagInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case lagId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let lagId = lagId {
            try encodeContainer.encode(lagId, forKey: .lagId)
        }
    }
}

public struct DisassociateConnectionFromLagInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateConnectionFromLagInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateConnectionFromLagInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateConnectionFromLagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateConnectionFromLagInput>
    public typealias MOutput = OperationOutput<DisassociateConnectionFromLagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateConnectionFromLagOutputError>
}

public struct DisassociateConnectionFromLagInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateConnectionFromLagInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateConnectionFromLagInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateConnectionFromLagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateConnectionFromLagInput>
    public typealias MOutput = OperationOutput<DisassociateConnectionFromLagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateConnectionFromLagOutputError>
}

public struct DisassociateConnectionFromLagInput: Equatable {
    /// <p>The ID of the connection.</p>
    public let connectionId: String?
    /// <p>The ID of the LAG.</p>
    public let lagId: String?

    public init (
        connectionId: String? = nil,
        lagId: String? = nil
    )
    {
        self.connectionId = connectionId
        self.lagId = lagId
    }
}

struct DisassociateConnectionFromLagInputBody: Equatable {
    public let connectionId: String?
    public let lagId: String?
}

extension DisassociateConnectionFromLagInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case lagId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lagId)
        lagId = lagIdDecoded
    }
}

extension DisassociateConnectionFromLagOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateConnectionFromLagOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateConnectionFromLagOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateConnectionFromLagOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateConnectionFromLagOutputResponse(awsDevice: \(String(describing: awsDevice)), awsDeviceV2: \(String(describing: awsDeviceV2)), bandwidth: \(String(describing: bandwidth)), connectionId: \(String(describing: connectionId)), connectionName: \(String(describing: connectionName)), connectionState: \(String(describing: connectionState)), encryptionMode: \(String(describing: encryptionMode)), hasLogicalRedundancy: \(String(describing: hasLogicalRedundancy)), jumboFrameCapable: \(String(describing: jumboFrameCapable)), lagId: \(String(describing: lagId)), loaIssueTime: \(String(describing: loaIssueTime)), location: \(String(describing: location)), macSecCapable: \(String(describing: macSecCapable)), macSecKeys: \(String(describing: macSecKeys)), ownerAccount: \(String(describing: ownerAccount)), partnerName: \(String(describing: partnerName)), portEncryptionStatus: \(String(describing: portEncryptionStatus)), providerName: \(String(describing: providerName)), region: \(String(describing: region)), tags: \(String(describing: tags)), vlan: \(String(describing: vlan)))"}
}

extension DisassociateConnectionFromLagOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateConnectionFromLagOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.awsDevice = output.awsDevice
            self.awsDeviceV2 = output.awsDeviceV2
            self.bandwidth = output.bandwidth
            self.connectionId = output.connectionId
            self.connectionName = output.connectionName
            self.connectionState = output.connectionState
            self.encryptionMode = output.encryptionMode
            self.hasLogicalRedundancy = output.hasLogicalRedundancy
            self.jumboFrameCapable = output.jumboFrameCapable
            self.lagId = output.lagId
            self.loaIssueTime = output.loaIssueTime
            self.location = output.location
            self.macSecCapable = output.macSecCapable
            self.macSecKeys = output.macSecKeys
            self.ownerAccount = output.ownerAccount
            self.partnerName = output.partnerName
            self.portEncryptionStatus = output.portEncryptionStatus
            self.providerName = output.providerName
            self.region = output.region
            self.tags = output.tags
            self.vlan = output.vlan
        } else {
            self.awsDevice = nil
            self.awsDeviceV2 = nil
            self.bandwidth = nil
            self.connectionId = nil
            self.connectionName = nil
            self.connectionState = nil
            self.encryptionMode = nil
            self.hasLogicalRedundancy = nil
            self.jumboFrameCapable = nil
            self.lagId = nil
            self.loaIssueTime = nil
            self.location = nil
            self.macSecCapable = nil
            self.macSecKeys = nil
            self.ownerAccount = nil
            self.partnerName = nil
            self.portEncryptionStatus = nil
            self.providerName = nil
            self.region = nil
            self.tags = nil
            self.vlan = 0
        }
    }
}

/// <p>Information about an AWS Direct Connect connection.</p>
public struct DisassociateConnectionFromLagOutputResponse: Equatable {
    /// <p>The Direct Connect endpoint on which the physical connection terminates.</p>
    @available(*, deprecated)
    public let awsDevice: String?
    /// <p>The Direct Connect endpoint on which the physical connection terminates.</p>
    public let awsDeviceV2: String?
    /// <p>The bandwidth of the connection.</p>
    public let bandwidth: String?
    /// <p>The ID of the connection.</p>
    public let connectionId: String?
    /// <p>The name of the connection.</p>
    public let connectionName: String?
    /// <p>The state of the connection. The following are the possible values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ordering</code>: The initial state of a hosted connection provisioned on an interconnect. The connection stays in the ordering state until the owner of the hosted connection confirms or declines the connection order.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>requested</code>: The initial state of a standard connection. The connection stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: The connection has been approved and is being initialized.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>available</code>: The network link is up and the connection is ready for use.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>down</code>: The network link is down.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>: The connection is being deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>: The connection has been deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>rejected</code>: A hosted connection in the <code>ordering</code> state enters the <code>rejected</code> state if it is deleted by the customer.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>unknown</code>: The state of the connection is not available.</p>
    ///             </li>
    ///          </ul>
    public let connectionState: ConnectionState?
    /// <p>The MAC Security (MACsec) connection encryption mode.</p>
    ///          <p>The valid values are <code>no_encrypt</code>, <code>should_encrypt</code>, and <code>must_encrypt</code>.</p>
    public let encryptionMode: String?
    /// <p>Indicates whether the connection supports a secondary BGP peer in the same address family (IPv4/IPv6).</p>
    public let hasLogicalRedundancy: HasLogicalRedundancy?
    /// <p>Indicates whether jumbo frames (9001 MTU) are supported.</p>
    public let jumboFrameCapable: Bool?
    /// <p>The ID of the LAG.</p>
    public let lagId: String?
    /// <p>The time of the most recent call to <a>DescribeLoa</a> for this connection.</p>
    public let loaIssueTime: Date?
    /// <p>The location of the connection.</p>
    public let location: String?
    /// <p>Indicates whether the connection supports MAC Security (MACsec).</p>
    public let macSecCapable: Bool?
    /// <p>The MAC Security (MACsec) security keys associated with the connection.</p>
    public let macSecKeys: [MacSecKey]?
    /// <p>The ID of the AWS account that owns the connection.</p>
    public let ownerAccount: String?
    /// <p>The name of the AWS Direct Connect service provider associated with the connection.</p>
    public let partnerName: String?
    /// <p>The MAC Security (MACsec) port link status of the connection.</p>
    ///          <p>The valid values are <code>Encryption Up</code>, which means that there is an active Connection Key Name, or <code>Encryption Down</code>.</p>
    public let portEncryptionStatus: String?
    /// <p>The name of the service provider associated with the connection.</p>
    public let providerName: String?
    /// <p>The AWS Region where the connection is located.</p>
    public let region: String?
    /// <p>The tags associated with the connection.</p>
    public let tags: [Tag]?
    /// <p>The ID of the VLAN.</p>
    public let vlan: Int

    public init (
        awsDevice: String? = nil,
        awsDeviceV2: String? = nil,
        bandwidth: String? = nil,
        connectionId: String? = nil,
        connectionName: String? = nil,
        connectionState: ConnectionState? = nil,
        encryptionMode: String? = nil,
        hasLogicalRedundancy: HasLogicalRedundancy? = nil,
        jumboFrameCapable: Bool? = nil,
        lagId: String? = nil,
        loaIssueTime: Date? = nil,
        location: String? = nil,
        macSecCapable: Bool? = nil,
        macSecKeys: [MacSecKey]? = nil,
        ownerAccount: String? = nil,
        partnerName: String? = nil,
        portEncryptionStatus: String? = nil,
        providerName: String? = nil,
        region: String? = nil,
        tags: [Tag]? = nil,
        vlan: Int = 0
    )
    {
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.bandwidth = bandwidth
        self.connectionId = connectionId
        self.connectionName = connectionName
        self.connectionState = connectionState
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.loaIssueTime = loaIssueTime
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.ownerAccount = ownerAccount
        self.partnerName = partnerName
        self.portEncryptionStatus = portEncryptionStatus
        self.providerName = providerName
        self.region = region
        self.tags = tags
        self.vlan = vlan
    }
}

struct DisassociateConnectionFromLagOutputResponseBody: Equatable {
    public let ownerAccount: String?
    public let connectionId: String?
    public let connectionName: String?
    public let connectionState: ConnectionState?
    public let region: String?
    public let location: String?
    public let bandwidth: String?
    public let vlan: Int
    public let partnerName: String?
    public let loaIssueTime: Date?
    public let lagId: String?
    public let awsDevice: String?
    public let jumboFrameCapable: Bool?
    public let awsDeviceV2: String?
    public let hasLogicalRedundancy: HasLogicalRedundancy?
    public let tags: [Tag]?
    public let providerName: String?
    public let macSecCapable: Bool?
    public let portEncryptionStatus: String?
    public let encryptionMode: String?
    public let macSecKeys: [MacSecKey]?
}

extension DisassociateConnectionFromLagOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case awsDevice
        case awsDeviceV2
        case bandwidth
        case connectionId
        case connectionName
        case connectionState
        case encryptionMode
        case hasLogicalRedundancy
        case jumboFrameCapable
        case lagId
        case loaIssueTime
        case location
        case macSecCapable
        case macSecKeys
        case ownerAccount
        case partnerName
        case portEncryptionStatus
        case providerName
        case region
        case tags
        case vlan
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let vlanDecoded = try containerValues.decode(Int.self, forKey: .vlan)
        vlan = vlanDecoded
        let partnerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .partnerName)
        partnerName = partnerNameDecoded
        let loaIssueTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .loaIssueTime)
        loaIssueTime = loaIssueTimeDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let awsDeviceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDevice)
        awsDevice = awsDeviceDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let hasLogicalRedundancyDecoded = try containerValues.decodeIfPresent(HasLogicalRedundancy.self, forKey: .hasLogicalRedundancy)
        hasLogicalRedundancy = hasLogicalRedundancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let macSecCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .macSecCapable)
        macSecCapable = macSecCapableDecoded
        let portEncryptionStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portEncryptionStatus)
        portEncryptionStatus = portEncryptionStatusDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let macSecKeysContainer = try containerValues.decodeIfPresent([MacSecKey?].self, forKey: .macSecKeys)
        var macSecKeysDecoded0:[MacSecKey]? = nil
        if let macSecKeysContainer = macSecKeysContainer {
            macSecKeysDecoded0 = [MacSecKey]()
            for structure0 in macSecKeysContainer {
                if let structure0 = structure0 {
                    macSecKeysDecoded0?.append(structure0)
                }
            }
        }
        macSecKeys = macSecKeysDecoded0
    }
}

public struct DisassociateMacSecKeyInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateMacSecKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateMacSecKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateMacSecKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateMacSecKeyInput>
    public typealias MOutput = OperationOutput<DisassociateMacSecKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateMacSecKeyOutputError>
}

extension DisassociateMacSecKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateMacSecKeyInput(connectionId: \(String(describing: connectionId)), secretARN: \(String(describing: secretARN)))"}
}

extension DisassociateMacSecKeyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case secretARN
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let secretARN = secretARN {
            try encodeContainer.encode(secretARN, forKey: .secretARN)
        }
    }
}

public struct DisassociateMacSecKeyInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateMacSecKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateMacSecKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateMacSecKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateMacSecKeyInput>
    public typealias MOutput = OperationOutput<DisassociateMacSecKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateMacSecKeyOutputError>
}

public struct DisassociateMacSecKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateMacSecKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateMacSecKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateMacSecKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateMacSecKeyInput>
    public typealias MOutput = OperationOutput<DisassociateMacSecKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateMacSecKeyOutputError>
}

public struct DisassociateMacSecKeyInput: Equatable {
    /// <p>The ID of the dedicated connection (dxcon-xxxx), or the ID of the LAG (dxlag-xxxx).</p>
    ///          <p>You can use <a>DescribeConnections</a> or <a>DescribeLags</a> to retrieve connection ID.</p>
    public let connectionId: String?
    /// <p>The Amazon Resource Name (ARN) of the MAC Security (MACsec) secret key.</p>
    ///          <p>You can use <a>DescribeConnections</a> to retrieve the ARN of the MAC Security (MACsec) secret key.</p>
    public let secretARN: String?

    public init (
        connectionId: String? = nil,
        secretARN: String? = nil
    )
    {
        self.connectionId = connectionId
        self.secretARN = secretARN
    }
}

struct DisassociateMacSecKeyInputBody: Equatable {
    public let connectionId: String?
    public let secretARN: String?
}

extension DisassociateMacSecKeyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case secretARN
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let secretARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretARN)
        secretARN = secretARNDecoded
    }
}

extension DisassociateMacSecKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateMacSecKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateMacSecKeyOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateMacSecKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateMacSecKeyOutputResponse(connectionId: \(String(describing: connectionId)), macSecKeys: \(String(describing: macSecKeys)))"}
}

extension DisassociateMacSecKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateMacSecKeyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectionId = output.connectionId
            self.macSecKeys = output.macSecKeys
        } else {
            self.connectionId = nil
            self.macSecKeys = nil
        }
    }
}

public struct DisassociateMacSecKeyOutputResponse: Equatable {
    /// <p>The ID of the dedicated connection (dxcon-xxxx), or the ID of the LAG (dxlag-xxxx).</p>
    public let connectionId: String?
    /// <p>The MAC Security (MACsec) security keys no longer associated with the dedicated connection.</p>
    public let macSecKeys: [MacSecKey]?

    public init (
        connectionId: String? = nil,
        macSecKeys: [MacSecKey]? = nil
    )
    {
        self.connectionId = connectionId
        self.macSecKeys = macSecKeys
    }
}

struct DisassociateMacSecKeyOutputResponseBody: Equatable {
    public let connectionId: String?
    public let macSecKeys: [MacSecKey]?
}

extension DisassociateMacSecKeyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case macSecKeys
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let macSecKeysContainer = try containerValues.decodeIfPresent([MacSecKey?].self, forKey: .macSecKeys)
        var macSecKeysDecoded0:[MacSecKey]? = nil
        if let macSecKeysContainer = macSecKeysContainer {
            macSecKeysDecoded0 = [MacSecKey]()
            for structure0 in macSecKeysContainer {
                if let structure0 = structure0 {
                    macSecKeysDecoded0?.append(structure0)
                }
            }
        }
        macSecKeys = macSecKeysDecoded0
    }
}

extension DuplicateTagKeysException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DuplicateTagKeysException(message: \(String(describing: message)))"}
}

extension DuplicateTagKeysException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DuplicateTagKeysExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A tag key was specified more than once.</p>
public struct DuplicateTagKeysException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateTagKeysExceptionBody: Equatable {
    public let message: String?
}

extension DuplicateTagKeysExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum GatewayType {
    case transitgateway
    case virtualprivategateway
    case sdkUnknown(String)
}

extension GatewayType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [GatewayType] {
        return [
            .transitgateway,
            .virtualprivategateway,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .transitgateway: return "transitGateway"
        case .virtualprivategateway: return "virtualPrivateGateway"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = GatewayType(rawValue: rawValue) ?? GatewayType.sdkUnknown(rawValue)
    }
}

public enum HasLogicalRedundancy {
    case no
    case unknown
    case yes
    case sdkUnknown(String)
}

extension HasLogicalRedundancy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [HasLogicalRedundancy] {
        return [
            .no,
            .unknown,
            .yes,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .no: return "no"
        case .unknown: return "unknown"
        case .yes: return "yes"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = HasLogicalRedundancy(rawValue: rawValue) ?? HasLogicalRedundancy.sdkUnknown(rawValue)
    }
}

extension Interconnect: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsDevice
        case awsDeviceV2
        case bandwidth
        case hasLogicalRedundancy
        case interconnectId
        case interconnectName
        case interconnectState
        case jumboFrameCapable
        case lagId
        case loaIssueTime
        case location
        case providerName
        case region
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsDevice = awsDevice {
            try encodeContainer.encode(awsDevice, forKey: .awsDevice)
        }
        if let awsDeviceV2 = awsDeviceV2 {
            try encodeContainer.encode(awsDeviceV2, forKey: .awsDeviceV2)
        }
        if let bandwidth = bandwidth {
            try encodeContainer.encode(bandwidth, forKey: .bandwidth)
        }
        if let hasLogicalRedundancy = hasLogicalRedundancy {
            try encodeContainer.encode(hasLogicalRedundancy.rawValue, forKey: .hasLogicalRedundancy)
        }
        if let interconnectId = interconnectId {
            try encodeContainer.encode(interconnectId, forKey: .interconnectId)
        }
        if let interconnectName = interconnectName {
            try encodeContainer.encode(interconnectName, forKey: .interconnectName)
        }
        if let interconnectState = interconnectState {
            try encodeContainer.encode(interconnectState.rawValue, forKey: .interconnectState)
        }
        if let jumboFrameCapable = jumboFrameCapable {
            try encodeContainer.encode(jumboFrameCapable, forKey: .jumboFrameCapable)
        }
        if let lagId = lagId {
            try encodeContainer.encode(lagId, forKey: .lagId)
        }
        if let loaIssueTime = loaIssueTime {
            try encodeContainer.encode(loaIssueTime.timeIntervalSince1970, forKey: .loaIssueTime)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let providerName = providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interconnectIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .interconnectId)
        interconnectId = interconnectIdDecoded
        let interconnectNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .interconnectName)
        interconnectName = interconnectNameDecoded
        let interconnectStateDecoded = try containerValues.decodeIfPresent(InterconnectState.self, forKey: .interconnectState)
        interconnectState = interconnectStateDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let loaIssueTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .loaIssueTime)
        loaIssueTime = loaIssueTimeDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let awsDeviceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDevice)
        awsDevice = awsDeviceDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let hasLogicalRedundancyDecoded = try containerValues.decodeIfPresent(HasLogicalRedundancy.self, forKey: .hasLogicalRedundancy)
        hasLogicalRedundancy = hasLogicalRedundancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
    }
}

extension Interconnect: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Interconnect(awsDevice: \(String(describing: awsDevice)), awsDeviceV2: \(String(describing: awsDeviceV2)), bandwidth: \(String(describing: bandwidth)), hasLogicalRedundancy: \(String(describing: hasLogicalRedundancy)), interconnectId: \(String(describing: interconnectId)), interconnectName: \(String(describing: interconnectName)), interconnectState: \(String(describing: interconnectState)), jumboFrameCapable: \(String(describing: jumboFrameCapable)), lagId: \(String(describing: lagId)), loaIssueTime: \(String(describing: loaIssueTime)), location: \(String(describing: location)), providerName: \(String(describing: providerName)), region: \(String(describing: region)), tags: \(String(describing: tags)))"}
}

/// <p>Information about an interconnect.</p>
public struct Interconnect: Equatable {
    /// <p>The Direct Connect endpoint on which the physical connection terminates.</p>
    @available(*, deprecated)
    public let awsDevice: String?
    /// <p>The Direct Connect endpoint on which the physical connection terminates.</p>
    public let awsDeviceV2: String?
    /// <p>The bandwidth of the connection.</p>
    public let bandwidth: String?
    /// <p>Indicates whether the interconnect supports a secondary BGP in the same address family (IPv4/IPv6).</p>
    public let hasLogicalRedundancy: HasLogicalRedundancy?
    /// <p>The ID of the interconnect.</p>
    public let interconnectId: String?
    /// <p>The name of the interconnect.</p>
    public let interconnectName: String?
    /// <p>The state of the interconnect. The following are the possible values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>requested</code>: The initial state of an interconnect. The interconnect stays in the
    ///         requested state until the Letter of Authorization (LOA) is sent to the customer.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: The interconnect is approved, and is being initialized.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>available</code>: The network link is up, and the interconnect is ready for use.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>down</code>: The network link is down.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>: The interconnect is being deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>: The interconnect is deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>unknown</code>: The state of the interconnect is not available.</p>
    ///             </li>
    ///          </ul>
    public let interconnectState: InterconnectState?
    /// <p>Indicates whether jumbo frames (9001 MTU) are supported.</p>
    public let jumboFrameCapable: Bool?
    /// <p>The ID of the LAG.</p>
    public let lagId: String?
    /// <p>The time of the most recent call to <a>DescribeLoa</a> for this connection.</p>
    public let loaIssueTime: Date?
    /// <p>The location of the connection.</p>
    public let location: String?
    /// <p>The name of the service provider associated with the interconnect.</p>
    public let providerName: String?
    /// <p>The AWS Region where the connection is located.</p>
    public let region: String?
    /// <p>The tags associated with the interconnect.</p>
    public let tags: [Tag]?

    public init (
        awsDevice: String? = nil,
        awsDeviceV2: String? = nil,
        bandwidth: String? = nil,
        hasLogicalRedundancy: HasLogicalRedundancy? = nil,
        interconnectId: String? = nil,
        interconnectName: String? = nil,
        interconnectState: InterconnectState? = nil,
        jumboFrameCapable: Bool? = nil,
        lagId: String? = nil,
        loaIssueTime: Date? = nil,
        location: String? = nil,
        providerName: String? = nil,
        region: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.bandwidth = bandwidth
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.interconnectId = interconnectId
        self.interconnectName = interconnectName
        self.interconnectState = interconnectState
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.loaIssueTime = loaIssueTime
        self.location = location
        self.providerName = providerName
        self.region = region
        self.tags = tags
    }
}

public enum InterconnectState {
    case available
    case deleted
    case deleting
    case down
    case pending
    case requested
    case unknown
    case sdkUnknown(String)
}

extension InterconnectState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InterconnectState] {
        return [
            .available,
            .deleted,
            .deleting,
            .down,
            .pending,
            .requested,
            .unknown,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "available"
        case .deleted: return "deleted"
        case .deleting: return "deleting"
        case .down: return "down"
        case .pending: return "pending"
        case .requested: return "requested"
        case .unknown: return "unknown"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InterconnectState(rawValue: rawValue) ?? InterconnectState.sdkUnknown(rawValue)
    }
}

extension Lag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowsHostedConnections
        case awsDevice
        case awsDeviceV2
        case connections
        case connectionsBandwidth
        case encryptionMode
        case hasLogicalRedundancy
        case jumboFrameCapable
        case lagId
        case lagName
        case lagState
        case location
        case macSecCapable
        case macSecKeys
        case minimumLinks
        case numberOfConnections
        case ownerAccount
        case providerName
        case region
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowsHostedConnections != false {
            try encodeContainer.encode(allowsHostedConnections, forKey: .allowsHostedConnections)
        }
        if let awsDevice = awsDevice {
            try encodeContainer.encode(awsDevice, forKey: .awsDevice)
        }
        if let awsDeviceV2 = awsDeviceV2 {
            try encodeContainer.encode(awsDeviceV2, forKey: .awsDeviceV2)
        }
        if let connections = connections {
            var connectionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connections)
            for connectionlist0 in connections {
                try connectionsContainer.encode(connectionlist0)
            }
        }
        if let connectionsBandwidth = connectionsBandwidth {
            try encodeContainer.encode(connectionsBandwidth, forKey: .connectionsBandwidth)
        }
        if let encryptionMode = encryptionMode {
            try encodeContainer.encode(encryptionMode, forKey: .encryptionMode)
        }
        if let hasLogicalRedundancy = hasLogicalRedundancy {
            try encodeContainer.encode(hasLogicalRedundancy.rawValue, forKey: .hasLogicalRedundancy)
        }
        if let jumboFrameCapable = jumboFrameCapable {
            try encodeContainer.encode(jumboFrameCapable, forKey: .jumboFrameCapable)
        }
        if let lagId = lagId {
            try encodeContainer.encode(lagId, forKey: .lagId)
        }
        if let lagName = lagName {
            try encodeContainer.encode(lagName, forKey: .lagName)
        }
        if let lagState = lagState {
            try encodeContainer.encode(lagState.rawValue, forKey: .lagState)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let macSecCapable = macSecCapable {
            try encodeContainer.encode(macSecCapable, forKey: .macSecCapable)
        }
        if let macSecKeys = macSecKeys {
            var macSecKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .macSecKeys)
            for macseckeylist0 in macSecKeys {
                try macSecKeysContainer.encode(macseckeylist0)
            }
        }
        if minimumLinks != 0 {
            try encodeContainer.encode(minimumLinks, forKey: .minimumLinks)
        }
        if numberOfConnections != 0 {
            try encodeContainer.encode(numberOfConnections, forKey: .numberOfConnections)
        }
        if let ownerAccount = ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
        if let providerName = providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionsBandwidthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionsBandwidth)
        connectionsBandwidth = connectionsBandwidthDecoded
        let numberOfConnectionsDecoded = try containerValues.decode(Int.self, forKey: .numberOfConnections)
        numberOfConnections = numberOfConnectionsDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let lagNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lagName)
        lagName = lagNameDecoded
        let lagStateDecoded = try containerValues.decodeIfPresent(LagState.self, forKey: .lagState)
        lagState = lagStateDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let minimumLinksDecoded = try containerValues.decode(Int.self, forKey: .minimumLinks)
        minimumLinks = minimumLinksDecoded
        let awsDeviceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDevice)
        awsDevice = awsDeviceDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let connectionsContainer = try containerValues.decodeIfPresent([Connection?].self, forKey: .connections)
        var connectionsDecoded0:[Connection]? = nil
        if let connectionsContainer = connectionsContainer {
            connectionsDecoded0 = [Connection]()
            for structure0 in connectionsContainer {
                if let structure0 = structure0 {
                    connectionsDecoded0?.append(structure0)
                }
            }
        }
        connections = connectionsDecoded0
        let allowsHostedConnectionsDecoded = try containerValues.decode(Bool.self, forKey: .allowsHostedConnections)
        allowsHostedConnections = allowsHostedConnectionsDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let hasLogicalRedundancyDecoded = try containerValues.decodeIfPresent(HasLogicalRedundancy.self, forKey: .hasLogicalRedundancy)
        hasLogicalRedundancy = hasLogicalRedundancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let macSecCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .macSecCapable)
        macSecCapable = macSecCapableDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let macSecKeysContainer = try containerValues.decodeIfPresent([MacSecKey?].self, forKey: .macSecKeys)
        var macSecKeysDecoded0:[MacSecKey]? = nil
        if let macSecKeysContainer = macSecKeysContainer {
            macSecKeysDecoded0 = [MacSecKey]()
            for structure0 in macSecKeysContainer {
                if let structure0 = structure0 {
                    macSecKeysDecoded0?.append(structure0)
                }
            }
        }
        macSecKeys = macSecKeysDecoded0
    }
}

extension Lag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Lag(allowsHostedConnections: \(String(describing: allowsHostedConnections)), awsDevice: \(String(describing: awsDevice)), awsDeviceV2: \(String(describing: awsDeviceV2)), connections: \(String(describing: connections)), connectionsBandwidth: \(String(describing: connectionsBandwidth)), encryptionMode: \(String(describing: encryptionMode)), hasLogicalRedundancy: \(String(describing: hasLogicalRedundancy)), jumboFrameCapable: \(String(describing: jumboFrameCapable)), lagId: \(String(describing: lagId)), lagName: \(String(describing: lagName)), lagState: \(String(describing: lagState)), location: \(String(describing: location)), macSecCapable: \(String(describing: macSecCapable)), macSecKeys: \(String(describing: macSecKeys)), minimumLinks: \(String(describing: minimumLinks)), numberOfConnections: \(String(describing: numberOfConnections)), ownerAccount: \(String(describing: ownerAccount)), providerName: \(String(describing: providerName)), region: \(String(describing: region)), tags: \(String(describing: tags)))"}
}

/// <p>Information about a link aggregation group (LAG).</p>
public struct Lag: Equatable {
    /// <p>Indicates whether the LAG can host other connections.</p>
    public let allowsHostedConnections: Bool
    /// <p>The AWS Direct Connect endpoint that hosts the LAG.</p>
    @available(*, deprecated)
    public let awsDevice: String?
    /// <p>The AWS Direct Connect endpoint that hosts the LAG.</p>
    public let awsDeviceV2: String?
    /// <p>The connections bundled by the LAG.</p>
    public let connections: [Connection]?
    /// <p>The individual bandwidth of the physical connections bundled by the LAG. The possible
    ///       values are 1Gbps and 10Gbps. </p>
    public let connectionsBandwidth: String?
    /// <p>The LAG MAC Security (MACsec) encryption mode.</p>
    ///          <p>The valid values are <code>no_encrypt</code>, <code>should_encrypt</code>, and <code>must_encrypt</code>.</p>
    public let encryptionMode: String?
    /// <p>Indicates whether the LAG supports a secondary BGP peer in the same address family (IPv4/IPv6).</p>
    public let hasLogicalRedundancy: HasLogicalRedundancy?
    /// <p>Indicates whether jumbo frames (9001 MTU) are supported.</p>
    public let jumboFrameCapable: Bool?
    /// <p>The ID of the LAG.</p>
    public let lagId: String?
    /// <p>The name of the LAG.</p>
    public let lagName: String?
    /// <p>The state of the LAG. The following are the possible values:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>requested</code>: The initial state of a LAG. The LAG stays in the
    ///                 requested state until the Letter of Authorization (LOA) is available.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: The LAG has been approved and is being initialized.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>available</code>: The network link is established and the LAG is ready for use.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>down</code>: The network link is down.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>: The LAG is being deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>: The LAG is deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>unknown</code>: The state of the LAG is not available.</p>
    ///             </li>
    ///          </ul>
    public let lagState: LagState?
    /// <p>The location of the LAG.</p>
    public let location: String?
    /// <p>Indicates whether the LAG supports MAC Security (MACsec).</p>
    public let macSecCapable: Bool?
    /// <p>The MAC Security (MACsec) security keys associated with the LAG.</p>
    public let macSecKeys: [MacSecKey]?
    /// <p>The minimum number of physical dedicated connections that must be operational for the LAG itself to be operational.</p>
    public let minimumLinks: Int
    /// <p>The number of physical dedicated connections bundled by the LAG, up to a maximum of 10.</p>
    public let numberOfConnections: Int
    /// <p>The ID of the AWS account that owns the LAG.</p>
    public let ownerAccount: String?
    /// <p>The name of the service provider associated with the LAG.</p>
    public let providerName: String?
    /// <p>The AWS Region where the connection is located.</p>
    public let region: String?
    /// <p>The tags associated with the LAG.</p>
    public let tags: [Tag]?

    public init (
        allowsHostedConnections: Bool = false,
        awsDevice: String? = nil,
        awsDeviceV2: String? = nil,
        connections: [Connection]? = nil,
        connectionsBandwidth: String? = nil,
        encryptionMode: String? = nil,
        hasLogicalRedundancy: HasLogicalRedundancy? = nil,
        jumboFrameCapable: Bool? = nil,
        lagId: String? = nil,
        lagName: String? = nil,
        lagState: LagState? = nil,
        location: String? = nil,
        macSecCapable: Bool? = nil,
        macSecKeys: [MacSecKey]? = nil,
        minimumLinks: Int = 0,
        numberOfConnections: Int = 0,
        ownerAccount: String? = nil,
        providerName: String? = nil,
        region: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.allowsHostedConnections = allowsHostedConnections
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.connections = connections
        self.connectionsBandwidth = connectionsBandwidth
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.lagName = lagName
        self.lagState = lagState
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.minimumLinks = minimumLinks
        self.numberOfConnections = numberOfConnections
        self.ownerAccount = ownerAccount
        self.providerName = providerName
        self.region = region
        self.tags = tags
    }
}

public enum LagState {
    case available
    case deleted
    case deleting
    case down
    case pending
    case requested
    case unknown
    case sdkUnknown(String)
}

extension LagState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LagState] {
        return [
            .available,
            .deleted,
            .deleting,
            .down,
            .pending,
            .requested,
            .unknown,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "available"
        case .deleted: return "deleted"
        case .deleting: return "deleting"
        case .down: return "down"
        case .pending: return "pending"
        case .requested: return "requested"
        case .unknown: return "unknown"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LagState(rawValue: rawValue) ?? LagState.sdkUnknown(rawValue)
    }
}

public struct ListVirtualInterfaceTestHistoryInputBodyMiddleware: Middleware {
    public let id: String = "ListVirtualInterfaceTestHistoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVirtualInterfaceTestHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVirtualInterfaceTestHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVirtualInterfaceTestHistoryInput>
    public typealias MOutput = OperationOutput<ListVirtualInterfaceTestHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVirtualInterfaceTestHistoryOutputError>
}

extension ListVirtualInterfaceTestHistoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListVirtualInterfaceTestHistoryInput(bgpPeers: \(String(describing: bgpPeers)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), status: \(String(describing: status)), testId: \(String(describing: testId)), virtualInterfaceId: \(String(describing: virtualInterfaceId)))"}
}

extension ListVirtualInterfaceTestHistoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bgpPeers
        case maxResults
        case nextToken
        case status
        case testId
        case virtualInterfaceId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bgpPeers = bgpPeers {
            var bgpPeersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bgpPeers)
            for bgppeeridlist0 in bgpPeers {
                try bgpPeersContainer.encode(bgppeeridlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let testId = testId {
            try encodeContainer.encode(testId, forKey: .testId)
        }
        if let virtualInterfaceId = virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
    }
}

public struct ListVirtualInterfaceTestHistoryInputHeadersMiddleware: Middleware {
    public let id: String = "ListVirtualInterfaceTestHistoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVirtualInterfaceTestHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVirtualInterfaceTestHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVirtualInterfaceTestHistoryInput>
    public typealias MOutput = OperationOutput<ListVirtualInterfaceTestHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVirtualInterfaceTestHistoryOutputError>
}

public struct ListVirtualInterfaceTestHistoryInputQueryItemMiddleware: Middleware {
    public let id: String = "ListVirtualInterfaceTestHistoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVirtualInterfaceTestHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVirtualInterfaceTestHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVirtualInterfaceTestHistoryInput>
    public typealias MOutput = OperationOutput<ListVirtualInterfaceTestHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVirtualInterfaceTestHistoryOutputError>
}

public struct ListVirtualInterfaceTestHistoryInput: Equatable {
    /// <p>The BGP peers that were placed in the DOWN state during the virtual interface failover test.</p>
    public let bgpPeers: [String]?
    /// <p>The maximum number of results to return with a single call.
    /// 	To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    /// 	        <p>If <code>MaxResults</code> is given a value larger than 100, only 100 results are
    ///       returned.</p>
    public let maxResults: Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?
    /// <p>The status of the virtual interface failover test.</p>
    public let status: String?
    /// <p>The ID of the virtual interface failover test.</p>
    public let testId: String?
    /// <p>The ID of the virtual interface that was tested.</p>
    public let virtualInterfaceId: String?

    public init (
        bgpPeers: [String]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        status: String? = nil,
        testId: String? = nil,
        virtualInterfaceId: String? = nil
    )
    {
        self.bgpPeers = bgpPeers
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
        self.testId = testId
        self.virtualInterfaceId = virtualInterfaceId
    }
}

struct ListVirtualInterfaceTestHistoryInputBody: Equatable {
    public let testId: String?
    public let virtualInterfaceId: String?
    public let bgpPeers: [String]?
    public let status: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListVirtualInterfaceTestHistoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bgpPeers
        case maxResults
        case nextToken
        case status
        case testId
        case virtualInterfaceId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .testId)
        testId = testIdDecoded
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let bgpPeersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .bgpPeers)
        var bgpPeersDecoded0:[String]? = nil
        if let bgpPeersContainer = bgpPeersContainer {
            bgpPeersDecoded0 = [String]()
            for string0 in bgpPeersContainer {
                if let string0 = string0 {
                    bgpPeersDecoded0?.append(string0)
                }
            }
        }
        bgpPeers = bgpPeersDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListVirtualInterfaceTestHistoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVirtualInterfaceTestHistoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListVirtualInterfaceTestHistoryOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVirtualInterfaceTestHistoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListVirtualInterfaceTestHistoryOutputResponse(nextToken: \(String(describing: nextToken)), virtualInterfaceTestHistory: \(String(describing: virtualInterfaceTestHistory)))"}
}

extension ListVirtualInterfaceTestHistoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListVirtualInterfaceTestHistoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.virtualInterfaceTestHistory = output.virtualInterfaceTestHistory
        } else {
            self.nextToken = nil
            self.virtualInterfaceTestHistory = nil
        }
    }
}

public struct ListVirtualInterfaceTestHistoryOutputResponse: Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: String?
    /// <p>The ID of the tested virtual interface.</p>
    public let virtualInterfaceTestHistory: [VirtualInterfaceTestHistory]?

    public init (
        nextToken: String? = nil,
        virtualInterfaceTestHistory: [VirtualInterfaceTestHistory]? = nil
    )
    {
        self.nextToken = nextToken
        self.virtualInterfaceTestHistory = virtualInterfaceTestHistory
    }
}

struct ListVirtualInterfaceTestHistoryOutputResponseBody: Equatable {
    public let virtualInterfaceTestHistory: [VirtualInterfaceTestHistory]?
    public let nextToken: String?
}

extension ListVirtualInterfaceTestHistoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case virtualInterfaceTestHistory
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceTestHistoryContainer = try containerValues.decodeIfPresent([VirtualInterfaceTestHistory?].self, forKey: .virtualInterfaceTestHistory)
        var virtualInterfaceTestHistoryDecoded0:[VirtualInterfaceTestHistory]? = nil
        if let virtualInterfaceTestHistoryContainer = virtualInterfaceTestHistoryContainer {
            virtualInterfaceTestHistoryDecoded0 = [VirtualInterfaceTestHistory]()
            for structure0 in virtualInterfaceTestHistoryContainer {
                if let structure0 = structure0 {
                    virtualInterfaceTestHistoryDecoded0?.append(structure0)
                }
            }
        }
        virtualInterfaceTestHistory = virtualInterfaceTestHistoryDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension Loa: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case loaContent
        case loaContentType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loaContent = loaContent {
            try encodeContainer.encode(loaContent.base64EncodedString(), forKey: .loaContent)
        }
        if let loaContentType = loaContentType {
            try encodeContainer.encode(loaContentType.rawValue, forKey: .loaContentType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loaContentDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .loaContent)
        loaContent = loaContentDecoded
        let loaContentTypeDecoded = try containerValues.decodeIfPresent(LoaContentType.self, forKey: .loaContentType)
        loaContentType = loaContentTypeDecoded
    }
}

extension Loa: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Loa(loaContent: \(String(describing: loaContent)), loaContentType: \(String(describing: loaContentType)))"}
}

/// <p>Information about a Letter of Authorization - Connecting Facility Assignment (LOA-CFA) for a connection.</p>
public struct Loa: Equatable {
    /// <p>The binary contents of the LOA-CFA document.</p>
    public let loaContent: Data?
    /// <p>The standard media type for the LOA-CFA document. The only supported value is application/pdf.</p>
    public let loaContentType: LoaContentType?

    public init (
        loaContent: Data? = nil,
        loaContentType: LoaContentType? = nil
    )
    {
        self.loaContent = loaContent
        self.loaContentType = loaContentType
    }
}

public enum LoaContentType {
    case pdf
    case sdkUnknown(String)
}

extension LoaContentType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LoaContentType] {
        return [
            .pdf,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .pdf: return "application/pdf"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LoaContentType(rawValue: rawValue) ?? LoaContentType.sdkUnknown(rawValue)
    }
}

extension Location: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availableMacSecPortSpeeds
        case availablePortSpeeds
        case availableProviders
        case locationCode
        case locationName
        case region
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availableMacSecPortSpeeds = availableMacSecPortSpeeds {
            var availableMacSecPortSpeedsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availableMacSecPortSpeeds)
            for availablemacsecportspeeds0 in availableMacSecPortSpeeds {
                try availableMacSecPortSpeedsContainer.encode(availablemacsecportspeeds0)
            }
        }
        if let availablePortSpeeds = availablePortSpeeds {
            var availablePortSpeedsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availablePortSpeeds)
            for availableportspeeds0 in availablePortSpeeds {
                try availablePortSpeedsContainer.encode(availableportspeeds0)
            }
        }
        if let availableProviders = availableProviders {
            var availableProvidersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availableProviders)
            for providerlist0 in availableProviders {
                try availableProvidersContainer.encode(providerlist0)
            }
        }
        if let locationCode = locationCode {
            try encodeContainer.encode(locationCode, forKey: .locationCode)
        }
        if let locationName = locationName {
            try encodeContainer.encode(locationName, forKey: .locationName)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationCode)
        locationCode = locationCodeDecoded
        let locationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationName)
        locationName = locationNameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let availablePortSpeedsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .availablePortSpeeds)
        var availablePortSpeedsDecoded0:[String]? = nil
        if let availablePortSpeedsContainer = availablePortSpeedsContainer {
            availablePortSpeedsDecoded0 = [String]()
            for string0 in availablePortSpeedsContainer {
                if let string0 = string0 {
                    availablePortSpeedsDecoded0?.append(string0)
                }
            }
        }
        availablePortSpeeds = availablePortSpeedsDecoded0
        let availableProvidersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .availableProviders)
        var availableProvidersDecoded0:[String]? = nil
        if let availableProvidersContainer = availableProvidersContainer {
            availableProvidersDecoded0 = [String]()
            for string0 in availableProvidersContainer {
                if let string0 = string0 {
                    availableProvidersDecoded0?.append(string0)
                }
            }
        }
        availableProviders = availableProvidersDecoded0
        let availableMacSecPortSpeedsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .availableMacSecPortSpeeds)
        var availableMacSecPortSpeedsDecoded0:[String]? = nil
        if let availableMacSecPortSpeedsContainer = availableMacSecPortSpeedsContainer {
            availableMacSecPortSpeedsDecoded0 = [String]()
            for string0 in availableMacSecPortSpeedsContainer {
                if let string0 = string0 {
                    availableMacSecPortSpeedsDecoded0?.append(string0)
                }
            }
        }
        availableMacSecPortSpeeds = availableMacSecPortSpeedsDecoded0
    }
}

extension Location: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Location(availableMacSecPortSpeeds: \(String(describing: availableMacSecPortSpeeds)), availablePortSpeeds: \(String(describing: availablePortSpeeds)), availableProviders: \(String(describing: availableProviders)), locationCode: \(String(describing: locationCode)), locationName: \(String(describing: locationName)), region: \(String(describing: region)))"}
}

/// <p>Information about an AWS Direct Connect location.</p>
public struct Location: Equatable {
    /// <p>The available MAC Security (MACsec) port speeds for the location.</p>
    public let availableMacSecPortSpeeds: [String]?
    /// <p>The available port speeds for the location.</p>
    public let availablePortSpeeds: [String]?
    /// <p>The name of the service provider for the location.</p>
    public let availableProviders: [String]?
    /// <p>The code for the location.</p>
    public let locationCode: String?
    /// <p>The name of the location. This includes the name of the colocation partner and the physical site of the building.</p>
    public let locationName: String?
    /// <p>The AWS Region for the location.</p>
    public let region: String?

    public init (
        availableMacSecPortSpeeds: [String]? = nil,
        availablePortSpeeds: [String]? = nil,
        availableProviders: [String]? = nil,
        locationCode: String? = nil,
        locationName: String? = nil,
        region: String? = nil
    )
    {
        self.availableMacSecPortSpeeds = availableMacSecPortSpeeds
        self.availablePortSpeeds = availablePortSpeeds
        self.availableProviders = availableProviders
        self.locationCode = locationCode
        self.locationName = locationName
        self.region = region
    }
}

extension MacSecKey: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ckn
        case secretARN
        case startOn
        case state
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ckn = ckn {
            try encodeContainer.encode(ckn, forKey: .ckn)
        }
        if let secretARN = secretARN {
            try encodeContainer.encode(secretARN, forKey: .secretARN)
        }
        if let startOn = startOn {
            try encodeContainer.encode(startOn, forKey: .startOn)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretARN)
        secretARN = secretARNDecoded
        let cknDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ckn)
        ckn = cknDecoded
        let stateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .state)
        state = stateDecoded
        let startOnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startOn)
        startOn = startOnDecoded
    }
}

extension MacSecKey: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MacSecKey(ckn: \(String(describing: ckn)), secretARN: \(String(describing: secretARN)), startOn: \(String(describing: startOn)), state: \(String(describing: state)))"}
}

/// <p>Information about the MAC Security (MACsec) secret key.</p>
public struct MacSecKey: Equatable {
    /// <p>The Connection Key Name (CKN) for the MAC Security secret key.</p>
    public let ckn: String?
    /// <p>The Amazon Resource Name (ARN) of the MAC Security (MACsec) secret key.</p>
    public let secretARN: String?
    /// <p>The date that the MAC Security (MACsec) secret key takes effect. The value is displayed in UTC format.</p>
    public let startOn: String?
    /// <p>The state of the MAC Security (MACsec) secret key.</p>
    ///          <p>The possible values are:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>associating</code>: The MAC Security (MACsec) secret key is being validated and not yet associated with the connection or LAG.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>associated</code>: The MAC Security (MACsec) secret key is validated and associated with the connection or LAG.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>disassociating</code>: The MAC Security (MACsec) secret key is being disassociated from the connection or LAG</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>disassociated</code>: The MAC Security (MACsec) secret key is no longer associated with the connection or LAG.</p>
    ///             </li>
    ///          </ul>
    public let state: String?

    public init (
        ckn: String? = nil,
        secretARN: String? = nil,
        startOn: String? = nil,
        state: String? = nil
    )
    {
        self.ckn = ckn
        self.secretARN = secretARN
        self.startOn = startOn
        self.state = state
    }
}

extension NewBGPPeer: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addressFamily
        case amazonAddress
        case asn
        case authKey
        case customerAddress
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressFamily = addressFamily {
            try encodeContainer.encode(addressFamily.rawValue, forKey: .addressFamily)
        }
        if let amazonAddress = amazonAddress {
            try encodeContainer.encode(amazonAddress, forKey: .amazonAddress)
        }
        if asn != 0 {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let authKey = authKey {
            try encodeContainer.encode(authKey, forKey: .authKey)
        }
        if let customerAddress = customerAddress {
            try encodeContainer.encode(customerAddress, forKey: .customerAddress)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let asnDecoded = try containerValues.decode(Int.self, forKey: .asn)
        asn = asnDecoded
        let authKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authKey)
        authKey = authKeyDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let amazonAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amazonAddress)
        amazonAddress = amazonAddressDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
    }
}

extension NewBGPPeer: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NewBGPPeer(addressFamily: \(String(describing: addressFamily)), amazonAddress: \(String(describing: amazonAddress)), asn: \(String(describing: asn)), authKey: \(String(describing: authKey)), customerAddress: \(String(describing: customerAddress)))"}
}

/// <p>Information about a new BGP peer.</p>
public struct NewBGPPeer: Equatable {
    /// <p>The address family for the BGP peer.</p>
    public let addressFamily: AddressFamily?
    /// <p>The IP address assigned to the Amazon interface.</p>
    public let amazonAddress: String?
    /// <p>The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.</p>
    public let asn: Int
    /// <p>The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.</p>
    public let authKey: String?
    /// <p>The IP address assigned to the customer interface.</p>
    public let customerAddress: String?

    public init (
        addressFamily: AddressFamily? = nil,
        amazonAddress: String? = nil,
        asn: Int = 0,
        authKey: String? = nil,
        customerAddress: String? = nil
    )
    {
        self.addressFamily = addressFamily
        self.amazonAddress = amazonAddress
        self.asn = asn
        self.authKey = authKey
        self.customerAddress = customerAddress
    }
}

extension NewPrivateVirtualInterface: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addressFamily
        case amazonAddress
        case asn
        case authKey
        case customerAddress
        case directConnectGatewayId
        case mtu
        case tags
        case virtualGatewayId
        case virtualInterfaceName
        case vlan
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressFamily = addressFamily {
            try encodeContainer.encode(addressFamily.rawValue, forKey: .addressFamily)
        }
        if let amazonAddress = amazonAddress {
            try encodeContainer.encode(amazonAddress, forKey: .amazonAddress)
        }
        if asn != 0 {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let authKey = authKey {
            try encodeContainer.encode(authKey, forKey: .authKey)
        }
        if let customerAddress = customerAddress {
            try encodeContainer.encode(customerAddress, forKey: .customerAddress)
        }
        if let directConnectGatewayId = directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let mtu = mtu {
            try encodeContainer.encode(mtu, forKey: .mtu)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let virtualGatewayId = virtualGatewayId {
            try encodeContainer.encode(virtualGatewayId, forKey: .virtualGatewayId)
        }
        if let virtualInterfaceName = virtualInterfaceName {
            try encodeContainer.encode(virtualInterfaceName, forKey: .virtualInterfaceName)
        }
        if vlan != 0 {
            try encodeContainer.encode(vlan, forKey: .vlan)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceName)
        virtualInterfaceName = virtualInterfaceNameDecoded
        let vlanDecoded = try containerValues.decode(Int.self, forKey: .vlan)
        vlan = vlanDecoded
        let asnDecoded = try containerValues.decode(Int.self, forKey: .asn)
        asn = asnDecoded
        let mtuDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .mtu)
        mtu = mtuDecoded
        let authKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authKey)
        authKey = authKeyDecoded
        let amazonAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amazonAddress)
        amazonAddress = amazonAddressDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let virtualGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualGatewayId)
        virtualGatewayId = virtualGatewayIdDecoded
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NewPrivateVirtualInterface: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NewPrivateVirtualInterface(addressFamily: \(String(describing: addressFamily)), amazonAddress: \(String(describing: amazonAddress)), asn: \(String(describing: asn)), authKey: \(String(describing: authKey)), customerAddress: \(String(describing: customerAddress)), directConnectGatewayId: \(String(describing: directConnectGatewayId)), mtu: \(String(describing: mtu)), tags: \(String(describing: tags)), virtualGatewayId: \(String(describing: virtualGatewayId)), virtualInterfaceName: \(String(describing: virtualInterfaceName)), vlan: \(String(describing: vlan)))"}
}

/// <p>Information about a private virtual interface.</p>
public struct NewPrivateVirtualInterface: Equatable {
    /// <p>The address family for the BGP peer.</p>
    public let addressFamily: AddressFamily?
    /// <p>The IP address assigned to the Amazon interface.</p>
    public let amazonAddress: String?
    /// <p>The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.</p>
    ///          <p>The valid values are 1-2147483647.</p>
    public let asn: Int
    /// <p>The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.</p>
    public let authKey: String?
    /// <p>The IP address assigned to the customer interface.</p>
    public let customerAddress: String?
    /// <p>The ID of the Direct Connect gateway.</p>
    public let directConnectGatewayId: String?
    /// <p>The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 9001. The default value is 1500.</p>
    public let mtu: Int?
    /// <p>The tags associated with the private virtual interface.</p>
    public let tags: [Tag]?
    /// <p>The ID of the virtual private gateway.</p>
    public let virtualGatewayId: String?
    /// <p>The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).</p>
    public let virtualInterfaceName: String?
    /// <p>The ID of the VLAN.</p>
    public let vlan: Int

    public init (
        addressFamily: AddressFamily? = nil,
        amazonAddress: String? = nil,
        asn: Int = 0,
        authKey: String? = nil,
        customerAddress: String? = nil,
        directConnectGatewayId: String? = nil,
        mtu: Int? = nil,
        tags: [Tag]? = nil,
        virtualGatewayId: String? = nil,
        virtualInterfaceName: String? = nil,
        vlan: Int = 0
    )
    {
        self.addressFamily = addressFamily
        self.amazonAddress = amazonAddress
        self.asn = asn
        self.authKey = authKey
        self.customerAddress = customerAddress
        self.directConnectGatewayId = directConnectGatewayId
        self.mtu = mtu
        self.tags = tags
        self.virtualGatewayId = virtualGatewayId
        self.virtualInterfaceName = virtualInterfaceName
        self.vlan = vlan
    }
}

extension NewPrivateVirtualInterfaceAllocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addressFamily
        case amazonAddress
        case asn
        case authKey
        case customerAddress
        case mtu
        case tags
        case virtualInterfaceName
        case vlan
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressFamily = addressFamily {
            try encodeContainer.encode(addressFamily.rawValue, forKey: .addressFamily)
        }
        if let amazonAddress = amazonAddress {
            try encodeContainer.encode(amazonAddress, forKey: .amazonAddress)
        }
        if asn != 0 {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let authKey = authKey {
            try encodeContainer.encode(authKey, forKey: .authKey)
        }
        if let customerAddress = customerAddress {
            try encodeContainer.encode(customerAddress, forKey: .customerAddress)
        }
        if let mtu = mtu {
            try encodeContainer.encode(mtu, forKey: .mtu)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let virtualInterfaceName = virtualInterfaceName {
            try encodeContainer.encode(virtualInterfaceName, forKey: .virtualInterfaceName)
        }
        if vlan != 0 {
            try encodeContainer.encode(vlan, forKey: .vlan)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceName)
        virtualInterfaceName = virtualInterfaceNameDecoded
        let vlanDecoded = try containerValues.decode(Int.self, forKey: .vlan)
        vlan = vlanDecoded
        let asnDecoded = try containerValues.decode(Int.self, forKey: .asn)
        asn = asnDecoded
        let mtuDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .mtu)
        mtu = mtuDecoded
        let authKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authKey)
        authKey = authKeyDecoded
        let amazonAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amazonAddress)
        amazonAddress = amazonAddressDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NewPrivateVirtualInterfaceAllocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NewPrivateVirtualInterfaceAllocation(addressFamily: \(String(describing: addressFamily)), amazonAddress: \(String(describing: amazonAddress)), asn: \(String(describing: asn)), authKey: \(String(describing: authKey)), customerAddress: \(String(describing: customerAddress)), mtu: \(String(describing: mtu)), tags: \(String(describing: tags)), virtualInterfaceName: \(String(describing: virtualInterfaceName)), vlan: \(String(describing: vlan)))"}
}

/// <p>Information about a private virtual interface to be provisioned on a connection.</p>
public struct NewPrivateVirtualInterfaceAllocation: Equatable {
    /// <p>The address family for the BGP peer.</p>
    public let addressFamily: AddressFamily?
    /// <p>The IP address assigned to the Amazon interface.</p>
    public let amazonAddress: String?
    /// <p>The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.</p>
    ///          <p>The valid values are 1-2147483647.</p>
    public let asn: Int
    /// <p>The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.</p>
    public let authKey: String?
    /// <p>The IP address assigned to the customer interface.</p>
    public let customerAddress: String?
    /// <p>The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 9001. The default value is 1500.</p>
    public let mtu: Int?
    /// <p>The tags associated with the private virtual interface.</p>
    public let tags: [Tag]?
    /// <p>The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).</p>
    public let virtualInterfaceName: String?
    /// <p>The ID of the VLAN.</p>
    public let vlan: Int

    public init (
        addressFamily: AddressFamily? = nil,
        amazonAddress: String? = nil,
        asn: Int = 0,
        authKey: String? = nil,
        customerAddress: String? = nil,
        mtu: Int? = nil,
        tags: [Tag]? = nil,
        virtualInterfaceName: String? = nil,
        vlan: Int = 0
    )
    {
        self.addressFamily = addressFamily
        self.amazonAddress = amazonAddress
        self.asn = asn
        self.authKey = authKey
        self.customerAddress = customerAddress
        self.mtu = mtu
        self.tags = tags
        self.virtualInterfaceName = virtualInterfaceName
        self.vlan = vlan
    }
}

extension NewPublicVirtualInterface: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addressFamily
        case amazonAddress
        case asn
        case authKey
        case customerAddress
        case routeFilterPrefixes
        case tags
        case virtualInterfaceName
        case vlan
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressFamily = addressFamily {
            try encodeContainer.encode(addressFamily.rawValue, forKey: .addressFamily)
        }
        if let amazonAddress = amazonAddress {
            try encodeContainer.encode(amazonAddress, forKey: .amazonAddress)
        }
        if asn != 0 {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let authKey = authKey {
            try encodeContainer.encode(authKey, forKey: .authKey)
        }
        if let customerAddress = customerAddress {
            try encodeContainer.encode(customerAddress, forKey: .customerAddress)
        }
        if let routeFilterPrefixes = routeFilterPrefixes {
            var routeFilterPrefixesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .routeFilterPrefixes)
            for routefilterprefixlist0 in routeFilterPrefixes {
                try routeFilterPrefixesContainer.encode(routefilterprefixlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let virtualInterfaceName = virtualInterfaceName {
            try encodeContainer.encode(virtualInterfaceName, forKey: .virtualInterfaceName)
        }
        if vlan != 0 {
            try encodeContainer.encode(vlan, forKey: .vlan)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceName)
        virtualInterfaceName = virtualInterfaceNameDecoded
        let vlanDecoded = try containerValues.decode(Int.self, forKey: .vlan)
        vlan = vlanDecoded
        let asnDecoded = try containerValues.decode(Int.self, forKey: .asn)
        asn = asnDecoded
        let authKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authKey)
        authKey = authKeyDecoded
        let amazonAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amazonAddress)
        amazonAddress = amazonAddressDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let routeFilterPrefixesContainer = try containerValues.decodeIfPresent([RouteFilterPrefix?].self, forKey: .routeFilterPrefixes)
        var routeFilterPrefixesDecoded0:[RouteFilterPrefix]? = nil
        if let routeFilterPrefixesContainer = routeFilterPrefixesContainer {
            routeFilterPrefixesDecoded0 = [RouteFilterPrefix]()
            for structure0 in routeFilterPrefixesContainer {
                if let structure0 = structure0 {
                    routeFilterPrefixesDecoded0?.append(structure0)
                }
            }
        }
        routeFilterPrefixes = routeFilterPrefixesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NewPublicVirtualInterface: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NewPublicVirtualInterface(addressFamily: \(String(describing: addressFamily)), amazonAddress: \(String(describing: amazonAddress)), asn: \(String(describing: asn)), authKey: \(String(describing: authKey)), customerAddress: \(String(describing: customerAddress)), routeFilterPrefixes: \(String(describing: routeFilterPrefixes)), tags: \(String(describing: tags)), virtualInterfaceName: \(String(describing: virtualInterfaceName)), vlan: \(String(describing: vlan)))"}
}

/// <p>Information about a public virtual interface.</p>
public struct NewPublicVirtualInterface: Equatable {
    /// <p>The address family for the BGP peer.</p>
    public let addressFamily: AddressFamily?
    /// <p>The IP address assigned to the Amazon interface.</p>
    public let amazonAddress: String?
    /// <p>The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.</p>
    ///          <p>The valid values are 1-2147483647.</p>
    public let asn: Int
    /// <p>The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.</p>
    public let authKey: String?
    /// <p>The IP address assigned to the customer interface.</p>
    public let customerAddress: String?
    /// <p>The routes to be advertised to the AWS network in this Region. Applies to public virtual interfaces.</p>
    public let routeFilterPrefixes: [RouteFilterPrefix]?
    /// <p>The tags associated with the public virtual interface.</p>
    public let tags: [Tag]?
    /// <p>The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).</p>
    public let virtualInterfaceName: String?
    /// <p>The ID of the VLAN.</p>
    public let vlan: Int

    public init (
        addressFamily: AddressFamily? = nil,
        amazonAddress: String? = nil,
        asn: Int = 0,
        authKey: String? = nil,
        customerAddress: String? = nil,
        routeFilterPrefixes: [RouteFilterPrefix]? = nil,
        tags: [Tag]? = nil,
        virtualInterfaceName: String? = nil,
        vlan: Int = 0
    )
    {
        self.addressFamily = addressFamily
        self.amazonAddress = amazonAddress
        self.asn = asn
        self.authKey = authKey
        self.customerAddress = customerAddress
        self.routeFilterPrefixes = routeFilterPrefixes
        self.tags = tags
        self.virtualInterfaceName = virtualInterfaceName
        self.vlan = vlan
    }
}

extension NewPublicVirtualInterfaceAllocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addressFamily
        case amazonAddress
        case asn
        case authKey
        case customerAddress
        case routeFilterPrefixes
        case tags
        case virtualInterfaceName
        case vlan
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressFamily = addressFamily {
            try encodeContainer.encode(addressFamily.rawValue, forKey: .addressFamily)
        }
        if let amazonAddress = amazonAddress {
            try encodeContainer.encode(amazonAddress, forKey: .amazonAddress)
        }
        if asn != 0 {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let authKey = authKey {
            try encodeContainer.encode(authKey, forKey: .authKey)
        }
        if let customerAddress = customerAddress {
            try encodeContainer.encode(customerAddress, forKey: .customerAddress)
        }
        if let routeFilterPrefixes = routeFilterPrefixes {
            var routeFilterPrefixesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .routeFilterPrefixes)
            for routefilterprefixlist0 in routeFilterPrefixes {
                try routeFilterPrefixesContainer.encode(routefilterprefixlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let virtualInterfaceName = virtualInterfaceName {
            try encodeContainer.encode(virtualInterfaceName, forKey: .virtualInterfaceName)
        }
        if vlan != 0 {
            try encodeContainer.encode(vlan, forKey: .vlan)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceName)
        virtualInterfaceName = virtualInterfaceNameDecoded
        let vlanDecoded = try containerValues.decode(Int.self, forKey: .vlan)
        vlan = vlanDecoded
        let asnDecoded = try containerValues.decode(Int.self, forKey: .asn)
        asn = asnDecoded
        let authKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authKey)
        authKey = authKeyDecoded
        let amazonAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amazonAddress)
        amazonAddress = amazonAddressDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let routeFilterPrefixesContainer = try containerValues.decodeIfPresent([RouteFilterPrefix?].self, forKey: .routeFilterPrefixes)
        var routeFilterPrefixesDecoded0:[RouteFilterPrefix]? = nil
        if let routeFilterPrefixesContainer = routeFilterPrefixesContainer {
            routeFilterPrefixesDecoded0 = [RouteFilterPrefix]()
            for structure0 in routeFilterPrefixesContainer {
                if let structure0 = structure0 {
                    routeFilterPrefixesDecoded0?.append(structure0)
                }
            }
        }
        routeFilterPrefixes = routeFilterPrefixesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NewPublicVirtualInterfaceAllocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NewPublicVirtualInterfaceAllocation(addressFamily: \(String(describing: addressFamily)), amazonAddress: \(String(describing: amazonAddress)), asn: \(String(describing: asn)), authKey: \(String(describing: authKey)), customerAddress: \(String(describing: customerAddress)), routeFilterPrefixes: \(String(describing: routeFilterPrefixes)), tags: \(String(describing: tags)), virtualInterfaceName: \(String(describing: virtualInterfaceName)), vlan: \(String(describing: vlan)))"}
}

/// <p>Information about a public virtual interface to be provisioned on a connection.</p>
public struct NewPublicVirtualInterfaceAllocation: Equatable {
    /// <p>The address family for the BGP peer.</p>
    public let addressFamily: AddressFamily?
    /// <p>The IP address assigned to the Amazon interface.</p>
    public let amazonAddress: String?
    /// <p>The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.</p>
    ///          <p>The valid values are 1-2147483647.</p>
    public let asn: Int
    /// <p>The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.</p>
    public let authKey: String?
    /// <p>The IP address assigned to the customer interface.</p>
    public let customerAddress: String?
    /// <p>The routes to be advertised to the AWS network in this Region. Applies to public virtual interfaces.</p>
    public let routeFilterPrefixes: [RouteFilterPrefix]?
    /// <p>The tags associated with the public virtual interface.</p>
    public let tags: [Tag]?
    /// <p>The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).</p>
    public let virtualInterfaceName: String?
    /// <p>The ID of the VLAN.</p>
    public let vlan: Int

    public init (
        addressFamily: AddressFamily? = nil,
        amazonAddress: String? = nil,
        asn: Int = 0,
        authKey: String? = nil,
        customerAddress: String? = nil,
        routeFilterPrefixes: [RouteFilterPrefix]? = nil,
        tags: [Tag]? = nil,
        virtualInterfaceName: String? = nil,
        vlan: Int = 0
    )
    {
        self.addressFamily = addressFamily
        self.amazonAddress = amazonAddress
        self.asn = asn
        self.authKey = authKey
        self.customerAddress = customerAddress
        self.routeFilterPrefixes = routeFilterPrefixes
        self.tags = tags
        self.virtualInterfaceName = virtualInterfaceName
        self.vlan = vlan
    }
}

extension NewTransitVirtualInterface: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addressFamily
        case amazonAddress
        case asn
        case authKey
        case customerAddress
        case directConnectGatewayId
        case mtu
        case tags
        case virtualInterfaceName
        case vlan
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressFamily = addressFamily {
            try encodeContainer.encode(addressFamily.rawValue, forKey: .addressFamily)
        }
        if let amazonAddress = amazonAddress {
            try encodeContainer.encode(amazonAddress, forKey: .amazonAddress)
        }
        if asn != 0 {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let authKey = authKey {
            try encodeContainer.encode(authKey, forKey: .authKey)
        }
        if let customerAddress = customerAddress {
            try encodeContainer.encode(customerAddress, forKey: .customerAddress)
        }
        if let directConnectGatewayId = directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let mtu = mtu {
            try encodeContainer.encode(mtu, forKey: .mtu)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let virtualInterfaceName = virtualInterfaceName {
            try encodeContainer.encode(virtualInterfaceName, forKey: .virtualInterfaceName)
        }
        if vlan != 0 {
            try encodeContainer.encode(vlan, forKey: .vlan)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceName)
        virtualInterfaceName = virtualInterfaceNameDecoded
        let vlanDecoded = try containerValues.decode(Int.self, forKey: .vlan)
        vlan = vlanDecoded
        let asnDecoded = try containerValues.decode(Int.self, forKey: .asn)
        asn = asnDecoded
        let mtuDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .mtu)
        mtu = mtuDecoded
        let authKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authKey)
        authKey = authKeyDecoded
        let amazonAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amazonAddress)
        amazonAddress = amazonAddressDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NewTransitVirtualInterface: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NewTransitVirtualInterface(addressFamily: \(String(describing: addressFamily)), amazonAddress: \(String(describing: amazonAddress)), asn: \(String(describing: asn)), authKey: \(String(describing: authKey)), customerAddress: \(String(describing: customerAddress)), directConnectGatewayId: \(String(describing: directConnectGatewayId)), mtu: \(String(describing: mtu)), tags: \(String(describing: tags)), virtualInterfaceName: \(String(describing: virtualInterfaceName)), vlan: \(String(describing: vlan)))"}
}

/// <p>Information about a transit virtual interface.</p>
public struct NewTransitVirtualInterface: Equatable {
    /// <p>The address family for the BGP peer.</p>
    public let addressFamily: AddressFamily?
    /// <p>The IP address assigned to the Amazon interface.</p>
    public let amazonAddress: String?
    /// <p>The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.</p>
    ///          <p>The valid values are 1-2147483647.</p>
    public let asn: Int
    /// <p>The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.</p>
    public let authKey: String?
    /// <p>The IP address assigned to the customer interface.</p>
    public let customerAddress: String?
    /// <p>The ID of the Direct Connect gateway.</p>
    public let directConnectGatewayId: String?
    /// <p>The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 9001. The default value is 1500.</p>
    public let mtu: Int?
    /// <p>The tags associated with the transitive virtual interface.</p>
    public let tags: [Tag]?
    /// <p>The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).</p>
    public let virtualInterfaceName: String?
    /// <p>The ID of the VLAN.</p>
    public let vlan: Int

    public init (
        addressFamily: AddressFamily? = nil,
        amazonAddress: String? = nil,
        asn: Int = 0,
        authKey: String? = nil,
        customerAddress: String? = nil,
        directConnectGatewayId: String? = nil,
        mtu: Int? = nil,
        tags: [Tag]? = nil,
        virtualInterfaceName: String? = nil,
        vlan: Int = 0
    )
    {
        self.addressFamily = addressFamily
        self.amazonAddress = amazonAddress
        self.asn = asn
        self.authKey = authKey
        self.customerAddress = customerAddress
        self.directConnectGatewayId = directConnectGatewayId
        self.mtu = mtu
        self.tags = tags
        self.virtualInterfaceName = virtualInterfaceName
        self.vlan = vlan
    }
}

extension NewTransitVirtualInterfaceAllocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addressFamily
        case amazonAddress
        case asn
        case authKey
        case customerAddress
        case mtu
        case tags
        case virtualInterfaceName
        case vlan
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressFamily = addressFamily {
            try encodeContainer.encode(addressFamily.rawValue, forKey: .addressFamily)
        }
        if let amazonAddress = amazonAddress {
            try encodeContainer.encode(amazonAddress, forKey: .amazonAddress)
        }
        if asn != 0 {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let authKey = authKey {
            try encodeContainer.encode(authKey, forKey: .authKey)
        }
        if let customerAddress = customerAddress {
            try encodeContainer.encode(customerAddress, forKey: .customerAddress)
        }
        if let mtu = mtu {
            try encodeContainer.encode(mtu, forKey: .mtu)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let virtualInterfaceName = virtualInterfaceName {
            try encodeContainer.encode(virtualInterfaceName, forKey: .virtualInterfaceName)
        }
        if vlan != 0 {
            try encodeContainer.encode(vlan, forKey: .vlan)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceName)
        virtualInterfaceName = virtualInterfaceNameDecoded
        let vlanDecoded = try containerValues.decode(Int.self, forKey: .vlan)
        vlan = vlanDecoded
        let asnDecoded = try containerValues.decode(Int.self, forKey: .asn)
        asn = asnDecoded
        let mtuDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .mtu)
        mtu = mtuDecoded
        let authKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authKey)
        authKey = authKeyDecoded
        let amazonAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amazonAddress)
        amazonAddress = amazonAddressDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NewTransitVirtualInterfaceAllocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NewTransitVirtualInterfaceAllocation(addressFamily: \(String(describing: addressFamily)), amazonAddress: \(String(describing: amazonAddress)), asn: \(String(describing: asn)), authKey: \(String(describing: authKey)), customerAddress: \(String(describing: customerAddress)), mtu: \(String(describing: mtu)), tags: \(String(describing: tags)), virtualInterfaceName: \(String(describing: virtualInterfaceName)), vlan: \(String(describing: vlan)))"}
}

/// <p>Information about a transit virtual interface to be provisioned on a connection.</p>
public struct NewTransitVirtualInterfaceAllocation: Equatable {
    /// <p>The address family for the BGP peer.</p>
    public let addressFamily: AddressFamily?
    /// <p>The IP address assigned to the Amazon interface.</p>
    public let amazonAddress: String?
    /// <p>The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.</p>
    ///          <p>The valid values are 1-2147483647.</p>
    public let asn: Int
    /// <p>The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.</p>
    public let authKey: String?
    /// <p>The IP address assigned to the customer interface.</p>
    public let customerAddress: String?
    /// <p>The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 9001. The default value is 1500. </p>
    public let mtu: Int?
    /// <p>The tags associated with the transitive virtual interface.</p>
    public let tags: [Tag]?
    /// <p>The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).</p>
    public let virtualInterfaceName: String?
    /// <p>The ID of the VLAN.</p>
    public let vlan: Int

    public init (
        addressFamily: AddressFamily? = nil,
        amazonAddress: String? = nil,
        asn: Int = 0,
        authKey: String? = nil,
        customerAddress: String? = nil,
        mtu: Int? = nil,
        tags: [Tag]? = nil,
        virtualInterfaceName: String? = nil,
        vlan: Int = 0
    )
    {
        self.addressFamily = addressFamily
        self.amazonAddress = amazonAddress
        self.asn = asn
        self.authKey = authKey
        self.customerAddress = customerAddress
        self.mtu = mtu
        self.tags = tags
        self.virtualInterfaceName = virtualInterfaceName
        self.vlan = vlan
    }
}

extension ResourceTag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ResourceTag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceTag(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

/// <p>Information about a tag associated with an AWS Direct Connect resource.</p>
public struct ResourceTag: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?
    /// <p>The tags.</p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension RouteFilterPrefix: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cidr
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidr = cidr {
            try encodeContainer.encode(cidr, forKey: .cidr)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cidr)
        cidr = cidrDecoded
    }
}

extension RouteFilterPrefix: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RouteFilterPrefix(cidr: \(String(describing: cidr)))"}
}

/// <p>Information about a route filter prefix that a customer can advertise through Border Gateway Protocol (BGP)
///         over a public virtual interface.</p>
public struct RouteFilterPrefix: Equatable {
    /// <p>The CIDR block for the advertised route. Separate multiple routes using commas. An IPv6 CIDR must use /64 or shorter.</p>
    public let cidr: String?

    public init (
        cidr: String? = nil
    )
    {
        self.cidr = cidr
    }
}

public struct StartBgpFailoverTestInputBodyMiddleware: Middleware {
    public let id: String = "StartBgpFailoverTestInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartBgpFailoverTestInput>,
                  next: H) -> Swift.Result<OperationOutput<StartBgpFailoverTestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartBgpFailoverTestInput>
    public typealias MOutput = OperationOutput<StartBgpFailoverTestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartBgpFailoverTestOutputError>
}

extension StartBgpFailoverTestInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartBgpFailoverTestInput(bgpPeers: \(String(describing: bgpPeers)), testDurationInMinutes: \(String(describing: testDurationInMinutes)), virtualInterfaceId: \(String(describing: virtualInterfaceId)))"}
}

extension StartBgpFailoverTestInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bgpPeers
        case testDurationInMinutes
        case virtualInterfaceId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bgpPeers = bgpPeers {
            var bgpPeersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bgpPeers)
            for bgppeeridlist0 in bgpPeers {
                try bgpPeersContainer.encode(bgppeeridlist0)
            }
        }
        if let testDurationInMinutes = testDurationInMinutes {
            try encodeContainer.encode(testDurationInMinutes, forKey: .testDurationInMinutes)
        }
        if let virtualInterfaceId = virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
    }
}

public struct StartBgpFailoverTestInputHeadersMiddleware: Middleware {
    public let id: String = "StartBgpFailoverTestInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartBgpFailoverTestInput>,
                  next: H) -> Swift.Result<OperationOutput<StartBgpFailoverTestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartBgpFailoverTestInput>
    public typealias MOutput = OperationOutput<StartBgpFailoverTestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartBgpFailoverTestOutputError>
}

public struct StartBgpFailoverTestInputQueryItemMiddleware: Middleware {
    public let id: String = "StartBgpFailoverTestInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartBgpFailoverTestInput>,
                  next: H) -> Swift.Result<OperationOutput<StartBgpFailoverTestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartBgpFailoverTestInput>
    public typealias MOutput = OperationOutput<StartBgpFailoverTestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartBgpFailoverTestOutputError>
}

public struct StartBgpFailoverTestInput: Equatable {
    /// <p>The BGP peers to place in the DOWN state.</p>
    public let bgpPeers: [String]?
    /// <p>The time in minutes that the virtual interface failover test will last.</p>
    ///          <p>Maximum value: 180 minutes (3 hours).</p>
    ///          <p>Default: 180 minutes (3 hours).</p>
    public let testDurationInMinutes: Int?
    /// <p>The ID of the virtual interface you want to test.</p>
    public let virtualInterfaceId: String?

    public init (
        bgpPeers: [String]? = nil,
        testDurationInMinutes: Int? = nil,
        virtualInterfaceId: String? = nil
    )
    {
        self.bgpPeers = bgpPeers
        self.testDurationInMinutes = testDurationInMinutes
        self.virtualInterfaceId = virtualInterfaceId
    }
}

struct StartBgpFailoverTestInputBody: Equatable {
    public let virtualInterfaceId: String?
    public let bgpPeers: [String]?
    public let testDurationInMinutes: Int?
}

extension StartBgpFailoverTestInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bgpPeers
        case testDurationInMinutes
        case virtualInterfaceId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let bgpPeersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .bgpPeers)
        var bgpPeersDecoded0:[String]? = nil
        if let bgpPeersContainer = bgpPeersContainer {
            bgpPeersDecoded0 = [String]()
            for string0 in bgpPeersContainer {
                if let string0 = string0 {
                    bgpPeersDecoded0?.append(string0)
                }
            }
        }
        bgpPeers = bgpPeersDecoded0
        let testDurationInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .testDurationInMinutes)
        testDurationInMinutes = testDurationInMinutesDecoded
    }
}

extension StartBgpFailoverTestOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartBgpFailoverTestOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartBgpFailoverTestOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartBgpFailoverTestOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartBgpFailoverTestOutputResponse(virtualInterfaceTest: \(String(describing: virtualInterfaceTest)))"}
}

extension StartBgpFailoverTestOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartBgpFailoverTestOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.virtualInterfaceTest = output.virtualInterfaceTest
        } else {
            self.virtualInterfaceTest = nil
        }
    }
}

public struct StartBgpFailoverTestOutputResponse: Equatable {
    /// <p>Information about the virtual interface failover test.</p>
    public let virtualInterfaceTest: VirtualInterfaceTestHistory?

    public init (
        virtualInterfaceTest: VirtualInterfaceTestHistory? = nil
    )
    {
        self.virtualInterfaceTest = virtualInterfaceTest
    }
}

struct StartBgpFailoverTestOutputResponseBody: Equatable {
    public let virtualInterfaceTest: VirtualInterfaceTestHistory?
}

extension StartBgpFailoverTestOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualInterfaceTest
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceTestDecoded = try containerValues.decodeIfPresent(VirtualInterfaceTestHistory.self, forKey: .virtualInterfaceTest)
        virtualInterfaceTest = virtualInterfaceTestDecoded
    }
}

public struct StopBgpFailoverTestInputBodyMiddleware: Middleware {
    public let id: String = "StopBgpFailoverTestInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopBgpFailoverTestInput>,
                  next: H) -> Swift.Result<OperationOutput<StopBgpFailoverTestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopBgpFailoverTestInput>
    public typealias MOutput = OperationOutput<StopBgpFailoverTestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopBgpFailoverTestOutputError>
}

extension StopBgpFailoverTestInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopBgpFailoverTestInput(virtualInterfaceId: \(String(describing: virtualInterfaceId)))"}
}

extension StopBgpFailoverTestInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case virtualInterfaceId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let virtualInterfaceId = virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
    }
}

public struct StopBgpFailoverTestInputHeadersMiddleware: Middleware {
    public let id: String = "StopBgpFailoverTestInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopBgpFailoverTestInput>,
                  next: H) -> Swift.Result<OperationOutput<StopBgpFailoverTestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopBgpFailoverTestInput>
    public typealias MOutput = OperationOutput<StopBgpFailoverTestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopBgpFailoverTestOutputError>
}

public struct StopBgpFailoverTestInputQueryItemMiddleware: Middleware {
    public let id: String = "StopBgpFailoverTestInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopBgpFailoverTestInput>,
                  next: H) -> Swift.Result<OperationOutput<StopBgpFailoverTestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopBgpFailoverTestInput>
    public typealias MOutput = OperationOutput<StopBgpFailoverTestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopBgpFailoverTestOutputError>
}

public struct StopBgpFailoverTestInput: Equatable {
    /// <p>The ID of the virtual interface you no longer want to test.</p>
    public let virtualInterfaceId: String?

    public init (
        virtualInterfaceId: String? = nil
    )
    {
        self.virtualInterfaceId = virtualInterfaceId
    }
}

struct StopBgpFailoverTestInputBody: Equatable {
    public let virtualInterfaceId: String?
}

extension StopBgpFailoverTestInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualInterfaceId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
    }
}

extension StopBgpFailoverTestOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopBgpFailoverTestOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopBgpFailoverTestOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopBgpFailoverTestOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopBgpFailoverTestOutputResponse(virtualInterfaceTest: \(String(describing: virtualInterfaceTest)))"}
}

extension StopBgpFailoverTestOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopBgpFailoverTestOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.virtualInterfaceTest = output.virtualInterfaceTest
        } else {
            self.virtualInterfaceTest = nil
        }
    }
}

public struct StopBgpFailoverTestOutputResponse: Equatable {
    /// <p>Information about the virtual interface failover test.</p>
    public let virtualInterfaceTest: VirtualInterfaceTestHistory?

    public init (
        virtualInterfaceTest: VirtualInterfaceTestHistory? = nil
    )
    {
        self.virtualInterfaceTest = virtualInterfaceTest
    }
}

struct StopBgpFailoverTestOutputResponseBody: Equatable {
    public let virtualInterfaceTest: VirtualInterfaceTestHistory?
}

extension StopBgpFailoverTestOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualInterfaceTest
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceTestDecoded = try containerValues.decodeIfPresent(VirtualInterfaceTestHistory.self, forKey: .virtualInterfaceTest)
        virtualInterfaceTest = virtualInterfaceTestDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Information about a tag.</p>
public struct Tag: Equatable {
    /// <p>The key.</p>
    public let key: String?
    /// <p>The value.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?
    /// <p>The tags to add.</p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateTagKeysException" : self = .duplicateTagKeysException(try DuplicateTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case duplicateTagKeysException(DuplicateTagKeysException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TooManyTagsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyTagsException(message: \(String(describing: message)))"}
}

extension TooManyTagsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have reached the limit on the number of tags that can be assigned.</p>
public struct TooManyTagsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyTagsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?
    /// <p>The tag keys of the tags to remove.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tagKeys
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateConnectionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConnectionInput>
    public typealias MOutput = OperationOutput<UpdateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConnectionOutputError>
}

extension UpdateConnectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConnectionInput(connectionId: \(String(describing: connectionId)), connectionName: \(String(describing: connectionName)), encryptionMode: \(String(describing: encryptionMode)))"}
}

extension UpdateConnectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case connectionName
        case encryptionMode
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let connectionName = connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let encryptionMode = encryptionMode {
            try encodeContainer.encode(encryptionMode, forKey: .encryptionMode)
        }
    }
}

public struct UpdateConnectionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConnectionInput>
    public typealias MOutput = OperationOutput<UpdateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConnectionOutputError>
}

public struct UpdateConnectionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConnectionInput>
    public typealias MOutput = OperationOutput<UpdateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConnectionOutputError>
}

public struct UpdateConnectionInput: Equatable {
    /// <p>The ID of the dedicated connection.</p>
    ///          <p>You can use <a>DescribeConnections</a> to retrieve the connection ID.</p>
    public let connectionId: String?
    /// <p>The name of the connection.</p>
    public let connectionName: String?
    /// <p>The connection MAC Security (MACsec) encryption mode.</p>
    ///          <p>The valid values are <code>no_encrypt</code>, <code>should_encrypt</code>, and <code>must_encrypt</code>.</p>
    public let encryptionMode: String?

    public init (
        connectionId: String? = nil,
        connectionName: String? = nil,
        encryptionMode: String? = nil
    )
    {
        self.connectionId = connectionId
        self.connectionName = connectionName
        self.encryptionMode = encryptionMode
    }
}

struct UpdateConnectionInputBody: Equatable {
    public let connectionId: String?
    public let connectionName: String?
    public let encryptionMode: String?
}

extension UpdateConnectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionId
        case connectionName
        case encryptionMode
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
    }
}

extension UpdateConnectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConnectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConnectionOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConnectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConnectionOutputResponse(awsDevice: \(String(describing: awsDevice)), awsDeviceV2: \(String(describing: awsDeviceV2)), bandwidth: \(String(describing: bandwidth)), connectionId: \(String(describing: connectionId)), connectionName: \(String(describing: connectionName)), connectionState: \(String(describing: connectionState)), encryptionMode: \(String(describing: encryptionMode)), hasLogicalRedundancy: \(String(describing: hasLogicalRedundancy)), jumboFrameCapable: \(String(describing: jumboFrameCapable)), lagId: \(String(describing: lagId)), loaIssueTime: \(String(describing: loaIssueTime)), location: \(String(describing: location)), macSecCapable: \(String(describing: macSecCapable)), macSecKeys: \(String(describing: macSecKeys)), ownerAccount: \(String(describing: ownerAccount)), partnerName: \(String(describing: partnerName)), portEncryptionStatus: \(String(describing: portEncryptionStatus)), providerName: \(String(describing: providerName)), region: \(String(describing: region)), tags: \(String(describing: tags)), vlan: \(String(describing: vlan)))"}
}

extension UpdateConnectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.awsDevice = output.awsDevice
            self.awsDeviceV2 = output.awsDeviceV2
            self.bandwidth = output.bandwidth
            self.connectionId = output.connectionId
            self.connectionName = output.connectionName
            self.connectionState = output.connectionState
            self.encryptionMode = output.encryptionMode
            self.hasLogicalRedundancy = output.hasLogicalRedundancy
            self.jumboFrameCapable = output.jumboFrameCapable
            self.lagId = output.lagId
            self.loaIssueTime = output.loaIssueTime
            self.location = output.location
            self.macSecCapable = output.macSecCapable
            self.macSecKeys = output.macSecKeys
            self.ownerAccount = output.ownerAccount
            self.partnerName = output.partnerName
            self.portEncryptionStatus = output.portEncryptionStatus
            self.providerName = output.providerName
            self.region = output.region
            self.tags = output.tags
            self.vlan = output.vlan
        } else {
            self.awsDevice = nil
            self.awsDeviceV2 = nil
            self.bandwidth = nil
            self.connectionId = nil
            self.connectionName = nil
            self.connectionState = nil
            self.encryptionMode = nil
            self.hasLogicalRedundancy = nil
            self.jumboFrameCapable = nil
            self.lagId = nil
            self.loaIssueTime = nil
            self.location = nil
            self.macSecCapable = nil
            self.macSecKeys = nil
            self.ownerAccount = nil
            self.partnerName = nil
            self.portEncryptionStatus = nil
            self.providerName = nil
            self.region = nil
            self.tags = nil
            self.vlan = 0
        }
    }
}

/// <p>Information about an AWS Direct Connect connection.</p>
public struct UpdateConnectionOutputResponse: Equatable {
    /// <p>The Direct Connect endpoint on which the physical connection terminates.</p>
    @available(*, deprecated)
    public let awsDevice: String?
    /// <p>The Direct Connect endpoint on which the physical connection terminates.</p>
    public let awsDeviceV2: String?
    /// <p>The bandwidth of the connection.</p>
    public let bandwidth: String?
    /// <p>The ID of the connection.</p>
    public let connectionId: String?
    /// <p>The name of the connection.</p>
    public let connectionName: String?
    /// <p>The state of the connection. The following are the possible values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ordering</code>: The initial state of a hosted connection provisioned on an interconnect. The connection stays in the ordering state until the owner of the hosted connection confirms or declines the connection order.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>requested</code>: The initial state of a standard connection. The connection stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: The connection has been approved and is being initialized.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>available</code>: The network link is up and the connection is ready for use.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>down</code>: The network link is down.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>: The connection is being deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>: The connection has been deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>rejected</code>: A hosted connection in the <code>ordering</code> state enters the <code>rejected</code> state if it is deleted by the customer.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>unknown</code>: The state of the connection is not available.</p>
    ///             </li>
    ///          </ul>
    public let connectionState: ConnectionState?
    /// <p>The MAC Security (MACsec) connection encryption mode.</p>
    ///          <p>The valid values are <code>no_encrypt</code>, <code>should_encrypt</code>, and <code>must_encrypt</code>.</p>
    public let encryptionMode: String?
    /// <p>Indicates whether the connection supports a secondary BGP peer in the same address family (IPv4/IPv6).</p>
    public let hasLogicalRedundancy: HasLogicalRedundancy?
    /// <p>Indicates whether jumbo frames (9001 MTU) are supported.</p>
    public let jumboFrameCapable: Bool?
    /// <p>The ID of the LAG.</p>
    public let lagId: String?
    /// <p>The time of the most recent call to <a>DescribeLoa</a> for this connection.</p>
    public let loaIssueTime: Date?
    /// <p>The location of the connection.</p>
    public let location: String?
    /// <p>Indicates whether the connection supports MAC Security (MACsec).</p>
    public let macSecCapable: Bool?
    /// <p>The MAC Security (MACsec) security keys associated with the connection.</p>
    public let macSecKeys: [MacSecKey]?
    /// <p>The ID of the AWS account that owns the connection.</p>
    public let ownerAccount: String?
    /// <p>The name of the AWS Direct Connect service provider associated with the connection.</p>
    public let partnerName: String?
    /// <p>The MAC Security (MACsec) port link status of the connection.</p>
    ///          <p>The valid values are <code>Encryption Up</code>, which means that there is an active Connection Key Name, or <code>Encryption Down</code>.</p>
    public let portEncryptionStatus: String?
    /// <p>The name of the service provider associated with the connection.</p>
    public let providerName: String?
    /// <p>The AWS Region where the connection is located.</p>
    public let region: String?
    /// <p>The tags associated with the connection.</p>
    public let tags: [Tag]?
    /// <p>The ID of the VLAN.</p>
    public let vlan: Int

    public init (
        awsDevice: String? = nil,
        awsDeviceV2: String? = nil,
        bandwidth: String? = nil,
        connectionId: String? = nil,
        connectionName: String? = nil,
        connectionState: ConnectionState? = nil,
        encryptionMode: String? = nil,
        hasLogicalRedundancy: HasLogicalRedundancy? = nil,
        jumboFrameCapable: Bool? = nil,
        lagId: String? = nil,
        loaIssueTime: Date? = nil,
        location: String? = nil,
        macSecCapable: Bool? = nil,
        macSecKeys: [MacSecKey]? = nil,
        ownerAccount: String? = nil,
        partnerName: String? = nil,
        portEncryptionStatus: String? = nil,
        providerName: String? = nil,
        region: String? = nil,
        tags: [Tag]? = nil,
        vlan: Int = 0
    )
    {
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.bandwidth = bandwidth
        self.connectionId = connectionId
        self.connectionName = connectionName
        self.connectionState = connectionState
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.loaIssueTime = loaIssueTime
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.ownerAccount = ownerAccount
        self.partnerName = partnerName
        self.portEncryptionStatus = portEncryptionStatus
        self.providerName = providerName
        self.region = region
        self.tags = tags
        self.vlan = vlan
    }
}

struct UpdateConnectionOutputResponseBody: Equatable {
    public let ownerAccount: String?
    public let connectionId: String?
    public let connectionName: String?
    public let connectionState: ConnectionState?
    public let region: String?
    public let location: String?
    public let bandwidth: String?
    public let vlan: Int
    public let partnerName: String?
    public let loaIssueTime: Date?
    public let lagId: String?
    public let awsDevice: String?
    public let jumboFrameCapable: Bool?
    public let awsDeviceV2: String?
    public let hasLogicalRedundancy: HasLogicalRedundancy?
    public let tags: [Tag]?
    public let providerName: String?
    public let macSecCapable: Bool?
    public let portEncryptionStatus: String?
    public let encryptionMode: String?
    public let macSecKeys: [MacSecKey]?
}

extension UpdateConnectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case awsDevice
        case awsDeviceV2
        case bandwidth
        case connectionId
        case connectionName
        case connectionState
        case encryptionMode
        case hasLogicalRedundancy
        case jumboFrameCapable
        case lagId
        case loaIssueTime
        case location
        case macSecCapable
        case macSecKeys
        case ownerAccount
        case partnerName
        case portEncryptionStatus
        case providerName
        case region
        case tags
        case vlan
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let vlanDecoded = try containerValues.decode(Int.self, forKey: .vlan)
        vlan = vlanDecoded
        let partnerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .partnerName)
        partnerName = partnerNameDecoded
        let loaIssueTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .loaIssueTime)
        loaIssueTime = loaIssueTimeDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let awsDeviceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDevice)
        awsDevice = awsDeviceDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let hasLogicalRedundancyDecoded = try containerValues.decodeIfPresent(HasLogicalRedundancy.self, forKey: .hasLogicalRedundancy)
        hasLogicalRedundancy = hasLogicalRedundancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let macSecCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .macSecCapable)
        macSecCapable = macSecCapableDecoded
        let portEncryptionStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portEncryptionStatus)
        portEncryptionStatus = portEncryptionStatusDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let macSecKeysContainer = try containerValues.decodeIfPresent([MacSecKey?].self, forKey: .macSecKeys)
        var macSecKeysDecoded0:[MacSecKey]? = nil
        if let macSecKeysContainer = macSecKeysContainer {
            macSecKeysDecoded0 = [MacSecKey]()
            for structure0 in macSecKeysContainer {
                if let structure0 = structure0 {
                    macSecKeysDecoded0?.append(structure0)
                }
            }
        }
        macSecKeys = macSecKeysDecoded0
    }
}

public struct UpdateDirectConnectGatewayAssociationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDirectConnectGatewayAssociationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDirectConnectGatewayAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDirectConnectGatewayAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDirectConnectGatewayAssociationInput>
    public typealias MOutput = OperationOutput<UpdateDirectConnectGatewayAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDirectConnectGatewayAssociationOutputError>
}

extension UpdateDirectConnectGatewayAssociationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDirectConnectGatewayAssociationInput(addAllowedPrefixesToDirectConnectGateway: \(String(describing: addAllowedPrefixesToDirectConnectGateway)), associationId: \(String(describing: associationId)), removeAllowedPrefixesToDirectConnectGateway: \(String(describing: removeAllowedPrefixesToDirectConnectGateway)))"}
}

extension UpdateDirectConnectGatewayAssociationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addAllowedPrefixesToDirectConnectGateway
        case associationId
        case removeAllowedPrefixesToDirectConnectGateway
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addAllowedPrefixesToDirectConnectGateway = addAllowedPrefixesToDirectConnectGateway {
            var addAllowedPrefixesToDirectConnectGatewayContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addAllowedPrefixesToDirectConnectGateway)
            for routefilterprefixlist0 in addAllowedPrefixesToDirectConnectGateway {
                try addAllowedPrefixesToDirectConnectGatewayContainer.encode(routefilterprefixlist0)
            }
        }
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let removeAllowedPrefixesToDirectConnectGateway = removeAllowedPrefixesToDirectConnectGateway {
            var removeAllowedPrefixesToDirectConnectGatewayContainer = encodeContainer.nestedUnkeyedContainer(forKey: .removeAllowedPrefixesToDirectConnectGateway)
            for routefilterprefixlist0 in removeAllowedPrefixesToDirectConnectGateway {
                try removeAllowedPrefixesToDirectConnectGatewayContainer.encode(routefilterprefixlist0)
            }
        }
    }
}

public struct UpdateDirectConnectGatewayAssociationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDirectConnectGatewayAssociationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDirectConnectGatewayAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDirectConnectGatewayAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDirectConnectGatewayAssociationInput>
    public typealias MOutput = OperationOutput<UpdateDirectConnectGatewayAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDirectConnectGatewayAssociationOutputError>
}

public struct UpdateDirectConnectGatewayAssociationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDirectConnectGatewayAssociationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDirectConnectGatewayAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDirectConnectGatewayAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDirectConnectGatewayAssociationInput>
    public typealias MOutput = OperationOutput<UpdateDirectConnectGatewayAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDirectConnectGatewayAssociationOutputError>
}

public struct UpdateDirectConnectGatewayAssociationInput: Equatable {
    /// <p>The Amazon VPC prefixes to advertise to the Direct Connect gateway.</p>
    public let addAllowedPrefixesToDirectConnectGateway: [RouteFilterPrefix]?
    /// <p>The ID of the Direct Connect gateway association.</p>
    public let associationId: String?
    /// <p>The Amazon VPC prefixes to no longer advertise to the Direct Connect gateway.</p>
    public let removeAllowedPrefixesToDirectConnectGateway: [RouteFilterPrefix]?

    public init (
        addAllowedPrefixesToDirectConnectGateway: [RouteFilterPrefix]? = nil,
        associationId: String? = nil,
        removeAllowedPrefixesToDirectConnectGateway: [RouteFilterPrefix]? = nil
    )
    {
        self.addAllowedPrefixesToDirectConnectGateway = addAllowedPrefixesToDirectConnectGateway
        self.associationId = associationId
        self.removeAllowedPrefixesToDirectConnectGateway = removeAllowedPrefixesToDirectConnectGateway
    }
}

struct UpdateDirectConnectGatewayAssociationInputBody: Equatable {
    public let associationId: String?
    public let addAllowedPrefixesToDirectConnectGateway: [RouteFilterPrefix]?
    public let removeAllowedPrefixesToDirectConnectGateway: [RouteFilterPrefix]?
}

extension UpdateDirectConnectGatewayAssociationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case addAllowedPrefixesToDirectConnectGateway
        case associationId
        case removeAllowedPrefixesToDirectConnectGateway
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let addAllowedPrefixesToDirectConnectGatewayContainer = try containerValues.decodeIfPresent([RouteFilterPrefix?].self, forKey: .addAllowedPrefixesToDirectConnectGateway)
        var addAllowedPrefixesToDirectConnectGatewayDecoded0:[RouteFilterPrefix]? = nil
        if let addAllowedPrefixesToDirectConnectGatewayContainer = addAllowedPrefixesToDirectConnectGatewayContainer {
            addAllowedPrefixesToDirectConnectGatewayDecoded0 = [RouteFilterPrefix]()
            for structure0 in addAllowedPrefixesToDirectConnectGatewayContainer {
                if let structure0 = structure0 {
                    addAllowedPrefixesToDirectConnectGatewayDecoded0?.append(structure0)
                }
            }
        }
        addAllowedPrefixesToDirectConnectGateway = addAllowedPrefixesToDirectConnectGatewayDecoded0
        let removeAllowedPrefixesToDirectConnectGatewayContainer = try containerValues.decodeIfPresent([RouteFilterPrefix?].self, forKey: .removeAllowedPrefixesToDirectConnectGateway)
        var removeAllowedPrefixesToDirectConnectGatewayDecoded0:[RouteFilterPrefix]? = nil
        if let removeAllowedPrefixesToDirectConnectGatewayContainer = removeAllowedPrefixesToDirectConnectGatewayContainer {
            removeAllowedPrefixesToDirectConnectGatewayDecoded0 = [RouteFilterPrefix]()
            for structure0 in removeAllowedPrefixesToDirectConnectGatewayContainer {
                if let structure0 = structure0 {
                    removeAllowedPrefixesToDirectConnectGatewayDecoded0?.append(structure0)
                }
            }
        }
        removeAllowedPrefixesToDirectConnectGateway = removeAllowedPrefixesToDirectConnectGatewayDecoded0
    }
}

extension UpdateDirectConnectGatewayAssociationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDirectConnectGatewayAssociationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDirectConnectGatewayAssociationOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDirectConnectGatewayAssociationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDirectConnectGatewayAssociationOutputResponse(directConnectGatewayAssociation: \(String(describing: directConnectGatewayAssociation)))"}
}

extension UpdateDirectConnectGatewayAssociationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDirectConnectGatewayAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directConnectGatewayAssociation = output.directConnectGatewayAssociation
        } else {
            self.directConnectGatewayAssociation = nil
        }
    }
}

public struct UpdateDirectConnectGatewayAssociationOutputResponse: Equatable {
    /// <p>Information about an association between a Direct Connect gateway and a virtual private gateway or transit gateway.</p>
    public let directConnectGatewayAssociation: DirectConnectGatewayAssociation?

    public init (
        directConnectGatewayAssociation: DirectConnectGatewayAssociation? = nil
    )
    {
        self.directConnectGatewayAssociation = directConnectGatewayAssociation
    }
}

struct UpdateDirectConnectGatewayAssociationOutputResponseBody: Equatable {
    public let directConnectGatewayAssociation: DirectConnectGatewayAssociation?
}

extension UpdateDirectConnectGatewayAssociationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directConnectGatewayAssociation
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directConnectGatewayAssociationDecoded = try containerValues.decodeIfPresent(DirectConnectGatewayAssociation.self, forKey: .directConnectGatewayAssociation)
        directConnectGatewayAssociation = directConnectGatewayAssociationDecoded
    }
}

public struct UpdateLagInputBodyMiddleware: Middleware {
    public let id: String = "UpdateLagInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLagInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLagInput>
    public typealias MOutput = OperationOutput<UpdateLagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLagOutputError>
}

extension UpdateLagInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLagInput(encryptionMode: \(String(describing: encryptionMode)), lagId: \(String(describing: lagId)), lagName: \(String(describing: lagName)), minimumLinks: \(String(describing: minimumLinks)))"}
}

extension UpdateLagInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionMode
        case lagId
        case lagName
        case minimumLinks
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionMode = encryptionMode {
            try encodeContainer.encode(encryptionMode, forKey: .encryptionMode)
        }
        if let lagId = lagId {
            try encodeContainer.encode(lagId, forKey: .lagId)
        }
        if let lagName = lagName {
            try encodeContainer.encode(lagName, forKey: .lagName)
        }
        if minimumLinks != 0 {
            try encodeContainer.encode(minimumLinks, forKey: .minimumLinks)
        }
    }
}

public struct UpdateLagInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateLagInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLagInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLagInput>
    public typealias MOutput = OperationOutput<UpdateLagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLagOutputError>
}

public struct UpdateLagInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateLagInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLagInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLagInput>
    public typealias MOutput = OperationOutput<UpdateLagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLagOutputError>
}

public struct UpdateLagInput: Equatable {
    /// <p>The LAG MAC Security (MACsec) encryption mode.</p>
    ///          <p>AWS applies the value to all connections which are part of the LAG.</p>
    public let encryptionMode: String?
    /// <p>The ID of the LAG.</p>
    public let lagId: String?
    /// <p>The name of the LAG.</p>
    public let lagName: String?
    /// <p>The minimum number of physical connections that must be operational for the LAG itself to be operational.</p>
    public let minimumLinks: Int

    public init (
        encryptionMode: String? = nil,
        lagId: String? = nil,
        lagName: String? = nil,
        minimumLinks: Int = 0
    )
    {
        self.encryptionMode = encryptionMode
        self.lagId = lagId
        self.lagName = lagName
        self.minimumLinks = minimumLinks
    }
}

struct UpdateLagInputBody: Equatable {
    public let lagId: String?
    public let lagName: String?
    public let minimumLinks: Int
    public let encryptionMode: String?
}

extension UpdateLagInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case encryptionMode
        case lagId
        case lagName
        case minimumLinks
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lagIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let lagNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lagName)
        lagName = lagNameDecoded
        let minimumLinksDecoded = try containerValues.decode(Int.self, forKey: .minimumLinks)
        minimumLinks = minimumLinksDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
    }
}

extension UpdateLagOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLagOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLagOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLagOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLagOutputResponse(allowsHostedConnections: \(String(describing: allowsHostedConnections)), awsDevice: \(String(describing: awsDevice)), awsDeviceV2: \(String(describing: awsDeviceV2)), connections: \(String(describing: connections)), connectionsBandwidth: \(String(describing: connectionsBandwidth)), encryptionMode: \(String(describing: encryptionMode)), hasLogicalRedundancy: \(String(describing: hasLogicalRedundancy)), jumboFrameCapable: \(String(describing: jumboFrameCapable)), lagId: \(String(describing: lagId)), lagName: \(String(describing: lagName)), lagState: \(String(describing: lagState)), location: \(String(describing: location)), macSecCapable: \(String(describing: macSecCapable)), macSecKeys: \(String(describing: macSecKeys)), minimumLinks: \(String(describing: minimumLinks)), numberOfConnections: \(String(describing: numberOfConnections)), ownerAccount: \(String(describing: ownerAccount)), providerName: \(String(describing: providerName)), region: \(String(describing: region)), tags: \(String(describing: tags)))"}
}

extension UpdateLagOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateLagOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.allowsHostedConnections = output.allowsHostedConnections
            self.awsDevice = output.awsDevice
            self.awsDeviceV2 = output.awsDeviceV2
            self.connections = output.connections
            self.connectionsBandwidth = output.connectionsBandwidth
            self.encryptionMode = output.encryptionMode
            self.hasLogicalRedundancy = output.hasLogicalRedundancy
            self.jumboFrameCapable = output.jumboFrameCapable
            self.lagId = output.lagId
            self.lagName = output.lagName
            self.lagState = output.lagState
            self.location = output.location
            self.macSecCapable = output.macSecCapable
            self.macSecKeys = output.macSecKeys
            self.minimumLinks = output.minimumLinks
            self.numberOfConnections = output.numberOfConnections
            self.ownerAccount = output.ownerAccount
            self.providerName = output.providerName
            self.region = output.region
            self.tags = output.tags
        } else {
            self.allowsHostedConnections = false
            self.awsDevice = nil
            self.awsDeviceV2 = nil
            self.connections = nil
            self.connectionsBandwidth = nil
            self.encryptionMode = nil
            self.hasLogicalRedundancy = nil
            self.jumboFrameCapable = nil
            self.lagId = nil
            self.lagName = nil
            self.lagState = nil
            self.location = nil
            self.macSecCapable = nil
            self.macSecKeys = nil
            self.minimumLinks = 0
            self.numberOfConnections = 0
            self.ownerAccount = nil
            self.providerName = nil
            self.region = nil
            self.tags = nil
        }
    }
}

/// <p>Information about a link aggregation group (LAG).</p>
public struct UpdateLagOutputResponse: Equatable {
    /// <p>Indicates whether the LAG can host other connections.</p>
    public let allowsHostedConnections: Bool
    /// <p>The AWS Direct Connect endpoint that hosts the LAG.</p>
    @available(*, deprecated)
    public let awsDevice: String?
    /// <p>The AWS Direct Connect endpoint that hosts the LAG.</p>
    public let awsDeviceV2: String?
    /// <p>The connections bundled by the LAG.</p>
    public let connections: [Connection]?
    /// <p>The individual bandwidth of the physical connections bundled by the LAG. The possible
    ///       values are 1Gbps and 10Gbps. </p>
    public let connectionsBandwidth: String?
    /// <p>The LAG MAC Security (MACsec) encryption mode.</p>
    ///          <p>The valid values are <code>no_encrypt</code>, <code>should_encrypt</code>, and <code>must_encrypt</code>.</p>
    public let encryptionMode: String?
    /// <p>Indicates whether the LAG supports a secondary BGP peer in the same address family (IPv4/IPv6).</p>
    public let hasLogicalRedundancy: HasLogicalRedundancy?
    /// <p>Indicates whether jumbo frames (9001 MTU) are supported.</p>
    public let jumboFrameCapable: Bool?
    /// <p>The ID of the LAG.</p>
    public let lagId: String?
    /// <p>The name of the LAG.</p>
    public let lagName: String?
    /// <p>The state of the LAG. The following are the possible values:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>requested</code>: The initial state of a LAG. The LAG stays in the
    ///                 requested state until the Letter of Authorization (LOA) is available.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: The LAG has been approved and is being initialized.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>available</code>: The network link is established and the LAG is ready for use.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>down</code>: The network link is down.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>: The LAG is being deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>: The LAG is deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>unknown</code>: The state of the LAG is not available.</p>
    ///             </li>
    ///          </ul>
    public let lagState: LagState?
    /// <p>The location of the LAG.</p>
    public let location: String?
    /// <p>Indicates whether the LAG supports MAC Security (MACsec).</p>
    public let macSecCapable: Bool?
    /// <p>The MAC Security (MACsec) security keys associated with the LAG.</p>
    public let macSecKeys: [MacSecKey]?
    /// <p>The minimum number of physical dedicated connections that must be operational for the LAG itself to be operational.</p>
    public let minimumLinks: Int
    /// <p>The number of physical dedicated connections bundled by the LAG, up to a maximum of 10.</p>
    public let numberOfConnections: Int
    /// <p>The ID of the AWS account that owns the LAG.</p>
    public let ownerAccount: String?
    /// <p>The name of the service provider associated with the LAG.</p>
    public let providerName: String?
    /// <p>The AWS Region where the connection is located.</p>
    public let region: String?
    /// <p>The tags associated with the LAG.</p>
    public let tags: [Tag]?

    public init (
        allowsHostedConnections: Bool = false,
        awsDevice: String? = nil,
        awsDeviceV2: String? = nil,
        connections: [Connection]? = nil,
        connectionsBandwidth: String? = nil,
        encryptionMode: String? = nil,
        hasLogicalRedundancy: HasLogicalRedundancy? = nil,
        jumboFrameCapable: Bool? = nil,
        lagId: String? = nil,
        lagName: String? = nil,
        lagState: LagState? = nil,
        location: String? = nil,
        macSecCapable: Bool? = nil,
        macSecKeys: [MacSecKey]? = nil,
        minimumLinks: Int = 0,
        numberOfConnections: Int = 0,
        ownerAccount: String? = nil,
        providerName: String? = nil,
        region: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.allowsHostedConnections = allowsHostedConnections
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.connections = connections
        self.connectionsBandwidth = connectionsBandwidth
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.lagName = lagName
        self.lagState = lagState
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.minimumLinks = minimumLinks
        self.numberOfConnections = numberOfConnections
        self.ownerAccount = ownerAccount
        self.providerName = providerName
        self.region = region
        self.tags = tags
    }
}

struct UpdateLagOutputResponseBody: Equatable {
    public let connectionsBandwidth: String?
    public let numberOfConnections: Int
    public let lagId: String?
    public let ownerAccount: String?
    public let lagName: String?
    public let lagState: LagState?
    public let location: String?
    public let region: String?
    public let minimumLinks: Int
    public let awsDevice: String?
    public let awsDeviceV2: String?
    public let connections: [Connection]?
    public let allowsHostedConnections: Bool
    public let jumboFrameCapable: Bool?
    public let hasLogicalRedundancy: HasLogicalRedundancy?
    public let tags: [Tag]?
    public let providerName: String?
    public let macSecCapable: Bool?
    public let encryptionMode: String?
    public let macSecKeys: [MacSecKey]?
}

extension UpdateLagOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allowsHostedConnections
        case awsDevice
        case awsDeviceV2
        case connections
        case connectionsBandwidth
        case encryptionMode
        case hasLogicalRedundancy
        case jumboFrameCapable
        case lagId
        case lagName
        case lagState
        case location
        case macSecCapable
        case macSecKeys
        case minimumLinks
        case numberOfConnections
        case ownerAccount
        case providerName
        case region
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionsBandwidthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionsBandwidth)
        connectionsBandwidth = connectionsBandwidthDecoded
        let numberOfConnectionsDecoded = try containerValues.decode(Int.self, forKey: .numberOfConnections)
        numberOfConnections = numberOfConnectionsDecoded
        let lagIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lagId)
        lagId = lagIdDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let lagNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lagName)
        lagName = lagNameDecoded
        let lagStateDecoded = try containerValues.decodeIfPresent(LagState.self, forKey: .lagState)
        lagState = lagStateDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let minimumLinksDecoded = try containerValues.decode(Int.self, forKey: .minimumLinks)
        minimumLinks = minimumLinksDecoded
        let awsDeviceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDevice)
        awsDevice = awsDeviceDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let connectionsContainer = try containerValues.decodeIfPresent([Connection?].self, forKey: .connections)
        var connectionsDecoded0:[Connection]? = nil
        if let connectionsContainer = connectionsContainer {
            connectionsDecoded0 = [Connection]()
            for structure0 in connectionsContainer {
                if let structure0 = structure0 {
                    connectionsDecoded0?.append(structure0)
                }
            }
        }
        connections = connectionsDecoded0
        let allowsHostedConnectionsDecoded = try containerValues.decode(Bool.self, forKey: .allowsHostedConnections)
        allowsHostedConnections = allowsHostedConnectionsDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let hasLogicalRedundancyDecoded = try containerValues.decodeIfPresent(HasLogicalRedundancy.self, forKey: .hasLogicalRedundancy)
        hasLogicalRedundancy = hasLogicalRedundancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let macSecCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .macSecCapable)
        macSecCapable = macSecCapableDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let macSecKeysContainer = try containerValues.decodeIfPresent([MacSecKey?].self, forKey: .macSecKeys)
        var macSecKeysDecoded0:[MacSecKey]? = nil
        if let macSecKeysContainer = macSecKeysContainer {
            macSecKeysDecoded0 = [MacSecKey]()
            for structure0 in macSecKeysContainer {
                if let structure0 = structure0 {
                    macSecKeysDecoded0?.append(structure0)
                }
            }
        }
        macSecKeys = macSecKeysDecoded0
    }
}

public struct UpdateVirtualInterfaceAttributesInputBodyMiddleware: Middleware {
    public let id: String = "UpdateVirtualInterfaceAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVirtualInterfaceAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVirtualInterfaceAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVirtualInterfaceAttributesInput>
    public typealias MOutput = OperationOutput<UpdateVirtualInterfaceAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVirtualInterfaceAttributesOutputError>
}

extension UpdateVirtualInterfaceAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateVirtualInterfaceAttributesInput(mtu: \(String(describing: mtu)), virtualInterfaceId: \(String(describing: virtualInterfaceId)))"}
}

extension UpdateVirtualInterfaceAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mtu
        case virtualInterfaceId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mtu = mtu {
            try encodeContainer.encode(mtu, forKey: .mtu)
        }
        if let virtualInterfaceId = virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
    }
}

public struct UpdateVirtualInterfaceAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateVirtualInterfaceAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVirtualInterfaceAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVirtualInterfaceAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVirtualInterfaceAttributesInput>
    public typealias MOutput = OperationOutput<UpdateVirtualInterfaceAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVirtualInterfaceAttributesOutputError>
}

public struct UpdateVirtualInterfaceAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateVirtualInterfaceAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVirtualInterfaceAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVirtualInterfaceAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVirtualInterfaceAttributesInput>
    public typealias MOutput = OperationOutput<UpdateVirtualInterfaceAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVirtualInterfaceAttributesOutputError>
}

public struct UpdateVirtualInterfaceAttributesInput: Equatable {
    /// <p>The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 9001. The default value is 1500.</p>
    public let mtu: Int?
    /// <p>The ID of the virtual private interface.</p>
    public let virtualInterfaceId: String?

    public init (
        mtu: Int? = nil,
        virtualInterfaceId: String? = nil
    )
    {
        self.mtu = mtu
        self.virtualInterfaceId = virtualInterfaceId
    }
}

struct UpdateVirtualInterfaceAttributesInputBody: Equatable {
    public let virtualInterfaceId: String?
    public let mtu: Int?
}

extension UpdateVirtualInterfaceAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case mtu
        case virtualInterfaceId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let mtuDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .mtu)
        mtu = mtuDecoded
    }
}

extension UpdateVirtualInterfaceAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVirtualInterfaceAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectConnectClientException" : self = .directConnectClientException(try DirectConnectClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectConnectServerException" : self = .directConnectServerException(try DirectConnectServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateVirtualInterfaceAttributesOutputError: Swift.Error, Equatable {
    case directConnectClientException(DirectConnectClientException)
    case directConnectServerException(DirectConnectServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVirtualInterfaceAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateVirtualInterfaceAttributesOutputResponse(addressFamily: \(String(describing: addressFamily)), amazonAddress: \(String(describing: amazonAddress)), amazonSideAsn: \(String(describing: amazonSideAsn)), asn: \(String(describing: asn)), authKey: \(String(describing: authKey)), awsDeviceV2: \(String(describing: awsDeviceV2)), bgpPeers: \(String(describing: bgpPeers)), connectionId: \(String(describing: connectionId)), customerAddress: \(String(describing: customerAddress)), customerRouterConfig: \(String(describing: customerRouterConfig)), directConnectGatewayId: \(String(describing: directConnectGatewayId)), jumboFrameCapable: \(String(describing: jumboFrameCapable)), location: \(String(describing: location)), mtu: \(String(describing: mtu)), ownerAccount: \(String(describing: ownerAccount)), region: \(String(describing: region)), routeFilterPrefixes: \(String(describing: routeFilterPrefixes)), tags: \(String(describing: tags)), virtualGatewayId: \(String(describing: virtualGatewayId)), virtualInterfaceId: \(String(describing: virtualInterfaceId)), virtualInterfaceName: \(String(describing: virtualInterfaceName)), virtualInterfaceState: \(String(describing: virtualInterfaceState)), virtualInterfaceType: \(String(describing: virtualInterfaceType)), vlan: \(String(describing: vlan)))"}
}

extension UpdateVirtualInterfaceAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateVirtualInterfaceAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.addressFamily = output.addressFamily
            self.amazonAddress = output.amazonAddress
            self.amazonSideAsn = output.amazonSideAsn
            self.asn = output.asn
            self.authKey = output.authKey
            self.awsDeviceV2 = output.awsDeviceV2
            self.bgpPeers = output.bgpPeers
            self.connectionId = output.connectionId
            self.customerAddress = output.customerAddress
            self.customerRouterConfig = output.customerRouterConfig
            self.directConnectGatewayId = output.directConnectGatewayId
            self.jumboFrameCapable = output.jumboFrameCapable
            self.location = output.location
            self.mtu = output.mtu
            self.ownerAccount = output.ownerAccount
            self.region = output.region
            self.routeFilterPrefixes = output.routeFilterPrefixes
            self.tags = output.tags
            self.virtualGatewayId = output.virtualGatewayId
            self.virtualInterfaceId = output.virtualInterfaceId
            self.virtualInterfaceName = output.virtualInterfaceName
            self.virtualInterfaceState = output.virtualInterfaceState
            self.virtualInterfaceType = output.virtualInterfaceType
            self.vlan = output.vlan
        } else {
            self.addressFamily = nil
            self.amazonAddress = nil
            self.amazonSideAsn = nil
            self.asn = 0
            self.authKey = nil
            self.awsDeviceV2 = nil
            self.bgpPeers = nil
            self.connectionId = nil
            self.customerAddress = nil
            self.customerRouterConfig = nil
            self.directConnectGatewayId = nil
            self.jumboFrameCapable = nil
            self.location = nil
            self.mtu = nil
            self.ownerAccount = nil
            self.region = nil
            self.routeFilterPrefixes = nil
            self.tags = nil
            self.virtualGatewayId = nil
            self.virtualInterfaceId = nil
            self.virtualInterfaceName = nil
            self.virtualInterfaceState = nil
            self.virtualInterfaceType = nil
            self.vlan = 0
        }
    }
}

/// <p>Information about a virtual interface.</p>
public struct UpdateVirtualInterfaceAttributesOutputResponse: Equatable {
    /// <p>The address family for the BGP peer.</p>
    public let addressFamily: AddressFamily?
    /// <p>The IP address assigned to the Amazon interface.</p>
    public let amazonAddress: String?
    /// <p>The autonomous system number (ASN) for the Amazon side of the connection.</p>
    public let amazonSideAsn: Int?
    /// <p>The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.</p>
    ///          <p>The valid values are 1-2147483647.</p>
    public let asn: Int
    /// <p>The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.</p>
    public let authKey: String?
    /// <p>The
    ///       Direct Connect endpoint on which the virtual interface terminates.</p>
    public let awsDeviceV2: String?
    /// <p>The BGP peers configured on this virtual interface.</p>
    public let bgpPeers: [BGPPeer]?
    /// <p>The ID of the connection.</p>
    public let connectionId: String?
    /// <p>The IP address assigned to the customer interface.</p>
    public let customerAddress: String?
    /// <p>The customer router configuration.</p>
    public let customerRouterConfig: String?
    /// <p>The ID of the Direct Connect gateway.</p>
    public let directConnectGatewayId: String?
    /// <p>Indicates whether jumbo frames (9001 MTU) are supported.</p>
    public let jumboFrameCapable: Bool?
    /// <p>The location of the connection.</p>
    public let location: String?
    /// <p>The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 9001. The default value is 1500.</p>
    public let mtu: Int?
    /// <p>The ID of the AWS account that owns the virtual interface.</p>
    public let ownerAccount: String?
    /// <p>The AWS Region where the virtual interface is located.</p>
    public let region: String?
    /// <p>The routes to be advertised to the AWS network in this Region. Applies to public virtual interfaces.</p>
    public let routeFilterPrefixes: [RouteFilterPrefix]?
    /// <p>The tags associated with the virtual interface.</p>
    public let tags: [Tag]?
    /// <p>The ID of the virtual private gateway. Applies only to private virtual interfaces.</p>
    public let virtualGatewayId: String?
    /// <p>The ID of the virtual interface.</p>
    public let virtualInterfaceId: String?
    /// <p>The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).</p>
    public let virtualInterfaceName: String?
    /// <p>The state of the virtual interface. The following are the possible values:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>confirming</code>: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>verifying</code>: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>available</code>: A virtual interface that is able to forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>down</code>: A virtual interface that is BGP down.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>: A virtual interface is in this state immediately after calling <a>DeleteVirtualInterface</a> until it can no longer forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>: A virtual interface that cannot forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>rejected</code>: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the <code>Confirming</code> state is deleted by the virtual interface owner, the virtual interface enters the <code>Rejected</code> state.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>unknown</code>: The state of the virtual interface is not available.</p>
    ///             </li>
    ///          </ul>
    public let virtualInterfaceState: VirtualInterfaceState?
    /// <p>The type of virtual interface. The possible values are <code>private</code> and <code>public</code>.</p>
    public let virtualInterfaceType: String?
    /// <p>The ID of the VLAN.</p>
    public let vlan: Int

    public init (
        addressFamily: AddressFamily? = nil,
        amazonAddress: String? = nil,
        amazonSideAsn: Int? = nil,
        asn: Int = 0,
        authKey: String? = nil,
        awsDeviceV2: String? = nil,
        bgpPeers: [BGPPeer]? = nil,
        connectionId: String? = nil,
        customerAddress: String? = nil,
        customerRouterConfig: String? = nil,
        directConnectGatewayId: String? = nil,
        jumboFrameCapable: Bool? = nil,
        location: String? = nil,
        mtu: Int? = nil,
        ownerAccount: String? = nil,
        region: String? = nil,
        routeFilterPrefixes: [RouteFilterPrefix]? = nil,
        tags: [Tag]? = nil,
        virtualGatewayId: String? = nil,
        virtualInterfaceId: String? = nil,
        virtualInterfaceName: String? = nil,
        virtualInterfaceState: VirtualInterfaceState? = nil,
        virtualInterfaceType: String? = nil,
        vlan: Int = 0
    )
    {
        self.addressFamily = addressFamily
        self.amazonAddress = amazonAddress
        self.amazonSideAsn = amazonSideAsn
        self.asn = asn
        self.authKey = authKey
        self.awsDeviceV2 = awsDeviceV2
        self.bgpPeers = bgpPeers
        self.connectionId = connectionId
        self.customerAddress = customerAddress
        self.customerRouterConfig = customerRouterConfig
        self.directConnectGatewayId = directConnectGatewayId
        self.jumboFrameCapable = jumboFrameCapable
        self.location = location
        self.mtu = mtu
        self.ownerAccount = ownerAccount
        self.region = region
        self.routeFilterPrefixes = routeFilterPrefixes
        self.tags = tags
        self.virtualGatewayId = virtualGatewayId
        self.virtualInterfaceId = virtualInterfaceId
        self.virtualInterfaceName = virtualInterfaceName
        self.virtualInterfaceState = virtualInterfaceState
        self.virtualInterfaceType = virtualInterfaceType
        self.vlan = vlan
    }
}

struct UpdateVirtualInterfaceAttributesOutputResponseBody: Equatable {
    public let ownerAccount: String?
    public let virtualInterfaceId: String?
    public let location: String?
    public let connectionId: String?
    public let virtualInterfaceType: String?
    public let virtualInterfaceName: String?
    public let vlan: Int
    public let asn: Int
    public let amazonSideAsn: Int?
    public let authKey: String?
    public let amazonAddress: String?
    public let customerAddress: String?
    public let addressFamily: AddressFamily?
    public let virtualInterfaceState: VirtualInterfaceState?
    public let customerRouterConfig: String?
    public let mtu: Int?
    public let jumboFrameCapable: Bool?
    public let virtualGatewayId: String?
    public let directConnectGatewayId: String?
    public let routeFilterPrefixes: [RouteFilterPrefix]?
    public let bgpPeers: [BGPPeer]?
    public let region: String?
    public let awsDeviceV2: String?
    public let tags: [Tag]?
}

extension UpdateVirtualInterfaceAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case addressFamily
        case amazonAddress
        case amazonSideAsn
        case asn
        case authKey
        case awsDeviceV2
        case bgpPeers
        case connectionId
        case customerAddress
        case customerRouterConfig
        case directConnectGatewayId
        case jumboFrameCapable
        case location
        case mtu
        case ownerAccount
        case region
        case routeFilterPrefixes
        case tags
        case virtualGatewayId
        case virtualInterfaceId
        case virtualInterfaceName
        case virtualInterfaceState
        case virtualInterfaceType
        case vlan
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let virtualInterfaceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceType)
        virtualInterfaceType = virtualInterfaceTypeDecoded
        let virtualInterfaceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceName)
        virtualInterfaceName = virtualInterfaceNameDecoded
        let vlanDecoded = try containerValues.decode(Int.self, forKey: .vlan)
        vlan = vlanDecoded
        let asnDecoded = try containerValues.decode(Int.self, forKey: .asn)
        asn = asnDecoded
        let amazonSideAsnDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .amazonSideAsn)
        amazonSideAsn = amazonSideAsnDecoded
        let authKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authKey)
        authKey = authKeyDecoded
        let amazonAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amazonAddress)
        amazonAddress = amazonAddressDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let virtualInterfaceStateDecoded = try containerValues.decodeIfPresent(VirtualInterfaceState.self, forKey: .virtualInterfaceState)
        virtualInterfaceState = virtualInterfaceStateDecoded
        let customerRouterConfigDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerRouterConfig)
        customerRouterConfig = customerRouterConfigDecoded
        let mtuDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .mtu)
        mtu = mtuDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let virtualGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualGatewayId)
        virtualGatewayId = virtualGatewayIdDecoded
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let routeFilterPrefixesContainer = try containerValues.decodeIfPresent([RouteFilterPrefix?].self, forKey: .routeFilterPrefixes)
        var routeFilterPrefixesDecoded0:[RouteFilterPrefix]? = nil
        if let routeFilterPrefixesContainer = routeFilterPrefixesContainer {
            routeFilterPrefixesDecoded0 = [RouteFilterPrefix]()
            for structure0 in routeFilterPrefixesContainer {
                if let structure0 = structure0 {
                    routeFilterPrefixesDecoded0?.append(structure0)
                }
            }
        }
        routeFilterPrefixes = routeFilterPrefixesDecoded0
        let bgpPeersContainer = try containerValues.decodeIfPresent([BGPPeer?].self, forKey: .bgpPeers)
        var bgpPeersDecoded0:[BGPPeer]? = nil
        if let bgpPeersContainer = bgpPeersContainer {
            bgpPeersDecoded0 = [BGPPeer]()
            for structure0 in bgpPeersContainer {
                if let structure0 = structure0 {
                    bgpPeersDecoded0?.append(structure0)
                }
            }
        }
        bgpPeers = bgpPeersDecoded0
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension VirtualGateway: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case virtualGatewayId
        case virtualGatewayState
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let virtualGatewayId = virtualGatewayId {
            try encodeContainer.encode(virtualGatewayId, forKey: .virtualGatewayId)
        }
        if let virtualGatewayState = virtualGatewayState {
            try encodeContainer.encode(virtualGatewayState, forKey: .virtualGatewayState)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualGatewayId)
        virtualGatewayId = virtualGatewayIdDecoded
        let virtualGatewayStateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualGatewayState)
        virtualGatewayState = virtualGatewayStateDecoded
    }
}

extension VirtualGateway: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualGateway(virtualGatewayId: \(String(describing: virtualGatewayId)), virtualGatewayState: \(String(describing: virtualGatewayState)))"}
}

/// <p>Information about a virtual private gateway for a private virtual interface.</p>
public struct VirtualGateway: Equatable {
    /// <p>The ID of the virtual private gateway.</p>
    public let virtualGatewayId: String?
    /// <p>The state of the virtual private gateway. The following are the possible values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: Initial state after creating the virtual private gateway.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>available</code>: Ready for use by a private virtual interface.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>: Initial state after deleting the virtual private gateway.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>: The virtual private gateway is deleted. The private virtual interface is unable to send traffic over this gateway.</p>
    ///             </li>
    ///          </ul>
    public let virtualGatewayState: String?

    public init (
        virtualGatewayId: String? = nil,
        virtualGatewayState: String? = nil
    )
    {
        self.virtualGatewayId = virtualGatewayId
        self.virtualGatewayState = virtualGatewayState
    }
}

extension VirtualInterface: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addressFamily
        case amazonAddress
        case amazonSideAsn
        case asn
        case authKey
        case awsDeviceV2
        case bgpPeers
        case connectionId
        case customerAddress
        case customerRouterConfig
        case directConnectGatewayId
        case jumboFrameCapable
        case location
        case mtu
        case ownerAccount
        case region
        case routeFilterPrefixes
        case tags
        case virtualGatewayId
        case virtualInterfaceId
        case virtualInterfaceName
        case virtualInterfaceState
        case virtualInterfaceType
        case vlan
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressFamily = addressFamily {
            try encodeContainer.encode(addressFamily.rawValue, forKey: .addressFamily)
        }
        if let amazonAddress = amazonAddress {
            try encodeContainer.encode(amazonAddress, forKey: .amazonAddress)
        }
        if let amazonSideAsn = amazonSideAsn {
            try encodeContainer.encode(amazonSideAsn, forKey: .amazonSideAsn)
        }
        if asn != 0 {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let authKey = authKey {
            try encodeContainer.encode(authKey, forKey: .authKey)
        }
        if let awsDeviceV2 = awsDeviceV2 {
            try encodeContainer.encode(awsDeviceV2, forKey: .awsDeviceV2)
        }
        if let bgpPeers = bgpPeers {
            var bgpPeersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bgpPeers)
            for bgppeerlist0 in bgpPeers {
                try bgpPeersContainer.encode(bgppeerlist0)
            }
        }
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let customerAddress = customerAddress {
            try encodeContainer.encode(customerAddress, forKey: .customerAddress)
        }
        if let customerRouterConfig = customerRouterConfig {
            try encodeContainer.encode(customerRouterConfig, forKey: .customerRouterConfig)
        }
        if let directConnectGatewayId = directConnectGatewayId {
            try encodeContainer.encode(directConnectGatewayId, forKey: .directConnectGatewayId)
        }
        if let jumboFrameCapable = jumboFrameCapable {
            try encodeContainer.encode(jumboFrameCapable, forKey: .jumboFrameCapable)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let mtu = mtu {
            try encodeContainer.encode(mtu, forKey: .mtu)
        }
        if let ownerAccount = ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let routeFilterPrefixes = routeFilterPrefixes {
            var routeFilterPrefixesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .routeFilterPrefixes)
            for routefilterprefixlist0 in routeFilterPrefixes {
                try routeFilterPrefixesContainer.encode(routefilterprefixlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let virtualGatewayId = virtualGatewayId {
            try encodeContainer.encode(virtualGatewayId, forKey: .virtualGatewayId)
        }
        if let virtualInterfaceId = virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
        if let virtualInterfaceName = virtualInterfaceName {
            try encodeContainer.encode(virtualInterfaceName, forKey: .virtualInterfaceName)
        }
        if let virtualInterfaceState = virtualInterfaceState {
            try encodeContainer.encode(virtualInterfaceState.rawValue, forKey: .virtualInterfaceState)
        }
        if let virtualInterfaceType = virtualInterfaceType {
            try encodeContainer.encode(virtualInterfaceType, forKey: .virtualInterfaceType)
        }
        if vlan != 0 {
            try encodeContainer.encode(vlan, forKey: .vlan)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let virtualInterfaceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceType)
        virtualInterfaceType = virtualInterfaceTypeDecoded
        let virtualInterfaceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceName)
        virtualInterfaceName = virtualInterfaceNameDecoded
        let vlanDecoded = try containerValues.decode(Int.self, forKey: .vlan)
        vlan = vlanDecoded
        let asnDecoded = try containerValues.decode(Int.self, forKey: .asn)
        asn = asnDecoded
        let amazonSideAsnDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .amazonSideAsn)
        amazonSideAsn = amazonSideAsnDecoded
        let authKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authKey)
        authKey = authKeyDecoded
        let amazonAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amazonAddress)
        amazonAddress = amazonAddressDecoded
        let customerAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerAddress)
        customerAddress = customerAddressDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let virtualInterfaceStateDecoded = try containerValues.decodeIfPresent(VirtualInterfaceState.self, forKey: .virtualInterfaceState)
        virtualInterfaceState = virtualInterfaceStateDecoded
        let customerRouterConfigDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerRouterConfig)
        customerRouterConfig = customerRouterConfigDecoded
        let mtuDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .mtu)
        mtu = mtuDecoded
        let jumboFrameCapableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .jumboFrameCapable)
        jumboFrameCapable = jumboFrameCapableDecoded
        let virtualGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualGatewayId)
        virtualGatewayId = virtualGatewayIdDecoded
        let directConnectGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directConnectGatewayId)
        directConnectGatewayId = directConnectGatewayIdDecoded
        let routeFilterPrefixesContainer = try containerValues.decodeIfPresent([RouteFilterPrefix?].self, forKey: .routeFilterPrefixes)
        var routeFilterPrefixesDecoded0:[RouteFilterPrefix]? = nil
        if let routeFilterPrefixesContainer = routeFilterPrefixesContainer {
            routeFilterPrefixesDecoded0 = [RouteFilterPrefix]()
            for structure0 in routeFilterPrefixesContainer {
                if let structure0 = structure0 {
                    routeFilterPrefixesDecoded0?.append(structure0)
                }
            }
        }
        routeFilterPrefixes = routeFilterPrefixesDecoded0
        let bgpPeersContainer = try containerValues.decodeIfPresent([BGPPeer?].self, forKey: .bgpPeers)
        var bgpPeersDecoded0:[BGPPeer]? = nil
        if let bgpPeersContainer = bgpPeersContainer {
            bgpPeersDecoded0 = [BGPPeer]()
            for structure0 in bgpPeersContainer {
                if let structure0 = structure0 {
                    bgpPeersDecoded0?.append(structure0)
                }
            }
        }
        bgpPeers = bgpPeersDecoded0
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let awsDeviceV2Decoded = try containerValues.decodeIfPresent(String.self, forKey: .awsDeviceV2)
        awsDeviceV2 = awsDeviceV2Decoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension VirtualInterface: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualInterface(addressFamily: \(String(describing: addressFamily)), amazonAddress: \(String(describing: amazonAddress)), amazonSideAsn: \(String(describing: amazonSideAsn)), asn: \(String(describing: asn)), authKey: \(String(describing: authKey)), awsDeviceV2: \(String(describing: awsDeviceV2)), bgpPeers: \(String(describing: bgpPeers)), connectionId: \(String(describing: connectionId)), customerAddress: \(String(describing: customerAddress)), customerRouterConfig: \(String(describing: customerRouterConfig)), directConnectGatewayId: \(String(describing: directConnectGatewayId)), jumboFrameCapable: \(String(describing: jumboFrameCapable)), location: \(String(describing: location)), mtu: \(String(describing: mtu)), ownerAccount: \(String(describing: ownerAccount)), region: \(String(describing: region)), routeFilterPrefixes: \(String(describing: routeFilterPrefixes)), tags: \(String(describing: tags)), virtualGatewayId: \(String(describing: virtualGatewayId)), virtualInterfaceId: \(String(describing: virtualInterfaceId)), virtualInterfaceName: \(String(describing: virtualInterfaceName)), virtualInterfaceState: \(String(describing: virtualInterfaceState)), virtualInterfaceType: \(String(describing: virtualInterfaceType)), vlan: \(String(describing: vlan)))"}
}

/// <p>Information about a virtual interface.</p>
public struct VirtualInterface: Equatable {
    /// <p>The address family for the BGP peer.</p>
    public let addressFamily: AddressFamily?
    /// <p>The IP address assigned to the Amazon interface.</p>
    public let amazonAddress: String?
    /// <p>The autonomous system number (ASN) for the Amazon side of the connection.</p>
    public let amazonSideAsn: Int?
    /// <p>The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.</p>
    ///          <p>The valid values are 1-2147483647.</p>
    public let asn: Int
    /// <p>The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.</p>
    public let authKey: String?
    /// <p>The
    ///       Direct Connect endpoint on which the virtual interface terminates.</p>
    public let awsDeviceV2: String?
    /// <p>The BGP peers configured on this virtual interface.</p>
    public let bgpPeers: [BGPPeer]?
    /// <p>The ID of the connection.</p>
    public let connectionId: String?
    /// <p>The IP address assigned to the customer interface.</p>
    public let customerAddress: String?
    /// <p>The customer router configuration.</p>
    public let customerRouterConfig: String?
    /// <p>The ID of the Direct Connect gateway.</p>
    public let directConnectGatewayId: String?
    /// <p>Indicates whether jumbo frames (9001 MTU) are supported.</p>
    public let jumboFrameCapable: Bool?
    /// <p>The location of the connection.</p>
    public let location: String?
    /// <p>The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 9001. The default value is 1500.</p>
    public let mtu: Int?
    /// <p>The ID of the AWS account that owns the virtual interface.</p>
    public let ownerAccount: String?
    /// <p>The AWS Region where the virtual interface is located.</p>
    public let region: String?
    /// <p>The routes to be advertised to the AWS network in this Region. Applies to public virtual interfaces.</p>
    public let routeFilterPrefixes: [RouteFilterPrefix]?
    /// <p>The tags associated with the virtual interface.</p>
    public let tags: [Tag]?
    /// <p>The ID of the virtual private gateway. Applies only to private virtual interfaces.</p>
    public let virtualGatewayId: String?
    /// <p>The ID of the virtual interface.</p>
    public let virtualInterfaceId: String?
    /// <p>The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).</p>
    public let virtualInterfaceName: String?
    /// <p>The state of the virtual interface. The following are the possible values:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>confirming</code>: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>verifying</code>: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>available</code>: A virtual interface that is able to forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>down</code>: A virtual interface that is BGP down.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleting</code>: A virtual interface is in this state immediately after calling <a>DeleteVirtualInterface</a> until it can no longer forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deleted</code>: A virtual interface that cannot forward traffic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>rejected</code>: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the <code>Confirming</code> state is deleted by the virtual interface owner, the virtual interface enters the <code>Rejected</code> state.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>unknown</code>: The state of the virtual interface is not available.</p>
    ///             </li>
    ///          </ul>
    public let virtualInterfaceState: VirtualInterfaceState?
    /// <p>The type of virtual interface. The possible values are <code>private</code> and <code>public</code>.</p>
    public let virtualInterfaceType: String?
    /// <p>The ID of the VLAN.</p>
    public let vlan: Int

    public init (
        addressFamily: AddressFamily? = nil,
        amazonAddress: String? = nil,
        amazonSideAsn: Int? = nil,
        asn: Int = 0,
        authKey: String? = nil,
        awsDeviceV2: String? = nil,
        bgpPeers: [BGPPeer]? = nil,
        connectionId: String? = nil,
        customerAddress: String? = nil,
        customerRouterConfig: String? = nil,
        directConnectGatewayId: String? = nil,
        jumboFrameCapable: Bool? = nil,
        location: String? = nil,
        mtu: Int? = nil,
        ownerAccount: String? = nil,
        region: String? = nil,
        routeFilterPrefixes: [RouteFilterPrefix]? = nil,
        tags: [Tag]? = nil,
        virtualGatewayId: String? = nil,
        virtualInterfaceId: String? = nil,
        virtualInterfaceName: String? = nil,
        virtualInterfaceState: VirtualInterfaceState? = nil,
        virtualInterfaceType: String? = nil,
        vlan: Int = 0
    )
    {
        self.addressFamily = addressFamily
        self.amazonAddress = amazonAddress
        self.amazonSideAsn = amazonSideAsn
        self.asn = asn
        self.authKey = authKey
        self.awsDeviceV2 = awsDeviceV2
        self.bgpPeers = bgpPeers
        self.connectionId = connectionId
        self.customerAddress = customerAddress
        self.customerRouterConfig = customerRouterConfig
        self.directConnectGatewayId = directConnectGatewayId
        self.jumboFrameCapable = jumboFrameCapable
        self.location = location
        self.mtu = mtu
        self.ownerAccount = ownerAccount
        self.region = region
        self.routeFilterPrefixes = routeFilterPrefixes
        self.tags = tags
        self.virtualGatewayId = virtualGatewayId
        self.virtualInterfaceId = virtualInterfaceId
        self.virtualInterfaceName = virtualInterfaceName
        self.virtualInterfaceState = virtualInterfaceState
        self.virtualInterfaceType = virtualInterfaceType
        self.vlan = vlan
    }
}

public enum VirtualInterfaceState {
    case available
    case confirming
    case deleted
    case deleting
    case down
    case pending
    case rejected
    case unknown
    case verifying
    case sdkUnknown(String)
}

extension VirtualInterfaceState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [VirtualInterfaceState] {
        return [
            .available,
            .confirming,
            .deleted,
            .deleting,
            .down,
            .pending,
            .rejected,
            .unknown,
            .verifying,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "available"
        case .confirming: return "confirming"
        case .deleted: return "deleted"
        case .deleting: return "deleting"
        case .down: return "down"
        case .pending: return "pending"
        case .rejected: return "rejected"
        case .unknown: return "unknown"
        case .verifying: return "verifying"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = VirtualInterfaceState(rawValue: rawValue) ?? VirtualInterfaceState.sdkUnknown(rawValue)
    }
}

extension VirtualInterfaceTestHistory: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bgpPeers
        case endTime
        case ownerAccount
        case startTime
        case status
        case testDurationInMinutes
        case testId
        case virtualInterfaceId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bgpPeers = bgpPeers {
            var bgpPeersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bgpPeers)
            for bgppeeridlist0 in bgpPeers {
                try bgpPeersContainer.encode(bgppeeridlist0)
            }
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let ownerAccount = ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let testDurationInMinutes = testDurationInMinutes {
            try encodeContainer.encode(testDurationInMinutes, forKey: .testDurationInMinutes)
        }
        if let testId = testId {
            try encodeContainer.encode(testId, forKey: .testId)
        }
        if let virtualInterfaceId = virtualInterfaceId {
            try encodeContainer.encode(virtualInterfaceId, forKey: .virtualInterfaceId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .testId)
        testId = testIdDecoded
        let virtualInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualInterfaceId)
        virtualInterfaceId = virtualInterfaceIdDecoded
        let bgpPeersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .bgpPeers)
        var bgpPeersDecoded0:[String]? = nil
        if let bgpPeersContainer = bgpPeersContainer {
            bgpPeersDecoded0 = [String]()
            for string0 in bgpPeersContainer {
                if let string0 = string0 {
                    bgpPeersDecoded0?.append(string0)
                }
            }
        }
        bgpPeers = bgpPeersDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let testDurationInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .testDurationInMinutes)
        testDurationInMinutes = testDurationInMinutesDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension VirtualInterfaceTestHistory: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualInterfaceTestHistory(bgpPeers: \(String(describing: bgpPeers)), endTime: \(String(describing: endTime)), ownerAccount: \(String(describing: ownerAccount)), startTime: \(String(describing: startTime)), status: \(String(describing: status)), testDurationInMinutes: \(String(describing: testDurationInMinutes)), testId: \(String(describing: testId)), virtualInterfaceId: \(String(describing: virtualInterfaceId)))"}
}

/// <p>Information about the virtual interface failover test.</p>
public struct VirtualInterfaceTestHistory: Equatable {
    /// <p>The BGP peers that were put in the DOWN state as part of the virtual interface failover test.</p>
    public let bgpPeers: [String]?
    /// <p>The time that the virtual interface moves out of the DOWN state.</p>
    public let endTime: Date?
    /// <p>The owner ID of the tested virtual interface.</p>
    public let ownerAccount: String?
    /// <p>The time that the virtual interface moves to the DOWN state.</p>
    public let startTime: Date?
    /// <p>The status of the virtual interface failover test.</p>
    public let status: String?
    /// <p>The time that the virtual interface failover test ran in minutes.</p>
    public let testDurationInMinutes: Int?
    /// <p>The ID of the virtual interface failover test.</p>
    public let testId: String?
    /// <p>The ID of the tested virtual interface.</p>
    public let virtualInterfaceId: String?

    public init (
        bgpPeers: [String]? = nil,
        endTime: Date? = nil,
        ownerAccount: String? = nil,
        startTime: Date? = nil,
        status: String? = nil,
        testDurationInMinutes: Int? = nil,
        testId: String? = nil,
        virtualInterfaceId: String? = nil
    )
    {
        self.bgpPeers = bgpPeers
        self.endTime = endTime
        self.ownerAccount = ownerAccount
        self.startTime = startTime
        self.status = status
        self.testDurationInMinutes = testDurationInMinutes
        self.testId = testId
        self.virtualInterfaceId = virtualInterfaceId
    }
}
