// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension CancelJournalKinesisStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelJournalKinesisStreamInput(ledgerName: \(String(describing: ledgerName)), streamId: \(String(describing: streamId)))"}
}

extension CancelJournalKinesisStreamInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CancelJournalKinesisStreamInputHeadersMiddleware: Middleware {
    public let id: String = "CancelJournalKinesisStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelJournalKinesisStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelJournalKinesisStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelJournalKinesisStreamInput>
    public typealias MOutput = OperationOutput<CancelJournalKinesisStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelJournalKinesisStreamOutputError>
}

public struct CancelJournalKinesisStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelJournalKinesisStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelJournalKinesisStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelJournalKinesisStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelJournalKinesisStreamInput>
    public typealias MOutput = OperationOutput<CancelJournalKinesisStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelJournalKinesisStreamOutputError>
}

public struct CancelJournalKinesisStreamInput: Equatable {
    /// <p>The name of the ledger.</p>
    public let ledgerName: String?
    /// <p>The UUID (represented in Base62-encoded text) of the QLDB journal stream to be
    ///          canceled.</p>
    public let streamId: String?

    public init (
        ledgerName: String? = nil,
        streamId: String? = nil
    )
    {
        self.ledgerName = ledgerName
        self.streamId = streamId
    }
}

struct CancelJournalKinesisStreamInputBody: Equatable {
}

extension CancelJournalKinesisStreamInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CancelJournalKinesisStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelJournalKinesisStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourcePreconditionNotMetException" : self = .resourcePreconditionNotMetException(try ResourcePreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelJournalKinesisStreamOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourcePreconditionNotMetException(ResourcePreconditionNotMetException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelJournalKinesisStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelJournalKinesisStreamOutputResponse(streamId: \(String(describing: streamId)))"}
}

extension CancelJournalKinesisStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CancelJournalKinesisStreamOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.streamId = output.streamId
        } else {
            self.streamId = nil
        }
    }
}

public struct CancelJournalKinesisStreamOutputResponse: Equatable {
    /// <p>The UUID (Base62-encoded text) of the canceled QLDB journal stream.</p>
    public let streamId: String?

    public init (
        streamId: String? = nil
    )
    {
        self.streamId = streamId
    }
}

struct CancelJournalKinesisStreamOutputResponseBody: Equatable {
    public let streamId: String?
}

extension CancelJournalKinesisStreamOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case streamId = "StreamId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamId)
        streamId = streamIdDecoded
    }
}

public struct CreateLedgerInputBodyMiddleware: Middleware {
    public let id: String = "CreateLedgerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLedgerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLedgerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLedgerInput>
    public typealias MOutput = OperationOutput<CreateLedgerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLedgerOutputError>
}

extension CreateLedgerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLedgerInput(deletionProtection: \(String(describing: deletionProtection)), name: \(String(describing: name)), permissionsMode: \(String(describing: permissionsMode)), tags: \(String(describing: tags)))"}
}

extension CreateLedgerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deletionProtection = "DeletionProtection"
        case name = "Name"
        case permissionsMode = "PermissionsMode"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deletionProtection = deletionProtection {
            try encodeContainer.encode(deletionProtection, forKey: .deletionProtection)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissionsMode = permissionsMode {
            try encodeContainer.encode(permissionsMode.rawValue, forKey: .permissionsMode)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateLedgerInputHeadersMiddleware: Middleware {
    public let id: String = "CreateLedgerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLedgerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLedgerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLedgerInput>
    public typealias MOutput = OperationOutput<CreateLedgerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLedgerOutputError>
}

public struct CreateLedgerInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateLedgerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLedgerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLedgerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLedgerInput>
    public typealias MOutput = OperationOutput<CreateLedgerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLedgerOutputError>
}

public struct CreateLedgerInput: Equatable {
    /// <p>The flag that prevents a ledger from being deleted by any user. If not provided on
    ///       ledger creation, this feature is enabled (<code>true</code>) by default.</p>
    ///          <p>If deletion protection is enabled, you must first disable it before you can delete the
    ///       ledger. You can disable it by calling the <code>UpdateLedger</code> operation to set the flag to <code>false</code>.</p>
    public let deletionProtection: Bool?
    /// <p>The name of the ledger that you want to create. The name must be unique among all of
    ///          your ledgers in the current AWS Region.</p>
    ///          <p>Naming constraints for ledger names are defined in <a href="https://docs.aws.amazon.com/qldb/latest/developerguide/limits.html#limits.naming">Quotas in Amazon QLDB</a>
    ///          in the <i>Amazon QLDB Developer Guide</i>.</p>
    public let name: String?
    /// <p>The permissions mode to assign to the ledger that you want to create. This parameter can
    ///          have one of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ALLOW_ALL</code>: A legacy permissions mode that enables access control with
    ///                API-level granularity for ledgers.</p>
    ///                <p>This mode allows users who have the <code>SendCommand</code> API permission for
    ///                this ledger to run all PartiQL commands (hence, <code>ALLOW_ALL</code>) on any tables
    ///                in the specified ledger. This mode disregards any table-level or command-level IAM
    ///                permissions policies that you create for the ledger.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>STANDARD</code>: (<i>Recommended</i>) A permissions mode that
    ///                enables access control with finer granularity for ledgers, tables, and PartiQL
    ///                commands.</p>
    ///                <p>By default, this mode denies all user requests to run any PartiQL commands on any
    ///                tables in this ledger. To allow PartiQL commands to run, you must create IAM
    ///                permissions policies for specific table resources and PartiQL actions, in addition to
    ///                the <code>SendCommand</code> API permission for the ledger. For information, see
    ///                   <a href="https://docs.aws.amazon.com/qldb/latest/developerguide/getting-started-standard-mode.html">Getting
    ///                   started with the standard permissions mode</a> in the <i>Amazon QLDB
    ///                   Developer Guide</i>.</p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>We strongly recommend using the <code>STANDARD</code> permissions mode to maximize
    ///             the security of your ledger data.</p>
    ///          </note>
    public let permissionsMode: PermissionsMode?
    /// <p>The key-value pairs to add as tags to the ledger that you want to create. Tag keys are
    ///          case sensitive. Tag values are case sensitive and can be null.</p>
    public let tags: [String:String?]?

    public init (
        deletionProtection: Bool? = nil,
        name: String? = nil,
        permissionsMode: PermissionsMode? = nil,
        tags: [String:String?]? = nil
    )
    {
        self.deletionProtection = deletionProtection
        self.name = name
        self.permissionsMode = permissionsMode
        self.tags = tags
    }
}

struct CreateLedgerInputBody: Equatable {
    public let name: String?
    public let tags: [String:String?]?
    public let permissionsMode: PermissionsMode?
    public let deletionProtection: Bool?
}

extension CreateLedgerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deletionProtection = "DeletionProtection"
        case name = "Name"
        case permissionsMode = "PermissionsMode"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String?]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String?]()
            for (key0, tagvalue0) in tagsContainer {
                tagsDecoded0?[key0] = tagvalue0
            }
        }
        tags = tagsDecoded0
        let permissionsModeDecoded = try containerValues.decodeIfPresent(PermissionsMode.self, forKey: .permissionsMode)
        permissionsMode = permissionsModeDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
    }
}

extension CreateLedgerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLedgerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLedgerOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLedgerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLedgerOutputResponse(arn: \(String(describing: arn)), creationDateTime: \(String(describing: creationDateTime)), deletionProtection: \(String(describing: deletionProtection)), name: \(String(describing: name)), permissionsMode: \(String(describing: permissionsMode)), state: \(String(describing: state)))"}
}

extension CreateLedgerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateLedgerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.deletionProtection = output.deletionProtection
            self.name = output.name
            self.permissionsMode = output.permissionsMode
            self.state = output.state
        } else {
            self.arn = nil
            self.creationDateTime = nil
            self.deletionProtection = nil
            self.name = nil
            self.permissionsMode = nil
            self.state = nil
        }
    }
}

public struct CreateLedgerOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the ledger.</p>
    public let arn: String?
    /// <p>The date and time, in epoch time format, when the ledger was created. (Epoch time format
    ///          is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)</p>
    public let creationDateTime: Date?
    /// <p>The flag that prevents a ledger from being deleted by any user. If not provided on
    ///       ledger creation, this feature is enabled (<code>true</code>) by default.</p>
    ///          <p>If deletion protection is enabled, you must first disable it before you can delete the
    ///       ledger. You can disable it by calling the <code>UpdateLedger</code> operation to set the flag to <code>false</code>.</p>
    public let deletionProtection: Bool?
    /// <p>The name of the ledger.</p>
    public let name: String?
    /// <p>The permissions mode of the ledger that you created.</p>
    public let permissionsMode: PermissionsMode?
    /// <p>The current status of the ledger.</p>
    public let state: LedgerState?

    public init (
        arn: String? = nil,
        creationDateTime: Date? = nil,
        deletionProtection: Bool? = nil,
        name: String? = nil,
        permissionsMode: PermissionsMode? = nil,
        state: LedgerState? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.deletionProtection = deletionProtection
        self.name = name
        self.permissionsMode = permissionsMode
        self.state = state
    }
}

struct CreateLedgerOutputResponseBody: Equatable {
    public let name: String?
    public let arn: String?
    public let state: LedgerState?
    public let creationDateTime: Date?
    public let permissionsMode: PermissionsMode?
    public let deletionProtection: Bool?
}

extension CreateLedgerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationDateTime = "CreationDateTime"
        case deletionProtection = "DeletionProtection"
        case name = "Name"
        case permissionsMode = "PermissionsMode"
        case state = "State"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(LedgerState.self, forKey: .state)
        state = stateDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let permissionsModeDecoded = try containerValues.decodeIfPresent(PermissionsMode.self, forKey: .permissionsMode)
        permissionsMode = permissionsModeDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
    }
}

extension DeleteLedgerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLedgerInput(name: \(String(describing: name)))"}
}

extension DeleteLedgerInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteLedgerInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteLedgerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLedgerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLedgerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLedgerInput>
    public typealias MOutput = OperationOutput<DeleteLedgerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLedgerOutputError>
}

public struct DeleteLedgerInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteLedgerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLedgerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLedgerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLedgerInput>
    public typealias MOutput = OperationOutput<DeleteLedgerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLedgerOutputError>
}

public struct DeleteLedgerInput: Equatable {
    /// <p>The name of the ledger that you want to delete.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteLedgerInputBody: Equatable {
}

extension DeleteLedgerInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteLedgerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLedgerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourcePreconditionNotMetException" : self = .resourcePreconditionNotMetException(try ResourcePreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLedgerOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourcePreconditionNotMetException(ResourcePreconditionNotMetException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLedgerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLedgerOutputResponse()"}
}

extension DeleteLedgerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLedgerOutputResponse: Equatable {

    public init() {}
}

struct DeleteLedgerOutputResponseBody: Equatable {
}

extension DeleteLedgerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeJournalKinesisStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeJournalKinesisStreamInput(ledgerName: \(String(describing: ledgerName)), streamId: \(String(describing: streamId)))"}
}

extension DescribeJournalKinesisStreamInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeJournalKinesisStreamInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeJournalKinesisStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeJournalKinesisStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeJournalKinesisStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeJournalKinesisStreamInput>
    public typealias MOutput = OperationOutput<DescribeJournalKinesisStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeJournalKinesisStreamOutputError>
}

public struct DescribeJournalKinesisStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeJournalKinesisStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeJournalKinesisStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeJournalKinesisStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeJournalKinesisStreamInput>
    public typealias MOutput = OperationOutput<DescribeJournalKinesisStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeJournalKinesisStreamOutputError>
}

public struct DescribeJournalKinesisStreamInput: Equatable {
    /// <p>The name of the ledger.</p>
    public let ledgerName: String?
    /// <p>The UUID (represented in Base62-encoded text) of the QLDB journal stream to
    ///          describe.</p>
    public let streamId: String?

    public init (
        ledgerName: String? = nil,
        streamId: String? = nil
    )
    {
        self.ledgerName = ledgerName
        self.streamId = streamId
    }
}

struct DescribeJournalKinesisStreamInputBody: Equatable {
}

extension DescribeJournalKinesisStreamInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeJournalKinesisStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeJournalKinesisStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourcePreconditionNotMetException" : self = .resourcePreconditionNotMetException(try ResourcePreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeJournalKinesisStreamOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourcePreconditionNotMetException(ResourcePreconditionNotMetException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeJournalKinesisStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeJournalKinesisStreamOutputResponse(stream: \(String(describing: stream)))"}
}

extension DescribeJournalKinesisStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeJournalKinesisStreamOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.stream = output.stream
        } else {
            self.stream = nil
        }
    }
}

public struct DescribeJournalKinesisStreamOutputResponse: Equatable {
    /// <p>Information about the QLDB journal stream returned by a
    ///             <code>DescribeJournalS3Export</code> request.</p>
    public let stream: JournalKinesisStreamDescription?

    public init (
        stream: JournalKinesisStreamDescription? = nil
    )
    {
        self.stream = stream
    }
}

struct DescribeJournalKinesisStreamOutputResponseBody: Equatable {
    public let stream: JournalKinesisStreamDescription?
}

extension DescribeJournalKinesisStreamOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stream = "Stream"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamDecoded = try containerValues.decodeIfPresent(JournalKinesisStreamDescription.self, forKey: .stream)
        stream = streamDecoded
    }
}

extension DescribeJournalS3ExportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeJournalS3ExportInput(exportId: \(String(describing: exportId)), name: \(String(describing: name)))"}
}

extension DescribeJournalS3ExportInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeJournalS3ExportInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeJournalS3ExportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeJournalS3ExportInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeJournalS3ExportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeJournalS3ExportInput>
    public typealias MOutput = OperationOutput<DescribeJournalS3ExportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeJournalS3ExportOutputError>
}

public struct DescribeJournalS3ExportInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeJournalS3ExportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeJournalS3ExportInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeJournalS3ExportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeJournalS3ExportInput>
    public typealias MOutput = OperationOutput<DescribeJournalS3ExportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeJournalS3ExportOutputError>
}

public struct DescribeJournalS3ExportInput: Equatable {
    /// <p>The UUID (represented in Base62-encoded text) of the journal export job to
    ///          describe.</p>
    public let exportId: String?
    /// <p>The name of the ledger.</p>
    public let name: String?

    public init (
        exportId: String? = nil,
        name: String? = nil
    )
    {
        self.exportId = exportId
        self.name = name
    }
}

struct DescribeJournalS3ExportInputBody: Equatable {
}

extension DescribeJournalS3ExportInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeJournalS3ExportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeJournalS3ExportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeJournalS3ExportOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeJournalS3ExportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeJournalS3ExportOutputResponse(exportDescription: \(String(describing: exportDescription)))"}
}

extension DescribeJournalS3ExportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeJournalS3ExportOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.exportDescription = output.exportDescription
        } else {
            self.exportDescription = nil
        }
    }
}

public struct DescribeJournalS3ExportOutputResponse: Equatable {
    /// <p>Information about the journal export job returned by a
    ///             <code>DescribeJournalS3Export</code> request.</p>
    public let exportDescription: JournalS3ExportDescription?

    public init (
        exportDescription: JournalS3ExportDescription? = nil
    )
    {
        self.exportDescription = exportDescription
    }
}

struct DescribeJournalS3ExportOutputResponseBody: Equatable {
    public let exportDescription: JournalS3ExportDescription?
}

extension DescribeJournalS3ExportOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exportDescription = "ExportDescription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportDescriptionDecoded = try containerValues.decodeIfPresent(JournalS3ExportDescription.self, forKey: .exportDescription)
        exportDescription = exportDescriptionDecoded
    }
}

extension DescribeLedgerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLedgerInput(name: \(String(describing: name)))"}
}

extension DescribeLedgerInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeLedgerInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeLedgerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLedgerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLedgerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLedgerInput>
    public typealias MOutput = OperationOutput<DescribeLedgerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLedgerOutputError>
}

public struct DescribeLedgerInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeLedgerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLedgerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLedgerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLedgerInput>
    public typealias MOutput = OperationOutput<DescribeLedgerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLedgerOutputError>
}

public struct DescribeLedgerInput: Equatable {
    /// <p>The name of the ledger that you want to describe.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DescribeLedgerInputBody: Equatable {
}

extension DescribeLedgerInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeLedgerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLedgerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLedgerOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLedgerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLedgerOutputResponse(arn: \(String(describing: arn)), creationDateTime: \(String(describing: creationDateTime)), deletionProtection: \(String(describing: deletionProtection)), name: \(String(describing: name)), permissionsMode: \(String(describing: permissionsMode)), state: \(String(describing: state)))"}
}

extension DescribeLedgerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeLedgerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.deletionProtection = output.deletionProtection
            self.name = output.name
            self.permissionsMode = output.permissionsMode
            self.state = output.state
        } else {
            self.arn = nil
            self.creationDateTime = nil
            self.deletionProtection = nil
            self.name = nil
            self.permissionsMode = nil
            self.state = nil
        }
    }
}

public struct DescribeLedgerOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the ledger.</p>
    public let arn: String?
    /// <p>The date and time, in epoch time format, when the ledger was created. (Epoch time format
    ///          is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)</p>
    public let creationDateTime: Date?
    /// <p>The flag that prevents a ledger from being deleted by any user. If not provided on
    ///       ledger creation, this feature is enabled (<code>true</code>) by default.</p>
    ///          <p>If deletion protection is enabled, you must first disable it before you can delete the
    ///       ledger. You can disable it by calling the <code>UpdateLedger</code> operation to set the flag to <code>false</code>.</p>
    public let deletionProtection: Bool?
    /// <p>The name of the ledger.</p>
    public let name: String?
    /// <p>The permissions mode of the ledger.</p>
    public let permissionsMode: PermissionsMode?
    /// <p>The current status of the ledger.</p>
    public let state: LedgerState?

    public init (
        arn: String? = nil,
        creationDateTime: Date? = nil,
        deletionProtection: Bool? = nil,
        name: String? = nil,
        permissionsMode: PermissionsMode? = nil,
        state: LedgerState? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.deletionProtection = deletionProtection
        self.name = name
        self.permissionsMode = permissionsMode
        self.state = state
    }
}

struct DescribeLedgerOutputResponseBody: Equatable {
    public let name: String?
    public let arn: String?
    public let state: LedgerState?
    public let creationDateTime: Date?
    public let permissionsMode: PermissionsMode?
    public let deletionProtection: Bool?
}

extension DescribeLedgerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationDateTime = "CreationDateTime"
        case deletionProtection = "DeletionProtection"
        case name = "Name"
        case permissionsMode = "PermissionsMode"
        case state = "State"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(LedgerState.self, forKey: .state)
        state = stateDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let permissionsModeDecoded = try containerValues.decodeIfPresent(PermissionsMode.self, forKey: .permissionsMode)
        permissionsMode = permissionsModeDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
    }
}

public enum ErrorCause {
    case iamPermissionRevoked
    case kinesisStreamNotFound
    case sdkUnknown(String)
}

extension ErrorCause : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ErrorCause] {
        return [
            .iamPermissionRevoked,
            .kinesisStreamNotFound,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .iamPermissionRevoked: return "IAM_PERMISSION_REVOKED"
        case .kinesisStreamNotFound: return "KINESIS_STREAM_NOT_FOUND"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ErrorCause(rawValue: rawValue) ?? ErrorCause.sdkUnknown(rawValue)
    }
}

public struct ExportJournalToS3InputBodyMiddleware: Middleware {
    public let id: String = "ExportJournalToS3InputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExportJournalToS3Input>,
                  next: H) -> Swift.Result<OperationOutput<ExportJournalToS3OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExportJournalToS3Input>
    public typealias MOutput = OperationOutput<ExportJournalToS3OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExportJournalToS3OutputError>
}

extension ExportJournalToS3Input: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportJournalToS3Input(exclusiveEndTime: \(String(describing: exclusiveEndTime)), inclusiveStartTime: \(String(describing: inclusiveStartTime)), name: \(String(describing: name)), roleArn: \(String(describing: roleArn)), s3ExportConfiguration: \(String(describing: s3ExportConfiguration)))"}
}

extension ExportJournalToS3Input: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exclusiveEndTime = "ExclusiveEndTime"
        case inclusiveStartTime = "InclusiveStartTime"
        case roleArn = "RoleArn"
        case s3ExportConfiguration = "S3ExportConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exclusiveEndTime = exclusiveEndTime {
            try encodeContainer.encode(exclusiveEndTime.timeIntervalSince1970, forKey: .exclusiveEndTime)
        }
        if let inclusiveStartTime = inclusiveStartTime {
            try encodeContainer.encode(inclusiveStartTime.timeIntervalSince1970, forKey: .inclusiveStartTime)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let s3ExportConfiguration = s3ExportConfiguration {
            try encodeContainer.encode(s3ExportConfiguration, forKey: .s3ExportConfiguration)
        }
    }
}

public struct ExportJournalToS3InputHeadersMiddleware: Middleware {
    public let id: String = "ExportJournalToS3InputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExportJournalToS3Input>,
                  next: H) -> Swift.Result<OperationOutput<ExportJournalToS3OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExportJournalToS3Input>
    public typealias MOutput = OperationOutput<ExportJournalToS3OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExportJournalToS3OutputError>
}

public struct ExportJournalToS3InputQueryItemMiddleware: Middleware {
    public let id: String = "ExportJournalToS3InputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExportJournalToS3Input>,
                  next: H) -> Swift.Result<OperationOutput<ExportJournalToS3OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExportJournalToS3Input>
    public typealias MOutput = OperationOutput<ExportJournalToS3OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExportJournalToS3OutputError>
}

public struct ExportJournalToS3Input: Equatable {
    /// <p>The exclusive end date and time for the range of journal contents to export.</p>
    ///          <p>The <code>ExclusiveEndTime</code> must be in <code>ISO 8601</code> date and time format
    ///          and in Universal Coordinated Time (UTC). For example:
    ///          <code>2019-06-13T21:36:34Z</code>.</p>
    ///          <p>The <code>ExclusiveEndTime</code> must be less than or equal to the current UTC date and
    ///          time.</p>
    public let exclusiveEndTime: Date?
    /// <p>The inclusive start date and time for the range of journal contents to export.</p>
    ///          <p>The <code>InclusiveStartTime</code> must be in <code>ISO 8601</code> date and time
    ///          format and in Universal Coordinated Time (UTC). For example:
    ///             <code>2019-06-13T21:36:34Z</code>.</p>
    ///          <p>The <code>InclusiveStartTime</code> must be before <code>ExclusiveEndTime</code>.</p>
    ///          <p>If you provide an <code>InclusiveStartTime</code> that is before the ledger's
    ///             <code>CreationDateTime</code>, Amazon QLDB defaults it to the ledger's
    ///             <code>CreationDateTime</code>.</p>
    public let inclusiveStartTime: Date?
    /// <p>The name of the ledger.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role that grants QLDB permissions for a
    ///          journal export job to do the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Write objects into your Amazon Simple Storage Service (Amazon S3) bucket.</p>
    ///             </li>
    ///             <li>
    ///                <p>(Optional) Use your customer master key (CMK) in AWS Key Management Service (AWS
    ///                KMS) for server-side encryption of your exported data.</p>
    ///             </li>
    ///          </ul>
    public let roleArn: String?
    /// <p>The configuration settings of the Amazon S3 bucket destination for your export
    ///          request.</p>
    public let s3ExportConfiguration: S3ExportConfiguration?

    public init (
        exclusiveEndTime: Date? = nil,
        inclusiveStartTime: Date? = nil,
        name: String? = nil,
        roleArn: String? = nil,
        s3ExportConfiguration: S3ExportConfiguration? = nil
    )
    {
        self.exclusiveEndTime = exclusiveEndTime
        self.inclusiveStartTime = inclusiveStartTime
        self.name = name
        self.roleArn = roleArn
        self.s3ExportConfiguration = s3ExportConfiguration
    }
}

struct ExportJournalToS3InputBody: Equatable {
    public let inclusiveStartTime: Date?
    public let exclusiveEndTime: Date?
    public let s3ExportConfiguration: S3ExportConfiguration?
    public let roleArn: String?
}

extension ExportJournalToS3InputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exclusiveEndTime = "ExclusiveEndTime"
        case inclusiveStartTime = "InclusiveStartTime"
        case roleArn = "RoleArn"
        case s3ExportConfiguration = "S3ExportConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inclusiveStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .inclusiveStartTime)
        inclusiveStartTime = inclusiveStartTimeDecoded
        let exclusiveEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .exclusiveEndTime)
        exclusiveEndTime = exclusiveEndTimeDecoded
        let s3ExportConfigurationDecoded = try containerValues.decodeIfPresent(S3ExportConfiguration.self, forKey: .s3ExportConfiguration)
        s3ExportConfiguration = s3ExportConfigurationDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension ExportJournalToS3OutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportJournalToS3OutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourcePreconditionNotMetException" : self = .resourcePreconditionNotMetException(try ResourcePreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExportJournalToS3OutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case resourcePreconditionNotMetException(ResourcePreconditionNotMetException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportJournalToS3OutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportJournalToS3OutputResponse(exportId: \(String(describing: exportId)))"}
}

extension ExportJournalToS3OutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ExportJournalToS3OutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.exportId = output.exportId
        } else {
            self.exportId = nil
        }
    }
}

public struct ExportJournalToS3OutputResponse: Equatable {
    /// <p>The UUID (represented in Base62-encoded text) that QLDB assigns to each journal export
    ///          job.</p>
    ///          <p>To describe your export request and check the status of the job, you can use
    ///             <code>ExportId</code> to call <code>DescribeJournalS3Export</code>.</p>
    public let exportId: String?

    public init (
        exportId: String? = nil
    )
    {
        self.exportId = exportId
    }
}

struct ExportJournalToS3OutputResponseBody: Equatable {
    public let exportId: String?
}

extension ExportJournalToS3OutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exportId = "ExportId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exportId)
        exportId = exportIdDecoded
    }
}

public enum ExportStatus {
    case cancelled
    case completed
    case inProgress
    case sdkUnknown(String)
}

extension ExportStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExportStatus] {
        return [
            .cancelled,
            .completed,
            .inProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancelled: return "CANCELLED"
        case .completed: return "COMPLETED"
        case .inProgress: return "IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExportStatus(rawValue: rawValue) ?? ExportStatus.sdkUnknown(rawValue)
    }
}

public struct GetBlockInputBodyMiddleware: Middleware {
    public let id: String = "GetBlockInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBlockInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBlockInput>
    public typealias MOutput = OperationOutput<GetBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBlockOutputError>
}

extension GetBlockInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBlockInput(blockAddress: \(String(describing: blockAddress)), digestTipAddress: \(String(describing: digestTipAddress)), name: \(String(describing: name)))"}
}

extension GetBlockInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case blockAddress = "BlockAddress"
        case digestTipAddress = "DigestTipAddress"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockAddress = blockAddress {
            try encodeContainer.encode(blockAddress, forKey: .blockAddress)
        }
        if let digestTipAddress = digestTipAddress {
            try encodeContainer.encode(digestTipAddress, forKey: .digestTipAddress)
        }
    }
}

public struct GetBlockInputHeadersMiddleware: Middleware {
    public let id: String = "GetBlockInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBlockInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBlockInput>
    public typealias MOutput = OperationOutput<GetBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBlockOutputError>
}

public struct GetBlockInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBlockInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBlockInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBlockInput>
    public typealias MOutput = OperationOutput<GetBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBlockOutputError>
}

public struct GetBlockInput: Equatable {
    /// <p>The location of the block that you want to request. An address is an Amazon Ion
    ///          structure that has two fields: <code>strandId</code> and <code>sequenceNo</code>.</p>
    ///          <p>For example: <code>{strandId:"BlFTjlSXze9BIh1KOszcE3",sequenceNo:14}</code>.</p>
    public let blockAddress: ValueHolder?
    /// <p>The latest block location covered by the digest for which to request a proof. An address
    ///          is an Amazon Ion structure that has two fields: <code>strandId</code> and
    ///             <code>sequenceNo</code>.</p>
    ///          <p>For example: <code>{strandId:"BlFTjlSXze9BIh1KOszcE3",sequenceNo:49}</code>.</p>
    public let digestTipAddress: ValueHolder?
    /// <p>The name of the ledger.</p>
    public let name: String?

    public init (
        blockAddress: ValueHolder? = nil,
        digestTipAddress: ValueHolder? = nil,
        name: String? = nil
    )
    {
        self.blockAddress = blockAddress
        self.digestTipAddress = digestTipAddress
        self.name = name
    }
}

struct GetBlockInputBody: Equatable {
    public let blockAddress: ValueHolder?
    public let digestTipAddress: ValueHolder?
}

extension GetBlockInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case blockAddress = "BlockAddress"
        case digestTipAddress = "DigestTipAddress"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockAddressDecoded = try containerValues.decodeIfPresent(ValueHolder.self, forKey: .blockAddress)
        blockAddress = blockAddressDecoded
        let digestTipAddressDecoded = try containerValues.decodeIfPresent(ValueHolder.self, forKey: .digestTipAddress)
        digestTipAddress = digestTipAddressDecoded
    }
}

extension GetBlockOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBlockOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourcePreconditionNotMetException" : self = .resourcePreconditionNotMetException(try ResourcePreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBlockOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourcePreconditionNotMetException(ResourcePreconditionNotMetException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBlockOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBlockOutputResponse(block: \(String(describing: block)), proof: \(String(describing: proof)))"}
}

extension GetBlockOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBlockOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.block = output.block
            self.proof = output.proof
        } else {
            self.block = nil
            self.proof = nil
        }
    }
}

public struct GetBlockOutputResponse: Equatable {
    /// <p>The block data object in Amazon Ion format.</p>
    public let block: ValueHolder?
    /// <p>The proof object in Amazon Ion format returned by a <code>GetBlock</code> request. A
    ///          proof contains the list of hash values required to recalculate the specified digest using a
    ///          Merkle tree, starting with the specified block.</p>
    public let proof: ValueHolder?

    public init (
        block: ValueHolder? = nil,
        proof: ValueHolder? = nil
    )
    {
        self.block = block
        self.proof = proof
    }
}

struct GetBlockOutputResponseBody: Equatable {
    public let block: ValueHolder?
    public let proof: ValueHolder?
}

extension GetBlockOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case block = "Block"
        case proof = "Proof"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockDecoded = try containerValues.decodeIfPresent(ValueHolder.self, forKey: .block)
        block = blockDecoded
        let proofDecoded = try containerValues.decodeIfPresent(ValueHolder.self, forKey: .proof)
        proof = proofDecoded
    }
}

extension GetDigestInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDigestInput(name: \(String(describing: name)))"}
}

extension GetDigestInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDigestInputHeadersMiddleware: Middleware {
    public let id: String = "GetDigestInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDigestInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDigestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDigestInput>
    public typealias MOutput = OperationOutput<GetDigestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDigestOutputError>
}

public struct GetDigestInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDigestInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDigestInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDigestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDigestInput>
    public typealias MOutput = OperationOutput<GetDigestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDigestOutputError>
}

public struct GetDigestInput: Equatable {
    /// <p>The name of the ledger.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct GetDigestInputBody: Equatable {
}

extension GetDigestInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDigestOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDigestOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourcePreconditionNotMetException" : self = .resourcePreconditionNotMetException(try ResourcePreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDigestOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourcePreconditionNotMetException(ResourcePreconditionNotMetException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDigestOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDigestOutputResponse(digest: \(String(describing: digest)), digestTipAddress: \(String(describing: digestTipAddress)))"}
}

extension GetDigestOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDigestOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.digest = output.digest
            self.digestTipAddress = output.digestTipAddress
        } else {
            self.digest = nil
            self.digestTipAddress = nil
        }
    }
}

public struct GetDigestOutputResponse: Equatable {
    /// <p>The 256-bit hash value representing the digest returned by a <code>GetDigest</code>
    ///          request.</p>
    public let digest: Data?
    /// <p>The latest block location covered by the digest that you requested. An address is an
    ///          Amazon Ion structure that has two fields: <code>strandId</code> and
    ///          <code>sequenceNo</code>.</p>
    public let digestTipAddress: ValueHolder?

    public init (
        digest: Data? = nil,
        digestTipAddress: ValueHolder? = nil
    )
    {
        self.digest = digest
        self.digestTipAddress = digestTipAddress
    }
}

struct GetDigestOutputResponseBody: Equatable {
    public let digest: Data?
    public let digestTipAddress: ValueHolder?
}

extension GetDigestOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case digest = "Digest"
        case digestTipAddress = "DigestTipAddress"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let digestDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .digest)
        digest = digestDecoded
        let digestTipAddressDecoded = try containerValues.decodeIfPresent(ValueHolder.self, forKey: .digestTipAddress)
        digestTipAddress = digestTipAddressDecoded
    }
}

public struct GetRevisionInputBodyMiddleware: Middleware {
    public let id: String = "GetRevisionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRevisionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRevisionInput>
    public typealias MOutput = OperationOutput<GetRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRevisionOutputError>
}

extension GetRevisionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRevisionInput(blockAddress: \(String(describing: blockAddress)), digestTipAddress: \(String(describing: digestTipAddress)), documentId: \(String(describing: documentId)), name: \(String(describing: name)))"}
}

extension GetRevisionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case blockAddress = "BlockAddress"
        case digestTipAddress = "DigestTipAddress"
        case documentId = "DocumentId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockAddress = blockAddress {
            try encodeContainer.encode(blockAddress, forKey: .blockAddress)
        }
        if let digestTipAddress = digestTipAddress {
            try encodeContainer.encode(digestTipAddress, forKey: .digestTipAddress)
        }
        if let documentId = documentId {
            try encodeContainer.encode(documentId, forKey: .documentId)
        }
    }
}

public struct GetRevisionInputHeadersMiddleware: Middleware {
    public let id: String = "GetRevisionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRevisionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRevisionInput>
    public typealias MOutput = OperationOutput<GetRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRevisionOutputError>
}

public struct GetRevisionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRevisionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRevisionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRevisionInput>
    public typealias MOutput = OperationOutput<GetRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRevisionOutputError>
}

public struct GetRevisionInput: Equatable {
    /// <p>The block location of the document revision to be verified. An address is an Amazon Ion
    ///          structure that has two fields: <code>strandId</code> and <code>sequenceNo</code>.</p>
    ///          <p>For example: <code>{strandId:"BlFTjlSXze9BIh1KOszcE3",sequenceNo:14}</code>.</p>
    public let blockAddress: ValueHolder?
    /// <p>The latest block location covered by the digest for which to request a proof. An address
    ///          is an Amazon Ion structure that has two fields: <code>strandId</code> and
    ///             <code>sequenceNo</code>.</p>
    ///          <p>For example: <code>{strandId:"BlFTjlSXze9BIh1KOszcE3",sequenceNo:49}</code>.</p>
    public let digestTipAddress: ValueHolder?
    /// <p>The UUID (represented in Base62-encoded text) of the document to be verified.</p>
    public let documentId: String?
    /// <p>The name of the ledger.</p>
    public let name: String?

    public init (
        blockAddress: ValueHolder? = nil,
        digestTipAddress: ValueHolder? = nil,
        documentId: String? = nil,
        name: String? = nil
    )
    {
        self.blockAddress = blockAddress
        self.digestTipAddress = digestTipAddress
        self.documentId = documentId
        self.name = name
    }
}

struct GetRevisionInputBody: Equatable {
    public let blockAddress: ValueHolder?
    public let documentId: String?
    public let digestTipAddress: ValueHolder?
}

extension GetRevisionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case blockAddress = "BlockAddress"
        case digestTipAddress = "DigestTipAddress"
        case documentId = "DocumentId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockAddressDecoded = try containerValues.decodeIfPresent(ValueHolder.self, forKey: .blockAddress)
        blockAddress = blockAddressDecoded
        let documentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentId)
        documentId = documentIdDecoded
        let digestTipAddressDecoded = try containerValues.decodeIfPresent(ValueHolder.self, forKey: .digestTipAddress)
        digestTipAddress = digestTipAddressDecoded
    }
}

extension GetRevisionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRevisionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourcePreconditionNotMetException" : self = .resourcePreconditionNotMetException(try ResourcePreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRevisionOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourcePreconditionNotMetException(ResourcePreconditionNotMetException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRevisionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRevisionOutputResponse(proof: \(String(describing: proof)), revision: \(String(describing: revision)))"}
}

extension GetRevisionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRevisionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.proof = output.proof
            self.revision = output.revision
        } else {
            self.proof = nil
            self.revision = nil
        }
    }
}

public struct GetRevisionOutputResponse: Equatable {
    /// <p>The proof object in Amazon Ion format returned by a <code>GetRevision</code> request. A
    ///          proof contains the list of hash values that are required to recalculate the specified
    ///          digest using a Merkle tree, starting with the specified document revision.</p>
    public let proof: ValueHolder?
    /// <p>The document revision data object in Amazon Ion format.</p>
    public let revision: ValueHolder?

    public init (
        proof: ValueHolder? = nil,
        revision: ValueHolder? = nil
    )
    {
        self.proof = proof
        self.revision = revision
    }
}

struct GetRevisionOutputResponseBody: Equatable {
    public let proof: ValueHolder?
    public let revision: ValueHolder?
}

extension GetRevisionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case proof = "Proof"
        case revision = "Revision"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proofDecoded = try containerValues.decodeIfPresent(ValueHolder.self, forKey: .proof)
        proof = proofDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(ValueHolder.self, forKey: .revision)
        revision = revisionDecoded
    }
}

extension InvalidParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterException(message: \(String(describing: message)), parameterName: \(String(describing: parameterName)))"}
}

extension InvalidParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.parameterName = output.parameterName
        } else {
            self.message = nil
            self.parameterName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more parameters in the request aren't valid.</p>
public struct InvalidParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The name of the invalid parameter.</p>
    public var parameterName: String?

    public init (
        message: String? = nil,
        parameterName: String? = nil
    )
    {
        self.message = message
        self.parameterName = parameterName
    }
}

struct InvalidParameterExceptionBody: Equatable {
    public let message: String?
    public let parameterName: String?
}

extension InvalidParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case parameterName = "ParameterName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let parameterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
    }
}

extension JournalKinesisStreamDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case errorCause = "ErrorCause"
        case exclusiveEndTime = "ExclusiveEndTime"
        case inclusiveStartTime = "InclusiveStartTime"
        case kinesisConfiguration = "KinesisConfiguration"
        case ledgerName = "LedgerName"
        case roleArn = "RoleArn"
        case status = "Status"
        case streamId = "StreamId"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let errorCause = errorCause {
            try encodeContainer.encode(errorCause.rawValue, forKey: .errorCause)
        }
        if let exclusiveEndTime = exclusiveEndTime {
            try encodeContainer.encode(exclusiveEndTime.timeIntervalSince1970, forKey: .exclusiveEndTime)
        }
        if let inclusiveStartTime = inclusiveStartTime {
            try encodeContainer.encode(inclusiveStartTime.timeIntervalSince1970, forKey: .inclusiveStartTime)
        }
        if let kinesisConfiguration = kinesisConfiguration {
            try encodeContainer.encode(kinesisConfiguration, forKey: .kinesisConfiguration)
        }
        if let ledgerName = ledgerName {
            try encodeContainer.encode(ledgerName, forKey: .ledgerName)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let streamId = streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ledgerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ledgerName)
        ledgerName = ledgerNameDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let inclusiveStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .inclusiveStartTime)
        inclusiveStartTime = inclusiveStartTimeDecoded
        let exclusiveEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .exclusiveEndTime)
        exclusiveEndTime = exclusiveEndTimeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(StreamStatus.self, forKey: .status)
        status = statusDecoded
        let kinesisConfigurationDecoded = try containerValues.decodeIfPresent(KinesisConfiguration.self, forKey: .kinesisConfiguration)
        kinesisConfiguration = kinesisConfigurationDecoded
        let errorCauseDecoded = try containerValues.decodeIfPresent(ErrorCause.self, forKey: .errorCause)
        errorCause = errorCauseDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
    }
}

extension JournalKinesisStreamDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JournalKinesisStreamDescription(arn: \(String(describing: arn)), creationTime: \(String(describing: creationTime)), errorCause: \(String(describing: errorCause)), exclusiveEndTime: \(String(describing: exclusiveEndTime)), inclusiveStartTime: \(String(describing: inclusiveStartTime)), kinesisConfiguration: \(String(describing: kinesisConfiguration)), ledgerName: \(String(describing: ledgerName)), roleArn: \(String(describing: roleArn)), status: \(String(describing: status)), streamId: \(String(describing: streamId)), streamName: \(String(describing: streamName)))"}
}

/// <p>Information about an Amazon QLDB journal stream, including the Amazon Resource Name
///          (ARN), stream name, creation time, current status, and the parameters of the original
///          stream creation request.</p>
public struct JournalKinesisStreamDescription: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the QLDB journal stream.</p>
    public let arn: String?
    /// <p>The date and time, in epoch time format, when the QLDB journal stream was created.
    ///          (Epoch time format is the number of seconds elapsed since 12:00:00 AM January 1, 1970
    ///          UTC.)</p>
    public let creationTime: Date?
    /// <p>The error message that describes the reason that a stream has a status of
    ///             <code>IMPAIRED</code> or <code>FAILED</code>. This is not applicable to streams that
    ///          have other status values.</p>
    public let errorCause: ErrorCause?
    /// <p>The exclusive date and time that specifies when the stream ends. If this parameter is
    ///          blank, the stream runs indefinitely until you cancel it.</p>
    public let exclusiveEndTime: Date?
    /// <p>The inclusive start date and time from which to start streaming journal data.</p>
    public let inclusiveStartTime: Date?
    /// <p>The configuration settings of the Amazon Kinesis Data Streams destination for a QLDB journal
    ///          stream.</p>
    public let kinesisConfiguration: KinesisConfiguration?
    /// <p>The name of the ledger.</p>
    public let ledgerName: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role that grants QLDB permissions for a
    ///          journal stream to write data records to a Kinesis Data Streams resource.</p>
    public let roleArn: String?
    /// <p>The current state of the QLDB journal stream.</p>
    public let status: StreamStatus?
    /// <p>The UUID (represented in Base62-encoded text) of the QLDB journal stream.</p>
    public let streamId: String?
    /// <p>The user-defined name of the QLDB journal stream.</p>
    public let streamName: String?

    public init (
        arn: String? = nil,
        creationTime: Date? = nil,
        errorCause: ErrorCause? = nil,
        exclusiveEndTime: Date? = nil,
        inclusiveStartTime: Date? = nil,
        kinesisConfiguration: KinesisConfiguration? = nil,
        ledgerName: String? = nil,
        roleArn: String? = nil,
        status: StreamStatus? = nil,
        streamId: String? = nil,
        streamName: String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.errorCause = errorCause
        self.exclusiveEndTime = exclusiveEndTime
        self.inclusiveStartTime = inclusiveStartTime
        self.kinesisConfiguration = kinesisConfiguration
        self.ledgerName = ledgerName
        self.roleArn = roleArn
        self.status = status
        self.streamId = streamId
        self.streamName = streamName
    }
}

extension JournalS3ExportDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exclusiveEndTime = "ExclusiveEndTime"
        case exportCreationTime = "ExportCreationTime"
        case exportId = "ExportId"
        case inclusiveStartTime = "InclusiveStartTime"
        case ledgerName = "LedgerName"
        case roleArn = "RoleArn"
        case s3ExportConfiguration = "S3ExportConfiguration"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exclusiveEndTime = exclusiveEndTime {
            try encodeContainer.encode(exclusiveEndTime.timeIntervalSince1970, forKey: .exclusiveEndTime)
        }
        if let exportCreationTime = exportCreationTime {
            try encodeContainer.encode(exportCreationTime.timeIntervalSince1970, forKey: .exportCreationTime)
        }
        if let exportId = exportId {
            try encodeContainer.encode(exportId, forKey: .exportId)
        }
        if let inclusiveStartTime = inclusiveStartTime {
            try encodeContainer.encode(inclusiveStartTime.timeIntervalSince1970, forKey: .inclusiveStartTime)
        }
        if let ledgerName = ledgerName {
            try encodeContainer.encode(ledgerName, forKey: .ledgerName)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let s3ExportConfiguration = s3ExportConfiguration {
            try encodeContainer.encode(s3ExportConfiguration, forKey: .s3ExportConfiguration)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ledgerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ledgerName)
        ledgerName = ledgerNameDecoded
        let exportIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exportId)
        exportId = exportIdDecoded
        let exportCreationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .exportCreationTime)
        exportCreationTime = exportCreationTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ExportStatus.self, forKey: .status)
        status = statusDecoded
        let inclusiveStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .inclusiveStartTime)
        inclusiveStartTime = inclusiveStartTimeDecoded
        let exclusiveEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .exclusiveEndTime)
        exclusiveEndTime = exclusiveEndTimeDecoded
        let s3ExportConfigurationDecoded = try containerValues.decodeIfPresent(S3ExportConfiguration.self, forKey: .s3ExportConfiguration)
        s3ExportConfiguration = s3ExportConfigurationDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension JournalS3ExportDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JournalS3ExportDescription(exclusiveEndTime: \(String(describing: exclusiveEndTime)), exportCreationTime: \(String(describing: exportCreationTime)), exportId: \(String(describing: exportId)), inclusiveStartTime: \(String(describing: inclusiveStartTime)), ledgerName: \(String(describing: ledgerName)), roleArn: \(String(describing: roleArn)), s3ExportConfiguration: \(String(describing: s3ExportConfiguration)), status: \(String(describing: status)))"}
}

/// <p>Information about a journal export job, including the ledger name, export ID, creation
///          time, current status, and the parameters of the original export creation request.</p>
public struct JournalS3ExportDescription: Equatable {
    /// <p>The exclusive end date and time for the range of journal contents that are specified in
    ///          the original export request.</p>
    public let exclusiveEndTime: Date?
    /// <p>The date and time, in epoch time format, when the export job was created. (Epoch time
    ///          format is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)</p>
    public let exportCreationTime: Date?
    /// <p>The UUID (represented in Base62-encoded text) of the journal export job.</p>
    public let exportId: String?
    /// <p>The inclusive start date and time for the range of journal contents that are specified
    ///          in the original export request.</p>
    public let inclusiveStartTime: Date?
    /// <p>The name of the ledger.</p>
    public let ledgerName: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role that grants QLDB permissions for a
    ///          journal export job to do the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Write objects into your Amazon Simple Storage Service (Amazon S3) bucket.</p>
    ///             </li>
    ///             <li>
    ///                <p>(Optional) Use your customer master key (CMK) in AWS Key Management Service (AWS
    ///                KMS) for server-side encryption of your exported data.</p>
    ///             </li>
    ///          </ul>
    public let roleArn: String?
    /// <p>The Amazon Simple Storage Service (Amazon S3) bucket location in which a journal export job writes the journal
    ///          contents.</p>
    public let s3ExportConfiguration: S3ExportConfiguration?
    /// <p>The current state of the journal export job.</p>
    public let status: ExportStatus?

    public init (
        exclusiveEndTime: Date? = nil,
        exportCreationTime: Date? = nil,
        exportId: String? = nil,
        inclusiveStartTime: Date? = nil,
        ledgerName: String? = nil,
        roleArn: String? = nil,
        s3ExportConfiguration: S3ExportConfiguration? = nil,
        status: ExportStatus? = nil
    )
    {
        self.exclusiveEndTime = exclusiveEndTime
        self.exportCreationTime = exportCreationTime
        self.exportId = exportId
        self.inclusiveStartTime = inclusiveStartTime
        self.ledgerName = ledgerName
        self.roleArn = roleArn
        self.s3ExportConfiguration = s3ExportConfiguration
        self.status = status
    }
}

extension KinesisConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aggregationEnabled = "AggregationEnabled"
        case streamArn = "StreamArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationEnabled = aggregationEnabled {
            try encodeContainer.encode(aggregationEnabled, forKey: .aggregationEnabled)
        }
        if let streamArn = streamArn {
            try encodeContainer.encode(streamArn, forKey: .streamArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamArn)
        streamArn = streamArnDecoded
        let aggregationEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .aggregationEnabled)
        aggregationEnabled = aggregationEnabledDecoded
    }
}

extension KinesisConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisConfiguration(aggregationEnabled: \(String(describing: aggregationEnabled)), streamArn: \(String(describing: streamArn)))"}
}

/// <p>The configuration settings of the Amazon Kinesis Data Streams destination for an Amazon QLDB journal
///          stream.</p>
public struct KinesisConfiguration: Equatable {
    /// <p>Enables QLDB to publish multiple data records in a single Kinesis Data Streams record, increasing the
    ///          number of records sent per API call.</p>
    ///          <p>
    ///             <i>This option is enabled by default.</i> Record aggregation has important
    ///          implications for processing records and requires de-aggregation in your stream consumer. To
    ///          learn more, see <a href="https://docs.aws.amazon.com/streams/latest/dev/kinesis-kpl-concepts.html">KPL Key Concepts</a> and <a href="https://docs.aws.amazon.com/streams/latest/dev/kinesis-kpl-consumer-deaggregation.html">Consumer De-aggregation</a> in the <i>Amazon Kinesis Data Streams Developer
    ///          Guide</i>.</p>
    public let aggregationEnabled: Bool?
    /// <p>The Amazon Resource Name (ARN) of the Kinesis Data Streams resource.</p>
    public let streamArn: String?

    public init (
        aggregationEnabled: Bool? = nil,
        streamArn: String? = nil
    )
    {
        self.aggregationEnabled = aggregationEnabled
        self.streamArn = streamArn
    }
}

public enum LedgerState {
    case active
    case creating
    case deleted
    case deleting
    case sdkUnknown(String)
}

extension LedgerState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LedgerState] {
        return [
            .active,
            .creating,
            .deleted,
            .deleting,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .creating: return "CREATING"
        case .deleted: return "DELETED"
        case .deleting: return "DELETING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LedgerState(rawValue: rawValue) ?? LedgerState.sdkUnknown(rawValue)
    }
}

extension LedgerSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDateTime = "CreationDateTime"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(LedgerState.self, forKey: .state)
        state = stateDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
    }
}

extension LedgerSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LedgerSummary(creationDateTime: \(String(describing: creationDateTime)), name: \(String(describing: name)), state: \(String(describing: state)))"}
}

/// <p>Information about a ledger, including its name, state, and when it was created.</p>
public struct LedgerSummary: Equatable {
    /// <p>The date and time, in epoch time format, when the ledger was created. (Epoch time format
    ///          is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)</p>
    public let creationDateTime: Date?
    /// <p>The name of the ledger.</p>
    public let name: String?
    /// <p>The current status of the ledger.</p>
    public let state: LedgerState?

    public init (
        creationDateTime: Date? = nil,
        name: String? = nil,
        state: LedgerState? = nil
    )
    {
        self.creationDateTime = creationDateTime
        self.name = name
        self.state = state
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)), resourceType: \(String(describing: resourceType)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have reached the limit on the maximum number of resources allowed.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The type of resource.</p>
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceType = resourceType
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
    public let resourceType: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ListJournalKinesisStreamsForLedgerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJournalKinesisStreamsForLedgerInput(ledgerName: \(String(describing: ledgerName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListJournalKinesisStreamsForLedgerInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListJournalKinesisStreamsForLedgerInputHeadersMiddleware: Middleware {
    public let id: String = "ListJournalKinesisStreamsForLedgerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJournalKinesisStreamsForLedgerInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJournalKinesisStreamsForLedgerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJournalKinesisStreamsForLedgerInput>
    public typealias MOutput = OperationOutput<ListJournalKinesisStreamsForLedgerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJournalKinesisStreamsForLedgerOutputError>
}

public struct ListJournalKinesisStreamsForLedgerInputQueryItemMiddleware: Middleware {
    public let id: String = "ListJournalKinesisStreamsForLedgerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJournalKinesisStreamsForLedgerInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJournalKinesisStreamsForLedgerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next_token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "max_results".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJournalKinesisStreamsForLedgerInput>
    public typealias MOutput = OperationOutput<ListJournalKinesisStreamsForLedgerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJournalKinesisStreamsForLedgerOutputError>
}

public struct ListJournalKinesisStreamsForLedgerInput: Equatable {
    /// <p>The name of the ledger.</p>
    public let ledgerName: String?
    /// <p>The maximum number of results to return in a single
    ///             <code>ListJournalKinesisStreamsForLedger</code> request. (The actual number of results
    ///          returned might be fewer.)</p>
    public let maxResults: Int?
    /// <p>A pagination token, indicating that you want to retrieve the next page of results. If
    ///          you received a value for <code>NextToken</code> in the response from a previous
    ///             <code>ListJournalKinesisStreamsForLedger</code> call, you should use that value as input
    ///          here.</p>
    public let nextToken: String?

    public init (
        ledgerName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.ledgerName = ledgerName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListJournalKinesisStreamsForLedgerInputBody: Equatable {
}

extension ListJournalKinesisStreamsForLedgerInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListJournalKinesisStreamsForLedgerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListJournalKinesisStreamsForLedgerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourcePreconditionNotMetException" : self = .resourcePreconditionNotMetException(try ResourcePreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListJournalKinesisStreamsForLedgerOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourcePreconditionNotMetException(ResourcePreconditionNotMetException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJournalKinesisStreamsForLedgerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJournalKinesisStreamsForLedgerOutputResponse(nextToken: \(String(describing: nextToken)), streams: \(String(describing: streams)))"}
}

extension ListJournalKinesisStreamsForLedgerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListJournalKinesisStreamsForLedgerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.streams = output.streams
        } else {
            self.nextToken = nil
            self.streams = nil
        }
    }
}

public struct ListJournalKinesisStreamsForLedgerOutputResponse: Equatable {
    /// <ul>
    ///             <li>
    ///                <p>If <code>NextToken</code> is empty, the last page of results has been processed
    ///                and there are no more results to be retrieved.</p>
    ///             </li>
    ///             <li>
    ///                <p>If <code>NextToken</code> is <i>not</i> empty, more results are
    ///                available. To retrieve the next page of results, use the value of
    ///                   <code>NextToken</code> in a subsequent
    ///                   <code>ListJournalKinesisStreamsForLedger</code> call.</p>
    ///             </li>
    ///          </ul>
    public let nextToken: String?
    /// <p>The array of QLDB journal stream descriptors that are associated with the given
    ///          ledger.</p>
    public let streams: [JournalKinesisStreamDescription]?

    public init (
        nextToken: String? = nil,
        streams: [JournalKinesisStreamDescription]? = nil
    )
    {
        self.nextToken = nextToken
        self.streams = streams
    }
}

struct ListJournalKinesisStreamsForLedgerOutputResponseBody: Equatable {
    public let streams: [JournalKinesisStreamDescription]?
    public let nextToken: String?
}

extension ListJournalKinesisStreamsForLedgerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case streams = "Streams"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamsContainer = try containerValues.decodeIfPresent([JournalKinesisStreamDescription?].self, forKey: .streams)
        var streamsDecoded0:[JournalKinesisStreamDescription]? = nil
        if let streamsContainer = streamsContainer {
            streamsDecoded0 = [JournalKinesisStreamDescription]()
            for structure0 in streamsContainer {
                if let structure0 = structure0 {
                    streamsDecoded0?.append(structure0)
                }
            }
        }
        streams = streamsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListJournalS3ExportsForLedgerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJournalS3ExportsForLedgerInput(maxResults: \(String(describing: maxResults)), name: \(String(describing: name)), nextToken: \(String(describing: nextToken)))"}
}

extension ListJournalS3ExportsForLedgerInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListJournalS3ExportsForLedgerInputHeadersMiddleware: Middleware {
    public let id: String = "ListJournalS3ExportsForLedgerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJournalS3ExportsForLedgerInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJournalS3ExportsForLedgerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJournalS3ExportsForLedgerInput>
    public typealias MOutput = OperationOutput<ListJournalS3ExportsForLedgerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJournalS3ExportsForLedgerOutputError>
}

public struct ListJournalS3ExportsForLedgerInputQueryItemMiddleware: Middleware {
    public let id: String = "ListJournalS3ExportsForLedgerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJournalS3ExportsForLedgerInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJournalS3ExportsForLedgerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next_token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "max_results".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJournalS3ExportsForLedgerInput>
    public typealias MOutput = OperationOutput<ListJournalS3ExportsForLedgerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJournalS3ExportsForLedgerOutputError>
}

public struct ListJournalS3ExportsForLedgerInput: Equatable {
    /// <p>The maximum number of results to return in a single
    ///             <code>ListJournalS3ExportsForLedger</code> request. (The actual number of results
    ///          returned might be fewer.)</p>
    public let maxResults: Int?
    /// <p>The name of the ledger.</p>
    public let name: String?
    /// <p>A pagination token, indicating that you want to retrieve the next page of results. If
    ///          you received a value for <code>NextToken</code> in the response from a previous
    ///             <code>ListJournalS3ExportsForLedger</code> call, then you should use that value as input
    ///          here.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        name: String? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListJournalS3ExportsForLedgerInputBody: Equatable {
}

extension ListJournalS3ExportsForLedgerInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListJournalS3ExportsForLedgerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListJournalS3ExportsForLedgerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListJournalS3ExportsForLedgerOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJournalS3ExportsForLedgerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJournalS3ExportsForLedgerOutputResponse(journalS3Exports: \(String(describing: journalS3Exports)), nextToken: \(String(describing: nextToken)))"}
}

extension ListJournalS3ExportsForLedgerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListJournalS3ExportsForLedgerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.journalS3Exports = output.journalS3Exports
            self.nextToken = output.nextToken
        } else {
            self.journalS3Exports = nil
            self.nextToken = nil
        }
    }
}

public struct ListJournalS3ExportsForLedgerOutputResponse: Equatable {
    /// <p>The array of journal export job descriptions that are associated with the specified
    ///          ledger.</p>
    public let journalS3Exports: [JournalS3ExportDescription]?
    /// <ul>
    ///             <li>
    ///                <p>If <code>NextToken</code> is empty, then the last page of results has been
    ///                processed and there are no more results to be retrieved.</p>
    ///             </li>
    ///             <li>
    ///                <p>If <code>NextToken</code> is <i>not</i> empty, then there are more
    ///                results available. To retrieve the next page of results, use the value of
    ///                   <code>NextToken</code> in a subsequent <code>ListJournalS3ExportsForLedger</code>
    ///                call.</p>
    ///             </li>
    ///          </ul>
    public let nextToken: String?

    public init (
        journalS3Exports: [JournalS3ExportDescription]? = nil,
        nextToken: String? = nil
    )
    {
        self.journalS3Exports = journalS3Exports
        self.nextToken = nextToken
    }
}

struct ListJournalS3ExportsForLedgerOutputResponseBody: Equatable {
    public let journalS3Exports: [JournalS3ExportDescription]?
    public let nextToken: String?
}

extension ListJournalS3ExportsForLedgerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case journalS3Exports = "JournalS3Exports"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let journalS3ExportsContainer = try containerValues.decodeIfPresent([JournalS3ExportDescription?].self, forKey: .journalS3Exports)
        var journalS3ExportsDecoded0:[JournalS3ExportDescription]? = nil
        if let journalS3ExportsContainer = journalS3ExportsContainer {
            journalS3ExportsDecoded0 = [JournalS3ExportDescription]()
            for structure0 in journalS3ExportsContainer {
                if let structure0 = structure0 {
                    journalS3ExportsDecoded0?.append(structure0)
                }
            }
        }
        journalS3Exports = journalS3ExportsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListJournalS3ExportsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJournalS3ExportsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListJournalS3ExportsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListJournalS3ExportsInputHeadersMiddleware: Middleware {
    public let id: String = "ListJournalS3ExportsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJournalS3ExportsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJournalS3ExportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJournalS3ExportsInput>
    public typealias MOutput = OperationOutput<ListJournalS3ExportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJournalS3ExportsOutputError>
}

public struct ListJournalS3ExportsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListJournalS3ExportsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJournalS3ExportsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJournalS3ExportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next_token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "max_results".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJournalS3ExportsInput>
    public typealias MOutput = OperationOutput<ListJournalS3ExportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJournalS3ExportsOutputError>
}

public struct ListJournalS3ExportsInput: Equatable {
    /// <p>The maximum number of results to return in a single <code>ListJournalS3Exports</code>
    ///          request. (The actual number of results returned might be fewer.)</p>
    public let maxResults: Int?
    /// <p>A pagination token, indicating that you want to retrieve the next page of results. If
    ///          you received a value for <code>NextToken</code> in the response from a previous
    ///             <code>ListJournalS3Exports</code> call, then you should use that value as input
    ///          here.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListJournalS3ExportsInputBody: Equatable {
}

extension ListJournalS3ExportsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListJournalS3ExportsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListJournalS3ExportsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListJournalS3ExportsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJournalS3ExportsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJournalS3ExportsOutputResponse(journalS3Exports: \(String(describing: journalS3Exports)), nextToken: \(String(describing: nextToken)))"}
}

extension ListJournalS3ExportsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListJournalS3ExportsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.journalS3Exports = output.journalS3Exports
            self.nextToken = output.nextToken
        } else {
            self.journalS3Exports = nil
            self.nextToken = nil
        }
    }
}

public struct ListJournalS3ExportsOutputResponse: Equatable {
    /// <p>The array of journal export job descriptions for all ledgers that are associated with
    ///          the current AWS account and Region.</p>
    public let journalS3Exports: [JournalS3ExportDescription]?
    /// <ul>
    ///             <li>
    ///                <p>If <code>NextToken</code> is empty, then the last page of results has been
    ///                processed and there are no more results to be retrieved.</p>
    ///             </li>
    ///             <li>
    ///                <p>If <code>NextToken</code> is <i>not</i> empty, then there are more
    ///                results available. To retrieve the next page of results, use the value of
    ///                   <code>NextToken</code> in a subsequent <code>ListJournalS3Exports</code>
    ///                call.</p>
    ///             </li>
    ///          </ul>
    public let nextToken: String?

    public init (
        journalS3Exports: [JournalS3ExportDescription]? = nil,
        nextToken: String? = nil
    )
    {
        self.journalS3Exports = journalS3Exports
        self.nextToken = nextToken
    }
}

struct ListJournalS3ExportsOutputResponseBody: Equatable {
    public let journalS3Exports: [JournalS3ExportDescription]?
    public let nextToken: String?
}

extension ListJournalS3ExportsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case journalS3Exports = "JournalS3Exports"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let journalS3ExportsContainer = try containerValues.decodeIfPresent([JournalS3ExportDescription?].self, forKey: .journalS3Exports)
        var journalS3ExportsDecoded0:[JournalS3ExportDescription]? = nil
        if let journalS3ExportsContainer = journalS3ExportsContainer {
            journalS3ExportsDecoded0 = [JournalS3ExportDescription]()
            for structure0 in journalS3ExportsContainer {
                if let structure0 = structure0 {
                    journalS3ExportsDecoded0?.append(structure0)
                }
            }
        }
        journalS3Exports = journalS3ExportsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLedgersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLedgersInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListLedgersInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListLedgersInputHeadersMiddleware: Middleware {
    public let id: String = "ListLedgersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLedgersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLedgersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLedgersInput>
    public typealias MOutput = OperationOutput<ListLedgersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLedgersOutputError>
}

public struct ListLedgersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListLedgersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLedgersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLedgersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next_token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "max_results".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLedgersInput>
    public typealias MOutput = OperationOutput<ListLedgersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLedgersOutputError>
}

public struct ListLedgersInput: Equatable {
    /// <p>The maximum number of results to return in a single <code>ListLedgers</code> request.
    ///          (The actual number of results returned might be fewer.)</p>
    public let maxResults: Int?
    /// <p>A pagination token, indicating that you want to retrieve the next page of results. If
    ///          you received a value for <code>NextToken</code> in the response from a previous
    ///             <code>ListLedgers</code> call, then you should use that value as input here.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLedgersInputBody: Equatable {
}

extension ListLedgersInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListLedgersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLedgersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLedgersOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLedgersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLedgersOutputResponse(ledgers: \(String(describing: ledgers)), nextToken: \(String(describing: nextToken)))"}
}

extension ListLedgersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListLedgersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.ledgers = output.ledgers
            self.nextToken = output.nextToken
        } else {
            self.ledgers = nil
            self.nextToken = nil
        }
    }
}

public struct ListLedgersOutputResponse: Equatable {
    /// <p>The array of ledger summaries that are associated with the current AWS account and
    ///          Region.</p>
    public let ledgers: [LedgerSummary]?
    /// <p>A pagination token, indicating whether there are more results available:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If <code>NextToken</code> is empty, then the last page of results has been
    ///                processed and there are no more results to be retrieved.</p>
    ///             </li>
    ///             <li>
    ///                <p>If <code>NextToken</code> is <i>not</i> empty, then there are more
    ///                results available. To retrieve the next page of results, use the value of
    ///                   <code>NextToken</code> in a subsequent <code>ListLedgers</code> call.</p>
    ///             </li>
    ///          </ul>
    public let nextToken: String?

    public init (
        ledgers: [LedgerSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.ledgers = ledgers
        self.nextToken = nextToken
    }
}

struct ListLedgersOutputResponseBody: Equatable {
    public let ledgers: [LedgerSummary]?
    public let nextToken: String?
}

extension ListLedgersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ledgers = "Ledgers"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ledgersContainer = try containerValues.decodeIfPresent([LedgerSummary?].self, forKey: .ledgers)
        var ledgersDecoded0:[LedgerSummary]? = nil
        if let ledgersContainer = ledgersContainer {
            ledgersDecoded0 = [LedgerSummary]()
            for structure0 in ledgersContainer {
                if let structure0 = structure0 {
                    ledgersDecoded0?.append(structure0)
                }
            }
        }
        ledgers = ledgersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) for which to list the tags. For example:</p>
    ///          <p>
    ///             <code>arn:aws:qldb:us-east-1:123456789012:ledger/exampleLedger</code>
    ///          </p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The tags that are currently associated with the specified Amazon QLDB resource.</p>
    public let tags: [String:String?]?

    public init (
        tags: [String:String?]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String?]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String?]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String?]()
            for (key0, tagvalue0) in tagsContainer {
                tagsDecoded0?[key0] = tagvalue0
            }
        }
        tags = tagsDecoded0
    }
}

public enum PermissionsMode {
    case allowAll
    case standard
    case sdkUnknown(String)
}

extension PermissionsMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PermissionsMode] {
        return [
            .allowAll,
            .standard,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .allowAll: return "ALLOW_ALL"
        case .standard: return "STANDARD"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PermissionsMode(rawValue: rawValue) ?? PermissionsMode.sdkUnknown(rawValue)
    }
}

extension ResourceAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceAlreadyExistsException(message: \(String(describing: message)), resourceName: \(String(describing: resourceName)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourceAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceName = output.resourceName
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceName = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource already exists.</p>
public struct ResourceAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The name of the resource.</p>
    public var resourceName: String?
    /// <p>The type of resource.</p>
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceName: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
        self.resourceType = resourceType
    }
}

struct ResourceAlreadyExistsExceptionBody: Equatable {
    public let message: String?
    public let resourceType: String?
    public let resourceName: String?
}

extension ResourceAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension ResourceInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInUseException(message: \(String(describing: message)), resourceName: \(String(describing: resourceName)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourceInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceName = output.resourceName
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceName = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource can't be modified at this time.</p>
public struct ResourceInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The name of the resource.</p>
    public var resourceName: String?
    /// <p>The type of resource.</p>
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceName: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
        self.resourceType = resourceType
    }
}

struct ResourceInUseExceptionBody: Equatable {
    public let message: String?
    public let resourceType: String?
    public let resourceName: String?
}

extension ResourceInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)), resourceName: \(String(describing: resourceName)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceName = output.resourceName
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceName = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource doesn't exist.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The name of the resource.</p>
    public var resourceName: String?
    /// <p>The type of resource.</p>
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceName: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
    public let resourceType: String?
    public let resourceName: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension ResourcePreconditionNotMetException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourcePreconditionNotMetException(message: \(String(describing: message)), resourceName: \(String(describing: resourceName)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourcePreconditionNotMetException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourcePreconditionNotMetExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceName = output.resourceName
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceName = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation failed because a condition wasn't satisfied in advance.</p>
public struct ResourcePreconditionNotMetException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The name of the resource.</p>
    public var resourceName: String?
    /// <p>The type of resource.</p>
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceName: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
        self.resourceType = resourceType
    }
}

struct ResourcePreconditionNotMetExceptionBody: Equatable {
    public let message: String?
    public let resourceType: String?
    public let resourceName: String?
}

extension ResourcePreconditionNotMetExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension S3EncryptionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case kmsKeyArn = "KmsKeyArn"
        case objectEncryptionType = "ObjectEncryptionType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyArn = kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let objectEncryptionType = objectEncryptionType {
            try encodeContainer.encode(objectEncryptionType.rawValue, forKey: .objectEncryptionType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectEncryptionTypeDecoded = try containerValues.decodeIfPresent(S3ObjectEncryptionType.self, forKey: .objectEncryptionType)
        objectEncryptionType = objectEncryptionTypeDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension S3EncryptionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3EncryptionConfiguration(kmsKeyArn: \(String(describing: kmsKeyArn)), objectEncryptionType: \(String(describing: objectEncryptionType)))"}
}

/// <p>The encryption settings that are used by a journal export job to write data in an
///          Amazon Simple Storage Service (Amazon S3) bucket.</p>
public struct S3EncryptionConfiguration: Equatable {
    /// <p>The Amazon Resource Name (ARN) for a symmetric customer master key (CMK) in AWS Key
    ///          Management Service (AWS KMS). Amazon S3 does not support asymmetric CMKs.</p>
    ///          <p>You must provide a <code>KmsKeyArn</code> if you specify <code>SSE_KMS</code> as the
    ///             <code>ObjectEncryptionType</code>.</p>
    ///          <p>
    ///             <code>KmsKeyArn</code> is not required if you specify <code>SSE_S3</code> as the
    ///             <code>ObjectEncryptionType</code>.</p>
    public let kmsKeyArn: String?
    /// <p>The Amazon S3 object encryption type.</p>
    ///          <p>To learn more about server-side encryption options in Amazon S3, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/serv-side-encryption.html">Protecting Data
    ///             Using Server-Side Encryption</a> in the <i>Amazon S3 Developer
    ///          Guide</i>.</p>
    public let objectEncryptionType: S3ObjectEncryptionType?

    public init (
        kmsKeyArn: String? = nil,
        objectEncryptionType: S3ObjectEncryptionType? = nil
    )
    {
        self.kmsKeyArn = kmsKeyArn
        self.objectEncryptionType = objectEncryptionType
    }
}

extension S3ExportConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case encryptionConfiguration = "EncryptionConfiguration"
        case prefix = "Prefix"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let encryptionConfiguration = encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let prefix = prefix {
            try encodeContainer.encode(prefix, forKey: .prefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(S3EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
    }
}

extension S3ExportConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3ExportConfiguration(bucket: \(String(describing: bucket)), encryptionConfiguration: \(String(describing: encryptionConfiguration)), prefix: \(String(describing: prefix)))"}
}

/// <p>The Amazon Simple Storage Service (Amazon S3) bucket location in which a journal export job writes the journal
///          contents.</p>
public struct S3ExportConfiguration: Equatable {
    /// <p>The Amazon S3 bucket name in which a journal export job writes the journal contents.</p>
    ///          <p>The bucket name must comply with the Amazon S3 bucket naming conventions. For more
    ///          information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html">Bucket Restrictions and
    ///             Limitations</a> in the <i>Amazon S3 Developer Guide</i>.</p>
    public let bucket: String?
    /// <p>The encryption settings that are used by a journal export job to write data in an Amazon S3
    ///          bucket.</p>
    public let encryptionConfiguration: S3EncryptionConfiguration?
    /// <p>The prefix for the Amazon S3 bucket in which a journal export job writes the journal
    ///          contents.</p>
    ///          <p>The prefix must comply with Amazon S3 key naming rules and restrictions. For more
    ///          information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html">Object Key and Metadata</a> in the <i>Amazon S3 Developer
    ///          Guide</i>.</p>
    ///          <p>The following are examples of valid <code>Prefix</code> values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>JournalExports-ForMyLedger/Testing/</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>JournalExports</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>My:Tests/</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let prefix: String?

    public init (
        bucket: String? = nil,
        encryptionConfiguration: S3EncryptionConfiguration? = nil,
        prefix: String? = nil
    )
    {
        self.bucket = bucket
        self.encryptionConfiguration = encryptionConfiguration
        self.prefix = prefix
    }
}

public enum S3ObjectEncryptionType {
    case noEncryption
    case sseKms
    case sseS3
    case sdkUnknown(String)
}

extension S3ObjectEncryptionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [S3ObjectEncryptionType] {
        return [
            .noEncryption,
            .sseKms,
            .sseS3,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .noEncryption: return "NO_ENCRYPTION"
        case .sseKms: return "SSE_KMS"
        case .sseS3: return "SSE_S3"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = S3ObjectEncryptionType(rawValue: rawValue) ?? S3ObjectEncryptionType.sdkUnknown(rawValue)
    }
}

public struct StreamJournalToKinesisInputBodyMiddleware: Middleware {
    public let id: String = "StreamJournalToKinesisInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StreamJournalToKinesisInput>,
                  next: H) -> Swift.Result<OperationOutput<StreamJournalToKinesisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StreamJournalToKinesisInput>
    public typealias MOutput = OperationOutput<StreamJournalToKinesisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StreamJournalToKinesisOutputError>
}

extension StreamJournalToKinesisInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StreamJournalToKinesisInput(exclusiveEndTime: \(String(describing: exclusiveEndTime)), inclusiveStartTime: \(String(describing: inclusiveStartTime)), kinesisConfiguration: \(String(describing: kinesisConfiguration)), ledgerName: \(String(describing: ledgerName)), roleArn: \(String(describing: roleArn)), streamName: \(String(describing: streamName)), tags: \(String(describing: tags)))"}
}

extension StreamJournalToKinesisInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exclusiveEndTime = "ExclusiveEndTime"
        case inclusiveStartTime = "InclusiveStartTime"
        case kinesisConfiguration = "KinesisConfiguration"
        case roleArn = "RoleArn"
        case streamName = "StreamName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exclusiveEndTime = exclusiveEndTime {
            try encodeContainer.encode(exclusiveEndTime.timeIntervalSince1970, forKey: .exclusiveEndTime)
        }
        if let inclusiveStartTime = inclusiveStartTime {
            try encodeContainer.encode(inclusiveStartTime.timeIntervalSince1970, forKey: .inclusiveStartTime)
        }
        if let kinesisConfiguration = kinesisConfiguration {
            try encodeContainer.encode(kinesisConfiguration, forKey: .kinesisConfiguration)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct StreamJournalToKinesisInputHeadersMiddleware: Middleware {
    public let id: String = "StreamJournalToKinesisInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StreamJournalToKinesisInput>,
                  next: H) -> Swift.Result<OperationOutput<StreamJournalToKinesisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StreamJournalToKinesisInput>
    public typealias MOutput = OperationOutput<StreamJournalToKinesisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StreamJournalToKinesisOutputError>
}

public struct StreamJournalToKinesisInputQueryItemMiddleware: Middleware {
    public let id: String = "StreamJournalToKinesisInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StreamJournalToKinesisInput>,
                  next: H) -> Swift.Result<OperationOutput<StreamJournalToKinesisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StreamJournalToKinesisInput>
    public typealias MOutput = OperationOutput<StreamJournalToKinesisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StreamJournalToKinesisOutputError>
}

public struct StreamJournalToKinesisInput: Equatable {
    /// <p>The exclusive date and time that specifies when the stream ends. If you don't define
    ///          this parameter, the stream runs indefinitely until you cancel it.</p>
    ///          <p>The <code>ExclusiveEndTime</code> must be in <code>ISO 8601</code> date and time format
    ///          and in Universal Coordinated Time (UTC). For example:
    ///          <code>2019-06-13T21:36:34Z</code>.</p>
    public let exclusiveEndTime: Date?
    /// <p>The inclusive start date and time from which to start streaming journal data. This
    ///          parameter must be in <code>ISO 8601</code> date and time format and in Universal
    ///          Coordinated Time (UTC). For example: <code>2019-06-13T21:36:34Z</code>.</p>
    ///          <p>The <code>InclusiveStartTime</code> cannot be in the future and must be before
    ///             <code>ExclusiveEndTime</code>.</p>
    ///          <p>If you provide an <code>InclusiveStartTime</code> that is before the ledger's
    ///             <code>CreationDateTime</code>, QLDB effectively defaults it to the ledger's
    ///             <code>CreationDateTime</code>.</p>
    public let inclusiveStartTime: Date?
    /// <p>The configuration settings of the Kinesis Data Streams destination for your stream request.</p>
    public let kinesisConfiguration: KinesisConfiguration?
    /// <p>The name of the ledger.</p>
    public let ledgerName: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role that grants QLDB permissions for a
    ///          journal stream to write data records to a Kinesis Data Streams resource.</p>
    public let roleArn: String?
    /// <p>The name that you want to assign to the QLDB journal stream. User-defined names can
    ///          help identify and indicate the purpose of a stream.</p>
    ///          <p>Your stream name must be unique among other <i>active</i> streams for a
    ///          given ledger. Stream names have the same naming constraints as ledger names, as defined in
    ///             <a href="https://docs.aws.amazon.com/qldb/latest/developerguide/limits.html#limits.naming">Quotas in Amazon QLDB</a> in the <i>Amazon QLDB Developer
    ///          Guide</i>.</p>
    public let streamName: String?
    /// <p>The key-value pairs to add as tags to the stream that you want to create. Tag keys are
    ///          case sensitive. Tag values are case sensitive and can be null.</p>
    public let tags: [String:String?]?

    public init (
        exclusiveEndTime: Date? = nil,
        inclusiveStartTime: Date? = nil,
        kinesisConfiguration: KinesisConfiguration? = nil,
        ledgerName: String? = nil,
        roleArn: String? = nil,
        streamName: String? = nil,
        tags: [String:String?]? = nil
    )
    {
        self.exclusiveEndTime = exclusiveEndTime
        self.inclusiveStartTime = inclusiveStartTime
        self.kinesisConfiguration = kinesisConfiguration
        self.ledgerName = ledgerName
        self.roleArn = roleArn
        self.streamName = streamName
        self.tags = tags
    }
}

struct StreamJournalToKinesisInputBody: Equatable {
    public let roleArn: String?
    public let tags: [String:String?]?
    public let inclusiveStartTime: Date?
    public let exclusiveEndTime: Date?
    public let kinesisConfiguration: KinesisConfiguration?
    public let streamName: String?
}

extension StreamJournalToKinesisInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exclusiveEndTime = "ExclusiveEndTime"
        case inclusiveStartTime = "InclusiveStartTime"
        case kinesisConfiguration = "KinesisConfiguration"
        case roleArn = "RoleArn"
        case streamName = "StreamName"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String?]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String?]()
            for (key0, tagvalue0) in tagsContainer {
                tagsDecoded0?[key0] = tagvalue0
            }
        }
        tags = tagsDecoded0
        let inclusiveStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .inclusiveStartTime)
        inclusiveStartTime = inclusiveStartTimeDecoded
        let exclusiveEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .exclusiveEndTime)
        exclusiveEndTime = exclusiveEndTimeDecoded
        let kinesisConfigurationDecoded = try containerValues.decodeIfPresent(KinesisConfiguration.self, forKey: .kinesisConfiguration)
        kinesisConfiguration = kinesisConfigurationDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
    }
}

extension StreamJournalToKinesisOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StreamJournalToKinesisOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourcePreconditionNotMetException" : self = .resourcePreconditionNotMetException(try ResourcePreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StreamJournalToKinesisOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourcePreconditionNotMetException(ResourcePreconditionNotMetException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StreamJournalToKinesisOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StreamJournalToKinesisOutputResponse(streamId: \(String(describing: streamId)))"}
}

extension StreamJournalToKinesisOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StreamJournalToKinesisOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.streamId = output.streamId
        } else {
            self.streamId = nil
        }
    }
}

public struct StreamJournalToKinesisOutputResponse: Equatable {
    /// <p>The UUID (represented in Base62-encoded text) that QLDB assigns to each QLDB journal
    ///          stream.</p>
    public let streamId: String?

    public init (
        streamId: String? = nil
    )
    {
        self.streamId = streamId
    }
}

struct StreamJournalToKinesisOutputResponseBody: Equatable {
    public let streamId: String?
}

extension StreamJournalToKinesisOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case streamId = "StreamId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamId)
        streamId = streamIdDecoded
    }
}

public enum StreamStatus {
    case active
    case canceled
    case completed
    case failed
    case impaired
    case sdkUnknown(String)
}

extension StreamStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StreamStatus] {
        return [
            .active,
            .canceled,
            .completed,
            .failed,
            .impaired,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .canceled: return "CANCELED"
        case .completed: return "COMPLETED"
        case .failed: return "FAILED"
        case .impaired: return "IMPAIRED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StreamStatus(rawValue: rawValue) ?? StreamStatus.sdkUnknown(rawValue)
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) to which you want to add the tags. For example:</p>
    ///          <p>
    ///             <code>arn:aws:qldb:us-east-1:123456789012:ledger/exampleLedger</code>
    ///          </p>
    public let resourceArn: String?
    /// <p>The key-value pairs to add as tags to the specified QLDB resource. Tag keys are case
    ///          sensitive. If you specify a key that already exists for the resource, your request fails
    ///          and returns an error. Tag values are case sensitive and can be null.</p>
    public let tags: [String:String?]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String?]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String?]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String?]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String?]()
            for (key0, tagvalue0) in tagsContainer {
                tagsDecoded0?[key0] = tagvalue0
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) from which to remove the tags. For example:</p>
    ///          <p>
    ///             <code>arn:aws:qldb:us-east-1:123456789012:ledger/exampleLedger</code>
    ///          </p>
    public let resourceArn: String?
    /// <p>The list of tag keys to remove.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateLedgerInputBodyMiddleware: Middleware {
    public let id: String = "UpdateLedgerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLedgerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLedgerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLedgerInput>
    public typealias MOutput = OperationOutput<UpdateLedgerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLedgerOutputError>
}

extension UpdateLedgerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLedgerInput(deletionProtection: \(String(describing: deletionProtection)), name: \(String(describing: name)))"}
}

extension UpdateLedgerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deletionProtection = "DeletionProtection"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deletionProtection = deletionProtection {
            try encodeContainer.encode(deletionProtection, forKey: .deletionProtection)
        }
    }
}

public struct UpdateLedgerInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateLedgerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLedgerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLedgerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLedgerInput>
    public typealias MOutput = OperationOutput<UpdateLedgerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLedgerOutputError>
}

public struct UpdateLedgerInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateLedgerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLedgerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLedgerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLedgerInput>
    public typealias MOutput = OperationOutput<UpdateLedgerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLedgerOutputError>
}

public struct UpdateLedgerInput: Equatable {
    /// <p>The flag that prevents a ledger from being deleted by any user. If not provided on
    ///       ledger creation, this feature is enabled (<code>true</code>) by default.</p>
    ///          <p>If deletion protection is enabled, you must first disable it before you can delete the
    ///       ledger. You can disable it by calling the <code>UpdateLedger</code> operation to set the flag to <code>false</code>.</p>
    public let deletionProtection: Bool?
    /// <p>The name of the ledger.</p>
    public let name: String?

    public init (
        deletionProtection: Bool? = nil,
        name: String? = nil
    )
    {
        self.deletionProtection = deletionProtection
        self.name = name
    }
}

struct UpdateLedgerInputBody: Equatable {
    public let deletionProtection: Bool?
}

extension UpdateLedgerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deletionProtection = "DeletionProtection"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
    }
}

extension UpdateLedgerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLedgerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLedgerOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLedgerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLedgerOutputResponse(arn: \(String(describing: arn)), creationDateTime: \(String(describing: creationDateTime)), deletionProtection: \(String(describing: deletionProtection)), name: \(String(describing: name)), state: \(String(describing: state)))"}
}

extension UpdateLedgerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateLedgerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.deletionProtection = output.deletionProtection
            self.name = output.name
            self.state = output.state
        } else {
            self.arn = nil
            self.creationDateTime = nil
            self.deletionProtection = nil
            self.name = nil
            self.state = nil
        }
    }
}

public struct UpdateLedgerOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the ledger.</p>
    public let arn: String?
    /// <p>The date and time, in epoch time format, when the ledger was created. (Epoch time format
    ///          is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)</p>
    public let creationDateTime: Date?
    /// <p>The flag that prevents a ledger from being deleted by any user. If not provided on
    ///       ledger creation, this feature is enabled (<code>true</code>) by default.</p>
    ///          <p>If deletion protection is enabled, you must first disable it before you can delete the
    ///       ledger. You can disable it by calling the <code>UpdateLedger</code> operation to set the flag to <code>false</code>.</p>
    public let deletionProtection: Bool?
    /// <p>The name of the ledger.</p>
    public let name: String?
    /// <p>The current status of the ledger.</p>
    public let state: LedgerState?

    public init (
        arn: String? = nil,
        creationDateTime: Date? = nil,
        deletionProtection: Bool? = nil,
        name: String? = nil,
        state: LedgerState? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.deletionProtection = deletionProtection
        self.name = name
        self.state = state
    }
}

struct UpdateLedgerOutputResponseBody: Equatable {
    public let name: String?
    public let arn: String?
    public let state: LedgerState?
    public let creationDateTime: Date?
    public let deletionProtection: Bool?
}

extension UpdateLedgerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationDateTime = "CreationDateTime"
        case deletionProtection = "DeletionProtection"
        case name = "Name"
        case state = "State"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(LedgerState.self, forKey: .state)
        state = stateDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
    }
}

public struct UpdateLedgerPermissionsModeInputBodyMiddleware: Middleware {
    public let id: String = "UpdateLedgerPermissionsModeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLedgerPermissionsModeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLedgerPermissionsModeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLedgerPermissionsModeInput>
    public typealias MOutput = OperationOutput<UpdateLedgerPermissionsModeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLedgerPermissionsModeOutputError>
}

extension UpdateLedgerPermissionsModeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLedgerPermissionsModeInput(name: \(String(describing: name)), permissionsMode: \(String(describing: permissionsMode)))"}
}

extension UpdateLedgerPermissionsModeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case permissionsMode = "PermissionsMode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permissionsMode = permissionsMode {
            try encodeContainer.encode(permissionsMode.rawValue, forKey: .permissionsMode)
        }
    }
}

public struct UpdateLedgerPermissionsModeInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateLedgerPermissionsModeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLedgerPermissionsModeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLedgerPermissionsModeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLedgerPermissionsModeInput>
    public typealias MOutput = OperationOutput<UpdateLedgerPermissionsModeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLedgerPermissionsModeOutputError>
}

public struct UpdateLedgerPermissionsModeInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateLedgerPermissionsModeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLedgerPermissionsModeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLedgerPermissionsModeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLedgerPermissionsModeInput>
    public typealias MOutput = OperationOutput<UpdateLedgerPermissionsModeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLedgerPermissionsModeOutputError>
}

public struct UpdateLedgerPermissionsModeInput: Equatable {
    /// <p>The name of the ledger.</p>
    public let name: String?
    /// <p>The permissions mode to assign to the ledger. This parameter can have one of the
    ///          following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ALLOW_ALL</code>: A legacy permissions mode that enables access control with
    ///                API-level granularity for ledgers.</p>
    ///                <p>This mode allows users who have the <code>SendCommand</code> API permission for
    ///                this ledger to run all PartiQL commands (hence, <code>ALLOW_ALL</code>) on any tables
    ///                in the specified ledger. This mode disregards any table-level or command-level IAM
    ///                permissions policies that you create for the ledger.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>STANDARD</code>: (<i>Recommended</i>) A permissions mode that
    ///                enables access control with finer granularity for ledgers, tables, and PartiQL
    ///                commands.</p>
    ///                <p>By default, this mode denies all user requests to run any PartiQL commands on any
    ///                tables in this ledger. To allow PartiQL commands to run, you must create IAM
    ///                permissions policies for specific table resources and PartiQL actions, in addition to
    ///                the <code>SendCommand</code> API permission for the ledger. For information, see
    ///                   <a href="https://docs.aws.amazon.com/qldb/latest/developerguide/getting-started-standard-mode.html">Getting
    ///                   started with the standard permissions mode</a> in the <i>Amazon QLDB
    ///                   Developer Guide</i>.</p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>We strongly recommend using the <code>STANDARD</code> permissions mode to maximize
    ///             the security of your ledger data.</p>
    ///          </note>
    public let permissionsMode: PermissionsMode?

    public init (
        name: String? = nil,
        permissionsMode: PermissionsMode? = nil
    )
    {
        self.name = name
        self.permissionsMode = permissionsMode
    }
}

struct UpdateLedgerPermissionsModeInputBody: Equatable {
    public let permissionsMode: PermissionsMode?
}

extension UpdateLedgerPermissionsModeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case permissionsMode = "PermissionsMode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsModeDecoded = try containerValues.decodeIfPresent(PermissionsMode.self, forKey: .permissionsMode)
        permissionsMode = permissionsModeDecoded
    }
}

extension UpdateLedgerPermissionsModeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLedgerPermissionsModeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLedgerPermissionsModeOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLedgerPermissionsModeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLedgerPermissionsModeOutputResponse(arn: \(String(describing: arn)), name: \(String(describing: name)), permissionsMode: \(String(describing: permissionsMode)))"}
}

extension UpdateLedgerPermissionsModeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateLedgerPermissionsModeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.name = output.name
            self.permissionsMode = output.permissionsMode
        } else {
            self.arn = nil
            self.name = nil
            self.permissionsMode = nil
        }
    }
}

public struct UpdateLedgerPermissionsModeOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the ledger.</p>
    public let arn: String?
    /// <p>The name of the ledger.</p>
    public let name: String?
    /// <p>The current permissions mode of the ledger.</p>
    public let permissionsMode: PermissionsMode?

    public init (
        arn: String? = nil,
        name: String? = nil,
        permissionsMode: PermissionsMode? = nil
    )
    {
        self.arn = arn
        self.name = name
        self.permissionsMode = permissionsMode
    }
}

struct UpdateLedgerPermissionsModeOutputResponseBody: Equatable {
    public let name: String?
    public let arn: String?
    public let permissionsMode: PermissionsMode?
}

extension UpdateLedgerPermissionsModeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case name = "Name"
        case permissionsMode = "PermissionsMode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let permissionsModeDecoded = try containerValues.decodeIfPresent(PermissionsMode.self, forKey: .permissionsMode)
        permissionsMode = permissionsModeDecoded
    }
}

extension ValueHolder: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ionText = "IonText"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ionText = ionText {
            try encodeContainer.encode(ionText, forKey: .ionText)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ionTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ionText)
        ionText = ionTextDecoded
    }
}

extension ValueHolder: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CONTENT_REDACTED"
    }
}

/// <p>A structure that can contain a value in multiple encoding formats.</p>
public struct ValueHolder: Equatable {
    /// <p>An Amazon Ion plaintext value contained in a <code>ValueHolder</code> structure.</p>
    public let ionText: String?

    public init (
        ionText: String? = nil
    )
    {
        self.ionText = ionText
    }
}
