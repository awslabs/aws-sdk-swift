// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             You are not authorized to perform this action.
///         </p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CancelQueryInputBodyMiddleware: Middleware {
    public let id: String = "CancelQueryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelQueryInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelQueryInput>
    public typealias MOutput = OperationOutput<CancelQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelQueryOutputError>
}

extension CancelQueryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelQueryInput(queryId: \(String(describing: queryId)))"}
}

extension CancelQueryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case queryId = "QueryId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryId = queryId {
            try encodeContainer.encode(queryId, forKey: .queryId)
        }
    }
}

public struct CancelQueryInputHeadersMiddleware: Middleware {
    public let id: String = "CancelQueryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelQueryInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelQueryInput>
    public typealias MOutput = OperationOutput<CancelQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelQueryOutputError>
}

public struct CancelQueryInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelQueryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelQueryInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelQueryInput>
    public typealias MOutput = OperationOutput<CancelQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelQueryOutputError>
}

public struct CancelQueryInput: Equatable {
    /// <p>
    ///       The id of the query that needs to be cancelled. <code>QueryID</code> is returned as part of QueryResult.
    ///     </p>
    public let queryId: String?

    public init (
        queryId: String? = nil
    )
    {
        self.queryId = queryId
    }
}

struct CancelQueryInputBody: Equatable {
    public let queryId: String?
}

extension CancelQueryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case queryId = "QueryId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryId)
        queryId = queryIdDecoded
    }
}

extension CancelQueryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelQueryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelQueryOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelQueryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelQueryOutputResponse(cancellationMessage: \(String(describing: cancellationMessage)))"}
}

extension CancelQueryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CancelQueryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cancellationMessage = output.cancellationMessage
        } else {
            self.cancellationMessage = nil
        }
    }
}

public struct CancelQueryOutputResponse: Equatable {
    /// <p>
    ///         A <code>CancellationMessage</code> is returned when a <code>CancelQuery</code> request for the query specified by <code>QueryId</code> has already been issued.
    ///     </p>
    public let cancellationMessage: String?

    public init (
        cancellationMessage: String? = nil
    )
    {
        self.cancellationMessage = cancellationMessage
    }
}

struct CancelQueryOutputResponseBody: Equatable {
    public let cancellationMessage: String?
}

extension CancelQueryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cancellationMessage = "CancellationMessage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cancellationMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cancellationMessage)
        cancellationMessage = cancellationMessageDecoded
    }
}

extension ColumnInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.value, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Box<`Type`>.self, forKey: .type)
        type = typeDecoded
    }
}

extension ColumnInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ColumnInfo(name: \(String(describing: name)), type: \(String(describing: type)))"}
}

/// <p>
///             Contains the meta data for query results such as the column names, data types, and other attributes.
///         </p>
public struct ColumnInfo: Equatable {
    /// <p>
    ///             The name of the result set column. The name of the result set is available for columns of all data types except for arrays.
    ///         </p>
    public let name: String?
    /// <p>
    ///             The data type of the result set column. The data type can be a scalar or complex. Scalar data types are integers, strings, doubles, booleans, and others. Complex data types are types such as arrays, rows, and others.
    ///         </p>
    public let type: Box<`Type`>?

    public init (
        name: String? = nil,
        type: Box<`Type`>? = nil
    )
    {
        self.name = name
        self.type = type
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///        Unable to poll results for a cancelled query.
///     </p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Datum: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arrayValue = "ArrayValue"
        case nullValue = "NullValue"
        case rowValue = "RowValue"
        case scalarValue = "ScalarValue"
        case timeSeriesValue = "TimeSeriesValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arrayValue = arrayValue {
            var arrayValueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .arrayValue)
            for datumlist0 in arrayValue {
                try arrayValueContainer.encode(datumlist0)
            }
        }
        if let nullValue = nullValue {
            try encodeContainer.encode(nullValue, forKey: .nullValue)
        }
        if let rowValue = rowValue {
            try encodeContainer.encode(rowValue, forKey: .rowValue)
        }
        if let scalarValue = scalarValue {
            try encodeContainer.encode(scalarValue, forKey: .scalarValue)
        }
        if let timeSeriesValue = timeSeriesValue {
            var timeSeriesValueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .timeSeriesValue)
            for timeseriesdatapointlist0 in timeSeriesValue {
                try timeSeriesValueContainer.encode(timeseriesdatapointlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scalarValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scalarValue)
        scalarValue = scalarValueDecoded
        let timeSeriesValueContainer = try containerValues.decodeIfPresent([TimeSeriesDataPoint?].self, forKey: .timeSeriesValue)
        var timeSeriesValueDecoded0:[TimeSeriesDataPoint]? = nil
        if let timeSeriesValueContainer = timeSeriesValueContainer {
            timeSeriesValueDecoded0 = [TimeSeriesDataPoint]()
            for structure0 in timeSeriesValueContainer {
                if let structure0 = structure0 {
                    timeSeriesValueDecoded0?.append(structure0)
                }
            }
        }
        timeSeriesValue = timeSeriesValueDecoded0
        let arrayValueContainer = try containerValues.decodeIfPresent([Datum?].self, forKey: .arrayValue)
        var arrayValueDecoded0:[Datum]? = nil
        if let arrayValueContainer = arrayValueContainer {
            arrayValueDecoded0 = [Datum]()
            for structure0 in arrayValueContainer {
                if let structure0 = structure0 {
                    arrayValueDecoded0?.append(structure0)
                }
            }
        }
        arrayValue = arrayValueDecoded0
        let rowValueDecoded = try containerValues.decodeIfPresent(Row.self, forKey: .rowValue)
        rowValue = rowValueDecoded
        let nullValueDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .nullValue)
        nullValue = nullValueDecoded
    }
}

extension Datum: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Datum(arrayValue: \(String(describing: arrayValue)), nullValue: \(String(describing: nullValue)), rowValue: \(String(describing: rowValue)), scalarValue: \(String(describing: scalarValue)), timeSeriesValue: \(String(describing: timeSeriesValue)))"}
}

/// <p>
///             Datum represents a single data point in a query result.
///         </p>
public struct Datum: Equatable {
    /// <p>
    ///             Indicates if the data point is an array.
    ///         </p>
    public let arrayValue: [Datum]?
    /// <p>
    ///             Indicates if the data point is null.
    ///         </p>
    public let nullValue: Bool?
    /// <p>
    ///             Indicates if the data point is a row.
    ///         </p>
    public let rowValue: Row?
    /// <p>
    ///             Indicates if the data point is a scalar value such as integer, string, double, or boolean.
    ///         </p>
    public let scalarValue: String?
    /// <p>
    ///             Indicates if the data point is of timeseries data type.
    ///         </p>
    public let timeSeriesValue: [TimeSeriesDataPoint]?

    public init (
        arrayValue: [Datum]? = nil,
        nullValue: Bool? = nil,
        rowValue: Row? = nil,
        scalarValue: String? = nil,
        timeSeriesValue: [TimeSeriesDataPoint]? = nil
    )
    {
        self.arrayValue = arrayValue
        self.nullValue = nullValue
        self.rowValue = rowValue
        self.scalarValue = scalarValue
        self.timeSeriesValue = timeSeriesValue
    }
}

extension DescribeEndpointsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEndpointsInput()"}
}

extension DescribeEndpointsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeEndpointsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEndpointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEndpointsInput>
    public typealias MOutput = OperationOutput<DescribeEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEndpointsOutputError>
}

public struct DescribeEndpointsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEndpointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEndpointsInput>
    public typealias MOutput = OperationOutput<DescribeEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEndpointsOutputError>
}

public struct DescribeEndpointsInput: Equatable {

    public init() {}
}

struct DescribeEndpointsInputBody: Equatable {
}

extension DescribeEndpointsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeEndpointsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEndpointsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEndpointsOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEndpointsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEndpointsOutputResponse(endpoints: \(String(describing: endpoints)))"}
}

extension DescribeEndpointsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endpoints = output.endpoints
        } else {
            self.endpoints = nil
        }
    }
}

public struct DescribeEndpointsOutputResponse: Equatable {
    /// <p>An <code>Endpoints</code> object is returned when a <code>DescribeEndpoints</code> request is made.</p>
    public let endpoints: [Endpoint]?

    public init (
        endpoints: [Endpoint]? = nil
    )
    {
        self.endpoints = endpoints
    }
}

struct DescribeEndpointsOutputResponseBody: Equatable {
    public let endpoints: [Endpoint]?
}

extension DescribeEndpointsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpoints = "Endpoints"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointsContainer = try containerValues.decodeIfPresent([Endpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[Endpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [Endpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
    }
}

extension Endpoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case cachePeriodInMinutes = "CachePeriodInMinutes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if cachePeriodInMinutes != 0 {
            try encodeContainer.encode(cachePeriodInMinutes, forKey: .cachePeriodInMinutes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .address)
        address = addressDecoded
        let cachePeriodInMinutesDecoded = try containerValues.decode(Int.self, forKey: .cachePeriodInMinutes)
        cachePeriodInMinutes = cachePeriodInMinutesDecoded
    }
}

extension Endpoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Endpoint(address: \(String(describing: address)), cachePeriodInMinutes: \(String(describing: cachePeriodInMinutes)))"}
}

/// <p>Represents an available endpoint against which to make API calls agaisnt, as well as the TTL for that endpoint.</p>
public struct Endpoint: Equatable {
    /// <p>An endpoint address.</p>
    public let address: String?
    /// <p>The TTL for the endpoint, in minutes.</p>
    public let cachePeriodInMinutes: Int

    public init (
        address: String? = nil,
        cachePeriodInMinutes: Int = 0
    )
    {
        self.address = address
        self.cachePeriodInMinutes = cachePeriodInMinutes
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             Timestream was unable to fully process this request because of an internal server error.
///         </p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEndpointException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidEndpointException(message: \(String(describing: message)))"}
}

extension InvalidEndpointException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidEndpointExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested endpoint was invalid.</p>
public struct InvalidEndpointException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEndpointExceptionBody: Equatable {
    public let message: String?
}

extension InvalidEndpointExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension QueryExecutionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueryExecutionException(message: \(String(describing: message)))"}
}

extension QueryExecutionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: QueryExecutionExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///         Timestream was unable to run the query successfully.
///     </p>
public struct QueryExecutionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct QueryExecutionExceptionBody: Equatable {
    public let message: String?
}

extension QueryExecutionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct QueryInputBodyMiddleware: Middleware {
    public let id: String = "QueryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<QueryInput>,
                  next: H) -> Swift.Result<OperationOutput<QueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<QueryInput>
    public typealias MOutput = OperationOutput<QueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<QueryOutputError>
}

extension QueryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueryInput(clientToken: \(String(describing: clientToken)), maxRows: \(String(describing: maxRows)), nextToken: \(String(describing: nextToken)), queryString: \(String(describing: queryString)))"}
}

extension QueryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case maxRows = "MaxRows"
        case nextToken = "NextToken"
        case queryString = "QueryString"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let maxRows = maxRows {
            try encodeContainer.encode(maxRows, forKey: .maxRows)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let queryString = queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
    }
}

public struct QueryInputHeadersMiddleware: Middleware {
    public let id: String = "QueryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<QueryInput>,
                  next: H) -> Swift.Result<OperationOutput<QueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<QueryInput>
    public typealias MOutput = OperationOutput<QueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<QueryOutputError>
}

public struct QueryInputQueryItemMiddleware: Middleware {
    public let id: String = "QueryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<QueryInput>,
                  next: H) -> Swift.Result<OperationOutput<QueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<QueryInput>
    public typealias MOutput = OperationOutput<QueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<QueryOutputError>
}

public struct QueryInput: Equatable {
    /// <p>
    ///        Unique, case-sensitive string of up to 64 ASCII characters that you specify when you make a Query request.
    ///        Providing a <code>ClientToken</code> makes the call to <code>Query</code> idempotent, meaning that multiple identical calls
    ///        have the same effect as one single call.
    ///     </p>
    ///
    ///          <p>Your query request will fail in the following cases:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   If you submit a request with the same client token outside the 5-minute idepotency window.
    ///                </p>
    ///            </li>
    ///             <li>
    ///                <p>
    ///                   If you submit a request with the same client token but a change in other parameters within the 5-minute idempotency window.
    ///                </p>
    ///            </li>
    ///          </ul>
    ///
    ///          <p>
    ///       After 4 hours, any request with the same client token is treated as a new request.
    ///       </p>
    public var clientToken: String?
    /// <p>
    ///       The total number of rows to return in the output. If the total number of rows available
    ///       is more than the value specified, a NextToken is provided in the command's output.
    ///       To resume pagination, provide the NextToken value in the starting-token argument of a
    ///       subsequent command.
    ///     </p>
    public let maxRows: Int?
    /// <p>
    ///        A pagination token passed to get a set of results.
    ///     </p>
    public let nextToken: String?
    /// <p>
    ///             The query to be executed by Timestream.
    ///         </p>
    public let queryString: String?

    public init (
        clientToken: String? = nil,
        maxRows: Int? = nil,
        nextToken: String? = nil,
        queryString: String? = nil
    )
    {
        self.clientToken = clientToken
        self.maxRows = maxRows
        self.nextToken = nextToken
        self.queryString = queryString
    }
}

struct QueryInputBody: Equatable {
    public let queryString: String?
    public let clientToken: String?
    public let nextToken: String?
    public let maxRows: Int?
}

extension QueryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case maxRows = "MaxRows"
        case nextToken = "NextToken"
        case queryString = "QueryString"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxRowsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxRows)
        maxRows = maxRowsDecoded
    }
}

extension QueryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension QueryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "QueryExecutionException" : self = .queryExecutionException(try QueryExecutionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum QueryOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case queryExecutionException(QueryExecutionException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension QueryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueryOutputResponse(columnInfo: \(String(describing: columnInfo)), nextToken: \(String(describing: nextToken)), queryId: \(String(describing: queryId)), queryStatus: \(String(describing: queryStatus)), rows: \(String(describing: rows)))"}
}

extension QueryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: QueryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.columnInfo = output.columnInfo
            self.nextToken = output.nextToken
            self.queryId = output.queryId
            self.queryStatus = output.queryStatus
            self.rows = output.rows
        } else {
            self.columnInfo = nil
            self.nextToken = nil
            self.queryId = nil
            self.queryStatus = nil
            self.rows = nil
        }
    }
}

public struct QueryOutputResponse: Equatable {
    /// <p>
    ///             The column data types of the returned result set.
    ///         </p>
    public let columnInfo: [ColumnInfo]?
    /// <p>
    ///        A pagination token that can be used again on a <code>Query</code> call to get the next set of results.
    ///     </p>
    public let nextToken: String?
    /// <p>
    ///        A unique ID for the given query.
    ///     </p>
    public let queryId: String?
    /// <p>Information about the status of the query, including progress and bytes scannned.</p>
    public let queryStatus: QueryStatus?
    /// <p>
    ///             The result set rows returned by the query.
    ///         </p>
    public let rows: [Row]?

    public init (
        columnInfo: [ColumnInfo]? = nil,
        nextToken: String? = nil,
        queryId: String? = nil,
        queryStatus: QueryStatus? = nil,
        rows: [Row]? = nil
    )
    {
        self.columnInfo = columnInfo
        self.nextToken = nextToken
        self.queryId = queryId
        self.queryStatus = queryStatus
        self.rows = rows
    }
}

struct QueryOutputResponseBody: Equatable {
    public let queryId: String?
    public let nextToken: String?
    public let rows: [Row]?
    public let columnInfo: [ColumnInfo]?
    public let queryStatus: QueryStatus?
}

extension QueryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case columnInfo = "ColumnInfo"
        case nextToken = "NextToken"
        case queryId = "QueryId"
        case queryStatus = "QueryStatus"
        case rows = "Rows"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryId)
        queryId = queryIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let rowsContainer = try containerValues.decodeIfPresent([Row?].self, forKey: .rows)
        var rowsDecoded0:[Row]? = nil
        if let rowsContainer = rowsContainer {
            rowsDecoded0 = [Row]()
            for structure0 in rowsContainer {
                if let structure0 = structure0 {
                    rowsDecoded0?.append(structure0)
                }
            }
        }
        rows = rowsDecoded0
        let columnInfoContainer = try containerValues.decodeIfPresent([ColumnInfo?].self, forKey: .columnInfo)
        var columnInfoDecoded0:[ColumnInfo]? = nil
        if let columnInfoContainer = columnInfoContainer {
            columnInfoDecoded0 = [ColumnInfo]()
            for structure0 in columnInfoContainer {
                if let structure0 = structure0 {
                    columnInfoDecoded0?.append(structure0)
                }
            }
        }
        columnInfo = columnInfoDecoded0
        let queryStatusDecoded = try containerValues.decodeIfPresent(QueryStatus.self, forKey: .queryStatus)
        queryStatus = queryStatusDecoded
    }
}

extension QueryStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cumulativeBytesMetered = "CumulativeBytesMetered"
        case cumulativeBytesScanned = "CumulativeBytesScanned"
        case progressPercentage = "ProgressPercentage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cumulativeBytesMetered != 0 {
            try encodeContainer.encode(cumulativeBytesMetered, forKey: .cumulativeBytesMetered)
        }
        if cumulativeBytesScanned != 0 {
            try encodeContainer.encode(cumulativeBytesScanned, forKey: .cumulativeBytesScanned)
        }
        if progressPercentage != 0.0 {
            try encodeContainer.encode(progressPercentage, forKey: .progressPercentage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressPercentageDecoded = try containerValues.decode(Double.self, forKey: .progressPercentage)
        progressPercentage = progressPercentageDecoded
        let cumulativeBytesScannedDecoded = try containerValues.decode(Int.self, forKey: .cumulativeBytesScanned)
        cumulativeBytesScanned = cumulativeBytesScannedDecoded
        let cumulativeBytesMeteredDecoded = try containerValues.decode(Int.self, forKey: .cumulativeBytesMetered)
        cumulativeBytesMetered = cumulativeBytesMeteredDecoded
    }
}

extension QueryStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueryStatus(cumulativeBytesMetered: \(String(describing: cumulativeBytesMetered)), cumulativeBytesScanned: \(String(describing: cumulativeBytesScanned)), progressPercentage: \(String(describing: progressPercentage)))"}
}

/// <p>Information about the status of the query, including progress and bytes scannned.</p>
public struct QueryStatus: Equatable {
    /// <p>The amount of data scanned by the query in bytes that you will be charged for.
    ///             This is a cumulative sum and represents the total amount of data that you will be charged
    ///             for since the query was started.
    ///             The charge is applied only once and is either applied when
    ///             the query completes execution or when the query is cancelled.
    ///         </p>
    public let cumulativeBytesMetered: Int
    /// <p>The amount of data scanned by the query in bytes.
    ///             This is a cumulative sum and represents the total amount of bytes scanned since the query was started.
    ///         </p>
    public let cumulativeBytesScanned: Int
    /// <p>The progress of the query, expressed as a percentage.</p>
    public let progressPercentage: Double

    public init (
        cumulativeBytesMetered: Int = 0,
        cumulativeBytesScanned: Int = 0,
        progressPercentage: Double = 0.0
    )
    {
        self.cumulativeBytesMetered = cumulativeBytesMetered
        self.cumulativeBytesScanned = cumulativeBytesScanned
        self.progressPercentage = progressPercentage
    }
}

extension Row: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case data = "Data"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            var dataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .data)
            for datumlist0 in data {
                try dataContainer.encode(datumlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataContainer = try containerValues.decodeIfPresent([Datum?].self, forKey: .data)
        var dataDecoded0:[Datum]? = nil
        if let dataContainer = dataContainer {
            dataDecoded0 = [Datum]()
            for structure0 in dataContainer {
                if let structure0 = structure0 {
                    dataDecoded0?.append(structure0)
                }
            }
        }
        data = dataDecoded0
    }
}

extension Row: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Row(data: \(String(describing: data)))"}
}

/// <p>Represents a single row in the query results.</p>
public struct Row: Equatable {
    /// <p>List of data points in a single row of the result set.</p>
    public let data: [Datum]?

    public init (
        data: [Datum]? = nil
    )
    {
        self.data = data
    }
}

public enum ScalarType {
    case bigint
    case boolean
    case date
    case double
    case integer
    case intervalDayToSecond
    case intervalYearToMonth
    case time
    case timestamp
    case unknown
    case varchar
    case sdkUnknown(String)
}

extension ScalarType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ScalarType] {
        return [
            .bigint,
            .boolean,
            .date,
            .double,
            .integer,
            .intervalDayToSecond,
            .intervalYearToMonth,
            .time,
            .timestamp,
            .unknown,
            .varchar,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bigint: return "BIGINT"
        case .boolean: return "BOOLEAN"
        case .date: return "DATE"
        case .double: return "DOUBLE"
        case .integer: return "INTEGER"
        case .intervalDayToSecond: return "INTERVAL_DAY_TO_SECOND"
        case .intervalYearToMonth: return "INTERVAL_YEAR_TO_MONTH"
        case .time: return "TIME"
        case .timestamp: return "TIMESTAMP"
        case .unknown: return "UNKNOWN"
        case .varchar: return "VARCHAR"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ScalarType(rawValue: rawValue) ?? ScalarType.sdkUnknown(rawValue)
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was denied due to request throttling.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TimeSeriesDataPoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case time = "Time"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let time = time {
            try encodeContainer.encode(time, forKey: .time)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .time)
        time = timeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Datum.self, forKey: .value)
        value = valueDecoded
    }
}

extension TimeSeriesDataPoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TimeSeriesDataPoint(time: \(String(describing: time)), value: \(String(describing: value)))"}
}

/// <p>The timeseries datatype represents the values of a measure over time. A time series is an array of rows of timestamps and measure values, with rows sorted in ascending order of time. A TimeSeriesDataPoint is a single data point in the timeseries. It represents a tuple of (time, measure value) in a timeseries. </p>
public struct TimeSeriesDataPoint: Equatable {
    /// <p>The timestamp when the measure value was collected.</p>
    public let time: String?
    /// <p>The measure value for the  data point.</p>
    public let value: Datum?

    public init (
        time: String? = nil,
        value: Datum? = nil
    )
    {
        self.time = time
        self.value = value
    }
}

extension `Type`: CustomDebugStringConvertible {
    public var debugDescription: String {
        "`Type`(arrayColumnInfo: \(String(describing: arrayColumnInfo)), rowColumnInfo: \(String(describing: rowColumnInfo)), scalarType: \(String(describing: scalarType)), timeSeriesMeasureValueColumnInfo: \(String(describing: timeSeriesMeasureValueColumnInfo)))"}
}

/// <p>Contains the data type of a column in a query result set. The data type can be scalar or complex. The supported scalar data types are integers, boolean, string, double, timestamp, date, time, and intervals. The supported complex data types are arrays, rows, and timeseries.</p>
public struct `Type`: Equatable {
    /// <p>Indicates if the column is an array.</p>
    public let arrayColumnInfo: ColumnInfo?
    /// <p>Indicates if the column is a row.</p>
    public let rowColumnInfo: [ColumnInfo]?
    /// <p>Indicates if the column is of type string, integer, boolean, double, timestamp, date, time. </p>
    public let scalarType: ScalarType?
    /// <p>Indicates if the column is a timeseries data type.</p>
    public let timeSeriesMeasureValueColumnInfo: ColumnInfo?

    public init (
        arrayColumnInfo: ColumnInfo? = nil,
        rowColumnInfo: [ColumnInfo]? = nil,
        scalarType: ScalarType? = nil,
        timeSeriesMeasureValueColumnInfo: ColumnInfo? = nil
    )
    {
        self.arrayColumnInfo = arrayColumnInfo
        self.rowColumnInfo = rowColumnInfo
        self.scalarType = scalarType
        self.timeSeriesMeasureValueColumnInfo = timeSeriesMeasureValueColumnInfo
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             Invalid or malformed request.
///         </p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension `Type`: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arrayColumnInfo = "ArrayColumnInfo"
        case rowColumnInfo = "RowColumnInfo"
        case scalarType = "ScalarType"
        case timeSeriesMeasureValueColumnInfo = "TimeSeriesMeasureValueColumnInfo"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arrayColumnInfo = arrayColumnInfo {
            try encodeContainer.encode(arrayColumnInfo, forKey: .arrayColumnInfo)
        }
        if let rowColumnInfo = rowColumnInfo {
            var rowColumnInfoContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rowColumnInfo)
            for columninfolist0 in rowColumnInfo {
                try rowColumnInfoContainer.encode(columninfolist0)
            }
        }
        if let scalarType = scalarType {
            try encodeContainer.encode(scalarType.rawValue, forKey: .scalarType)
        }
        if let timeSeriesMeasureValueColumnInfo = timeSeriesMeasureValueColumnInfo {
            try encodeContainer.encode(timeSeriesMeasureValueColumnInfo, forKey: .timeSeriesMeasureValueColumnInfo)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scalarTypeDecoded = try containerValues.decodeIfPresent(ScalarType.self, forKey: .scalarType)
        scalarType = scalarTypeDecoded
        let arrayColumnInfoDecoded = try containerValues.decodeIfPresent(ColumnInfo.self, forKey: .arrayColumnInfo)
        arrayColumnInfo = arrayColumnInfoDecoded
        let timeSeriesMeasureValueColumnInfoDecoded = try containerValues.decodeIfPresent(ColumnInfo.self, forKey: .timeSeriesMeasureValueColumnInfo)
        timeSeriesMeasureValueColumnInfo = timeSeriesMeasureValueColumnInfoDecoded
        let rowColumnInfoContainer = try containerValues.decodeIfPresent([ColumnInfo?].self, forKey: .rowColumnInfo)
        var rowColumnInfoDecoded0:[ColumnInfo]? = nil
        if let rowColumnInfoContainer = rowColumnInfoContainer {
            rowColumnInfoDecoded0 = [ColumnInfo]()
            for structure0 in rowColumnInfoContainer {
                if let structure0 = structure0 {
                    rowColumnInfoDecoded0?.append(structure0)
                }
            }
        }
        rowColumnInfo = rowColumnInfoDecoded0
    }
}
