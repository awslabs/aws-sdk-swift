// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You don't have access to this item. The provided credentials couldn't be
/// 			validated. You might not be authorized to carry out the request. Make sure that your
/// 			account is authorized to use the Amazon QuickSight service, that your policies have the
/// 			correct permissions, and that you are using the correct access keys.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The AWS request ID for this request.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension AccountCustomization: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultTheme = "DefaultTheme"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultTheme = defaultTheme {
            try encodeContainer.encode(defaultTheme, forKey: .defaultTheme)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultThemeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultTheme)
        defaultTheme = defaultThemeDecoded
    }
}

extension AccountCustomization: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountCustomization(defaultTheme: \(String(describing: defaultTheme)))"}
}

/// <p>The Amazon QuickSight customizations associated with your AWS account or a QuickSight namespace in a specific AWS Region.</p>
public struct AccountCustomization: Equatable {
    /// <p>The default theme for this QuickSight subscription.</p>
    public let defaultTheme: String?

    public init (
        defaultTheme: String? = nil
    )
    {
        self.defaultTheme = defaultTheme
    }
}

extension AccountSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountName = "AccountName"
        case defaultNamespace = "DefaultNamespace"
        case edition = "Edition"
        case notificationEmail = "NotificationEmail"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountName = accountName {
            try encodeContainer.encode(accountName, forKey: .accountName)
        }
        if let defaultNamespace = defaultNamespace {
            try encodeContainer.encode(defaultNamespace, forKey: .defaultNamespace)
        }
        if let edition = edition {
            try encodeContainer.encode(edition.rawValue, forKey: .edition)
        }
        if let notificationEmail = notificationEmail {
            try encodeContainer.encode(notificationEmail, forKey: .notificationEmail)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountName)
        accountName = accountNameDecoded
        let editionDecoded = try containerValues.decodeIfPresent(Edition.self, forKey: .edition)
        edition = editionDecoded
        let defaultNamespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultNamespace)
        defaultNamespace = defaultNamespaceDecoded
        let notificationEmailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .notificationEmail)
        notificationEmail = notificationEmailDecoded
    }
}

extension AccountSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountSettings(accountName: \(String(describing: accountName)), defaultNamespace: \(String(describing: defaultNamespace)), edition: \(String(describing: edition)), notificationEmail: \(String(describing: notificationEmail)))"}
}

/// <p>The QuickSight settings associated with your AWS account.</p>
public struct AccountSettings: Equatable {
    /// <p>The "account name" you provided for the QuickSight subscription in your AWS account.
    ///             You create this name when you sign up for QuickSight. It is unique in all of AWS and
    ///             it appears only in the console when users sign in.</p>
    public let accountName: String?
    /// <p>The default QuickSight namespace for your AWS account. </p>
    public let defaultNamespace: String?
    /// <p>The edition of QuickSight that you're currently subscribed to:
    ///         Enterprise edition or Standard edition.</p>
    public let edition: Edition?
    /// <p>The main notification email for your QuickSight subscription.</p>
    public let notificationEmail: String?

    public init (
        accountName: String? = nil,
        defaultNamespace: String? = nil,
        edition: Edition? = nil,
        notificationEmail: String? = nil
    )
    {
        self.accountName = accountName
        self.defaultNamespace = defaultNamespace
        self.edition = edition
        self.notificationEmail = notificationEmail
    }
}

extension ActiveIAMPolicyAssignment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assignmentName = "AssignmentName"
        case policyArn = "PolicyArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentName = assignmentName {
            try encodeContainer.encode(assignmentName, forKey: .assignmentName)
        }
        if let policyArn = policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assignmentName)
        assignmentName = assignmentNameDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension ActiveIAMPolicyAssignment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActiveIAMPolicyAssignment(assignmentName: \(String(describing: assignmentName)), policyArn: \(String(describing: policyArn)))"}
}

/// <p>The active AWS Identity and Access Management (IAM) policy assignment.</p>
public struct ActiveIAMPolicyAssignment: Equatable {
    /// <p>A name for the IAM policy assignment.</p>
    public let assignmentName: String?
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let policyArn: String?

    public init (
        assignmentName: String? = nil,
        policyArn: String? = nil
    )
    {
        self.assignmentName = assignmentName
        self.policyArn = policyArn
    }
}

extension AdHocFilteringOption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityStatus = "AvailabilityStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityStatus = availabilityStatus {
            try encodeContainer.encode(availabilityStatus.rawValue, forKey: .availabilityStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityStatusDecoded = try containerValues.decodeIfPresent(DashboardBehavior.self, forKey: .availabilityStatus)
        availabilityStatus = availabilityStatusDecoded
    }
}

extension AdHocFilteringOption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdHocFilteringOption(availabilityStatus: \(String(describing: availabilityStatus)))"}
}

/// <p>Ad hoc (one-time) filtering option.</p>
public struct AdHocFilteringOption: Equatable {
    /// <p>Availability status.</p>
    public let availabilityStatus: DashboardBehavior?

    public init (
        availabilityStatus: DashboardBehavior? = nil
    )
    {
        self.availabilityStatus = availabilityStatus
    }
}

extension AmazonElasticsearchParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domain = "Domain"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension AmazonElasticsearchParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AmazonElasticsearchParameters(domain: \(String(describing: domain)))"}
}

/// <p>Amazon Elasticsearch Service parameters.</p>
public struct AmazonElasticsearchParameters: Equatable {
    /// <p>The Amazon Elasticsearch Service domain.</p>
    public let domain: String?

    public init (
        domain: String? = nil
    )
    {
        self.domain = domain
    }
}

extension Analysis: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case analysisId = "AnalysisId"
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case dataSetArns = "DataSetArns"
        case errors = "Errors"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case sheets = "Sheets"
        case status = "Status"
        case themeArn = "ThemeArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analysisId = analysisId {
            try encodeContainer.encode(analysisId, forKey: .analysisId)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let dataSetArns = dataSetArns {
            var dataSetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSetArns)
            for datasetarnslist0 in dataSetArns {
                try dataSetArnsContainer.encode(datasetarnslist0)
            }
        }
        if let errors = errors {
            var errorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errors)
            for analysiserrorlist0 in errors {
                try errorsContainer.encode(analysiserrorlist0)
            }
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sheets = sheets {
            var sheetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sheets)
            for sheetlist0 in sheets {
                try sheetsContainer.encode(sheetlist0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let themeArn = themeArn {
            try encodeContainer.encode(themeArn, forKey: .themeArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .analysisId)
        analysisId = analysisIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResourceStatus.self, forKey: .status)
        status = statusDecoded
        let errorsContainer = try containerValues.decodeIfPresent([AnalysisError?].self, forKey: .errors)
        var errorsDecoded0:[AnalysisError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [AnalysisError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let dataSetArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .dataSetArns)
        var dataSetArnsDecoded0:[String]? = nil
        if let dataSetArnsContainer = dataSetArnsContainer {
            dataSetArnsDecoded0 = [String]()
            for string0 in dataSetArnsContainer {
                if let string0 = string0 {
                    dataSetArnsDecoded0?.append(string0)
                }
            }
        }
        dataSetArns = dataSetArnsDecoded0
        let themeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .themeArn)
        themeArn = themeArnDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let sheetsContainer = try containerValues.decodeIfPresent([Sheet?].self, forKey: .sheets)
        var sheetsDecoded0:[Sheet]? = nil
        if let sheetsContainer = sheetsContainer {
            sheetsDecoded0 = [Sheet]()
            for structure0 in sheetsContainer {
                if let structure0 = structure0 {
                    sheetsDecoded0?.append(structure0)
                }
            }
        }
        sheets = sheetsDecoded0
    }
}

extension Analysis: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Analysis(analysisId: \(String(describing: analysisId)), arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), dataSetArns: \(String(describing: dataSetArns)), errors: \(String(describing: errors)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), name: \(String(describing: name)), sheets: \(String(describing: sheets)), status: \(String(describing: status)), themeArn: \(String(describing: themeArn)))"}
}

/// <p>Metadata structure for an analysis in Amazon QuickSight</p>
public struct Analysis: Equatable {
    /// <p>The ID of the analysis.</p>
    public let analysisId: String?
    /// <p>The Amazon Resource Name (ARN) of the analysis.</p>
    public let arn: String?
    /// <p>The time that the analysis was created.</p>
    public let createdTime: Date?
    /// <p>The ARNs of the datasets of the analysis.</p>
    public let dataSetArns: [String]?
    /// <p>Errors associated with the analysis.</p>
    public let errors: [AnalysisError]?
    /// <p>The time that the analysis was last updated.</p>
    public let lastUpdatedTime: Date?
    /// <p>The descriptive name of the analysis.</p>
    public let name: String?
    /// <p>A list of the associated sheets with the unique identifier and name of each sheet.</p>
    public let sheets: [Sheet]?
    /// <p>Status associated with the analysis.</p>
    public let status: ResourceStatus?
    /// <p>The ARN of the theme of the analysis.</p>
    public let themeArn: String?

    public init (
        analysisId: String? = nil,
        arn: String? = nil,
        createdTime: Date? = nil,
        dataSetArns: [String]? = nil,
        errors: [AnalysisError]? = nil,
        lastUpdatedTime: Date? = nil,
        name: String? = nil,
        sheets: [Sheet]? = nil,
        status: ResourceStatus? = nil,
        themeArn: String? = nil
    )
    {
        self.analysisId = analysisId
        self.arn = arn
        self.createdTime = createdTime
        self.dataSetArns = dataSetArns
        self.errors = errors
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.sheets = sheets
        self.status = status
        self.themeArn = themeArn
    }
}

extension AnalysisError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(AnalysisErrorType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AnalysisError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnalysisError(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

/// <p>A metadata error structure for an analysis.</p>
public struct AnalysisError: Equatable {
    /// <p>The message associated with the analysis error.</p>
    public let message: String?
    /// <p>The type of the analysis error.</p>
    public let type: AnalysisErrorType?

    public init (
        message: String? = nil,
        type: AnalysisErrorType? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

public enum AnalysisErrorType {
    case accessDenied
    case columnGeographicRoleMismatch
    case columnReplacementMissing
    case columnTypeMismatch
    case dataSetNotFound
    case internalFailure
    case parameterNotFound
    case parameterTypeInvalid
    case parameterValueIncompatible
    case sourceNotFound
    case sdkUnknown(String)
}

extension AnalysisErrorType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AnalysisErrorType] {
        return [
            .accessDenied,
            .columnGeographicRoleMismatch,
            .columnReplacementMissing,
            .columnTypeMismatch,
            .dataSetNotFound,
            .internalFailure,
            .parameterNotFound,
            .parameterTypeInvalid,
            .parameterValueIncompatible,
            .sourceNotFound,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accessDenied: return "ACCESS_DENIED"
        case .columnGeographicRoleMismatch: return "COLUMN_GEOGRAPHIC_ROLE_MISMATCH"
        case .columnReplacementMissing: return "COLUMN_REPLACEMENT_MISSING"
        case .columnTypeMismatch: return "COLUMN_TYPE_MISMATCH"
        case .dataSetNotFound: return "DATA_SET_NOT_FOUND"
        case .internalFailure: return "INTERNAL_FAILURE"
        case .parameterNotFound: return "PARAMETER_NOT_FOUND"
        case .parameterTypeInvalid: return "PARAMETER_TYPE_INVALID"
        case .parameterValueIncompatible: return "PARAMETER_VALUE_INCOMPATIBLE"
        case .sourceNotFound: return "SOURCE_NOT_FOUND"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AnalysisErrorType(rawValue: rawValue) ?? AnalysisErrorType.sdkUnknown(rawValue)
    }
}

public enum AnalysisFilterAttribute {
    case quicksightUser
    case sdkUnknown(String)
}

extension AnalysisFilterAttribute : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AnalysisFilterAttribute] {
        return [
            .quicksightUser,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .quicksightUser: return "QUICKSIGHT_USER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AnalysisFilterAttribute(rawValue: rawValue) ?? AnalysisFilterAttribute.sdkUnknown(rawValue)
    }
}

extension AnalysisSearchFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case `operator` = "Operator"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operatorDecoded = try containerValues.decodeIfPresent(FilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let nameDecoded = try containerValues.decodeIfPresent(AnalysisFilterAttribute.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AnalysisSearchFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnalysisSearchFilter(name: \(String(describing: name)), operator: \(String(describing: `operator`)), value: \(String(describing: value)))"}
}

/// <p>A filter that you apply when searching for one or more analyses.</p>
public struct AnalysisSearchFilter: Equatable {
    /// <p>The comparison operator that you want to use as a filter, for example
    ///                 <code>"Operator": "StringEquals"</code>.</p>
    public let `operator`: FilterOperator?
    /// <p>The name of the value that you want to use as a filter, for example <code>"Name":
    ///                 "QUICKSIGHT_USER"</code>.</p>
    public let name: AnalysisFilterAttribute?
    /// <p>The value of the named item, in this case <code>QUICKSIGHT_USER</code>, that you want
    ///             to use as a filter, for example <code>"Value"</code>. An example is
    ///                 <code>"arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.</p>
    public let value: String?

    public init (
        `operator`: FilterOperator? = nil,
        name: AnalysisFilterAttribute? = nil,
        value: String? = nil
    )
    {
        self.`operator` = `operator`
        self.name = name
        self.value = value
    }
}

extension AnalysisSourceEntity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sourceTemplate = "SourceTemplate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceTemplate = sourceTemplate {
            try encodeContainer.encode(sourceTemplate, forKey: .sourceTemplate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTemplateDecoded = try containerValues.decodeIfPresent(AnalysisSourceTemplate.self, forKey: .sourceTemplate)
        sourceTemplate = sourceTemplateDecoded
    }
}

extension AnalysisSourceEntity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnalysisSourceEntity(sourceTemplate: \(String(describing: sourceTemplate)))"}
}

/// <p>The source entity of an analysis.</p>
public struct AnalysisSourceEntity: Equatable {
    /// <p>The source template for the source entity of the analysis.</p>
    public let sourceTemplate: AnalysisSourceTemplate?

    public init (
        sourceTemplate: AnalysisSourceTemplate? = nil
    )
    {
        self.sourceTemplate = sourceTemplate
    }
}

extension AnalysisSourceTemplate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case dataSetReferences = "DataSetReferences"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dataSetReferences = dataSetReferences {
            var dataSetReferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSetReferences)
            for datasetreferencelist0 in dataSetReferences {
                try dataSetReferencesContainer.encode(datasetreferencelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetReferencesContainer = try containerValues.decodeIfPresent([DataSetReference?].self, forKey: .dataSetReferences)
        var dataSetReferencesDecoded0:[DataSetReference]? = nil
        if let dataSetReferencesContainer = dataSetReferencesContainer {
            dataSetReferencesDecoded0 = [DataSetReference]()
            for structure0 in dataSetReferencesContainer {
                if let structure0 = structure0 {
                    dataSetReferencesDecoded0?.append(structure0)
                }
            }
        }
        dataSetReferences = dataSetReferencesDecoded0
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension AnalysisSourceTemplate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnalysisSourceTemplate(arn: \(String(describing: arn)), dataSetReferences: \(String(describing: dataSetReferences)))"}
}

/// <p>The source template of an analysis.</p>
public struct AnalysisSourceTemplate: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the source template of an analysis.</p>
    public let arn: String?
    /// <p>The dataset references of the source template of an analysis.</p>
    public let dataSetReferences: [DataSetReference]?

    public init (
        arn: String? = nil,
        dataSetReferences: [DataSetReference]? = nil
    )
    {
        self.arn = arn
        self.dataSetReferences = dataSetReferences
    }
}

extension AnalysisSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case analysisId = "AnalysisId"
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analysisId = analysisId {
            try encodeContainer.encode(analysisId, forKey: .analysisId)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let analysisIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .analysisId)
        analysisId = analysisIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResourceStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension AnalysisSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnalysisSummary(analysisId: \(String(describing: analysisId)), arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), name: \(String(describing: name)), status: \(String(describing: status)))"}
}

/// <p>The summary metadata that describes an analysis.</p>
public struct AnalysisSummary: Equatable {
    /// <p>The ID of the analysis. This ID displays in the URL.</p>
    public let analysisId: String?
    /// <p>The Amazon Resource Name (ARN) for the analysis.</p>
    public let arn: String?
    /// <p>The time that the analysis was created.</p>
    public let createdTime: Date?
    /// <p>The time that the analysis was last updated.</p>
    public let lastUpdatedTime: Date?
    /// <p>The name of the analysis. This name is displayed in the QuickSight console.
    ///             </p>
    public let name: String?
    /// <p>The last known status for the analysis.</p>
    public let status: ResourceStatus?

    public init (
        analysisId: String? = nil,
        arn: String? = nil,
        createdTime: Date? = nil,
        lastUpdatedTime: Date? = nil,
        name: String? = nil,
        status: ResourceStatus? = nil
    )
    {
        self.analysisId = analysisId
        self.arn = arn
        self.createdTime = createdTime
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.status = status
    }
}

public enum AssignmentStatus {
    case disabled
    case draft
    case enabled
    case sdkUnknown(String)
}

extension AssignmentStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AssignmentStatus] {
        return [
            .disabled,
            .draft,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .draft: return "DRAFT"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AssignmentStatus(rawValue: rawValue) ?? AssignmentStatus.sdkUnknown(rawValue)
    }
}

extension AthenaParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workGroup = workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension AthenaParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AthenaParameters(workGroup: \(String(describing: workGroup)))"}
}

/// <p>Amazon Athena parameters.</p>
public struct AthenaParameters: Equatable {
    /// <p>The workgroup that Amazon Athena uses.</p>
    public let workGroup: String?

    public init (
        workGroup: String? = nil
    )
    {
        self.workGroup = workGroup
    }
}

extension AuroraParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case database = "Database"
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let host = host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .database)
        database = databaseDecoded
    }
}

extension AuroraParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuroraParameters(database: \(String(describing: database)), host: \(String(describing: host)), port: \(String(describing: port)))"}
}

/// <p>Amazon Aurora parameters.</p>
public struct AuroraParameters: Equatable {
    /// <p>Database.</p>
    public let database: String?
    /// <p>Host.</p>
    public let host: String?
    /// <p>Port.</p>
    public let port: Int

    public init (
        database: String? = nil,
        host: String? = nil,
        port: Int = 0
    )
    {
        self.database = database
        self.host = host
        self.port = port
    }
}

extension AuroraPostgreSqlParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case database = "Database"
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let host = host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .database)
        database = databaseDecoded
    }
}

extension AuroraPostgreSqlParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuroraPostgreSqlParameters(database: \(String(describing: database)), host: \(String(describing: host)), port: \(String(describing: port)))"}
}

/// <p>Amazon Aurora with PostgreSQL compatibility parameters.</p>
public struct AuroraPostgreSqlParameters: Equatable {
    /// <p>Database.</p>
    public let database: String?
    /// <p>Host.</p>
    public let host: String?
    /// <p>Port.</p>
    public let port: Int

    public init (
        database: String? = nil,
        host: String? = nil,
        port: Int = 0
    )
    {
        self.database = database
        self.host = host
        self.port = port
    }
}

extension AwsIotAnalyticsParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataSetName = "DataSetName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSetName = dataSetName {
            try encodeContainer.encode(dataSetName, forKey: .dataSetName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetName)
        dataSetName = dataSetNameDecoded
    }
}

extension AwsIotAnalyticsParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsIotAnalyticsParameters(dataSetName: \(String(describing: dataSetName)))"}
}

/// <p>AWS IoT Analytics parameters.</p>
public struct AwsIotAnalyticsParameters: Equatable {
    /// <p>Dataset name.</p>
    public let dataSetName: String?

    public init (
        dataSetName: String? = nil
    )
    {
        self.dataSetName = dataSetName
    }
}

extension BorderStyle: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case show = "Show"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if show != false {
            try encodeContainer.encode(show, forKey: .show)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let showDecoded = try containerValues.decode(Bool.self, forKey: .show)
        show = showDecoded
    }
}

extension BorderStyle: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BorderStyle(show: \(String(describing: show)))"}
}

/// <p>The display options for tile borders for visuals.</p>
public struct BorderStyle: Equatable {
    /// <p>The option to enable display of borders for visuals.</p>
    public let show: Bool

    public init (
        show: Bool = false
    )
    {
        self.show = show
    }
}

extension CalculatedColumn: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case columnId = "ColumnId"
        case columnName = "ColumnName"
        case expression = "Expression"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnId = columnId {
            try encodeContainer.encode(columnId, forKey: .columnId)
        }
        if let columnName = columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .columnName)
        columnName = columnNameDecoded
        let columnIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .columnId)
        columnId = columnIdDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expression)
        expression = expressionDecoded
    }
}

extension CalculatedColumn: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CalculatedColumn(columnId: \(String(describing: columnId)), columnName: \(String(describing: columnName)), expression: \(String(describing: expression)))"}
}

/// <p>A calculated column for a dataset.</p>
public struct CalculatedColumn: Equatable {
    /// <p>A unique ID to identify a calculated column. During a dataset update, if the column ID
    ///             of a calculated column matches that of an existing calculated column, Amazon QuickSight
    ///             preserves the existing calculated column.</p>
    public let columnId: String?
    /// <p>Column name.</p>
    public let columnName: String?
    /// <p>An expression that defines the calculated column.</p>
    public let expression: String?

    public init (
        columnId: String? = nil,
        columnName: String? = nil,
        expression: String? = nil
    )
    {
        self.columnId = columnId
        self.columnName = columnName
        self.expression = expression
    }
}

extension CancelIngestionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelIngestionInput(awsAccountId: \(String(describing: awsAccountId)), dataSetId: \(String(describing: dataSetId)), ingestionId: \(String(describing: ingestionId)))"}
}

extension CancelIngestionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CancelIngestionInputHeadersMiddleware: Middleware {
    public let id: String = "CancelIngestionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelIngestionInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelIngestionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelIngestionInput>
    public typealias MOutput = OperationOutput<CancelIngestionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelIngestionOutputError>
}

public struct CancelIngestionInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelIngestionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelIngestionInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelIngestionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelIngestionInput>
    public typealias MOutput = OperationOutput<CancelIngestionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelIngestionOutputError>
}

public struct CancelIngestionInput: Equatable {
    /// <p>The AWS account ID.</p>
    public let awsAccountId: String?
    /// <p>The ID of the dataset used in the ingestion.</p>
    public let dataSetId: String?
    /// <p>An ID for the ingestion.</p>
    public let ingestionId: String?

    public init (
        awsAccountId: String? = nil,
        dataSetId: String? = nil,
        ingestionId: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
        self.ingestionId = ingestionId
    }
}

struct CancelIngestionInputBody: Equatable {
}

extension CancelIngestionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CancelIngestionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelIngestionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelIngestionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelIngestionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelIngestionOutputResponse(arn: \(String(describing: arn)), ingestionId: \(String(describing: ingestionId)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension CancelIngestionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CancelIngestionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.ingestionId = output.ingestionId
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.ingestionId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CancelIngestionOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the data ingestion.</p>
    public let arn: String?
    /// <p>An ID for the ingestion.</p>
    public let ingestionId: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        arn: String? = nil,
        ingestionId: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.arn = arn
        self.ingestionId = ingestionId
        self.requestId = requestId
        self.status = status
    }
}

struct CancelIngestionOutputResponseBody: Equatable {
    public let arn: String?
    public let ingestionId: String?
    public let requestId: String?
    public let status: Int
}

extension CancelIngestionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case ingestionId = "IngestionId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let ingestionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ingestionId)
        ingestionId = ingestionIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension CastColumnTypeOperation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case columnName = "ColumnName"
        case format = "Format"
        case newColumnType = "NewColumnType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnName = columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
        if let format = format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let newColumnType = newColumnType {
            try encodeContainer.encode(newColumnType.rawValue, forKey: .newColumnType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .columnName)
        columnName = columnNameDecoded
        let newColumnTypeDecoded = try containerValues.decodeIfPresent(ColumnDataType.self, forKey: .newColumnType)
        newColumnType = newColumnTypeDecoded
        let formatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .format)
        format = formatDecoded
    }
}

extension CastColumnTypeOperation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CastColumnTypeOperation(columnName: \(String(describing: columnName)), format: \(String(describing: format)), newColumnType: \(String(describing: newColumnType)))"}
}

/// <p>A transform operation that casts a column to a different type.</p>
public struct CastColumnTypeOperation: Equatable {
    /// <p>Column name.</p>
    public let columnName: String?
    /// <p>When casting a column from string to datetime type, you can supply a string in a
    ///             format supported by Amazon QuickSight to denote the source data format.</p>
    public let format: String?
    /// <p>New column data type.</p>
    public let newColumnType: ColumnDataType?

    public init (
        columnName: String? = nil,
        format: String? = nil,
        newColumnType: ColumnDataType? = nil
    )
    {
        self.columnName = columnName
        self.format = format
        self.newColumnType = newColumnType
    }
}

public enum ColumnDataType {
    case datetime
    case decimal
    case integer
    case string
    case sdkUnknown(String)
}

extension ColumnDataType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ColumnDataType] {
        return [
            .datetime,
            .decimal,
            .integer,
            .string,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .datetime: return "DATETIME"
        case .decimal: return "DECIMAL"
        case .integer: return "INTEGER"
        case .string: return "STRING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ColumnDataType(rawValue: rawValue) ?? ColumnDataType.sdkUnknown(rawValue)
    }
}

extension ColumnDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case text = "Text"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
    }
}

extension ColumnDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ColumnDescription(text: \(String(describing: text)))"}
}

/// <p>Metadata that contains a description for a column.</p>
public struct ColumnDescription: Equatable {
    /// <p>The text of a description for a column.</p>
    public let text: String?

    public init (
        text: String? = nil
    )
    {
        self.text = text
    }
}

extension ColumnGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case geoSpatialColumnGroup = "GeoSpatialColumnGroup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let geoSpatialColumnGroup = geoSpatialColumnGroup {
            try encodeContainer.encode(geoSpatialColumnGroup, forKey: .geoSpatialColumnGroup)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geoSpatialColumnGroupDecoded = try containerValues.decodeIfPresent(GeoSpatialColumnGroup.self, forKey: .geoSpatialColumnGroup)
        geoSpatialColumnGroup = geoSpatialColumnGroupDecoded
    }
}

extension ColumnGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ColumnGroup(geoSpatialColumnGroup: \(String(describing: geoSpatialColumnGroup)))"}
}

/// <p>Groupings of columns that work together in certain Amazon QuickSight features. This is
///             a variant type structure. For this structure to be valid, only one of the attributes can
///             be non-null.</p>
public struct ColumnGroup: Equatable {
    /// <p>Geospatial column group that denotes a hierarchy.</p>
    public let geoSpatialColumnGroup: GeoSpatialColumnGroup?

    public init (
        geoSpatialColumnGroup: GeoSpatialColumnGroup? = nil
    )
    {
        self.geoSpatialColumnGroup = geoSpatialColumnGroup
    }
}

extension ColumnGroupColumnSchema: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ColumnGroupColumnSchema: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ColumnGroupColumnSchema(name: \(String(describing: name)))"}
}

/// <p>A structure describing the name, data type, and geographic role of the columns.</p>
public struct ColumnGroupColumnSchema: Equatable {
    /// <p>The name of the column group's column schema.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

extension ColumnGroupSchema: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case columnGroupColumnSchemaList = "ColumnGroupColumnSchemaList"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnGroupColumnSchemaList = columnGroupColumnSchemaList {
            var columnGroupColumnSchemaListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnGroupColumnSchemaList)
            for columngroupcolumnschemalist0 in columnGroupColumnSchemaList {
                try columnGroupColumnSchemaListContainer.encode(columngroupcolumnschemalist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let columnGroupColumnSchemaListContainer = try containerValues.decodeIfPresent([ColumnGroupColumnSchema?].self, forKey: .columnGroupColumnSchemaList)
        var columnGroupColumnSchemaListDecoded0:[ColumnGroupColumnSchema]? = nil
        if let columnGroupColumnSchemaListContainer = columnGroupColumnSchemaListContainer {
            columnGroupColumnSchemaListDecoded0 = [ColumnGroupColumnSchema]()
            for structure0 in columnGroupColumnSchemaListContainer {
                if let structure0 = structure0 {
                    columnGroupColumnSchemaListDecoded0?.append(structure0)
                }
            }
        }
        columnGroupColumnSchemaList = columnGroupColumnSchemaListDecoded0
    }
}

extension ColumnGroupSchema: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ColumnGroupSchema(columnGroupColumnSchemaList: \(String(describing: columnGroupColumnSchemaList)), name: \(String(describing: name)))"}
}

/// <p>The column group schema.</p>
public struct ColumnGroupSchema: Equatable {
    /// <p>A structure containing the list of schemas for column group columns.</p>
    public let columnGroupColumnSchemaList: [ColumnGroupColumnSchema]?
    /// <p>The name of the column group schema.</p>
    public let name: String?

    public init (
        columnGroupColumnSchemaList: [ColumnGroupColumnSchema]? = nil,
        name: String? = nil
    )
    {
        self.columnGroupColumnSchemaList = columnGroupColumnSchemaList
        self.name = name
    }
}

extension ColumnLevelPermissionRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case columnNames = "ColumnNames"
        case principals = "Principals"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnNames = columnNames {
            var columnNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnNames)
            for columnnamelist0 in columnNames {
                try columnNamesContainer.encode(columnnamelist0)
            }
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for principallist0 in principals {
                try principalsContainer.encode(principallist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .principals)
        var principalsDecoded0:[String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let columnNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .columnNames)
        var columnNamesDecoded0:[String]? = nil
        if let columnNamesContainer = columnNamesContainer {
            columnNamesDecoded0 = [String]()
            for string0 in columnNamesContainer {
                if let string0 = string0 {
                    columnNamesDecoded0?.append(string0)
                }
            }
        }
        columnNames = columnNamesDecoded0
    }
}

extension ColumnLevelPermissionRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ColumnLevelPermissionRule(columnNames: \(String(describing: columnNames)), principals: \(String(describing: principals)))"}
}

/// <p>A rule defined to grant access on one or more restricted columns.
///             Each dataset can have multiple rules.
///             To create a restricted column, you add it to one or more rules.
///             Each rule must contain at least one column and at least one user or group.
///             To be able to see a restricted column, a user or group needs to be added
///             to a rule for that column.</p>
public struct ColumnLevelPermissionRule: Equatable {
    /// <p>An array of column names.</p>
    public let columnNames: [String]?
    /// <p>An array of Amazon Resource Names (ARNs) for QuickSight users or groups.</p>
    public let principals: [String]?

    public init (
        columnNames: [String]? = nil,
        principals: [String]? = nil
    )
    {
        self.columnNames = columnNames
        self.principals = principals
    }
}

extension ColumnSchema: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataType = "DataType"
        case geographicRole = "GeographicRole"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataType = dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let geographicRole = geographicRole {
            try encodeContainer.encode(geographicRole, forKey: .geographicRole)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let geographicRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .geographicRole)
        geographicRole = geographicRoleDecoded
    }
}

extension ColumnSchema: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ColumnSchema(dataType: \(String(describing: dataType)), geographicRole: \(String(describing: geographicRole)), name: \(String(describing: name)))"}
}

/// <p>The column schema.</p>
public struct ColumnSchema: Equatable {
    /// <p>The data type of the column schema.</p>
    public let dataType: String?
    /// <p>The geographic role of the column schema.</p>
    public let geographicRole: String?
    /// <p>The name of the column schema.</p>
    public let name: String?

    public init (
        dataType: String? = nil,
        geographicRole: String? = nil,
        name: String? = nil
    )
    {
        self.dataType = dataType
        self.geographicRole = geographicRole
        self.name = name
    }
}

extension ColumnTag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case columnDescription = "ColumnDescription"
        case columnGeographicRole = "ColumnGeographicRole"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnDescription = columnDescription {
            try encodeContainer.encode(columnDescription, forKey: .columnDescription)
        }
        if let columnGeographicRole = columnGeographicRole {
            try encodeContainer.encode(columnGeographicRole.rawValue, forKey: .columnGeographicRole)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnGeographicRoleDecoded = try containerValues.decodeIfPresent(GeoSpatialDataRole.self, forKey: .columnGeographicRole)
        columnGeographicRole = columnGeographicRoleDecoded
        let columnDescriptionDecoded = try containerValues.decodeIfPresent(ColumnDescription.self, forKey: .columnDescription)
        columnDescription = columnDescriptionDecoded
    }
}

extension ColumnTag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ColumnTag(columnDescription: \(String(describing: columnDescription)), columnGeographicRole: \(String(describing: columnGeographicRole)))"}
}

/// <p>A tag for a column in a <a>TagColumnOperation</a> structure. This is a
///             variant type structure. For this structure to be valid, only one of the attributes can
///             be non-null.</p>
public struct ColumnTag: Equatable {
    /// <p>A description for a column.</p>
    public let columnDescription: ColumnDescription?
    /// <p>A geospatial role for a column.</p>
    public let columnGeographicRole: GeoSpatialDataRole?

    public init (
        columnDescription: ColumnDescription? = nil,
        columnGeographicRole: GeoSpatialDataRole? = nil
    )
    {
        self.columnDescription = columnDescription
        self.columnGeographicRole = columnGeographicRole
    }
}

extension ConcurrentUpdatingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConcurrentUpdatingException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension ConcurrentUpdatingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConcurrentUpdatingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A resource is already in a state that indicates an operation is happening that must complete
/// 			before a new update can be applied.</p>
public struct ConcurrentUpdatingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct ConcurrentUpdatingExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension ConcurrentUpdatingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Updating or deleting a resource can cause an inconsistent state.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The AWS request ID for this request.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

public struct CreateAccountCustomizationInputBodyMiddleware: Middleware {
    public let id: String = "CreateAccountCustomizationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAccountCustomizationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAccountCustomizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAccountCustomizationInput>
    public typealias MOutput = OperationOutput<CreateAccountCustomizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAccountCustomizationOutputError>
}

extension CreateAccountCustomizationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAccountCustomizationInput(accountCustomization: \(String(describing: accountCustomization)), awsAccountId: \(String(describing: awsAccountId)), namespace: \(String(describing: namespace)), tags: \(String(describing: tags)))"}
}

extension CreateAccountCustomizationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountCustomization = "AccountCustomization"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountCustomization = accountCustomization {
            try encodeContainer.encode(accountCustomization, forKey: .accountCustomization)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateAccountCustomizationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAccountCustomizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAccountCustomizationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAccountCustomizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAccountCustomizationInput>
    public typealias MOutput = OperationOutput<CreateAccountCustomizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAccountCustomizationOutputError>
}

public struct CreateAccountCustomizationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAccountCustomizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAccountCustomizationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAccountCustomizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let namespace = input.operationInput.namespace {
            let namespaceQueryItem = URLQueryItem(name: "namespace".urlPercentEncoding(), value: String(namespace).urlPercentEncoding())
            input.builder.withQueryItem(namespaceQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAccountCustomizationInput>
    public typealias MOutput = OperationOutput<CreateAccountCustomizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAccountCustomizationOutputError>
}

public struct CreateAccountCustomizationInput: Equatable {
    /// <p>The QuickSight customizations you're adding in the current AWS Region. You can add
    ///             these to an AWS account and a QuickSight namespace. </p>
    ///         <p>For example, you can add a default theme by setting <code>AccountCustomization</code>
    ///             to the midnight theme: <code>"AccountCustomization": { "DefaultTheme":
    ///                 "arn:aws:quicksight::aws:theme/MIDNIGHT" }</code>. Or, you can add a custom theme by
    ///             specifying <code>"AccountCustomization": { "DefaultTheme":
    ///                 "arn:aws:quicksight:us-west-2:111122223333:theme/bdb844d0-0fe9-4d9d-b520-0fe602d93639"
    ///                 }</code>. </p>
    public let accountCustomization: AccountCustomization?
    /// <p>The ID for the AWS account that you want to customize QuickSight for.</p>
    public let awsAccountId: String?
    /// <p>The QuickSight namespace that you want to add customizations to.</p>
    public let namespace: String?
    /// <p>A list of the tags that you want to attach to this resource.</p>
    public let tags: [Tag]?

    public init (
        accountCustomization: AccountCustomization? = nil,
        awsAccountId: String? = nil,
        namespace: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.accountCustomization = accountCustomization
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.tags = tags
    }
}

struct CreateAccountCustomizationInputBody: Equatable {
    public let accountCustomization: AccountCustomization?
    public let tags: [Tag]?
}

extension CreateAccountCustomizationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountCustomization = "AccountCustomization"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountCustomizationDecoded = try containerValues.decodeIfPresent(AccountCustomization.self, forKey: .accountCustomization)
        accountCustomization = accountCustomizationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAccountCustomizationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAccountCustomizationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAccountCustomizationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAccountCustomizationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAccountCustomizationOutputResponse(accountCustomization: \(String(describing: accountCustomization)), arn: \(String(describing: arn)), awsAccountId: \(String(describing: awsAccountId)), namespace: \(String(describing: namespace)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension CreateAccountCustomizationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAccountCustomizationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountCustomization = output.accountCustomization
            self.arn = output.arn
            self.awsAccountId = output.awsAccountId
            self.namespace = output.namespace
            self.requestId = output.requestId
        } else {
            self.accountCustomization = nil
            self.arn = nil
            self.awsAccountId = nil
            self.namespace = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateAccountCustomizationOutputResponse: Equatable {
    /// <p>The QuickSight customizations you're adding in the current AWS Region. </p>
    public let accountCustomization: AccountCustomization?
    /// <p>The Amazon Resource Name (ARN) for the customization that you created for this AWS account.</p>
    public let arn: String?
    /// <p>The ID for the AWS account that you want to customize QuickSight for.</p>
    public let awsAccountId: String?
    /// <p>The namespace associated with the customization you're creating. </p>
    public let namespace: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        accountCustomization: AccountCustomization? = nil,
        arn: String? = nil,
        awsAccountId: String? = nil,
        namespace: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.accountCustomization = accountCustomization
        self.arn = arn
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.requestId = requestId
        self.status = status
    }
}

struct CreateAccountCustomizationOutputResponseBody: Equatable {
    public let arn: String?
    public let awsAccountId: String?
    public let namespace: String?
    public let accountCustomization: AccountCustomization?
    public let requestId: String?
    public let status: Int
}

extension CreateAccountCustomizationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountCustomization = "AccountCustomization"
        case arn = "Arn"
        case awsAccountId = "AwsAccountId"
        case namespace = "Namespace"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let accountCustomizationDecoded = try containerValues.decodeIfPresent(AccountCustomization.self, forKey: .accountCustomization)
        accountCustomization = accountCustomizationDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

public struct CreateAnalysisInputBodyMiddleware: Middleware {
    public let id: String = "CreateAnalysisInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAnalysisInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAnalysisInput>
    public typealias MOutput = OperationOutput<CreateAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAnalysisOutputError>
}

extension CreateAnalysisInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAnalysisInput(analysisId: \(String(describing: analysisId)), awsAccountId: \(String(describing: awsAccountId)), name: \(String(describing: name)), parameters: \(String(describing: parameters)), permissions: \(String(describing: permissions)), sourceEntity: \(String(describing: sourceEntity)), tags: \(String(describing: tags)), themeArn: \(String(describing: themeArn)))"}
}

extension CreateAnalysisInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case parameters = "Parameters"
        case permissions = "Permissions"
        case sourceEntity = "SourceEntity"
        case tags = "Tags"
        case themeArn = "ThemeArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for resourcepermissionlist0 in permissions {
                try permissionsContainer.encode(resourcepermissionlist0)
            }
        }
        if let sourceEntity = sourceEntity {
            try encodeContainer.encode(sourceEntity, forKey: .sourceEntity)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let themeArn = themeArn {
            try encodeContainer.encode(themeArn, forKey: .themeArn)
        }
    }
}

public struct CreateAnalysisInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAnalysisInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAnalysisInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAnalysisInput>
    public typealias MOutput = OperationOutput<CreateAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAnalysisOutputError>
}

public struct CreateAnalysisInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAnalysisInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAnalysisInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAnalysisInput>
    public typealias MOutput = OperationOutput<CreateAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAnalysisOutputError>
}

public struct CreateAnalysisInput: Equatable {
    /// <p>The ID for the analysis that you're creating. This ID displays in the URL of the
    ///             analysis.</p>
    public let analysisId: String?
    /// <p>The ID of the AWS account where you are creating an analysis.</p>
    public let awsAccountId: String?
    /// <p>A descriptive name for the analysis that you're creating. This name displays for the
    ///             analysis in the QuickSight console. </p>
    public let name: String?
    /// <p>The parameter names and override values that you want to use. An analysis can have
    ///             any parameter type, and some parameters might accept multiple values. </p>
    public let parameters: Parameters?
    /// <p>A structure that describes the principals and the resource-level permissions on an
    ///             analysis. You can use the <code>Permissions</code> structure to grant permissions by
    ///             providing a list of AWS Identity and Access Management (IAM) action information for each
    ///             principal listed by Amazon Resource Name (ARN). </p>
    ///
    ///         <p>To specify no permissions, omit <code>Permissions</code>.</p>
    public let permissions: [ResourcePermission]?
    /// <p>A source entity to use for the analysis that you're creating. This metadata structure
    ///             contains details that describe a source template and one or more datasets.</p>
    public let sourceEntity: AnalysisSourceEntity?
    /// <p>Contains a map of the key-value pairs for the resource tag or tags assigned to the
    ///             analysis.</p>
    public let tags: [Tag]?
    /// <p>The ARN for the theme to apply to the analysis that you're creating. To see the theme
    ///             in the QuickSight console, make sure that you have access to it.</p>
    public let themeArn: String?

    public init (
        analysisId: String? = nil,
        awsAccountId: String? = nil,
        name: String? = nil,
        parameters: Parameters? = nil,
        permissions: [ResourcePermission]? = nil,
        sourceEntity: AnalysisSourceEntity? = nil,
        tags: [Tag]? = nil,
        themeArn: String? = nil
    )
    {
        self.analysisId = analysisId
        self.awsAccountId = awsAccountId
        self.name = name
        self.parameters = parameters
        self.permissions = permissions
        self.sourceEntity = sourceEntity
        self.tags = tags
        self.themeArn = themeArn
    }
}

struct CreateAnalysisInputBody: Equatable {
    public let name: String?
    public let parameters: Parameters?
    public let permissions: [ResourcePermission]?
    public let sourceEntity: AnalysisSourceEntity?
    public let themeArn: String?
    public let tags: [Tag]?
}

extension CreateAnalysisInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case parameters = "Parameters"
        case permissions = "Permissions"
        case sourceEntity = "SourceEntity"
        case tags = "Tags"
        case themeArn = "ThemeArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(Parameters.self, forKey: .parameters)
        parameters = parametersDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let sourceEntityDecoded = try containerValues.decodeIfPresent(AnalysisSourceEntity.self, forKey: .sourceEntity)
        sourceEntity = sourceEntityDecoded
        let themeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .themeArn)
        themeArn = themeArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAnalysisOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAnalysisOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAnalysisOutputError: Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAnalysisOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAnalysisOutputResponse(analysisId: \(String(describing: analysisId)), arn: \(String(describing: arn)), creationStatus: \(String(describing: creationStatus)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension CreateAnalysisOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.analysisId = output.analysisId
            self.arn = output.arn
            self.creationStatus = output.creationStatus
            self.requestId = output.requestId
        } else {
            self.analysisId = nil
            self.arn = nil
            self.creationStatus = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateAnalysisOutputResponse: Equatable {
    /// <p>The ID of the analysis.</p>
    public let analysisId: String?
    /// <p>The ARN for the analysis.</p>
    public let arn: String?
    /// <p>The status of the creation of the analysis. </p>
    public let creationStatus: ResourceStatus?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        analysisId: String? = nil,
        arn: String? = nil,
        creationStatus: ResourceStatus? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.analysisId = analysisId
        self.arn = arn
        self.creationStatus = creationStatus
        self.requestId = requestId
        self.status = status
    }
}

struct CreateAnalysisOutputResponseBody: Equatable {
    public let arn: String?
    public let analysisId: String?
    public let creationStatus: ResourceStatus?
    public let status: Int
    public let requestId: String?
}

extension CreateAnalysisOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analysisId = "AnalysisId"
        case arn = "Arn"
        case creationStatus = "CreationStatus"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let analysisIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .analysisId)
        analysisId = analysisIdDecoded
        let creationStatusDecoded = try containerValues.decodeIfPresent(ResourceStatus.self, forKey: .creationStatus)
        creationStatus = creationStatusDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension CreateColumnsOperation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case columns = "Columns"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columns = columns {
            var columnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columns)
            for calculatedcolumnlist0 in columns {
                try columnsContainer.encode(calculatedcolumnlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnsContainer = try containerValues.decodeIfPresent([CalculatedColumn?].self, forKey: .columns)
        var columnsDecoded0:[CalculatedColumn]? = nil
        if let columnsContainer = columnsContainer {
            columnsDecoded0 = [CalculatedColumn]()
            for structure0 in columnsContainer {
                if let structure0 = structure0 {
                    columnsDecoded0?.append(structure0)
                }
            }
        }
        columns = columnsDecoded0
    }
}

extension CreateColumnsOperation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateColumnsOperation(columns: \(String(describing: columns)))"}
}

/// <p>A transform operation that creates calculated columns. Columns created in one such
///             operation form a lexical closure.</p>
public struct CreateColumnsOperation: Equatable {
    /// <p>Calculated columns to create.</p>
    public let columns: [CalculatedColumn]?

    public init (
        columns: [CalculatedColumn]? = nil
    )
    {
        self.columns = columns
    }
}

public struct CreateDashboardInputBodyMiddleware: Middleware {
    public let id: String = "CreateDashboardInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDashboardInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDashboardInput>
    public typealias MOutput = OperationOutput<CreateDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDashboardOutputError>
}

extension CreateDashboardInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDashboardInput(awsAccountId: \(String(describing: awsAccountId)), dashboardId: \(String(describing: dashboardId)), dashboardPublishOptions: \(String(describing: dashboardPublishOptions)), name: \(String(describing: name)), parameters: \(String(describing: parameters)), permissions: \(String(describing: permissions)), sourceEntity: \(String(describing: sourceEntity)), tags: \(String(describing: tags)), themeArn: \(String(describing: themeArn)), versionDescription: \(String(describing: versionDescription)))"}
}

extension CreateDashboardInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dashboardPublishOptions = "DashboardPublishOptions"
        case name = "Name"
        case parameters = "Parameters"
        case permissions = "Permissions"
        case sourceEntity = "SourceEntity"
        case tags = "Tags"
        case themeArn = "ThemeArn"
        case versionDescription = "VersionDescription"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dashboardPublishOptions = dashboardPublishOptions {
            try encodeContainer.encode(dashboardPublishOptions, forKey: .dashboardPublishOptions)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for resourcepermissionlist0 in permissions {
                try permissionsContainer.encode(resourcepermissionlist0)
            }
        }
        if let sourceEntity = sourceEntity {
            try encodeContainer.encode(sourceEntity, forKey: .sourceEntity)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let themeArn = themeArn {
            try encodeContainer.encode(themeArn, forKey: .themeArn)
        }
        if let versionDescription = versionDescription {
            try encodeContainer.encode(versionDescription, forKey: .versionDescription)
        }
    }
}

public struct CreateDashboardInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDashboardInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDashboardInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDashboardInput>
    public typealias MOutput = OperationOutput<CreateDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDashboardOutputError>
}

public struct CreateDashboardInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDashboardInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDashboardInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDashboardInput>
    public typealias MOutput = OperationOutput<CreateDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDashboardOutputError>
}

public struct CreateDashboardInput: Equatable {
    /// <p>The ID of the AWS account where you want to create the dashboard.</p>
    public let awsAccountId: String?
    /// <p>The ID for the dashboard, also added to the IAM policy.</p>
    public let dashboardId: String?
    /// <p>Options for publishing the dashboard when you create it:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>AvailabilityStatus</code> for <code>AdHocFilteringOption</code> - This
    ///                     status can be either <code>ENABLED</code> or <code>DISABLED</code>. When this is
    ///                     set to <code>DISABLED</code>, QuickSight disables the left filter pane on the
    ///                     published dashboard, which can be used for ad hoc (one-time) filtering. This
    ///                     option is <code>ENABLED</code> by default. </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>AvailabilityStatus</code> for <code>ExportToCSVOption</code> - This
    ///                     status can be either <code>ENABLED</code> or <code>DISABLED</code>. The visual
    ///                     option to export data to .CSV format isn't enabled when this is set to
    ///                     <code>DISABLED</code>. This option is <code>ENABLED</code> by default. </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>VisibilityState</code> for <code>SheetControlsOption</code> - This
    ///                     visibility state can be either <code>COLLAPSED</code> or <code>EXPANDED</code>.
    ///                     This option is <code>COLLAPSED</code> by default. </p>
    ///             </li>
    ///          </ul>
    public let dashboardPublishOptions: DashboardPublishOptions?
    /// <p>The display name of the dashboard.</p>
    public let name: String?
    /// <p>The parameters for the creation of the dashboard, which you want to use to override
    ///             the default settings. A dashboard can have any type of parameters, and some parameters
    ///             might accept multiple values. </p>
    public let parameters: Parameters?
    /// <p>A structure that contains the permissions of the dashboard. You can use this structure
    ///             for granting permissions by providing a list of IAM action information for each
    ///             principal ARN. </p>
    ///
    ///         <p>To specify no permissions, omit the permissions list.</p>
    public let permissions: [ResourcePermission]?
    /// <p>The entity that you are using as a source when you create the dashboard. In
    ///             <code>SourceEntity</code>, you specify the type of object you're using as source. You
    ///             can only create a dashboard from a template, so you use a <code>SourceTemplate</code>
    ///             entity. If you need to create a dashboard from an analysis, first convert the analysis
    ///             to a template by using the <a>CreateTemplate</a> API operation. For
    ///             <code>SourceTemplate</code>, specify the Amazon Resource Name (ARN) of the source
    ///             template. The <code>SourceTemplate</code>ARN can contain any AWS Account and any
    ///             QuickSight-supported AWS Region. </p>
    ///         <p>Use the <code>DataSetReferences</code> entity within <code>SourceTemplate</code> to
    ///             list the replacement datasets for the placeholders listed in the original. The schema in
    ///             each dataset must match its placeholder. </p>
    public let sourceEntity: DashboardSourceEntity?
    /// <p>Contains a map of the key-value pairs for the resource tag or tags assigned to the
    ///             dashboard.</p>
    public let tags: [Tag]?
    /// <p>The Amazon Resource Name (ARN) of the theme that is being used for this dashboard. If
    ///             you add a value for this field, it overrides the value that is used in the source
    ///             entity. The theme ARN must exist in the same AWS account where you create the
    ///             dashboard.</p>
    public let themeArn: String?
    /// <p>A description for the first version of the dashboard being created.</p>
    public let versionDescription: String?

    public init (
        awsAccountId: String? = nil,
        dashboardId: String? = nil,
        dashboardPublishOptions: DashboardPublishOptions? = nil,
        name: String? = nil,
        parameters: Parameters? = nil,
        permissions: [ResourcePermission]? = nil,
        sourceEntity: DashboardSourceEntity? = nil,
        tags: [Tag]? = nil,
        themeArn: String? = nil,
        versionDescription: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.dashboardPublishOptions = dashboardPublishOptions
        self.name = name
        self.parameters = parameters
        self.permissions = permissions
        self.sourceEntity = sourceEntity
        self.tags = tags
        self.themeArn = themeArn
        self.versionDescription = versionDescription
    }
}

struct CreateDashboardInputBody: Equatable {
    public let name: String?
    public let parameters: Parameters?
    public let permissions: [ResourcePermission]?
    public let sourceEntity: DashboardSourceEntity?
    public let tags: [Tag]?
    public let versionDescription: String?
    public let dashboardPublishOptions: DashboardPublishOptions?
    public let themeArn: String?
}

extension CreateDashboardInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dashboardPublishOptions = "DashboardPublishOptions"
        case name = "Name"
        case parameters = "Parameters"
        case permissions = "Permissions"
        case sourceEntity = "SourceEntity"
        case tags = "Tags"
        case themeArn = "ThemeArn"
        case versionDescription = "VersionDescription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(Parameters.self, forKey: .parameters)
        parameters = parametersDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let sourceEntityDecoded = try containerValues.decodeIfPresent(DashboardSourceEntity.self, forKey: .sourceEntity)
        sourceEntity = sourceEntityDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let versionDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionDescription)
        versionDescription = versionDescriptionDecoded
        let dashboardPublishOptionsDecoded = try containerValues.decodeIfPresent(DashboardPublishOptions.self, forKey: .dashboardPublishOptions)
        dashboardPublishOptions = dashboardPublishOptionsDecoded
        let themeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .themeArn)
        themeArn = themeArnDecoded
    }
}

extension CreateDashboardOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDashboardOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDashboardOutputError: Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDashboardOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDashboardOutputResponse(arn: \(String(describing: arn)), creationStatus: \(String(describing: creationStatus)), dashboardId: \(String(describing: dashboardId)), requestId: \(String(describing: requestId)), status: \(String(describing: status)), versionArn: \(String(describing: versionArn)))"}
}

extension CreateDashboardOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDashboardOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationStatus = output.creationStatus
            self.dashboardId = output.dashboardId
            self.requestId = output.requestId
            self.versionArn = output.versionArn
        } else {
            self.arn = nil
            self.creationStatus = nil
            self.dashboardId = nil
            self.requestId = nil
            self.versionArn = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateDashboardOutputResponse: Equatable {
    /// <p>The ARN of the dashboard.</p>
    public let arn: String?
    /// <p>The status of the dashboard creation request.</p>
    public let creationStatus: ResourceStatus?
    /// <p>The ID for the dashboard.</p>
    public let dashboardId: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>The ARN of the dashboard, including the version number of the first version that is
    ///             created.</p>
    public let versionArn: String?

    public init (
        arn: String? = nil,
        creationStatus: ResourceStatus? = nil,
        dashboardId: String? = nil,
        requestId: String? = nil,
        status: Int = 0,
        versionArn: String? = nil
    )
    {
        self.arn = arn
        self.creationStatus = creationStatus
        self.dashboardId = dashboardId
        self.requestId = requestId
        self.status = status
        self.versionArn = versionArn
    }
}

struct CreateDashboardOutputResponseBody: Equatable {
    public let arn: String?
    public let versionArn: String?
    public let dashboardId: String?
    public let creationStatus: ResourceStatus?
    public let status: Int
    public let requestId: String?
}

extension CreateDashboardOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationStatus = "CreationStatus"
        case dashboardId = "DashboardId"
        case requestId = "RequestId"
        case status = "Status"
        case versionArn = "VersionArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let versionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionArn)
        versionArn = versionArnDecoded
        let dashboardIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let creationStatusDecoded = try containerValues.decodeIfPresent(ResourceStatus.self, forKey: .creationStatus)
        creationStatus = creationStatusDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

public struct CreateDataSetInputBodyMiddleware: Middleware {
    public let id: String = "CreateDataSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDataSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDataSetInput>
    public typealias MOutput = OperationOutput<CreateDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDataSetOutputError>
}

extension CreateDataSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDataSetInput(awsAccountId: \(String(describing: awsAccountId)), columnGroups: \(String(describing: columnGroups)), columnLevelPermissionRules: \(String(describing: columnLevelPermissionRules)), dataSetId: \(String(describing: dataSetId)), fieldFolders: \(String(describing: fieldFolders)), importMode: \(String(describing: importMode)), logicalTableMap: \(String(describing: logicalTableMap)), name: \(String(describing: name)), permissions: \(String(describing: permissions)), physicalTableMap: \(String(describing: physicalTableMap)), rowLevelPermissionDataSet: \(String(describing: rowLevelPermissionDataSet)), tags: \(String(describing: tags)))"}
}

extension CreateDataSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case columnGroups = "ColumnGroups"
        case columnLevelPermissionRules = "ColumnLevelPermissionRules"
        case dataSetId = "DataSetId"
        case fieldFolders = "FieldFolders"
        case importMode = "ImportMode"
        case logicalTableMap = "LogicalTableMap"
        case name = "Name"
        case permissions = "Permissions"
        case physicalTableMap = "PhysicalTableMap"
        case rowLevelPermissionDataSet = "RowLevelPermissionDataSet"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnGroups = columnGroups {
            var columnGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnGroups)
            for columngrouplist0 in columnGroups {
                try columnGroupsContainer.encode(columngrouplist0)
            }
        }
        if let columnLevelPermissionRules = columnLevelPermissionRules {
            var columnLevelPermissionRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnLevelPermissionRules)
            for columnlevelpermissionrulelist0 in columnLevelPermissionRules {
                try columnLevelPermissionRulesContainer.encode(columnlevelpermissionrulelist0)
            }
        }
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let fieldFolders = fieldFolders {
            var fieldFoldersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .fieldFolders)
            for (dictKey0, fieldfoldermap0) in fieldFolders {
                try fieldFoldersContainer.encode(fieldfoldermap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let importMode = importMode {
            try encodeContainer.encode(importMode.rawValue, forKey: .importMode)
        }
        if let logicalTableMap = logicalTableMap {
            var logicalTableMapContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .logicalTableMap)
            for (dictKey0, logicaltablemap0) in logicalTableMap {
                try logicalTableMapContainer.encode(logicaltablemap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for resourcepermissionlist0 in permissions {
                try permissionsContainer.encode(resourcepermissionlist0)
            }
        }
        if let physicalTableMap = physicalTableMap {
            var physicalTableMapContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .physicalTableMap)
            for (dictKey0, physicaltablemap0) in physicalTableMap {
                try physicalTableMapContainer.encode(physicaltablemap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let rowLevelPermissionDataSet = rowLevelPermissionDataSet {
            try encodeContainer.encode(rowLevelPermissionDataSet, forKey: .rowLevelPermissionDataSet)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateDataSetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDataSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDataSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDataSetInput>
    public typealias MOutput = OperationOutput<CreateDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDataSetOutputError>
}

public struct CreateDataSetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDataSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDataSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDataSetInput>
    public typealias MOutput = OperationOutput<CreateDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDataSetOutputError>
}

public struct CreateDataSetInput: Equatable {
    /// <p>The AWS account ID.</p>
    public let awsAccountId: String?
    /// <p>Groupings of columns that work together in certain QuickSight features. Currently, only geospatial hierarchy is supported.</p>
    public let columnGroups: [ColumnGroup]?
    /// <p>A set of one or more definitions of a <code>
    ///                <a>ColumnLevelPermissionRule</a>
    ///             </code>.</p>
    public let columnLevelPermissionRules: [ColumnLevelPermissionRule]?
    /// <p>An ID for the dataset that you want to create. This ID is unique per AWS Region for each AWS account.</p>
    public let dataSetId: String?
    /// <p>The folder that contains fields and nested subfolders for your dataset.</p>
    public let fieldFolders: [String:FieldFolder]?
    /// <p>Indicates whether you want to import the data into SPICE.</p>
    public let importMode: DataSetImportMode?
    /// <p>Configures the combination and transformation of the data from the physical tables.</p>
    public let logicalTableMap: [String:LogicalTable]?
    /// <p>The display name for the dataset.</p>
    public let name: String?
    /// <p>A list of resource permissions on the dataset.</p>
    public let permissions: [ResourcePermission]?
    /// <p>Declares the physical tables that are available in the underlying data sources.</p>
    public let physicalTableMap: [String:PhysicalTable]?
    /// <p>The row-level security configuration for the data that you want to create.</p>
    public let rowLevelPermissionDataSet: RowLevelPermissionDataSet?
    /// <p>Contains a map of the key-value pairs for the resource tag or tags assigned to the dataset.</p>
    public let tags: [Tag]?

    public init (
        awsAccountId: String? = nil,
        columnGroups: [ColumnGroup]? = nil,
        columnLevelPermissionRules: [ColumnLevelPermissionRule]? = nil,
        dataSetId: String? = nil,
        fieldFolders: [String:FieldFolder]? = nil,
        importMode: DataSetImportMode? = nil,
        logicalTableMap: [String:LogicalTable]? = nil,
        name: String? = nil,
        permissions: [ResourcePermission]? = nil,
        physicalTableMap: [String:PhysicalTable]? = nil,
        rowLevelPermissionDataSet: RowLevelPermissionDataSet? = nil,
        tags: [Tag]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.columnGroups = columnGroups
        self.columnLevelPermissionRules = columnLevelPermissionRules
        self.dataSetId = dataSetId
        self.fieldFolders = fieldFolders
        self.importMode = importMode
        self.logicalTableMap = logicalTableMap
        self.name = name
        self.permissions = permissions
        self.physicalTableMap = physicalTableMap
        self.rowLevelPermissionDataSet = rowLevelPermissionDataSet
        self.tags = tags
    }
}

struct CreateDataSetInputBody: Equatable {
    public let dataSetId: String?
    public let name: String?
    public let physicalTableMap: [String:PhysicalTable]?
    public let logicalTableMap: [String:LogicalTable]?
    public let importMode: DataSetImportMode?
    public let columnGroups: [ColumnGroup]?
    public let fieldFolders: [String:FieldFolder]?
    public let permissions: [ResourcePermission]?
    public let rowLevelPermissionDataSet: RowLevelPermissionDataSet?
    public let columnLevelPermissionRules: [ColumnLevelPermissionRule]?
    public let tags: [Tag]?
}

extension CreateDataSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case columnGroups = "ColumnGroups"
        case columnLevelPermissionRules = "ColumnLevelPermissionRules"
        case dataSetId = "DataSetId"
        case fieldFolders = "FieldFolders"
        case importMode = "ImportMode"
        case logicalTableMap = "LogicalTableMap"
        case name = "Name"
        case permissions = "Permissions"
        case physicalTableMap = "PhysicalTableMap"
        case rowLevelPermissionDataSet = "RowLevelPermissionDataSet"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let physicalTableMapContainer = try containerValues.decodeIfPresent([String: PhysicalTable?].self, forKey: .physicalTableMap)
        var physicalTableMapDecoded0: [String:PhysicalTable]? = nil
        if let physicalTableMapContainer = physicalTableMapContainer {
            physicalTableMapDecoded0 = [String:PhysicalTable]()
            for (key0, physicaltable0) in physicalTableMapContainer {
                if let physicaltable0 = physicaltable0 {
                    physicalTableMapDecoded0?[key0] = physicaltable0
                }
            }
        }
        physicalTableMap = physicalTableMapDecoded0
        let logicalTableMapContainer = try containerValues.decodeIfPresent([String: LogicalTable?].self, forKey: .logicalTableMap)
        var logicalTableMapDecoded0: [String:LogicalTable]? = nil
        if let logicalTableMapContainer = logicalTableMapContainer {
            logicalTableMapDecoded0 = [String:LogicalTable]()
            for (key0, logicaltable0) in logicalTableMapContainer {
                if let logicaltable0 = logicaltable0 {
                    logicalTableMapDecoded0?[key0] = logicaltable0
                }
            }
        }
        logicalTableMap = logicalTableMapDecoded0
        let importModeDecoded = try containerValues.decodeIfPresent(DataSetImportMode.self, forKey: .importMode)
        importMode = importModeDecoded
        let columnGroupsContainer = try containerValues.decodeIfPresent([ColumnGroup?].self, forKey: .columnGroups)
        var columnGroupsDecoded0:[ColumnGroup]? = nil
        if let columnGroupsContainer = columnGroupsContainer {
            columnGroupsDecoded0 = [ColumnGroup]()
            for structure0 in columnGroupsContainer {
                if let structure0 = structure0 {
                    columnGroupsDecoded0?.append(structure0)
                }
            }
        }
        columnGroups = columnGroupsDecoded0
        let fieldFoldersContainer = try containerValues.decodeIfPresent([String: FieldFolder?].self, forKey: .fieldFolders)
        var fieldFoldersDecoded0: [String:FieldFolder]? = nil
        if let fieldFoldersContainer = fieldFoldersContainer {
            fieldFoldersDecoded0 = [String:FieldFolder]()
            for (key0, fieldfolder0) in fieldFoldersContainer {
                if let fieldfolder0 = fieldfolder0 {
                    fieldFoldersDecoded0?[key0] = fieldfolder0
                }
            }
        }
        fieldFolders = fieldFoldersDecoded0
        let permissionsContainer = try containerValues.decodeIfPresent([ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let rowLevelPermissionDataSetDecoded = try containerValues.decodeIfPresent(RowLevelPermissionDataSet.self, forKey: .rowLevelPermissionDataSet)
        rowLevelPermissionDataSet = rowLevelPermissionDataSetDecoded
        let columnLevelPermissionRulesContainer = try containerValues.decodeIfPresent([ColumnLevelPermissionRule?].self, forKey: .columnLevelPermissionRules)
        var columnLevelPermissionRulesDecoded0:[ColumnLevelPermissionRule]? = nil
        if let columnLevelPermissionRulesContainer = columnLevelPermissionRulesContainer {
            columnLevelPermissionRulesDecoded0 = [ColumnLevelPermissionRule]()
            for structure0 in columnLevelPermissionRulesContainer {
                if let structure0 = structure0 {
                    columnLevelPermissionRulesDecoded0?.append(structure0)
                }
            }
        }
        columnLevelPermissionRules = columnLevelPermissionRulesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDataSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDataSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDataSetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDataSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDataSetOutputResponse(arn: \(String(describing: arn)), dataSetId: \(String(describing: dataSetId)), ingestionArn: \(String(describing: ingestionArn)), ingestionId: \(String(describing: ingestionId)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension CreateDataSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDataSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.dataSetId = output.dataSetId
            self.ingestionArn = output.ingestionArn
            self.ingestionId = output.ingestionId
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.dataSetId = nil
            self.ingestionArn = nil
            self.ingestionId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateDataSetOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset.</p>
    public let arn: String?
    /// <p>The ID for the dataset that you want to create. This ID is unique per AWS Region for each AWS account.</p>
    public let dataSetId: String?
    /// <p>The ARN for the ingestion, which is triggered as a result of dataset creation if the import
    /// 			mode is SPICE.</p>
    public let ingestionArn: String?
    /// <p>The ID of the ingestion, which is triggered as a result of dataset creation if the import
    /// 			mode is SPICE.</p>
    public let ingestionId: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        arn: String? = nil,
        dataSetId: String? = nil,
        ingestionArn: String? = nil,
        ingestionId: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.arn = arn
        self.dataSetId = dataSetId
        self.ingestionArn = ingestionArn
        self.ingestionId = ingestionId
        self.requestId = requestId
        self.status = status
    }
}

struct CreateDataSetOutputResponseBody: Equatable {
    public let arn: String?
    public let dataSetId: String?
    public let ingestionArn: String?
    public let ingestionId: String?
    public let requestId: String?
    public let status: Int
}

extension CreateDataSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case dataSetId = "DataSetId"
        case ingestionArn = "IngestionArn"
        case ingestionId = "IngestionId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let ingestionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ingestionArn)
        ingestionArn = ingestionArnDecoded
        let ingestionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ingestionId)
        ingestionId = ingestionIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

public struct CreateDataSourceInputBodyMiddleware: Middleware {
    public let id: String = "CreateDataSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDataSourceInput>
    public typealias MOutput = OperationOutput<CreateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDataSourceOutputError>
}

extension CreateDataSourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDataSourceInput(awsAccountId: \(String(describing: awsAccountId)), credentials: \(String(describing: credentials)), dataSourceId: \(String(describing: dataSourceId)), dataSourceParameters: \(String(describing: dataSourceParameters)), name: \(String(describing: name)), permissions: \(String(describing: permissions)), sslProperties: \(String(describing: sslProperties)), tags: \(String(describing: tags)), type: \(String(describing: type)), vpcConnectionProperties: \(String(describing: vpcConnectionProperties)))"}
}

extension CreateDataSourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case credentials = "Credentials"
        case dataSourceId = "DataSourceId"
        case dataSourceParameters = "DataSourceParameters"
        case name = "Name"
        case permissions = "Permissions"
        case sslProperties = "SslProperties"
        case tags = "Tags"
        case type = "Type"
        case vpcConnectionProperties = "VpcConnectionProperties"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let credentials = credentials {
            try encodeContainer.encode(credentials, forKey: .credentials)
        }
        if let dataSourceId = dataSourceId {
            try encodeContainer.encode(dataSourceId, forKey: .dataSourceId)
        }
        if let dataSourceParameters = dataSourceParameters {
            try encodeContainer.encode(dataSourceParameters, forKey: .dataSourceParameters)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for resourcepermissionlist0 in permissions {
                try permissionsContainer.encode(resourcepermissionlist0)
            }
        }
        if let sslProperties = sslProperties {
            try encodeContainer.encode(sslProperties, forKey: .sslProperties)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let vpcConnectionProperties = vpcConnectionProperties {
            try encodeContainer.encode(vpcConnectionProperties, forKey: .vpcConnectionProperties)
        }
    }
}

public struct CreateDataSourceInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDataSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDataSourceInput>
    public typealias MOutput = OperationOutput<CreateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDataSourceOutputError>
}

public struct CreateDataSourceInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDataSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDataSourceInput>
    public typealias MOutput = OperationOutput<CreateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDataSourceOutputError>
}

public struct CreateDataSourceInput: Equatable {
    /// <p>The AWS account ID.</p>
    public let awsAccountId: String?
    /// <p>The credentials QuickSight that uses to connect to your underlying source. Currently, only
    /// 			credentials based on user name and password are supported.</p>
    public let credentials: DataSourceCredentials?
    /// <p>An ID for the data source. This ID is unique per AWS Region for each AWS account. </p>
    public let dataSourceId: String?
    /// <p>The parameters that QuickSight uses to connect to your underlying source.</p>
    public let dataSourceParameters: DataSourceParameters?
    /// <p>A display name for the data source.</p>
    public let name: String?
    /// <p>A list of resource permissions on the data source.</p>
    public let permissions: [ResourcePermission]?
    /// <p>Secure Socket Layer (SSL) properties that apply when QuickSight connects to your underlying source.</p>
    public let sslProperties: SslProperties?
    /// <p>Contains a map of the key-value pairs for the resource tag or tags assigned to the data source.</p>
    public let tags: [Tag]?
    /// <p>The type of the data source. Currently, the supported types for this operation are:
    /// 			<code>ATHENA, AURORA, AURORA_POSTGRESQL, AMAZON_ELASTICSEARCH, MARIADB, MYSQL, POSTGRESQL, PRESTO, REDSHIFT, S3,
    /// 			SNOWFLAKE, SPARK, SQLSERVER, TERADATA</code>.
    /// 			Use <code>ListDataSources</code> to return a
    /// 			list of all data sources.</p>
    /// 		       <p>
    ///             <code>AMAZON_ELASTICSEARCH</code> is for Amazon managed Elasticsearch Service.</p>
    public let type: DataSourceType?
    /// <p>Use this parameter only when you want QuickSight to use a VPC connection when connecting to
    /// 			your underlying source.</p>
    public let vpcConnectionProperties: VpcConnectionProperties?

    public init (
        awsAccountId: String? = nil,
        credentials: DataSourceCredentials? = nil,
        dataSourceId: String? = nil,
        dataSourceParameters: DataSourceParameters? = nil,
        name: String? = nil,
        permissions: [ResourcePermission]? = nil,
        sslProperties: SslProperties? = nil,
        tags: [Tag]? = nil,
        type: DataSourceType? = nil,
        vpcConnectionProperties: VpcConnectionProperties? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.credentials = credentials
        self.dataSourceId = dataSourceId
        self.dataSourceParameters = dataSourceParameters
        self.name = name
        self.permissions = permissions
        self.sslProperties = sslProperties
        self.tags = tags
        self.type = type
        self.vpcConnectionProperties = vpcConnectionProperties
    }
}

struct CreateDataSourceInputBody: Equatable {
    public let dataSourceId: String?
    public let name: String?
    public let type: DataSourceType?
    public let dataSourceParameters: DataSourceParameters?
    public let credentials: DataSourceCredentials?
    public let permissions: [ResourcePermission]?
    public let vpcConnectionProperties: VpcConnectionProperties?
    public let sslProperties: SslProperties?
    public let tags: [Tag]?
}

extension CreateDataSourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case credentials = "Credentials"
        case dataSourceId = "DataSourceId"
        case dataSourceParameters = "DataSourceParameters"
        case name = "Name"
        case permissions = "Permissions"
        case sslProperties = "SslProperties"
        case tags = "Tags"
        case type = "Type"
        case vpcConnectionProperties = "VpcConnectionProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataSourceType.self, forKey: .type)
        type = typeDecoded
        let dataSourceParametersDecoded = try containerValues.decodeIfPresent(DataSourceParameters.self, forKey: .dataSourceParameters)
        dataSourceParameters = dataSourceParametersDecoded
        let credentialsDecoded = try containerValues.decodeIfPresent(DataSourceCredentials.self, forKey: .credentials)
        credentials = credentialsDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let vpcConnectionPropertiesDecoded = try containerValues.decodeIfPresent(VpcConnectionProperties.self, forKey: .vpcConnectionProperties)
        vpcConnectionProperties = vpcConnectionPropertiesDecoded
        let sslPropertiesDecoded = try containerValues.decodeIfPresent(SslProperties.self, forKey: .sslProperties)
        sslProperties = sslPropertiesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDataSourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDataSourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDataSourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDataSourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDataSourceOutputResponse(arn: \(String(describing: arn)), creationStatus: \(String(describing: creationStatus)), dataSourceId: \(String(describing: dataSourceId)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension CreateDataSourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDataSourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationStatus = output.creationStatus
            self.dataSourceId = output.dataSourceId
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.creationStatus = nil
            self.dataSourceId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateDataSourceOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the data source.</p>
    public let arn: String?
    /// <p>The status of creating the data source.</p>
    public let creationStatus: ResourceStatus?
    /// <p>The ID of the data source. This ID is unique per AWS Region for each AWS account.</p>
    public let dataSourceId: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        arn: String? = nil,
        creationStatus: ResourceStatus? = nil,
        dataSourceId: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.arn = arn
        self.creationStatus = creationStatus
        self.dataSourceId = dataSourceId
        self.requestId = requestId
        self.status = status
    }
}

struct CreateDataSourceOutputResponseBody: Equatable {
    public let arn: String?
    public let dataSourceId: String?
    public let creationStatus: ResourceStatus?
    public let requestId: String?
    public let status: Int
}

extension CreateDataSourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationStatus = "CreationStatus"
        case dataSourceId = "DataSourceId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let creationStatusDecoded = try containerValues.decodeIfPresent(ResourceStatus.self, forKey: .creationStatus)
        creationStatus = creationStatusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

public struct CreateGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGroupInput>
    public typealias MOutput = OperationOutput<CreateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGroupOutputError>
}

extension CreateGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGroupInput(awsAccountId: \(String(describing: awsAccountId)), description: \(String(describing: description)), groupName: \(String(describing: groupName)), namespace: \(String(describing: namespace)))"}
}

extension CreateGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case groupName = "GroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }
}

public struct CreateGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGroupInput>
    public typealias MOutput = OperationOutput<CreateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGroupOutputError>
}

public struct CreateGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGroupInput>
    public typealias MOutput = OperationOutput<CreateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGroupOutputError>
}

/// <p>The request object for this operation. </p>
public struct CreateGroupInput: Equatable {
    /// <p>The ID for the AWS account that the group is in. Currently, you use the ID for the AWS
    /// 			account that contains your Amazon QuickSight account.</p>
    public let awsAccountId: String?
    /// <p>A description for the group that you want to create.</p>
    public let description: String?
    /// <p>A name for the group that you want to create.</p>
    public let groupName: String?
    /// <p>The namespace. Currently, you should set this to <code>default</code>.</p>
    public let namespace: String?

    public init (
        awsAccountId: String? = nil,
        description: String? = nil,
        groupName: String? = nil,
        namespace: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.description = description
        self.groupName = groupName
        self.namespace = namespace
    }
}

struct CreateGroupInputBody: Equatable {
    public let groupName: String?
    public let description: String?
}

extension CreateGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case groupName = "GroupName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateGroupMembershipInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGroupMembershipInput(awsAccountId: \(String(describing: awsAccountId)), groupName: \(String(describing: groupName)), memberName: \(String(describing: memberName)), namespace: \(String(describing: namespace)))"}
}

extension CreateGroupMembershipInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CreateGroupMembershipInputHeadersMiddleware: Middleware {
    public let id: String = "CreateGroupMembershipInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGroupMembershipInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGroupMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGroupMembershipInput>
    public typealias MOutput = OperationOutput<CreateGroupMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGroupMembershipOutputError>
}

public struct CreateGroupMembershipInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateGroupMembershipInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGroupMembershipInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGroupMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGroupMembershipInput>
    public typealias MOutput = OperationOutput<CreateGroupMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGroupMembershipOutputError>
}

public struct CreateGroupMembershipInput: Equatable {
    /// <p>The ID for the AWS account that the group is in. Currently, you use the ID for the AWS
    /// 			account that contains your Amazon QuickSight account.</p>
    public let awsAccountId: String?
    /// <p>The name of the group that you want to add the user to.</p>
    public let groupName: String?
    /// <p>The name of the user that you want to add to the group membership.</p>
    public let memberName: String?
    /// <p>The namespace. Currently, you should set this to <code>default</code>.</p>
    public let namespace: String?

    public init (
        awsAccountId: String? = nil,
        groupName: String? = nil,
        memberName: String? = nil,
        namespace: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.groupName = groupName
        self.memberName = memberName
        self.namespace = namespace
    }
}

struct CreateGroupMembershipInputBody: Equatable {
}

extension CreateGroupMembershipInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CreateGroupMembershipOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGroupMembershipOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGroupMembershipOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGroupMembershipOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGroupMembershipOutputResponse(groupMember: \(String(describing: groupMember)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension CreateGroupMembershipOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateGroupMembershipOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.groupMember = output.groupMember
            self.requestId = output.requestId
        } else {
            self.groupMember = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateGroupMembershipOutputResponse: Equatable {
    /// <p>The group member.</p>
    public let groupMember: GroupMember?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        groupMember: GroupMember? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.groupMember = groupMember
        self.requestId = requestId
        self.status = status
    }
}

struct CreateGroupMembershipOutputResponseBody: Equatable {
    public let groupMember: GroupMember?
    public let requestId: String?
    public let status: Int
}

extension CreateGroupMembershipOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupMember = "GroupMember"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupMemberDecoded = try containerValues.decodeIfPresent(GroupMember.self, forKey: .groupMember)
        groupMember = groupMemberDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension CreateGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGroupOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGroupOutputResponse(group: \(String(describing: group)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension CreateGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.group = output.group
            self.requestId = output.requestId
        } else {
            self.group = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

/// <p>The response object for this operation.</p>
public struct CreateGroupOutputResponse: Equatable {
    /// <p>The name of the group.</p>
    public let group: Group?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        group: Group? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.group = group
        self.requestId = requestId
        self.status = status
    }
}

struct CreateGroupOutputResponseBody: Equatable {
    public let group: Group?
    public let requestId: String?
    public let status: Int
}

extension CreateGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(Group.self, forKey: .group)
        group = groupDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

public struct CreateIAMPolicyAssignmentInputBodyMiddleware: Middleware {
    public let id: String = "CreateIAMPolicyAssignmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIAMPolicyAssignmentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIAMPolicyAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIAMPolicyAssignmentInput>
    public typealias MOutput = OperationOutput<CreateIAMPolicyAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIAMPolicyAssignmentOutputError>
}

extension CreateIAMPolicyAssignmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateIAMPolicyAssignmentInput(assignmentName: \(String(describing: assignmentName)), assignmentStatus: \(String(describing: assignmentStatus)), awsAccountId: \(String(describing: awsAccountId)), identities: \(String(describing: identities)), namespace: \(String(describing: namespace)), policyArn: \(String(describing: policyArn)))"}
}

extension CreateIAMPolicyAssignmentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assignmentName = "AssignmentName"
        case assignmentStatus = "AssignmentStatus"
        case identities = "Identities"
        case policyArn = "PolicyArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentName = assignmentName {
            try encodeContainer.encode(assignmentName, forKey: .assignmentName)
        }
        if let assignmentStatus = assignmentStatus {
            try encodeContainer.encode(assignmentStatus.rawValue, forKey: .assignmentStatus)
        }
        if let identities = identities {
            var identitiesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .identities)
            for (dictKey0, identitymap0) in identities {
                try identitiesContainer.encode(identitymap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let policyArn = policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
    }
}

public struct CreateIAMPolicyAssignmentInputHeadersMiddleware: Middleware {
    public let id: String = "CreateIAMPolicyAssignmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIAMPolicyAssignmentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIAMPolicyAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIAMPolicyAssignmentInput>
    public typealias MOutput = OperationOutput<CreateIAMPolicyAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIAMPolicyAssignmentOutputError>
}

public struct CreateIAMPolicyAssignmentInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateIAMPolicyAssignmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIAMPolicyAssignmentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIAMPolicyAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIAMPolicyAssignmentInput>
    public typealias MOutput = OperationOutput<CreateIAMPolicyAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIAMPolicyAssignmentOutputError>
}

public struct CreateIAMPolicyAssignmentInput: Equatable {
    /// <p>The name of the assignment, also called a rule. It must be unique within an AWS account.</p>
    public let assignmentName: String?
    /// <p>The status of the assignment. Possible values are as follows:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ENABLED</code> - Anything specified in this assignment is used when creating the data
    /// 					source.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DISABLED</code> - This assignment isn't used when creating the data source.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DRAFT</code> - This assignment is an unfinished draft and isn't used when creating the
    /// 					data source.</p>
    ///             </li>
    ///          </ul>
    public let assignmentStatus: AssignmentStatus?
    /// <p>The ID of the AWS account where you want to assign an IAM policy to QuickSight users or
    /// 			groups.</p>
    public let awsAccountId: String?
    /// <p>The QuickSight users, groups, or both that you want to assign the policy to.</p>
    public let identities: [String:[String]]?
    /// <p>The namespace that contains the assignment.</p>
    public let namespace: String?
    /// <p>The ARN for the IAM policy to apply to the QuickSight users and groups
    /// 			specified in this assignment.</p>
    public let policyArn: String?

    public init (
        assignmentName: String? = nil,
        assignmentStatus: AssignmentStatus? = nil,
        awsAccountId: String? = nil,
        identities: [String:[String]]? = nil,
        namespace: String? = nil,
        policyArn: String? = nil
    )
    {
        self.assignmentName = assignmentName
        self.assignmentStatus = assignmentStatus
        self.awsAccountId = awsAccountId
        self.identities = identities
        self.namespace = namespace
        self.policyArn = policyArn
    }
}

struct CreateIAMPolicyAssignmentInputBody: Equatable {
    public let assignmentName: String?
    public let assignmentStatus: AssignmentStatus?
    public let policyArn: String?
    public let identities: [String:[String]]?
}

extension CreateIAMPolicyAssignmentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assignmentName = "AssignmentName"
        case assignmentStatus = "AssignmentStatus"
        case identities = "Identities"
        case policyArn = "PolicyArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assignmentName)
        assignmentName = assignmentNameDecoded
        let assignmentStatusDecoded = try containerValues.decodeIfPresent(AssignmentStatus.self, forKey: .assignmentStatus)
        assignmentStatus = assignmentStatusDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let identitiesContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .identities)
        var identitiesDecoded0: [String:[String]]? = nil
        if let identitiesContainer = identitiesContainer {
            identitiesDecoded0 = [String:[String]]()
            for (key0, identitynamelist0) in identitiesContainer {
                var identitynamelist0Decoded0: [String]? = nil
                if let identitynamelist0 = identitynamelist0 {
                    identitynamelist0Decoded0 = [String]()
                    for string1 in identitynamelist0 {
                        if let string1 = string1 {
                            identitynamelist0Decoded0?.append(string1)
                        }
                    }
                }
                identitiesDecoded0?[key0] = identitynamelist0Decoded0
            }
        }
        identities = identitiesDecoded0
    }
}

extension CreateIAMPolicyAssignmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateIAMPolicyAssignmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentUpdatingException" : self = .concurrentUpdatingException(try ConcurrentUpdatingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateIAMPolicyAssignmentOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case concurrentUpdatingException(ConcurrentUpdatingException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateIAMPolicyAssignmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateIAMPolicyAssignmentOutputResponse(assignmentId: \(String(describing: assignmentId)), assignmentName: \(String(describing: assignmentName)), assignmentStatus: \(String(describing: assignmentStatus)), identities: \(String(describing: identities)), policyArn: \(String(describing: policyArn)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension CreateIAMPolicyAssignmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateIAMPolicyAssignmentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assignmentId = output.assignmentId
            self.assignmentName = output.assignmentName
            self.assignmentStatus = output.assignmentStatus
            self.identities = output.identities
            self.policyArn = output.policyArn
            self.requestId = output.requestId
        } else {
            self.assignmentId = nil
            self.assignmentName = nil
            self.assignmentStatus = nil
            self.identities = nil
            self.policyArn = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateIAMPolicyAssignmentOutputResponse: Equatable {
    /// <p>The ID for the assignment.</p>
    public let assignmentId: String?
    /// <p>The name of the assignment. This name must be unique within the AWS account.</p>
    public let assignmentName: String?
    /// <p>The status of the assignment. Possible values are as follows:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ENABLED</code> - Anything specified in this assignment is used when creating the data
    /// 				source.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DISABLED</code> - This assignment isn't used when creating the data source.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DRAFT</code> - This assignment is an unfinished draft and isn't used when creating the
    /// 				data source.</p>
    ///             </li>
    ///          </ul>
    public let assignmentStatus: AssignmentStatus?
    /// <p>The QuickSight users, groups, or both that the IAM policy is assigned to.</p>
    public let identities: [String:[String]]?
    /// <p>The ARN for the IAM policy that is applied to the QuickSight users and groups specified in this assignment.</p>
    public let policyArn: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        assignmentId: String? = nil,
        assignmentName: String? = nil,
        assignmentStatus: AssignmentStatus? = nil,
        identities: [String:[String]]? = nil,
        policyArn: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.assignmentId = assignmentId
        self.assignmentName = assignmentName
        self.assignmentStatus = assignmentStatus
        self.identities = identities
        self.policyArn = policyArn
        self.requestId = requestId
        self.status = status
    }
}

struct CreateIAMPolicyAssignmentOutputResponseBody: Equatable {
    public let assignmentName: String?
    public let assignmentId: String?
    public let assignmentStatus: AssignmentStatus?
    public let policyArn: String?
    public let identities: [String:[String]]?
    public let requestId: String?
    public let status: Int
}

extension CreateIAMPolicyAssignmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assignmentId = "AssignmentId"
        case assignmentName = "AssignmentName"
        case assignmentStatus = "AssignmentStatus"
        case identities = "Identities"
        case policyArn = "PolicyArn"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assignmentName)
        assignmentName = assignmentNameDecoded
        let assignmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assignmentId)
        assignmentId = assignmentIdDecoded
        let assignmentStatusDecoded = try containerValues.decodeIfPresent(AssignmentStatus.self, forKey: .assignmentStatus)
        assignmentStatus = assignmentStatusDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let identitiesContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .identities)
        var identitiesDecoded0: [String:[String]]? = nil
        if let identitiesContainer = identitiesContainer {
            identitiesDecoded0 = [String:[String]]()
            for (key0, identitynamelist0) in identitiesContainer {
                var identitynamelist0Decoded0: [String]? = nil
                if let identitynamelist0 = identitynamelist0 {
                    identitynamelist0Decoded0 = [String]()
                    for string1 in identitynamelist0 {
                        if let string1 = string1 {
                            identitynamelist0Decoded0?.append(string1)
                        }
                    }
                }
                identitiesDecoded0?[key0] = identitynamelist0Decoded0
            }
        }
        identities = identitiesDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension CreateIngestionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateIngestionInput(awsAccountId: \(String(describing: awsAccountId)), dataSetId: \(String(describing: dataSetId)), ingestionId: \(String(describing: ingestionId)))"}
}

extension CreateIngestionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CreateIngestionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateIngestionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIngestionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIngestionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIngestionInput>
    public typealias MOutput = OperationOutput<CreateIngestionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIngestionOutputError>
}

public struct CreateIngestionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateIngestionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIngestionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIngestionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIngestionInput>
    public typealias MOutput = OperationOutput<CreateIngestionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIngestionOutputError>
}

public struct CreateIngestionInput: Equatable {
    /// <p>The AWS account ID.</p>
    public let awsAccountId: String?
    /// <p>The ID of the dataset used in the ingestion.</p>
    public let dataSetId: String?
    /// <p>An ID for the ingestion.</p>
    public let ingestionId: String?

    public init (
        awsAccountId: String? = nil,
        dataSetId: String? = nil,
        ingestionId: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
        self.ingestionId = ingestionId
    }
}

struct CreateIngestionInputBody: Equatable {
}

extension CreateIngestionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CreateIngestionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateIngestionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateIngestionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateIngestionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateIngestionOutputResponse(arn: \(String(describing: arn)), ingestionId: \(String(describing: ingestionId)), ingestionStatus: \(String(describing: ingestionStatus)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension CreateIngestionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateIngestionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.ingestionId = output.ingestionId
            self.ingestionStatus = output.ingestionStatus
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.ingestionId = nil
            self.ingestionStatus = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateIngestionOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the data ingestion.</p>
    public let arn: String?
    /// <p>An ID for the ingestion.</p>
    public let ingestionId: String?
    /// <p>The ingestion status.</p>
    public let ingestionStatus: IngestionStatus?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        arn: String? = nil,
        ingestionId: String? = nil,
        ingestionStatus: IngestionStatus? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.arn = arn
        self.ingestionId = ingestionId
        self.ingestionStatus = ingestionStatus
        self.requestId = requestId
        self.status = status
    }
}

struct CreateIngestionOutputResponseBody: Equatable {
    public let arn: String?
    public let ingestionId: String?
    public let ingestionStatus: IngestionStatus?
    public let requestId: String?
    public let status: Int
}

extension CreateIngestionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case ingestionId = "IngestionId"
        case ingestionStatus = "IngestionStatus"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let ingestionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ingestionId)
        ingestionId = ingestionIdDecoded
        let ingestionStatusDecoded = try containerValues.decodeIfPresent(IngestionStatus.self, forKey: .ingestionStatus)
        ingestionStatus = ingestionStatusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

public struct CreateNamespaceInputBodyMiddleware: Middleware {
    public let id: String = "CreateNamespaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateNamespaceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateNamespaceInput>
    public typealias MOutput = OperationOutput<CreateNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateNamespaceOutputError>
}

extension CreateNamespaceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateNamespaceInput(awsAccountId: \(String(describing: awsAccountId)), identityStore: \(String(describing: identityStore)), namespace: \(String(describing: namespace)), tags: \(String(describing: tags)))"}
}

extension CreateNamespaceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identityStore = "IdentityStore"
        case namespace = "Namespace"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStore = identityStore {
            try encodeContainer.encode(identityStore.rawValue, forKey: .identityStore)
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateNamespaceInputHeadersMiddleware: Middleware {
    public let id: String = "CreateNamespaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateNamespaceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateNamespaceInput>
    public typealias MOutput = OperationOutput<CreateNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateNamespaceOutputError>
}

public struct CreateNamespaceInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateNamespaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateNamespaceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateNamespaceInput>
    public typealias MOutput = OperationOutput<CreateNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateNamespaceOutputError>
}

public struct CreateNamespaceInput: Equatable {
    /// <p>The ID for the AWS account that you want to create the QuickSight namespace in.</p>
    public let awsAccountId: String?
    /// <p>Specifies the type of your user identity directory. Currently, this supports users
    ///             with an identity type of <code>QUICKSIGHT</code>.</p>
    public let identityStore: IdentityStore?
    /// <p>The name that you want to use to describe the new namespace.</p>
    public let namespace: String?
    /// <p>The tags that you want to associate with the namespace that you're creating.</p>
    public let tags: [Tag]?

    public init (
        awsAccountId: String? = nil,
        identityStore: IdentityStore? = nil,
        namespace: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.identityStore = identityStore
        self.namespace = namespace
        self.tags = tags
    }
}

struct CreateNamespaceInputBody: Equatable {
    public let namespace: String?
    public let identityStore: IdentityStore?
    public let tags: [Tag]?
}

extension CreateNamespaceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityStore = "IdentityStore"
        case namespace = "Namespace"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let identityStoreDecoded = try containerValues.decodeIfPresent(IdentityStore.self, forKey: .identityStore)
        identityStore = identityStoreDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateNamespaceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateNamespaceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateNamespaceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateNamespaceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateNamespaceOutputResponse(arn: \(String(describing: arn)), capacityRegion: \(String(describing: capacityRegion)), creationStatus: \(String(describing: creationStatus)), identityStore: \(String(describing: identityStore)), name: \(String(describing: name)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension CreateNamespaceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.capacityRegion = output.capacityRegion
            self.creationStatus = output.creationStatus
            self.identityStore = output.identityStore
            self.name = output.name
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.capacityRegion = nil
            self.creationStatus = nil
            self.identityStore = nil
            self.name = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateNamespaceOutputResponse: Equatable {
    /// <p>The ARN of the QuickSight namespace you created. </p>
    public let arn: String?
    /// <p>The AWS Region that you want to use for the free SPICE capacity for the new namespace.
    ///             This is set to the region that you run CreateNamespace in. </p>
    public let capacityRegion: String?
    /// <p>The status of the creation of the namespace. This is an asynchronous process. A status
    ///             of <code>CREATED</code> means that your namespace is ready to use. If an error occurs,
    ///             it indicates if the process is <code>retryable</code> or <code>non-retryable</code>. In
    ///             the case of a non-retryable error, refer to the error message for follow-up
    ///             tasks.</p>
    public let creationStatus: NamespaceStatus?
    /// <p>Specifies the type of your user identity directory. Currently, this supports users
    ///             with an identity type of <code>QUICKSIGHT</code>.</p>
    public let identityStore: IdentityStore?
    /// <p>The name of the new namespace that you created.</p>
    public let name: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        arn: String? = nil,
        capacityRegion: String? = nil,
        creationStatus: NamespaceStatus? = nil,
        identityStore: IdentityStore? = nil,
        name: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.arn = arn
        self.capacityRegion = capacityRegion
        self.creationStatus = creationStatus
        self.identityStore = identityStore
        self.name = name
        self.requestId = requestId
        self.status = status
    }
}

struct CreateNamespaceOutputResponseBody: Equatable {
    public let arn: String?
    public let name: String?
    public let capacityRegion: String?
    public let creationStatus: NamespaceStatus?
    public let identityStore: IdentityStore?
    public let requestId: String?
    public let status: Int
}

extension CreateNamespaceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case capacityRegion = "CapacityRegion"
        case creationStatus = "CreationStatus"
        case identityStore = "IdentityStore"
        case name = "Name"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let capacityRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .capacityRegion)
        capacityRegion = capacityRegionDecoded
        let creationStatusDecoded = try containerValues.decodeIfPresent(NamespaceStatus.self, forKey: .creationStatus)
        creationStatus = creationStatusDecoded
        let identityStoreDecoded = try containerValues.decodeIfPresent(IdentityStore.self, forKey: .identityStore)
        identityStore = identityStoreDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

public struct CreateTemplateAliasInputBodyMiddleware: Middleware {
    public let id: String = "CreateTemplateAliasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTemplateAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTemplateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTemplateAliasInput>
    public typealias MOutput = OperationOutput<CreateTemplateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTemplateAliasOutputError>
}

extension CreateTemplateAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTemplateAliasInput(aliasName: \(String(describing: aliasName)), awsAccountId: \(String(describing: awsAccountId)), templateId: \(String(describing: templateId)), templateVersionNumber: \(String(describing: templateVersionNumber)))"}
}

extension CreateTemplateAliasInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case templateVersionNumber = "TemplateVersionNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let templateVersionNumber = templateVersionNumber {
            try encodeContainer.encode(templateVersionNumber, forKey: .templateVersionNumber)
        }
    }
}

public struct CreateTemplateAliasInputHeadersMiddleware: Middleware {
    public let id: String = "CreateTemplateAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTemplateAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTemplateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTemplateAliasInput>
    public typealias MOutput = OperationOutput<CreateTemplateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTemplateAliasOutputError>
}

public struct CreateTemplateAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateTemplateAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTemplateAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTemplateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTemplateAliasInput>
    public typealias MOutput = OperationOutput<CreateTemplateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTemplateAliasOutputError>
}

public struct CreateTemplateAliasInput: Equatable {
    /// <p>The name that you want to give to the template alias that you're creating. Don't start the
    /// 			alias name with the <code>$</code> character. Alias names that start with <code>$</code>
    /// 			are reserved by QuickSight. </p>
    public let aliasName: String?
    /// <p>The ID of the AWS account that contains the template that you creating an alias for.</p>
    public let awsAccountId: String?
    /// <p>An ID for the template.</p>
    public let templateId: String?
    /// <p>The version number of the template.</p>
    public let templateVersionNumber: Int?

    public init (
        aliasName: String? = nil,
        awsAccountId: String? = nil,
        templateId: String? = nil,
        templateVersionNumber: Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.templateId = templateId
        self.templateVersionNumber = templateVersionNumber
    }
}

struct CreateTemplateAliasInputBody: Equatable {
    public let templateVersionNumber: Int?
}

extension CreateTemplateAliasInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case templateVersionNumber = "TemplateVersionNumber"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateVersionNumberDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .templateVersionNumber)
        templateVersionNumber = templateVersionNumberDecoded
    }
}

extension CreateTemplateAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTemplateAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTemplateAliasOutputError: Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTemplateAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTemplateAliasOutputResponse(requestId: \(String(describing: requestId)), status: \(String(describing: status)), templateAlias: \(String(describing: templateAlias)))"}
}

extension CreateTemplateAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateTemplateAliasOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.requestId = output.requestId
            self.templateAlias = output.templateAlias
        } else {
            self.requestId = nil
            self.templateAlias = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateTemplateAliasOutputResponse: Equatable {
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>Information about the template alias.</p>
    public let templateAlias: TemplateAlias?

    public init (
        requestId: String? = nil,
        status: Int = 0,
        templateAlias: TemplateAlias? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.templateAlias = templateAlias
    }
}

struct CreateTemplateAliasOutputResponseBody: Equatable {
    public let templateAlias: TemplateAlias?
    public let status: Int
    public let requestId: String?
}

extension CreateTemplateAliasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case templateAlias = "TemplateAlias"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateAliasDecoded = try containerValues.decodeIfPresent(TemplateAlias.self, forKey: .templateAlias)
        templateAlias = templateAliasDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

public struct CreateTemplateInputBodyMiddleware: Middleware {
    public let id: String = "CreateTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTemplateInput>
    public typealias MOutput = OperationOutput<CreateTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTemplateOutputError>
}

extension CreateTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTemplateInput(awsAccountId: \(String(describing: awsAccountId)), name: \(String(describing: name)), permissions: \(String(describing: permissions)), sourceEntity: \(String(describing: sourceEntity)), tags: \(String(describing: tags)), templateId: \(String(describing: templateId)), versionDescription: \(String(describing: versionDescription)))"}
}

extension CreateTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case permissions = "Permissions"
        case sourceEntity = "SourceEntity"
        case tags = "Tags"
        case versionDescription = "VersionDescription"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for resourcepermissionlist0 in permissions {
                try permissionsContainer.encode(resourcepermissionlist0)
            }
        }
        if let sourceEntity = sourceEntity {
            try encodeContainer.encode(sourceEntity, forKey: .sourceEntity)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let versionDescription = versionDescription {
            try encodeContainer.encode(versionDescription, forKey: .versionDescription)
        }
    }
}

public struct CreateTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "CreateTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTemplateInput>
    public typealias MOutput = OperationOutput<CreateTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTemplateOutputError>
}

public struct CreateTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTemplateInput>
    public typealias MOutput = OperationOutput<CreateTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTemplateOutputError>
}

public struct CreateTemplateInput: Equatable {
    /// <p>The ID for the AWS account that the group is in. Currently, you use the ID for the AWS
    /// 			account that contains your Amazon QuickSight account.</p>
    public let awsAccountId: String?
    /// <p>A display name for the template.</p>
    public let name: String?
    /// <p>A list of resource permissions to be set on the template. </p>
    public let permissions: [ResourcePermission]?
    /// <p>The entity that you are using as a source when you create the template. In
    /// 			<code>SourceEntity</code>, you specify the type of object you're using as source:
    /// 			<code>SourceTemplate</code> for a template or <code>SourceAnalysis</code> for an
    /// 			analysis. Both of these require an Amazon Resource Name (ARN). For
    /// 			<code>SourceTemplate</code>, specify the ARN of the source template. For
    /// 			<code>SourceAnalysis</code>, specify the ARN of the source analysis. The <code>SourceTemplate</code>
    /// 			ARN can contain any AWS Account and any QuickSight-supported AWS Region. </p>
    /// 		       <p>Use the <code>DataSetReferences</code> entity within <code>SourceTemplate</code> or
    /// 			<code>SourceAnalysis</code> to list the replacement datasets for the placeholders listed
    /// 			in the original. The schema in each dataset must match its placeholder. </p>
    public let sourceEntity: TemplateSourceEntity?
    /// <p>Contains a map of the key-value pairs for the resource tag or tags assigned to the resource.</p>
    public let tags: [Tag]?
    /// <p>An ID for the template that you want to create. This template is unique per AWS Region in
    /// 			each AWS account.</p>
    public let templateId: String?
    /// <p>A description of the current template version being created. This API operation creates the
    /// 			first version of the template. Every time <code>UpdateTemplate</code> is called, a new
    /// 			version is created. Each version of the template maintains a description of the version
    /// 			in the <code>VersionDescription</code> field.</p>
    public let versionDescription: String?

    public init (
        awsAccountId: String? = nil,
        name: String? = nil,
        permissions: [ResourcePermission]? = nil,
        sourceEntity: TemplateSourceEntity? = nil,
        tags: [Tag]? = nil,
        templateId: String? = nil,
        versionDescription: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.name = name
        self.permissions = permissions
        self.sourceEntity = sourceEntity
        self.tags = tags
        self.templateId = templateId
        self.versionDescription = versionDescription
    }
}

struct CreateTemplateInputBody: Equatable {
    public let name: String?
    public let permissions: [ResourcePermission]?
    public let sourceEntity: TemplateSourceEntity?
    public let tags: [Tag]?
    public let versionDescription: String?
}

extension CreateTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case permissions = "Permissions"
        case sourceEntity = "SourceEntity"
        case tags = "Tags"
        case versionDescription = "VersionDescription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let sourceEntityDecoded = try containerValues.decodeIfPresent(TemplateSourceEntity.self, forKey: .sourceEntity)
        sourceEntity = sourceEntityDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let versionDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionDescription)
        versionDescription = versionDescriptionDecoded
    }
}

extension CreateTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTemplateOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTemplateOutputResponse(arn: \(String(describing: arn)), creationStatus: \(String(describing: creationStatus)), requestId: \(String(describing: requestId)), status: \(String(describing: status)), templateId: \(String(describing: templateId)), versionArn: \(String(describing: versionArn)))"}
}

extension CreateTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationStatus = output.creationStatus
            self.requestId = output.requestId
            self.templateId = output.templateId
            self.versionArn = output.versionArn
        } else {
            self.arn = nil
            self.creationStatus = nil
            self.requestId = nil
            self.templateId = nil
            self.versionArn = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateTemplateOutputResponse: Equatable {
    /// <p>The ARN for the template.</p>
    public let arn: String?
    /// <p>The template creation status.</p>
    public let creationStatus: ResourceStatus?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>The ID of the template.</p>
    public let templateId: String?
    /// <p>The ARN for the template, including the version information of
    /// 			the first version.</p>
    public let versionArn: String?

    public init (
        arn: String? = nil,
        creationStatus: ResourceStatus? = nil,
        requestId: String? = nil,
        status: Int = 0,
        templateId: String? = nil,
        versionArn: String? = nil
    )
    {
        self.arn = arn
        self.creationStatus = creationStatus
        self.requestId = requestId
        self.status = status
        self.templateId = templateId
        self.versionArn = versionArn
    }
}

struct CreateTemplateOutputResponseBody: Equatable {
    public let arn: String?
    public let versionArn: String?
    public let templateId: String?
    public let creationStatus: ResourceStatus?
    public let status: Int
    public let requestId: String?
}

extension CreateTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationStatus = "CreationStatus"
        case requestId = "RequestId"
        case status = "Status"
        case templateId = "TemplateId"
        case versionArn = "VersionArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let versionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionArn)
        versionArn = versionArnDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let creationStatusDecoded = try containerValues.decodeIfPresent(ResourceStatus.self, forKey: .creationStatus)
        creationStatus = creationStatusDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

public struct CreateThemeAliasInputBodyMiddleware: Middleware {
    public let id: String = "CreateThemeAliasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateThemeAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateThemeAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateThemeAliasInput>
    public typealias MOutput = OperationOutput<CreateThemeAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateThemeAliasOutputError>
}

extension CreateThemeAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateThemeAliasInput(aliasName: \(String(describing: aliasName)), awsAccountId: \(String(describing: awsAccountId)), themeId: \(String(describing: themeId)), themeVersionNumber: \(String(describing: themeVersionNumber)))"}
}

extension CreateThemeAliasInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case themeVersionNumber = "ThemeVersionNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let themeVersionNumber = themeVersionNumber {
            try encodeContainer.encode(themeVersionNumber, forKey: .themeVersionNumber)
        }
    }
}

public struct CreateThemeAliasInputHeadersMiddleware: Middleware {
    public let id: String = "CreateThemeAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateThemeAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateThemeAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateThemeAliasInput>
    public typealias MOutput = OperationOutput<CreateThemeAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateThemeAliasOutputError>
}

public struct CreateThemeAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateThemeAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateThemeAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateThemeAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateThemeAliasInput>
    public typealias MOutput = OperationOutput<CreateThemeAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateThemeAliasOutputError>
}

public struct CreateThemeAliasInput: Equatable {
    /// <p>The name that you want to give to the theme alias that you are creating. The
    /// 			alias name can't begin with a <code>$</code>. Alias names that start with <code>$</code>
    /// 			are reserved by Amazon QuickSight. </p>
    public let aliasName: String?
    /// <p>The ID of the AWS account that contains the theme for the new theme alias.</p>
    public let awsAccountId: String?
    /// <p>An ID for the theme alias.</p>
    public let themeId: String?
    /// <p>The version number of the theme.</p>
    public let themeVersionNumber: Int?

    public init (
        aliasName: String? = nil,
        awsAccountId: String? = nil,
        themeId: String? = nil,
        themeVersionNumber: Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.themeId = themeId
        self.themeVersionNumber = themeVersionNumber
    }
}

struct CreateThemeAliasInputBody: Equatable {
    public let themeVersionNumber: Int?
}

extension CreateThemeAliasInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case themeVersionNumber = "ThemeVersionNumber"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeVersionNumberDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .themeVersionNumber)
        themeVersionNumber = themeVersionNumberDecoded
    }
}

extension CreateThemeAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateThemeAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateThemeAliasOutputError: Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateThemeAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateThemeAliasOutputResponse(requestId: \(String(describing: requestId)), status: \(String(describing: status)), themeAlias: \(String(describing: themeAlias)))"}
}

extension CreateThemeAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateThemeAliasOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.requestId = output.requestId
            self.themeAlias = output.themeAlias
        } else {
            self.requestId = nil
            self.themeAlias = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateThemeAliasOutputResponse: Equatable {
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>Information about the theme alias.</p>
    public let themeAlias: ThemeAlias?

    public init (
        requestId: String? = nil,
        status: Int = 0,
        themeAlias: ThemeAlias? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.themeAlias = themeAlias
    }
}

struct CreateThemeAliasOutputResponseBody: Equatable {
    public let themeAlias: ThemeAlias?
    public let status: Int
    public let requestId: String?
}

extension CreateThemeAliasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case themeAlias = "ThemeAlias"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeAliasDecoded = try containerValues.decodeIfPresent(ThemeAlias.self, forKey: .themeAlias)
        themeAlias = themeAliasDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

public struct CreateThemeInputBodyMiddleware: Middleware {
    public let id: String = "CreateThemeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateThemeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateThemeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateThemeInput>
    public typealias MOutput = OperationOutput<CreateThemeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateThemeOutputError>
}

extension CreateThemeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateThemeInput(awsAccountId: \(String(describing: awsAccountId)), baseThemeId: \(String(describing: baseThemeId)), configuration: \(String(describing: configuration)), name: \(String(describing: name)), permissions: \(String(describing: permissions)), tags: \(String(describing: tags)), themeId: \(String(describing: themeId)), versionDescription: \(String(describing: versionDescription)))"}
}

extension CreateThemeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case baseThemeId = "BaseThemeId"
        case configuration = "Configuration"
        case name = "Name"
        case permissions = "Permissions"
        case tags = "Tags"
        case versionDescription = "VersionDescription"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseThemeId = baseThemeId {
            try encodeContainer.encode(baseThemeId, forKey: .baseThemeId)
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for resourcepermissionlist0 in permissions {
                try permissionsContainer.encode(resourcepermissionlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let versionDescription = versionDescription {
            try encodeContainer.encode(versionDescription, forKey: .versionDescription)
        }
    }
}

public struct CreateThemeInputHeadersMiddleware: Middleware {
    public let id: String = "CreateThemeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateThemeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateThemeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateThemeInput>
    public typealias MOutput = OperationOutput<CreateThemeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateThemeOutputError>
}

public struct CreateThemeInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateThemeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateThemeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateThemeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateThemeInput>
    public typealias MOutput = OperationOutput<CreateThemeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateThemeOutputError>
}

public struct CreateThemeInput: Equatable {
    /// <p>The ID of the AWS account where you want to store the new theme. </p>
    public let awsAccountId: String?
    /// <p>The ID of the theme that a custom theme will inherit from. All themes inherit from one of
    /// 			the starting themes defined by Amazon QuickSight. For a list of the starting themes, use
    /// 				<code>ListThemes</code> or choose <b>Themes</b> from
    /// 			within a QuickSight analysis. </p>
    public let baseThemeId: String?
    /// <p>The theme configuration, which contains the theme display properties.</p>
    public let configuration: ThemeConfiguration?
    /// <p>A display name for the theme.</p>
    public let name: String?
    /// <p>A valid grouping of resource permissions to apply to the new theme.
    /// 			</p>
    public let permissions: [ResourcePermission]?
    /// <p>A map of the key-value pairs for the resource tag or tags that you want to add to the
    /// 			resource.</p>
    public let tags: [Tag]?
    /// <p>An ID for the theme that you want to create. The theme ID is unique per AWS Region in
    /// 			each AWS account.</p>
    public let themeId: String?
    /// <p>A description of the first version of the theme that you're creating. Every time
    /// 				<code>UpdateTheme</code> is called, a new version is created. Each version of the
    /// 			theme has a description of the version in the <code>VersionDescription</code>
    /// 			field.</p>
    public let versionDescription: String?

    public init (
        awsAccountId: String? = nil,
        baseThemeId: String? = nil,
        configuration: ThemeConfiguration? = nil,
        name: String? = nil,
        permissions: [ResourcePermission]? = nil,
        tags: [Tag]? = nil,
        themeId: String? = nil,
        versionDescription: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.baseThemeId = baseThemeId
        self.configuration = configuration
        self.name = name
        self.permissions = permissions
        self.tags = tags
        self.themeId = themeId
        self.versionDescription = versionDescription
    }
}

struct CreateThemeInputBody: Equatable {
    public let name: String?
    public let baseThemeId: String?
    public let versionDescription: String?
    public let configuration: ThemeConfiguration?
    public let permissions: [ResourcePermission]?
    public let tags: [Tag]?
}

extension CreateThemeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case baseThemeId = "BaseThemeId"
        case configuration = "Configuration"
        case name = "Name"
        case permissions = "Permissions"
        case tags = "Tags"
        case versionDescription = "VersionDescription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let baseThemeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baseThemeId)
        baseThemeId = baseThemeIdDecoded
        let versionDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionDescription)
        versionDescription = versionDescriptionDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(ThemeConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateThemeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateThemeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateThemeOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateThemeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateThemeOutputResponse(arn: \(String(describing: arn)), creationStatus: \(String(describing: creationStatus)), requestId: \(String(describing: requestId)), status: \(String(describing: status)), themeId: \(String(describing: themeId)), versionArn: \(String(describing: versionArn)))"}
}

extension CreateThemeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateThemeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationStatus = output.creationStatus
            self.requestId = output.requestId
            self.themeId = output.themeId
            self.versionArn = output.versionArn
        } else {
            self.arn = nil
            self.creationStatus = nil
            self.requestId = nil
            self.themeId = nil
            self.versionArn = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateThemeOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the theme.</p>
    public let arn: String?
    /// <p>The theme creation status.</p>
    public let creationStatus: ResourceStatus?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>The ID of the theme.</p>
    public let themeId: String?
    /// <p>The Amazon Resource Name (ARN) for the new theme.</p>
    public let versionArn: String?

    public init (
        arn: String? = nil,
        creationStatus: ResourceStatus? = nil,
        requestId: String? = nil,
        status: Int = 0,
        themeId: String? = nil,
        versionArn: String? = nil
    )
    {
        self.arn = arn
        self.creationStatus = creationStatus
        self.requestId = requestId
        self.status = status
        self.themeId = themeId
        self.versionArn = versionArn
    }
}

struct CreateThemeOutputResponseBody: Equatable {
    public let arn: String?
    public let versionArn: String?
    public let themeId: String?
    public let creationStatus: ResourceStatus?
    public let status: Int
    public let requestId: String?
}

extension CreateThemeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationStatus = "CreationStatus"
        case requestId = "RequestId"
        case status = "Status"
        case themeId = "ThemeId"
        case versionArn = "VersionArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let versionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionArn)
        versionArn = versionArnDecoded
        let themeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .themeId)
        themeId = themeIdDecoded
        let creationStatusDecoded = try containerValues.decodeIfPresent(ResourceStatus.self, forKey: .creationStatus)
        creationStatus = creationStatusDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension CredentialPair: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alternateDataSourceParameters = "AlternateDataSourceParameters"
        case password = "Password"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alternateDataSourceParameters = alternateDataSourceParameters {
            var alternateDataSourceParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .alternateDataSourceParameters)
            for datasourceparameterslist0 in alternateDataSourceParameters {
                try alternateDataSourceParametersContainer.encode(datasourceparameterslist0)
            }
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let alternateDataSourceParametersContainer = try containerValues.decodeIfPresent([DataSourceParameters?].self, forKey: .alternateDataSourceParameters)
        var alternateDataSourceParametersDecoded0:[DataSourceParameters]? = nil
        if let alternateDataSourceParametersContainer = alternateDataSourceParametersContainer {
            alternateDataSourceParametersDecoded0 = [DataSourceParameters]()
            for union0 in alternateDataSourceParametersContainer {
                if let union0 = union0 {
                    alternateDataSourceParametersDecoded0?.append(union0)
                }
            }
        }
        alternateDataSourceParameters = alternateDataSourceParametersDecoded0
    }
}

extension CredentialPair: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CredentialPair(alternateDataSourceParameters: \(String(describing: alternateDataSourceParameters)), password: \(String(describing: password)), username: \(String(describing: username)))"}
}

/// <p>The combination of user name and password that are used as credentials.</p>
public struct CredentialPair: Equatable {
    /// <p>A set of alternate data source parameters that you want to share for these
    ///             credentials. The credentials are applied in tandem with the data source parameters when
    ///             you copy a data source by using a create or update request. The API operation compares
    ///             the <code>DataSourceParameters</code> structure that's in the request with the
    ///             structures in the <code>AlternateDataSourceParameters</code> allow list. If the
    ///             structures are an exact match, the request is allowed to use the new data source with
    ///             the existing credentials. If the <code>AlternateDataSourceParameters</code> list is
    ///             null, the <code>DataSourceParameters</code> originally used with these
    ///                 <code>Credentials</code> is automatically allowed.</p>
    public let alternateDataSourceParameters: [DataSourceParameters]?
    /// <p>Password.</p>
    public let password: String?
    /// <p>User name.</p>
    public let username: String?

    public init (
        alternateDataSourceParameters: [DataSourceParameters]? = nil,
        password: String? = nil,
        username: String? = nil
    )
    {
        self.alternateDataSourceParameters = alternateDataSourceParameters
        self.password = password
        self.username = username
    }
}

extension CustomSql: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case columns = "Columns"
        case dataSourceArn = "DataSourceArn"
        case name = "Name"
        case sqlQuery = "SqlQuery"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columns = columns {
            var columnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columns)
            for inputcolumnlist0 in columns {
                try columnsContainer.encode(inputcolumnlist0)
            }
        }
        if let dataSourceArn = dataSourceArn {
            try encodeContainer.encode(dataSourceArn, forKey: .dataSourceArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sqlQuery = sqlQuery {
            try encodeContainer.encode(sqlQuery, forKey: .sqlQuery)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSourceArn)
        dataSourceArn = dataSourceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let sqlQueryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sqlQuery)
        sqlQuery = sqlQueryDecoded
        let columnsContainer = try containerValues.decodeIfPresent([InputColumn?].self, forKey: .columns)
        var columnsDecoded0:[InputColumn]? = nil
        if let columnsContainer = columnsContainer {
            columnsDecoded0 = [InputColumn]()
            for structure0 in columnsContainer {
                if let structure0 = structure0 {
                    columnsDecoded0?.append(structure0)
                }
            }
        }
        columns = columnsDecoded0
    }
}

extension CustomSql: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomSql(columns: \(String(describing: columns)), dataSourceArn: \(String(describing: dataSourceArn)), name: \(String(describing: name)), sqlQuery: \(String(describing: sqlQuery)))"}
}

/// <p>A physical table type built from the results of the custom SQL query.</p>
public struct CustomSql: Equatable {
    /// <p>The column schema from the SQL query result set.</p>
    public let columns: [InputColumn]?
    /// <p>The Amazon Resource Name (ARN) of the data source.</p>
    public let dataSourceArn: String?
    /// <p>A display name for the SQL query result.</p>
    public let name: String?
    /// <p>The SQL query.</p>
    public let sqlQuery: String?

    public init (
        columns: [InputColumn]? = nil,
        dataSourceArn: String? = nil,
        name: String? = nil,
        sqlQuery: String? = nil
    )
    {
        self.columns = columns
        self.dataSourceArn = dataSourceArn
        self.name = name
        self.sqlQuery = sqlQuery
    }
}

extension Dashboard: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case dashboardId = "DashboardId"
        case lastPublishedTime = "LastPublishedTime"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let dashboardId = dashboardId {
            try encodeContainer.encode(dashboardId, forKey: .dashboardId)
        }
        if let lastPublishedTime = lastPublishedTime {
            try encodeContainer.encode(lastPublishedTime.timeIntervalSince1970, forKey: .lastPublishedTime)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(DashboardVersion.self, forKey: .version)
        version = versionDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastPublishedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastPublishedTime)
        lastPublishedTime = lastPublishedTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension Dashboard: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Dashboard(arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), dashboardId: \(String(describing: dashboardId)), lastPublishedTime: \(String(describing: lastPublishedTime)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), name: \(String(describing: name)), version: \(String(describing: version)))"}
}

/// <p>Dashboard.</p>
public struct Dashboard: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let arn: String?
    /// <p>The time that this dataset was created.</p>
    public let createdTime: Date?
    /// <p>Dashboard ID.</p>
    public let dashboardId: String?
    /// <p>The last time that this dataset was published.</p>
    public let lastPublishedTime: Date?
    /// <p>The last time that this dataset was updated.</p>
    public let lastUpdatedTime: Date?
    /// <p>A display name for the dashboard.</p>
    public let name: String?
    /// <p>Version.</p>
    public let version: DashboardVersion?

    public init (
        arn: String? = nil,
        createdTime: Date? = nil,
        dashboardId: String? = nil,
        lastPublishedTime: Date? = nil,
        lastUpdatedTime: Date? = nil,
        name: String? = nil,
        version: DashboardVersion? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.dashboardId = dashboardId
        self.lastPublishedTime = lastPublishedTime
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.version = version
    }
}

public enum DashboardBehavior {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension DashboardBehavior : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DashboardBehavior] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DashboardBehavior(rawValue: rawValue) ?? DashboardBehavior.sdkUnknown(rawValue)
    }
}

extension DashboardError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(DashboardErrorType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DashboardError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DashboardError(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

/// <p>Dashboard error.</p>
public struct DashboardError: Equatable {
    /// <p>Message.</p>
    public let message: String?
    /// <p>Type.</p>
    public let type: DashboardErrorType?

    public init (
        message: String? = nil,
        type: DashboardErrorType? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

public enum DashboardErrorType {
    case accessDenied
    case columnGeographicRoleMismatch
    case columnReplacementMissing
    case columnTypeMismatch
    case dataSetNotFound
    case internalFailure
    case parameterNotFound
    case parameterTypeInvalid
    case parameterValueIncompatible
    case sourceNotFound
    case sdkUnknown(String)
}

extension DashboardErrorType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DashboardErrorType] {
        return [
            .accessDenied,
            .columnGeographicRoleMismatch,
            .columnReplacementMissing,
            .columnTypeMismatch,
            .dataSetNotFound,
            .internalFailure,
            .parameterNotFound,
            .parameterTypeInvalid,
            .parameterValueIncompatible,
            .sourceNotFound,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accessDenied: return "ACCESS_DENIED"
        case .columnGeographicRoleMismatch: return "COLUMN_GEOGRAPHIC_ROLE_MISMATCH"
        case .columnReplacementMissing: return "COLUMN_REPLACEMENT_MISSING"
        case .columnTypeMismatch: return "COLUMN_TYPE_MISMATCH"
        case .dataSetNotFound: return "DATA_SET_NOT_FOUND"
        case .internalFailure: return "INTERNAL_FAILURE"
        case .parameterNotFound: return "PARAMETER_NOT_FOUND"
        case .parameterTypeInvalid: return "PARAMETER_TYPE_INVALID"
        case .parameterValueIncompatible: return "PARAMETER_VALUE_INCOMPATIBLE"
        case .sourceNotFound: return "SOURCE_NOT_FOUND"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DashboardErrorType(rawValue: rawValue) ?? DashboardErrorType.sdkUnknown(rawValue)
    }
}

public enum DashboardFilterAttribute {
    case quicksightUser
    case sdkUnknown(String)
}

extension DashboardFilterAttribute : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DashboardFilterAttribute] {
        return [
            .quicksightUser,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .quicksightUser: return "QUICKSIGHT_USER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DashboardFilterAttribute(rawValue: rawValue) ?? DashboardFilterAttribute.sdkUnknown(rawValue)
    }
}

extension DashboardPublishOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adHocFilteringOption = "AdHocFilteringOption"
        case exportToCSVOption = "ExportToCSVOption"
        case sheetControlsOption = "SheetControlsOption"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adHocFilteringOption = adHocFilteringOption {
            try encodeContainer.encode(adHocFilteringOption, forKey: .adHocFilteringOption)
        }
        if let exportToCSVOption = exportToCSVOption {
            try encodeContainer.encode(exportToCSVOption, forKey: .exportToCSVOption)
        }
        if let sheetControlsOption = sheetControlsOption {
            try encodeContainer.encode(sheetControlsOption, forKey: .sheetControlsOption)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adHocFilteringOptionDecoded = try containerValues.decodeIfPresent(AdHocFilteringOption.self, forKey: .adHocFilteringOption)
        adHocFilteringOption = adHocFilteringOptionDecoded
        let exportToCSVOptionDecoded = try containerValues.decodeIfPresent(ExportToCSVOption.self, forKey: .exportToCSVOption)
        exportToCSVOption = exportToCSVOptionDecoded
        let sheetControlsOptionDecoded = try containerValues.decodeIfPresent(SheetControlsOption.self, forKey: .sheetControlsOption)
        sheetControlsOption = sheetControlsOptionDecoded
    }
}

extension DashboardPublishOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DashboardPublishOptions(adHocFilteringOption: \(String(describing: adHocFilteringOption)), exportToCSVOption: \(String(describing: exportToCSVOption)), sheetControlsOption: \(String(describing: sheetControlsOption)))"}
}

/// <p>Dashboard publish options.</p>
public struct DashboardPublishOptions: Equatable {
    /// <p>Ad hoc (one-time) filtering option.</p>
    public let adHocFilteringOption: AdHocFilteringOption?
    /// <p>Export to .csv option.</p>
    public let exportToCSVOption: ExportToCSVOption?
    /// <p>Sheet controls option.</p>
    public let sheetControlsOption: SheetControlsOption?

    public init (
        adHocFilteringOption: AdHocFilteringOption? = nil,
        exportToCSVOption: ExportToCSVOption? = nil,
        sheetControlsOption: SheetControlsOption? = nil
    )
    {
        self.adHocFilteringOption = adHocFilteringOption
        self.exportToCSVOption = exportToCSVOption
        self.sheetControlsOption = sheetControlsOption
    }
}

extension DashboardSearchFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case `operator` = "Operator"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operatorDecoded = try containerValues.decodeIfPresent(FilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let nameDecoded = try containerValues.decodeIfPresent(DashboardFilterAttribute.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension DashboardSearchFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DashboardSearchFilter(name: \(String(describing: name)), operator: \(String(describing: `operator`)), value: \(String(describing: value)))"}
}

/// <p>A filter that you apply when searching for dashboards. </p>
public struct DashboardSearchFilter: Equatable {
    /// <p>The comparison operator that you want to use as a filter, for example,
    ///             <code>"Operator": "StringEquals"</code>.</p>
    public let `operator`: FilterOperator?
    /// <p>The name of the value that you want to use as a filter, for example, <code>"Name":
    ///             "QUICKSIGHT_USER"</code>. </p>
    public let name: DashboardFilterAttribute?
    /// <p>The value of the named item, in this case <code>QUICKSIGHT_USER</code>, that you want
    ///             to use as a filter, for example, <code>"Value":
    ///             "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>. </p>
    public let value: String?

    public init (
        `operator`: FilterOperator? = nil,
        name: DashboardFilterAttribute? = nil,
        value: String? = nil
    )
    {
        self.`operator` = `operator`
        self.name = name
        self.value = value
    }
}

extension DashboardSourceEntity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sourceTemplate = "SourceTemplate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceTemplate = sourceTemplate {
            try encodeContainer.encode(sourceTemplate, forKey: .sourceTemplate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTemplateDecoded = try containerValues.decodeIfPresent(DashboardSourceTemplate.self, forKey: .sourceTemplate)
        sourceTemplate = sourceTemplateDecoded
    }
}

extension DashboardSourceEntity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DashboardSourceEntity(sourceTemplate: \(String(describing: sourceTemplate)))"}
}

/// <p>Dashboard source entity.</p>
public struct DashboardSourceEntity: Equatable {
    /// <p>Source template.</p>
    public let sourceTemplate: DashboardSourceTemplate?

    public init (
        sourceTemplate: DashboardSourceTemplate? = nil
    )
    {
        self.sourceTemplate = sourceTemplate
    }
}

extension DashboardSourceTemplate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case dataSetReferences = "DataSetReferences"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dataSetReferences = dataSetReferences {
            var dataSetReferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSetReferences)
            for datasetreferencelist0 in dataSetReferences {
                try dataSetReferencesContainer.encode(datasetreferencelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetReferencesContainer = try containerValues.decodeIfPresent([DataSetReference?].self, forKey: .dataSetReferences)
        var dataSetReferencesDecoded0:[DataSetReference]? = nil
        if let dataSetReferencesContainer = dataSetReferencesContainer {
            dataSetReferencesDecoded0 = [DataSetReference]()
            for structure0 in dataSetReferencesContainer {
                if let structure0 = structure0 {
                    dataSetReferencesDecoded0?.append(structure0)
                }
            }
        }
        dataSetReferences = dataSetReferencesDecoded0
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DashboardSourceTemplate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DashboardSourceTemplate(arn: \(String(describing: arn)), dataSetReferences: \(String(describing: dataSetReferences)))"}
}

/// <p>Dashboard source template.</p>
public struct DashboardSourceTemplate: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let arn: String?
    /// <p>Dataset references.</p>
    public let dataSetReferences: [DataSetReference]?

    public init (
        arn: String? = nil,
        dataSetReferences: [DataSetReference]? = nil
    )
    {
        self.arn = arn
        self.dataSetReferences = dataSetReferences
    }
}

extension DashboardSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case dashboardId = "DashboardId"
        case lastPublishedTime = "LastPublishedTime"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case publishedVersionNumber = "PublishedVersionNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let dashboardId = dashboardId {
            try encodeContainer.encode(dashboardId, forKey: .dashboardId)
        }
        if let lastPublishedTime = lastPublishedTime {
            try encodeContainer.encode(lastPublishedTime.timeIntervalSince1970, forKey: .lastPublishedTime)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let publishedVersionNumber = publishedVersionNumber {
            try encodeContainer.encode(publishedVersionNumber, forKey: .publishedVersionNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let dashboardIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let publishedVersionNumberDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .publishedVersionNumber)
        publishedVersionNumber = publishedVersionNumberDecoded
        let lastPublishedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastPublishedTime)
        lastPublishedTime = lastPublishedTimeDecoded
    }
}

extension DashboardSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DashboardSummary(arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), dashboardId: \(String(describing: dashboardId)), lastPublishedTime: \(String(describing: lastPublishedTime)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), name: \(String(describing: name)), publishedVersionNumber: \(String(describing: publishedVersionNumber)))"}
}

/// <p>Dashboard summary.</p>
public struct DashboardSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let arn: String?
    /// <p>The time that this dashboard was created.</p>
    public let createdTime: Date?
    /// <p>Dashboard ID.</p>
    public let dashboardId: String?
    /// <p>The last time that this dashboard was published.</p>
    public let lastPublishedTime: Date?
    /// <p>The last time that this dashboard was updated.</p>
    public let lastUpdatedTime: Date?
    /// <p>A display name for the dashboard.</p>
    public let name: String?
    /// <p>Published version number.</p>
    public let publishedVersionNumber: Int?

    public init (
        arn: String? = nil,
        createdTime: Date? = nil,
        dashboardId: String? = nil,
        lastPublishedTime: Date? = nil,
        lastUpdatedTime: Date? = nil,
        name: String? = nil,
        publishedVersionNumber: Int? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.dashboardId = dashboardId
        self.lastPublishedTime = lastPublishedTime
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.publishedVersionNumber = publishedVersionNumber
    }
}

public enum DashboardUIState {
    case collapsed
    case expanded
    case sdkUnknown(String)
}

extension DashboardUIState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DashboardUIState] {
        return [
            .collapsed,
            .expanded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .collapsed: return "COLLAPSED"
        case .expanded: return "EXPANDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DashboardUIState(rawValue: rawValue) ?? DashboardUIState.sdkUnknown(rawValue)
    }
}

extension DashboardVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case dataSetArns = "DataSetArns"
        case description = "Description"
        case errors = "Errors"
        case sheets = "Sheets"
        case sourceEntityArn = "SourceEntityArn"
        case status = "Status"
        case themeArn = "ThemeArn"
        case versionNumber = "VersionNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let dataSetArns = dataSetArns {
            var dataSetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSetArns)
            for datasetarnslist0 in dataSetArns {
                try dataSetArnsContainer.encode(datasetarnslist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let errors = errors {
            var errorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errors)
            for dashboarderrorlist0 in errors {
                try errorsContainer.encode(dashboarderrorlist0)
            }
        }
        if let sheets = sheets {
            var sheetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sheets)
            for sheetlist0 in sheets {
                try sheetsContainer.encode(sheetlist0)
            }
        }
        if let sourceEntityArn = sourceEntityArn {
            try encodeContainer.encode(sourceEntityArn, forKey: .sourceEntityArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let themeArn = themeArn {
            try encodeContainer.encode(themeArn, forKey: .themeArn)
        }
        if let versionNumber = versionNumber {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let errorsContainer = try containerValues.decodeIfPresent([DashboardError?].self, forKey: .errors)
        var errorsDecoded0:[DashboardError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [DashboardError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let versionNumberDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResourceStatus.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let sourceEntityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceEntityArn)
        sourceEntityArn = sourceEntityArnDecoded
        let dataSetArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .dataSetArns)
        var dataSetArnsDecoded0:[String]? = nil
        if let dataSetArnsContainer = dataSetArnsContainer {
            dataSetArnsDecoded0 = [String]()
            for string0 in dataSetArnsContainer {
                if let string0 = string0 {
                    dataSetArnsDecoded0?.append(string0)
                }
            }
        }
        dataSetArns = dataSetArnsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let themeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .themeArn)
        themeArn = themeArnDecoded
        let sheetsContainer = try containerValues.decodeIfPresent([Sheet?].self, forKey: .sheets)
        var sheetsDecoded0:[Sheet]? = nil
        if let sheetsContainer = sheetsContainer {
            sheetsDecoded0 = [Sheet]()
            for structure0 in sheetsContainer {
                if let structure0 = structure0 {
                    sheetsDecoded0?.append(structure0)
                }
            }
        }
        sheets = sheetsDecoded0
    }
}

extension DashboardVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DashboardVersion(arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), dataSetArns: \(String(describing: dataSetArns)), description: \(String(describing: description)), errors: \(String(describing: errors)), sheets: \(String(describing: sheets)), sourceEntityArn: \(String(describing: sourceEntityArn)), status: \(String(describing: status)), themeArn: \(String(describing: themeArn)), versionNumber: \(String(describing: versionNumber)))"}
}

/// <p>Dashboard version.</p>
public struct DashboardVersion: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let arn: String?
    /// <p>The time that this dashboard version was created.</p>
    public let createdTime: Date?
    /// <p>The Amazon Resource Numbers (ARNs) for the datasets that are associated with this
    ///             version of the dashboard.</p>
    public let dataSetArns: [String]?
    /// <p>Description.</p>
    public let description: String?
    /// <p>Errors associated with this dashboard version.</p>
    public let errors: [DashboardError]?
    /// <p>A list of the associated sheets with the unique identifier and name of each sheet.</p>
    public let sheets: [Sheet]?
    /// <p>Source entity ARN.</p>
    public let sourceEntityArn: String?
    /// <p>The HTTP status of the request.</p>
    public let status: ResourceStatus?
    /// <p>The ARN of the theme associated with a version of the dashboard.</p>
    public let themeArn: String?
    /// <p>Version number for this version of the dashboard.</p>
    public let versionNumber: Int?

    public init (
        arn: String? = nil,
        createdTime: Date? = nil,
        dataSetArns: [String]? = nil,
        description: String? = nil,
        errors: [DashboardError]? = nil,
        sheets: [Sheet]? = nil,
        sourceEntityArn: String? = nil,
        status: ResourceStatus? = nil,
        themeArn: String? = nil,
        versionNumber: Int? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.dataSetArns = dataSetArns
        self.description = description
        self.errors = errors
        self.sheets = sheets
        self.sourceEntityArn = sourceEntityArn
        self.status = status
        self.themeArn = themeArn
        self.versionNumber = versionNumber
    }
}

extension DashboardVersionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case sourceEntityArn = "SourceEntityArn"
        case status = "Status"
        case versionNumber = "VersionNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let sourceEntityArn = sourceEntityArn {
            try encodeContainer.encode(sourceEntityArn, forKey: .sourceEntityArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let versionNumber = versionNumber {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let versionNumberDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResourceStatus.self, forKey: .status)
        status = statusDecoded
        let sourceEntityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceEntityArn)
        sourceEntityArn = sourceEntityArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension DashboardVersionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DashboardVersionSummary(arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), description: \(String(describing: description)), sourceEntityArn: \(String(describing: sourceEntityArn)), status: \(String(describing: status)), versionNumber: \(String(describing: versionNumber)))"}
}

/// <p>Dashboard version summary.</p>
public struct DashboardVersionSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let arn: String?
    /// <p>The time that this dashboard version was created.</p>
    public let createdTime: Date?
    /// <p>Description.</p>
    public let description: String?
    /// <p>Source entity ARN.</p>
    public let sourceEntityArn: String?
    /// <p>The HTTP status of the request.</p>
    public let status: ResourceStatus?
    /// <p>Version number.</p>
    public let versionNumber: Int?

    public init (
        arn: String? = nil,
        createdTime: Date? = nil,
        description: String? = nil,
        sourceEntityArn: String? = nil,
        status: ResourceStatus? = nil,
        versionNumber: Int? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.description = description
        self.sourceEntityArn = sourceEntityArn
        self.status = status
        self.versionNumber = versionNumber
    }
}

extension DataColorPalette: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case colors = "Colors"
        case emptyFillColor = "EmptyFillColor"
        case minMaxGradient = "MinMaxGradient"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let colors = colors {
            var colorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .colors)
            for colorlist0 in colors {
                try colorsContainer.encode(colorlist0)
            }
        }
        if let emptyFillColor = emptyFillColor {
            try encodeContainer.encode(emptyFillColor, forKey: .emptyFillColor)
        }
        if let minMaxGradient = minMaxGradient {
            var minMaxGradientContainer = encodeContainer.nestedUnkeyedContainer(forKey: .minMaxGradient)
            for colorlist0 in minMaxGradient {
                try minMaxGradientContainer.encode(colorlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let colorsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .colors)
        var colorsDecoded0:[String]? = nil
        if let colorsContainer = colorsContainer {
            colorsDecoded0 = [String]()
            for string0 in colorsContainer {
                if let string0 = string0 {
                    colorsDecoded0?.append(string0)
                }
            }
        }
        colors = colorsDecoded0
        let minMaxGradientContainer = try containerValues.decodeIfPresent([String?].self, forKey: .minMaxGradient)
        var minMaxGradientDecoded0:[String]? = nil
        if let minMaxGradientContainer = minMaxGradientContainer {
            minMaxGradientDecoded0 = [String]()
            for string0 in minMaxGradientContainer {
                if let string0 = string0 {
                    minMaxGradientDecoded0?.append(string0)
                }
            }
        }
        minMaxGradient = minMaxGradientDecoded0
        let emptyFillColorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emptyFillColor)
        emptyFillColor = emptyFillColorDecoded
    }
}

extension DataColorPalette: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataColorPalette(colors: \(String(describing: colors)), emptyFillColor: \(String(describing: emptyFillColor)), minMaxGradient: \(String(describing: minMaxGradient)))"}
}

/// <p>The theme colors that are used for data colors in charts. The colors description is a
///             hexadecimal color code that consists of six alphanumerical characters, prefixed with
///                 <code>#</code>, for example #37BFF5. </p>
public struct DataColorPalette: Equatable {
    /// <p>The hexadecimal codes for the colors.</p>
    public let colors: [String]?
    /// <p>The hexadecimal code of a color that applies to charts where a lack of data is
    ///             highlighted.</p>
    public let emptyFillColor: String?
    /// <p>The minimum and maximum hexadecimal codes that describe a color gradient. </p>
    public let minMaxGradient: [String]?

    public init (
        colors: [String]? = nil,
        emptyFillColor: String? = nil,
        minMaxGradient: [String]? = nil
    )
    {
        self.colors = colors
        self.emptyFillColor = emptyFillColor
        self.minMaxGradient = minMaxGradient
    }
}

extension DataSet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case columnGroups = "ColumnGroups"
        case columnLevelPermissionRules = "ColumnLevelPermissionRules"
        case consumedSpiceCapacityInBytes = "ConsumedSpiceCapacityInBytes"
        case createdTime = "CreatedTime"
        case dataSetId = "DataSetId"
        case fieldFolders = "FieldFolders"
        case importMode = "ImportMode"
        case lastUpdatedTime = "LastUpdatedTime"
        case logicalTableMap = "LogicalTableMap"
        case name = "Name"
        case outputColumns = "OutputColumns"
        case physicalTableMap = "PhysicalTableMap"
        case rowLevelPermissionDataSet = "RowLevelPermissionDataSet"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let columnGroups = columnGroups {
            var columnGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnGroups)
            for columngrouplist0 in columnGroups {
                try columnGroupsContainer.encode(columngrouplist0)
            }
        }
        if let columnLevelPermissionRules = columnLevelPermissionRules {
            var columnLevelPermissionRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnLevelPermissionRules)
            for columnlevelpermissionrulelist0 in columnLevelPermissionRules {
                try columnLevelPermissionRulesContainer.encode(columnlevelpermissionrulelist0)
            }
        }
        if consumedSpiceCapacityInBytes != 0 {
            try encodeContainer.encode(consumedSpiceCapacityInBytes, forKey: .consumedSpiceCapacityInBytes)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let fieldFolders = fieldFolders {
            var fieldFoldersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .fieldFolders)
            for (dictKey0, fieldfoldermap0) in fieldFolders {
                try fieldFoldersContainer.encode(fieldfoldermap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let importMode = importMode {
            try encodeContainer.encode(importMode.rawValue, forKey: .importMode)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let logicalTableMap = logicalTableMap {
            var logicalTableMapContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .logicalTableMap)
            for (dictKey0, logicaltablemap0) in logicalTableMap {
                try logicalTableMapContainer.encode(logicaltablemap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputColumns = outputColumns {
            var outputColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputColumns)
            for outputcolumnlist0 in outputColumns {
                try outputColumnsContainer.encode(outputcolumnlist0)
            }
        }
        if let physicalTableMap = physicalTableMap {
            var physicalTableMapContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .physicalTableMap)
            for (dictKey0, physicaltablemap0) in physicalTableMap {
                try physicalTableMapContainer.encode(physicaltablemap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let rowLevelPermissionDataSet = rowLevelPermissionDataSet {
            try encodeContainer.encode(rowLevelPermissionDataSet, forKey: .rowLevelPermissionDataSet)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let physicalTableMapContainer = try containerValues.decodeIfPresent([String: PhysicalTable?].self, forKey: .physicalTableMap)
        var physicalTableMapDecoded0: [String:PhysicalTable]? = nil
        if let physicalTableMapContainer = physicalTableMapContainer {
            physicalTableMapDecoded0 = [String:PhysicalTable]()
            for (key0, physicaltable0) in physicalTableMapContainer {
                if let physicaltable0 = physicaltable0 {
                    physicalTableMapDecoded0?[key0] = physicaltable0
                }
            }
        }
        physicalTableMap = physicalTableMapDecoded0
        let logicalTableMapContainer = try containerValues.decodeIfPresent([String: LogicalTable?].self, forKey: .logicalTableMap)
        var logicalTableMapDecoded0: [String:LogicalTable]? = nil
        if let logicalTableMapContainer = logicalTableMapContainer {
            logicalTableMapDecoded0 = [String:LogicalTable]()
            for (key0, logicaltable0) in logicalTableMapContainer {
                if let logicaltable0 = logicaltable0 {
                    logicalTableMapDecoded0?[key0] = logicaltable0
                }
            }
        }
        logicalTableMap = logicalTableMapDecoded0
        let outputColumnsContainer = try containerValues.decodeIfPresent([OutputColumn?].self, forKey: .outputColumns)
        var outputColumnsDecoded0:[OutputColumn]? = nil
        if let outputColumnsContainer = outputColumnsContainer {
            outputColumnsDecoded0 = [OutputColumn]()
            for structure0 in outputColumnsContainer {
                if let structure0 = structure0 {
                    outputColumnsDecoded0?.append(structure0)
                }
            }
        }
        outputColumns = outputColumnsDecoded0
        let importModeDecoded = try containerValues.decodeIfPresent(DataSetImportMode.self, forKey: .importMode)
        importMode = importModeDecoded
        let consumedSpiceCapacityInBytesDecoded = try containerValues.decode(Int.self, forKey: .consumedSpiceCapacityInBytes)
        consumedSpiceCapacityInBytes = consumedSpiceCapacityInBytesDecoded
        let columnGroupsContainer = try containerValues.decodeIfPresent([ColumnGroup?].self, forKey: .columnGroups)
        var columnGroupsDecoded0:[ColumnGroup]? = nil
        if let columnGroupsContainer = columnGroupsContainer {
            columnGroupsDecoded0 = [ColumnGroup]()
            for structure0 in columnGroupsContainer {
                if let structure0 = structure0 {
                    columnGroupsDecoded0?.append(structure0)
                }
            }
        }
        columnGroups = columnGroupsDecoded0
        let fieldFoldersContainer = try containerValues.decodeIfPresent([String: FieldFolder?].self, forKey: .fieldFolders)
        var fieldFoldersDecoded0: [String:FieldFolder]? = nil
        if let fieldFoldersContainer = fieldFoldersContainer {
            fieldFoldersDecoded0 = [String:FieldFolder]()
            for (key0, fieldfolder0) in fieldFoldersContainer {
                if let fieldfolder0 = fieldfolder0 {
                    fieldFoldersDecoded0?[key0] = fieldfolder0
                }
            }
        }
        fieldFolders = fieldFoldersDecoded0
        let rowLevelPermissionDataSetDecoded = try containerValues.decodeIfPresent(RowLevelPermissionDataSet.self, forKey: .rowLevelPermissionDataSet)
        rowLevelPermissionDataSet = rowLevelPermissionDataSetDecoded
        let columnLevelPermissionRulesContainer = try containerValues.decodeIfPresent([ColumnLevelPermissionRule?].self, forKey: .columnLevelPermissionRules)
        var columnLevelPermissionRulesDecoded0:[ColumnLevelPermissionRule]? = nil
        if let columnLevelPermissionRulesContainer = columnLevelPermissionRulesContainer {
            columnLevelPermissionRulesDecoded0 = [ColumnLevelPermissionRule]()
            for structure0 in columnLevelPermissionRulesContainer {
                if let structure0 = structure0 {
                    columnLevelPermissionRulesDecoded0?.append(structure0)
                }
            }
        }
        columnLevelPermissionRules = columnLevelPermissionRulesDecoded0
    }
}

extension DataSet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataSet(arn: \(String(describing: arn)), columnGroups: \(String(describing: columnGroups)), columnLevelPermissionRules: \(String(describing: columnLevelPermissionRules)), consumedSpiceCapacityInBytes: \(String(describing: consumedSpiceCapacityInBytes)), createdTime: \(String(describing: createdTime)), dataSetId: \(String(describing: dataSetId)), fieldFolders: \(String(describing: fieldFolders)), importMode: \(String(describing: importMode)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), logicalTableMap: \(String(describing: logicalTableMap)), name: \(String(describing: name)), outputColumns: \(String(describing: outputColumns)), physicalTableMap: \(String(describing: physicalTableMap)), rowLevelPermissionDataSet: \(String(describing: rowLevelPermissionDataSet)))"}
}

/// <p>Dataset.</p>
public struct DataSet: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let arn: String?
    /// <p>Groupings of columns that work together in certain Amazon QuickSight features.
    ///             Currently, only geospatial hierarchy is supported.</p>
    public let columnGroups: [ColumnGroup]?
    /// <p>A set of one or more definitions of a <code>
    ///                <a>ColumnLevelPermissionRule</a>
    ///             </code>.</p>
    public let columnLevelPermissionRules: [ColumnLevelPermissionRule]?
    /// <p>The amount of SPICE capacity used by this dataset. This is 0 if the dataset isn't
    ///             imported into SPICE.</p>
    public let consumedSpiceCapacityInBytes: Int
    /// <p>The time that this dataset was created.</p>
    public let createdTime: Date?
    /// <p>The ID of the dataset.</p>
    public let dataSetId: String?
    /// <p>The folder that contains fields and nested subfolders for your dataset.</p>
    public let fieldFolders: [String:FieldFolder]?
    /// <p>A value that indicates whether you want to import the data into SPICE.</p>
    public let importMode: DataSetImportMode?
    /// <p>The last time that this dataset was updated.</p>
    public let lastUpdatedTime: Date?
    /// <p>Configures the combination and transformation of the data from the physical
    ///             tables.</p>
    public let logicalTableMap: [String:LogicalTable]?
    /// <p>A display name for the dataset.</p>
    public let name: String?
    /// <p>The list of columns after all transforms. These columns are available in templates,
    ///             analyses, and dashboards.</p>
    public let outputColumns: [OutputColumn]?
    /// <p>Declares the physical tables that are available in the underlying data sources.</p>
    public let physicalTableMap: [String:PhysicalTable]?
    /// <p>The row-level security configuration for the dataset.</p>
    public let rowLevelPermissionDataSet: RowLevelPermissionDataSet?

    public init (
        arn: String? = nil,
        columnGroups: [ColumnGroup]? = nil,
        columnLevelPermissionRules: [ColumnLevelPermissionRule]? = nil,
        consumedSpiceCapacityInBytes: Int = 0,
        createdTime: Date? = nil,
        dataSetId: String? = nil,
        fieldFolders: [String:FieldFolder]? = nil,
        importMode: DataSetImportMode? = nil,
        lastUpdatedTime: Date? = nil,
        logicalTableMap: [String:LogicalTable]? = nil,
        name: String? = nil,
        outputColumns: [OutputColumn]? = nil,
        physicalTableMap: [String:PhysicalTable]? = nil,
        rowLevelPermissionDataSet: RowLevelPermissionDataSet? = nil
    )
    {
        self.arn = arn
        self.columnGroups = columnGroups
        self.columnLevelPermissionRules = columnLevelPermissionRules
        self.consumedSpiceCapacityInBytes = consumedSpiceCapacityInBytes
        self.createdTime = createdTime
        self.dataSetId = dataSetId
        self.fieldFolders = fieldFolders
        self.importMode = importMode
        self.lastUpdatedTime = lastUpdatedTime
        self.logicalTableMap = logicalTableMap
        self.name = name
        self.outputColumns = outputColumns
        self.physicalTableMap = physicalTableMap
        self.rowLevelPermissionDataSet = rowLevelPermissionDataSet
    }
}

extension DataSetConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case columnGroupSchemaList = "ColumnGroupSchemaList"
        case dataSetSchema = "DataSetSchema"
        case placeholder = "Placeholder"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnGroupSchemaList = columnGroupSchemaList {
            var columnGroupSchemaListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnGroupSchemaList)
            for columngroupschemalist0 in columnGroupSchemaList {
                try columnGroupSchemaListContainer.encode(columngroupschemalist0)
            }
        }
        if let dataSetSchema = dataSetSchema {
            try encodeContainer.encode(dataSetSchema, forKey: .dataSetSchema)
        }
        if let placeholder = placeholder {
            try encodeContainer.encode(placeholder, forKey: .placeholder)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let placeholderDecoded = try containerValues.decodeIfPresent(String.self, forKey: .placeholder)
        placeholder = placeholderDecoded
        let dataSetSchemaDecoded = try containerValues.decodeIfPresent(DataSetSchema.self, forKey: .dataSetSchema)
        dataSetSchema = dataSetSchemaDecoded
        let columnGroupSchemaListContainer = try containerValues.decodeIfPresent([ColumnGroupSchema?].self, forKey: .columnGroupSchemaList)
        var columnGroupSchemaListDecoded0:[ColumnGroupSchema]? = nil
        if let columnGroupSchemaListContainer = columnGroupSchemaListContainer {
            columnGroupSchemaListDecoded0 = [ColumnGroupSchema]()
            for structure0 in columnGroupSchemaListContainer {
                if let structure0 = structure0 {
                    columnGroupSchemaListDecoded0?.append(structure0)
                }
            }
        }
        columnGroupSchemaList = columnGroupSchemaListDecoded0
    }
}

extension DataSetConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataSetConfiguration(columnGroupSchemaList: \(String(describing: columnGroupSchemaList)), dataSetSchema: \(String(describing: dataSetSchema)), placeholder: \(String(describing: placeholder)))"}
}

/// <p>Dataset configuration.</p>
public struct DataSetConfiguration: Equatable {
    /// <p>A structure containing the list of column group schemas.</p>
    public let columnGroupSchemaList: [ColumnGroupSchema]?
    /// <p>Dataset schema.</p>
    public let dataSetSchema: DataSetSchema?
    /// <p>Placeholder.</p>
    public let placeholder: String?

    public init (
        columnGroupSchemaList: [ColumnGroupSchema]? = nil,
        dataSetSchema: DataSetSchema? = nil,
        placeholder: String? = nil
    )
    {
        self.columnGroupSchemaList = columnGroupSchemaList
        self.dataSetSchema = dataSetSchema
        self.placeholder = placeholder
    }
}

public enum DataSetImportMode {
    case directQuery
    case spice
    case sdkUnknown(String)
}

extension DataSetImportMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataSetImportMode] {
        return [
            .directQuery,
            .spice,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .directQuery: return "DIRECT_QUERY"
        case .spice: return "SPICE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataSetImportMode(rawValue: rawValue) ?? DataSetImportMode.sdkUnknown(rawValue)
    }
}

extension DataSetReference: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataSetArn = "DataSetArn"
        case dataSetPlaceholder = "DataSetPlaceholder"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSetArn = dataSetArn {
            try encodeContainer.encode(dataSetArn, forKey: .dataSetArn)
        }
        if let dataSetPlaceholder = dataSetPlaceholder {
            try encodeContainer.encode(dataSetPlaceholder, forKey: .dataSetPlaceholder)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetPlaceholderDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetPlaceholder)
        dataSetPlaceholder = dataSetPlaceholderDecoded
        let dataSetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetArn)
        dataSetArn = dataSetArnDecoded
    }
}

extension DataSetReference: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataSetReference(dataSetArn: \(String(describing: dataSetArn)), dataSetPlaceholder: \(String(describing: dataSetPlaceholder)))"}
}

/// <p>Dataset reference.</p>
public struct DataSetReference: Equatable {
    /// <p>Dataset Amazon Resource Name (ARN).</p>
    public let dataSetArn: String?
    /// <p>Dataset placeholder.</p>
    public let dataSetPlaceholder: String?

    public init (
        dataSetArn: String? = nil,
        dataSetPlaceholder: String? = nil
    )
    {
        self.dataSetArn = dataSetArn
        self.dataSetPlaceholder = dataSetPlaceholder
    }
}

extension DataSetSchema: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case columnSchemaList = "ColumnSchemaList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnSchemaList = columnSchemaList {
            var columnSchemaListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnSchemaList)
            for columnschemalist0 in columnSchemaList {
                try columnSchemaListContainer.encode(columnschemalist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnSchemaListContainer = try containerValues.decodeIfPresent([ColumnSchema?].self, forKey: .columnSchemaList)
        var columnSchemaListDecoded0:[ColumnSchema]? = nil
        if let columnSchemaListContainer = columnSchemaListContainer {
            columnSchemaListDecoded0 = [ColumnSchema]()
            for structure0 in columnSchemaListContainer {
                if let structure0 = structure0 {
                    columnSchemaListDecoded0?.append(structure0)
                }
            }
        }
        columnSchemaList = columnSchemaListDecoded0
    }
}

extension DataSetSchema: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataSetSchema(columnSchemaList: \(String(describing: columnSchemaList)))"}
}

/// <p>Dataset schema.</p>
public struct DataSetSchema: Equatable {
    /// <p>A structure containing the list of column schemas.</p>
    public let columnSchemaList: [ColumnSchema]?

    public init (
        columnSchemaList: [ColumnSchema]? = nil
    )
    {
        self.columnSchemaList = columnSchemaList
    }
}

extension DataSetSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case columnLevelPermissionRulesApplied = "ColumnLevelPermissionRulesApplied"
        case createdTime = "CreatedTime"
        case dataSetId = "DataSetId"
        case importMode = "ImportMode"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case rowLevelPermissionDataSet = "RowLevelPermissionDataSet"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if columnLevelPermissionRulesApplied != false {
            try encodeContainer.encode(columnLevelPermissionRulesApplied, forKey: .columnLevelPermissionRulesApplied)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let importMode = importMode {
            try encodeContainer.encode(importMode.rawValue, forKey: .importMode)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rowLevelPermissionDataSet = rowLevelPermissionDataSet {
            try encodeContainer.encode(rowLevelPermissionDataSet, forKey: .rowLevelPermissionDataSet)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let importModeDecoded = try containerValues.decodeIfPresent(DataSetImportMode.self, forKey: .importMode)
        importMode = importModeDecoded
        let rowLevelPermissionDataSetDecoded = try containerValues.decodeIfPresent(RowLevelPermissionDataSet.self, forKey: .rowLevelPermissionDataSet)
        rowLevelPermissionDataSet = rowLevelPermissionDataSetDecoded
        let columnLevelPermissionRulesAppliedDecoded = try containerValues.decode(Bool.self, forKey: .columnLevelPermissionRulesApplied)
        columnLevelPermissionRulesApplied = columnLevelPermissionRulesAppliedDecoded
    }
}

extension DataSetSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataSetSummary(arn: \(String(describing: arn)), columnLevelPermissionRulesApplied: \(String(describing: columnLevelPermissionRulesApplied)), createdTime: \(String(describing: createdTime)), dataSetId: \(String(describing: dataSetId)), importMode: \(String(describing: importMode)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), name: \(String(describing: name)), rowLevelPermissionDataSet: \(String(describing: rowLevelPermissionDataSet)))"}
}

/// <p>Dataset summary.</p>
public struct DataSetSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset.</p>
    public let arn: String?
    /// <p>A value that indicates if the dataset has column level permission configured.</p>
    public let columnLevelPermissionRulesApplied: Bool
    /// <p>The time that this dataset was created.</p>
    public let createdTime: Date?
    /// <p>The ID of the dataset.</p>
    public let dataSetId: String?
    /// <p>A value that indicates whether you want to import the data into SPICE.</p>
    public let importMode: DataSetImportMode?
    /// <p>The last time that this dataset was updated.</p>
    public let lastUpdatedTime: Date?
    /// <p>A display name for the dataset.</p>
    public let name: String?
    /// <p>The row-level security configuration for the dataset.</p>
    public let rowLevelPermissionDataSet: RowLevelPermissionDataSet?

    public init (
        arn: String? = nil,
        columnLevelPermissionRulesApplied: Bool = false,
        createdTime: Date? = nil,
        dataSetId: String? = nil,
        importMode: DataSetImportMode? = nil,
        lastUpdatedTime: Date? = nil,
        name: String? = nil,
        rowLevelPermissionDataSet: RowLevelPermissionDataSet? = nil
    )
    {
        self.arn = arn
        self.columnLevelPermissionRulesApplied = columnLevelPermissionRulesApplied
        self.createdTime = createdTime
        self.dataSetId = dataSetId
        self.importMode = importMode
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.rowLevelPermissionDataSet = rowLevelPermissionDataSet
    }
}

extension DataSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alternateDataSourceParameters = "AlternateDataSourceParameters"
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case dataSourceId = "DataSourceId"
        case dataSourceParameters = "DataSourceParameters"
        case errorInfo = "ErrorInfo"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case sslProperties = "SslProperties"
        case status = "Status"
        case type = "Type"
        case vpcConnectionProperties = "VpcConnectionProperties"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alternateDataSourceParameters = alternateDataSourceParameters {
            var alternateDataSourceParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .alternateDataSourceParameters)
            for datasourceparameterslist0 in alternateDataSourceParameters {
                try alternateDataSourceParametersContainer.encode(datasourceparameterslist0)
            }
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let dataSourceId = dataSourceId {
            try encodeContainer.encode(dataSourceId, forKey: .dataSourceId)
        }
        if let dataSourceParameters = dataSourceParameters {
            try encodeContainer.encode(dataSourceParameters, forKey: .dataSourceParameters)
        }
        if let errorInfo = errorInfo {
            try encodeContainer.encode(errorInfo, forKey: .errorInfo)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sslProperties = sslProperties {
            try encodeContainer.encode(sslProperties, forKey: .sslProperties)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let vpcConnectionProperties = vpcConnectionProperties {
            try encodeContainer.encode(vpcConnectionProperties, forKey: .vpcConnectionProperties)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataSourceType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResourceStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let dataSourceParametersDecoded = try containerValues.decodeIfPresent(DataSourceParameters.self, forKey: .dataSourceParameters)
        dataSourceParameters = dataSourceParametersDecoded
        let alternateDataSourceParametersContainer = try containerValues.decodeIfPresent([DataSourceParameters?].self, forKey: .alternateDataSourceParameters)
        var alternateDataSourceParametersDecoded0:[DataSourceParameters]? = nil
        if let alternateDataSourceParametersContainer = alternateDataSourceParametersContainer {
            alternateDataSourceParametersDecoded0 = [DataSourceParameters]()
            for union0 in alternateDataSourceParametersContainer {
                if let union0 = union0 {
                    alternateDataSourceParametersDecoded0?.append(union0)
                }
            }
        }
        alternateDataSourceParameters = alternateDataSourceParametersDecoded0
        let vpcConnectionPropertiesDecoded = try containerValues.decodeIfPresent(VpcConnectionProperties.self, forKey: .vpcConnectionProperties)
        vpcConnectionProperties = vpcConnectionPropertiesDecoded
        let sslPropertiesDecoded = try containerValues.decodeIfPresent(SslProperties.self, forKey: .sslProperties)
        sslProperties = sslPropertiesDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(DataSourceErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
    }
}

extension DataSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataSource(alternateDataSourceParameters: \(String(describing: alternateDataSourceParameters)), arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), dataSourceId: \(String(describing: dataSourceId)), dataSourceParameters: \(String(describing: dataSourceParameters)), errorInfo: \(String(describing: errorInfo)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), name: \(String(describing: name)), sslProperties: \(String(describing: sslProperties)), status: \(String(describing: status)), type: \(String(describing: type)), vpcConnectionProperties: \(String(describing: vpcConnectionProperties)))"}
}

/// <p>The structure of a data source.</p>
public struct DataSource: Equatable {
    /// <p>A set of alternate data source parameters that you want to share for the credentials
    ///             stored with this data source. The credentials are applied in tandem with the data source
    ///             parameters when you copy a data source by using a create or update request. The API
    ///             operation compares the <code>DataSourceParameters</code> structure that's in the request
    ///             with the structures in the <code>AlternateDataSourceParameters</code> allow list. If the
    ///             structures are an exact match, the request is allowed to use the credentials from this
    ///             existing data source. If the <code>AlternateDataSourceParameters</code> list is null,
    ///             the <code>Credentials</code> originally used with this <code>DataSourceParameters</code>
    ///             are automatically allowed.</p>
    public let alternateDataSourceParameters: [DataSourceParameters]?
    /// <p>The Amazon Resource Name (ARN) of the data source.</p>
    public let arn: String?
    /// <p>The time that this data source was created.</p>
    public let createdTime: Date?
    /// <p>The ID of the data source. This ID is unique per AWS Region for each AWS
    ///             account.</p>
    public let dataSourceId: String?
    /// <p>The parameters that Amazon QuickSight uses to connect to your underlying source. This
    ///             is a variant type structure. For this structure to be valid, only one of the attributes
    ///             can be non-null.</p>
    public let dataSourceParameters: DataSourceParameters?
    /// <p>Error information from the last update or the creation of the data source.</p>
    public let errorInfo: DataSourceErrorInfo?
    /// <p>The last time that this data source was updated.</p>
    public let lastUpdatedTime: Date?
    /// <p>A display name for the data source.</p>
    public let name: String?
    /// <p>Secure Socket Layer (SSL) properties that apply when QuickSight connects to your
    ///             underlying source.</p>
    public let sslProperties: SslProperties?
    /// <p>The HTTP status of the request.</p>
    public let status: ResourceStatus?
    /// <p>The type of the data source. This type indicates which database engine the data source
    ///             connects to.</p>
    public let type: DataSourceType?
    /// <p>The VPC connection information. You need to use this parameter only when you want
    ///             QuickSight to use a VPC connection when connecting to your underlying source.</p>
    public let vpcConnectionProperties: VpcConnectionProperties?

    public init (
        alternateDataSourceParameters: [DataSourceParameters]? = nil,
        arn: String? = nil,
        createdTime: Date? = nil,
        dataSourceId: String? = nil,
        dataSourceParameters: DataSourceParameters? = nil,
        errorInfo: DataSourceErrorInfo? = nil,
        lastUpdatedTime: Date? = nil,
        name: String? = nil,
        sslProperties: SslProperties? = nil,
        status: ResourceStatus? = nil,
        type: DataSourceType? = nil,
        vpcConnectionProperties: VpcConnectionProperties? = nil
    )
    {
        self.alternateDataSourceParameters = alternateDataSourceParameters
        self.arn = arn
        self.createdTime = createdTime
        self.dataSourceId = dataSourceId
        self.dataSourceParameters = dataSourceParameters
        self.errorInfo = errorInfo
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.sslProperties = sslProperties
        self.status = status
        self.type = type
        self.vpcConnectionProperties = vpcConnectionProperties
    }
}

extension DataSourceCredentials: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case copySourceArn = "CopySourceArn"
        case credentialPair = "CredentialPair"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let copySourceArn = copySourceArn {
            try encodeContainer.encode(copySourceArn, forKey: .copySourceArn)
        }
        if let credentialPair = credentialPair {
            try encodeContainer.encode(credentialPair, forKey: .credentialPair)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let credentialPairDecoded = try containerValues.decodeIfPresent(CredentialPair.self, forKey: .credentialPair)
        credentialPair = credentialPairDecoded
        let copySourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .copySourceArn)
        copySourceArn = copySourceArnDecoded
    }
}

extension DataSourceCredentials: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CONTENT_REDACTED"
    }
}

/// <p>Data source credentials. This is a variant type structure. For this structure to be
///             valid, only one of the attributes can be non-null.</p>
public struct DataSourceCredentials: Equatable {
    /// <p>The Amazon Resource Name (ARN) of a data source that has the credential pair that you
    ///             want to use. When <code>CopySourceArn</code> is not null, the credential pair from the
    ///             data source in the ARN is used as the credentials for the
    ///             <code>DataSourceCredentials</code> structure.</p>
    public let copySourceArn: String?
    /// <p>Credential pair. For more information, see <a>CredentialPair</a>.</p>
    public let credentialPair: CredentialPair?

    public init (
        copySourceArn: String? = nil,
        credentialPair: CredentialPair? = nil
    )
    {
        self.copySourceArn = copySourceArn
        self.credentialPair = credentialPair
    }
}

extension DataSourceErrorInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(DataSourceErrorInfoType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DataSourceErrorInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataSourceErrorInfo(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

/// <p>Error information for the data source creation or update.</p>
public struct DataSourceErrorInfo: Equatable {
    /// <p>Error message.</p>
    public let message: String?
    /// <p>Error type.</p>
    public let type: DataSourceErrorInfoType?

    public init (
        message: String? = nil,
        type: DataSourceErrorInfoType? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

public enum DataSourceErrorInfoType {
    case accessDenied
    case conflict
    case copySourceNotFound
    case engineVersionNotSupported
    case genericSqlFailure
    case timeout
    case unknown
    case unknownHost
    case sdkUnknown(String)
}

extension DataSourceErrorInfoType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataSourceErrorInfoType] {
        return [
            .accessDenied,
            .conflict,
            .copySourceNotFound,
            .engineVersionNotSupported,
            .genericSqlFailure,
            .timeout,
            .unknown,
            .unknownHost,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accessDenied: return "ACCESS_DENIED"
        case .conflict: return "CONFLICT"
        case .copySourceNotFound: return "COPY_SOURCE_NOT_FOUND"
        case .engineVersionNotSupported: return "ENGINE_VERSION_NOT_SUPPORTED"
        case .genericSqlFailure: return "GENERIC_SQL_FAILURE"
        case .timeout: return "TIMEOUT"
        case .unknown: return "UNKNOWN"
        case .unknownHost: return "UNKNOWN_HOST"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataSourceErrorInfoType(rawValue: rawValue) ?? DataSourceErrorInfoType.sdkUnknown(rawValue)
    }
}

extension DataSourceParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amazonElasticsearchParameters = "AmazonElasticsearchParameters"
        case athenaParameters = "AthenaParameters"
        case auroraParameters = "AuroraParameters"
        case auroraPostgreSqlParameters = "AuroraPostgreSqlParameters"
        case awsIotAnalyticsParameters = "AwsIotAnalyticsParameters"
        case jiraParameters = "JiraParameters"
        case mariaDbParameters = "MariaDbParameters"
        case mySqlParameters = "MySqlParameters"
        case oracleParameters = "OracleParameters"
        case postgreSqlParameters = "PostgreSqlParameters"
        case prestoParameters = "PrestoParameters"
        case rdsParameters = "RdsParameters"
        case redshiftParameters = "RedshiftParameters"
        case s3Parameters = "S3Parameters"
        case serviceNowParameters = "ServiceNowParameters"
        case snowflakeParameters = "SnowflakeParameters"
        case sparkParameters = "SparkParameters"
        case sqlServerParameters = "SqlServerParameters"
        case teradataParameters = "TeradataParameters"
        case twitterParameters = "TwitterParameters"
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .amazonElasticsearchParameters(amazonElasticsearchParameters):
                if let amazonElasticsearchParameters = amazonElasticsearchParameters {
                    try container.encode(amazonElasticsearchParameters, forKey: .amazonElasticsearchParameters)
                }
            case let .athenaParameters(athenaParameters):
                if let athenaParameters = athenaParameters {
                    try container.encode(athenaParameters, forKey: .athenaParameters)
                }
            case let .auroraParameters(auroraParameters):
                if let auroraParameters = auroraParameters {
                    try container.encode(auroraParameters, forKey: .auroraParameters)
                }
            case let .auroraPostgreSqlParameters(auroraPostgreSqlParameters):
                if let auroraPostgreSqlParameters = auroraPostgreSqlParameters {
                    try container.encode(auroraPostgreSqlParameters, forKey: .auroraPostgreSqlParameters)
                }
            case let .awsIotAnalyticsParameters(awsIotAnalyticsParameters):
                if let awsIotAnalyticsParameters = awsIotAnalyticsParameters {
                    try container.encode(awsIotAnalyticsParameters, forKey: .awsIotAnalyticsParameters)
                }
            case let .jiraParameters(jiraParameters):
                if let jiraParameters = jiraParameters {
                    try container.encode(jiraParameters, forKey: .jiraParameters)
                }
            case let .mariaDbParameters(mariaDbParameters):
                if let mariaDbParameters = mariaDbParameters {
                    try container.encode(mariaDbParameters, forKey: .mariaDbParameters)
                }
            case let .mySqlParameters(mySqlParameters):
                if let mySqlParameters = mySqlParameters {
                    try container.encode(mySqlParameters, forKey: .mySqlParameters)
                }
            case let .oracleParameters(oracleParameters):
                if let oracleParameters = oracleParameters {
                    try container.encode(oracleParameters, forKey: .oracleParameters)
                }
            case let .postgreSqlParameters(postgreSqlParameters):
                if let postgreSqlParameters = postgreSqlParameters {
                    try container.encode(postgreSqlParameters, forKey: .postgreSqlParameters)
                }
            case let .prestoParameters(prestoParameters):
                if let prestoParameters = prestoParameters {
                    try container.encode(prestoParameters, forKey: .prestoParameters)
                }
            case let .rdsParameters(rdsParameters):
                if let rdsParameters = rdsParameters {
                    try container.encode(rdsParameters, forKey: .rdsParameters)
                }
            case let .redshiftParameters(redshiftParameters):
                if let redshiftParameters = redshiftParameters {
                    try container.encode(redshiftParameters, forKey: .redshiftParameters)
                }
            case let .s3Parameters(s3Parameters):
                if let s3Parameters = s3Parameters {
                    try container.encode(s3Parameters, forKey: .s3Parameters)
                }
            case let .serviceNowParameters(serviceNowParameters):
                if let serviceNowParameters = serviceNowParameters {
                    try container.encode(serviceNowParameters, forKey: .serviceNowParameters)
                }
            case let .snowflakeParameters(snowflakeParameters):
                if let snowflakeParameters = snowflakeParameters {
                    try container.encode(snowflakeParameters, forKey: .snowflakeParameters)
                }
            case let .sparkParameters(sparkParameters):
                if let sparkParameters = sparkParameters {
                    try container.encode(sparkParameters, forKey: .sparkParameters)
                }
            case let .sqlServerParameters(sqlServerParameters):
                if let sqlServerParameters = sqlServerParameters {
                    try container.encode(sqlServerParameters, forKey: .sqlServerParameters)
                }
            case let .teradataParameters(teradataParameters):
                if let teradataParameters = teradataParameters {
                    try container.encode(teradataParameters, forKey: .teradataParameters)
                }
            case let .twitterParameters(twitterParameters):
                if let twitterParameters = twitterParameters {
                    try container.encode(twitterParameters, forKey: .twitterParameters)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let amazonElasticsearchParametersDecoded = try values.decodeIfPresent(AmazonElasticsearchParameters.self, forKey: .amazonElasticsearchParameters)
        if let amazonElasticsearchParameters = amazonElasticsearchParametersDecoded {
            self = .amazonElasticsearchParameters(amazonElasticsearchParameters)
            return
        }
        let athenaParametersDecoded = try values.decodeIfPresent(AthenaParameters.self, forKey: .athenaParameters)
        if let athenaParameters = athenaParametersDecoded {
            self = .athenaParameters(athenaParameters)
            return
        }
        let auroraParametersDecoded = try values.decodeIfPresent(AuroraParameters.self, forKey: .auroraParameters)
        if let auroraParameters = auroraParametersDecoded {
            self = .auroraParameters(auroraParameters)
            return
        }
        let auroraPostgreSqlParametersDecoded = try values.decodeIfPresent(AuroraPostgreSqlParameters.self, forKey: .auroraPostgreSqlParameters)
        if let auroraPostgreSqlParameters = auroraPostgreSqlParametersDecoded {
            self = .auroraPostgreSqlParameters(auroraPostgreSqlParameters)
            return
        }
        let awsIotAnalyticsParametersDecoded = try values.decodeIfPresent(AwsIotAnalyticsParameters.self, forKey: .awsIotAnalyticsParameters)
        if let awsIotAnalyticsParameters = awsIotAnalyticsParametersDecoded {
            self = .awsIotAnalyticsParameters(awsIotAnalyticsParameters)
            return
        }
        let jiraParametersDecoded = try values.decodeIfPresent(JiraParameters.self, forKey: .jiraParameters)
        if let jiraParameters = jiraParametersDecoded {
            self = .jiraParameters(jiraParameters)
            return
        }
        let mariaDbParametersDecoded = try values.decodeIfPresent(MariaDbParameters.self, forKey: .mariaDbParameters)
        if let mariaDbParameters = mariaDbParametersDecoded {
            self = .mariaDbParameters(mariaDbParameters)
            return
        }
        let mySqlParametersDecoded = try values.decodeIfPresent(MySqlParameters.self, forKey: .mySqlParameters)
        if let mySqlParameters = mySqlParametersDecoded {
            self = .mySqlParameters(mySqlParameters)
            return
        }
        let oracleParametersDecoded = try values.decodeIfPresent(OracleParameters.self, forKey: .oracleParameters)
        if let oracleParameters = oracleParametersDecoded {
            self = .oracleParameters(oracleParameters)
            return
        }
        let postgreSqlParametersDecoded = try values.decodeIfPresent(PostgreSqlParameters.self, forKey: .postgreSqlParameters)
        if let postgreSqlParameters = postgreSqlParametersDecoded {
            self = .postgreSqlParameters(postgreSqlParameters)
            return
        }
        let prestoParametersDecoded = try values.decodeIfPresent(PrestoParameters.self, forKey: .prestoParameters)
        if let prestoParameters = prestoParametersDecoded {
            self = .prestoParameters(prestoParameters)
            return
        }
        let rdsParametersDecoded = try values.decodeIfPresent(RdsParameters.self, forKey: .rdsParameters)
        if let rdsParameters = rdsParametersDecoded {
            self = .rdsParameters(rdsParameters)
            return
        }
        let redshiftParametersDecoded = try values.decodeIfPresent(RedshiftParameters.self, forKey: .redshiftParameters)
        if let redshiftParameters = redshiftParametersDecoded {
            self = .redshiftParameters(redshiftParameters)
            return
        }
        let s3ParametersDecoded = try values.decodeIfPresent(S3Parameters.self, forKey: .s3Parameters)
        if let s3Parameters = s3ParametersDecoded {
            self = .s3Parameters(s3Parameters)
            return
        }
        let serviceNowParametersDecoded = try values.decodeIfPresent(ServiceNowParameters.self, forKey: .serviceNowParameters)
        if let serviceNowParameters = serviceNowParametersDecoded {
            self = .serviceNowParameters(serviceNowParameters)
            return
        }
        let snowflakeParametersDecoded = try values.decodeIfPresent(SnowflakeParameters.self, forKey: .snowflakeParameters)
        if let snowflakeParameters = snowflakeParametersDecoded {
            self = .snowflakeParameters(snowflakeParameters)
            return
        }
        let sparkParametersDecoded = try values.decodeIfPresent(SparkParameters.self, forKey: .sparkParameters)
        if let sparkParameters = sparkParametersDecoded {
            self = .sparkParameters(sparkParameters)
            return
        }
        let sqlServerParametersDecoded = try values.decodeIfPresent(SqlServerParameters.self, forKey: .sqlServerParameters)
        if let sqlServerParameters = sqlServerParametersDecoded {
            self = .sqlServerParameters(sqlServerParameters)
            return
        }
        let teradataParametersDecoded = try values.decodeIfPresent(TeradataParameters.self, forKey: .teradataParameters)
        if let teradataParameters = teradataParametersDecoded {
            self = .teradataParameters(teradataParameters)
            return
        }
        let twitterParametersDecoded = try values.decodeIfPresent(TwitterParameters.self, forKey: .twitterParameters)
        if let twitterParameters = twitterParametersDecoded {
            self = .twitterParameters(twitterParameters)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>The parameters that Amazon QuickSight uses to connect to your underlying data source.
///             This is a variant type structure. For this structure to be valid, only one of the
///             attributes can be non-null.</p>
public enum DataSourceParameters: Equatable {
    /// <p>Amazon Elasticsearch Service parameters.</p>
    case amazonElasticsearchParameters(AmazonElasticsearchParameters?)
    /// <p>Amazon Athena parameters.</p>
    case athenaParameters(AthenaParameters?)
    /// <p>Amazon Aurora MySQL parameters.</p>
    case auroraParameters(AuroraParameters?)
    /// <p>Aurora PostgreSQL parameters.</p>
    case auroraPostgreSqlParameters(AuroraPostgreSqlParameters?)
    /// <p>AWS IoT Analytics parameters.</p>
    case awsIotAnalyticsParameters(AwsIotAnalyticsParameters?)
    /// <p>Jira parameters.</p>
    case jiraParameters(JiraParameters?)
    /// <p>MariaDB parameters.</p>
    case mariaDbParameters(MariaDbParameters?)
    /// <p>MySQL parameters.</p>
    case mySqlParameters(MySqlParameters?)
    /// <p>Oracle parameters.</p>
    case oracleParameters(OracleParameters?)
    /// <p>PostgreSQL parameters.</p>
    case postgreSqlParameters(PostgreSqlParameters?)
    /// <p>Presto parameters.</p>
    case prestoParameters(PrestoParameters?)
    /// <p>Amazon RDS parameters.</p>
    case rdsParameters(RdsParameters?)
    /// <p>Amazon Redshift parameters.</p>
    case redshiftParameters(RedshiftParameters?)
    /// <p>S3 parameters.</p>
    case s3Parameters(S3Parameters?)
    /// <p>ServiceNow parameters.</p>
    case serviceNowParameters(ServiceNowParameters?)
    /// <p>Snowflake parameters.</p>
    case snowflakeParameters(SnowflakeParameters?)
    /// <p>Spark parameters.</p>
    case sparkParameters(SparkParameters?)
    /// <p>SQL Server parameters.</p>
    case sqlServerParameters(SqlServerParameters?)
    /// <p>Teradata parameters.</p>
    case teradataParameters(TeradataParameters?)
    /// <p>Twitter parameters.</p>
    case twitterParameters(TwitterParameters?)
    case sdkUnknown(String?)
}

public enum DataSourceType {
    case adobeAnalytics
    case amazonElasticsearch
    case athena
    case aurora
    case auroraPostgresql
    case awsIotAnalytics
    case github
    case jira
    case mariadb
    case mysql
    case oracle
    case postgresql
    case presto
    case redshift
    case s3
    case salesforce
    case servicenow
    case snowflake
    case spark
    case sqlserver
    case teradata
    case timestream
    case twitter
    case sdkUnknown(String)
}

extension DataSourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataSourceType] {
        return [
            .adobeAnalytics,
            .amazonElasticsearch,
            .athena,
            .aurora,
            .auroraPostgresql,
            .awsIotAnalytics,
            .github,
            .jira,
            .mariadb,
            .mysql,
            .oracle,
            .postgresql,
            .presto,
            .redshift,
            .s3,
            .salesforce,
            .servicenow,
            .snowflake,
            .spark,
            .sqlserver,
            .teradata,
            .timestream,
            .twitter,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .adobeAnalytics: return "ADOBE_ANALYTICS"
        case .amazonElasticsearch: return "AMAZON_ELASTICSEARCH"
        case .athena: return "ATHENA"
        case .aurora: return "AURORA"
        case .auroraPostgresql: return "AURORA_POSTGRESQL"
        case .awsIotAnalytics: return "AWS_IOT_ANALYTICS"
        case .github: return "GITHUB"
        case .jira: return "JIRA"
        case .mariadb: return "MARIADB"
        case .mysql: return "MYSQL"
        case .oracle: return "ORACLE"
        case .postgresql: return "POSTGRESQL"
        case .presto: return "PRESTO"
        case .redshift: return "REDSHIFT"
        case .s3: return "S3"
        case .salesforce: return "SALESFORCE"
        case .servicenow: return "SERVICENOW"
        case .snowflake: return "SNOWFLAKE"
        case .spark: return "SPARK"
        case .sqlserver: return "SQLSERVER"
        case .teradata: return "TERADATA"
        case .timestream: return "TIMESTREAM"
        case .twitter: return "TWITTER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataSourceType(rawValue: rawValue) ?? DataSourceType.sdkUnknown(rawValue)
    }
}

extension DateTimeParameter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for timestamplist0 in values {
                try valuesContainer.encode(timestamplist0.timeIntervalSince1970)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Date?].self, forKey: .values)
        var valuesDecoded0:[Date]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Date]()
            for timestamp0 in valuesContainer {
                if let timestamp0 = timestamp0 {
                    valuesDecoded0?.append(timestamp0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension DateTimeParameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DateTimeParameter(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>A date-time parameter.</p>
public struct DateTimeParameter: Equatable {
    /// <p>A display name for the date-time parameter.</p>
    public let name: String?
    /// <p>The values for the date-time parameter.</p>
    public let values: [Date]?

    public init (
        name: String? = nil,
        values: [Date]? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

extension DecimalParameter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for doublelist0 in values {
                try valuesContainer.encode(doublelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Double?].self, forKey: .values)
        var valuesDecoded0:[Double]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Double]()
            for double0 in valuesContainer {
                if let double0 = double0 {
                    valuesDecoded0?.append(double0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension DecimalParameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DecimalParameter(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>A decimal parameter.</p>
public struct DecimalParameter: Equatable {
    /// <p>A display name for the decimal parameter.</p>
    public let name: String?
    /// <p>The values for the decimal parameter.</p>
    public let values: [Double]?

    public init (
        name: String? = nil,
        values: [Double]? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

extension DeleteAccountCustomizationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAccountCustomizationInput(awsAccountId: \(String(describing: awsAccountId)), namespace: \(String(describing: namespace)))"}
}

extension DeleteAccountCustomizationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteAccountCustomizationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAccountCustomizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccountCustomizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccountCustomizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccountCustomizationInput>
    public typealias MOutput = OperationOutput<DeleteAccountCustomizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccountCustomizationOutputError>
}

public struct DeleteAccountCustomizationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAccountCustomizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccountCustomizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccountCustomizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let namespace = input.operationInput.namespace {
            let namespaceQueryItem = URLQueryItem(name: "namespace".urlPercentEncoding(), value: String(namespace).urlPercentEncoding())
            input.builder.withQueryItem(namespaceQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccountCustomizationInput>
    public typealias MOutput = OperationOutput<DeleteAccountCustomizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccountCustomizationOutputError>
}

public struct DeleteAccountCustomizationInput: Equatable {
    /// <p>The ID for the AWS account that you want to delete QuickSight customizations from in
    ///             this AWS Region.</p>
    public let awsAccountId: String?
    /// <p>The QuickSight namespace that you're deleting the customizations from.</p>
    public let namespace: String?

    public init (
        awsAccountId: String? = nil,
        namespace: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.namespace = namespace
    }
}

struct DeleteAccountCustomizationInputBody: Equatable {
}

extension DeleteAccountCustomizationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAccountCustomizationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAccountCustomizationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAccountCustomizationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccountCustomizationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAccountCustomizationOutputResponse(requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension DeleteAccountCustomizationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteAccountCustomizationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.requestId = output.requestId
        } else {
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteAccountCustomizationOutputResponse: Equatable {
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteAccountCustomizationOutputResponseBody: Equatable {
    public let requestId: String?
    public let status: Int
}

extension DeleteAccountCustomizationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteAnalysisInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAnalysisInput(analysisId: \(String(describing: analysisId)), awsAccountId: \(String(describing: awsAccountId)), forceDeleteWithoutRecovery: \(String(describing: forceDeleteWithoutRecovery)), recoveryWindowInDays: \(String(describing: recoveryWindowInDays)))"}
}

extension DeleteAnalysisInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteAnalysisInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAnalysisInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAnalysisInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAnalysisInput>
    public typealias MOutput = OperationOutput<DeleteAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAnalysisOutputError>
}

public struct DeleteAnalysisInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAnalysisInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAnalysisInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let recoveryWindowInDays = input.operationInput.recoveryWindowInDays {
            let recoveryWindowInDaysQueryItem = URLQueryItem(name: "recovery-window-in-days".urlPercentEncoding(), value: String(recoveryWindowInDays).urlPercentEncoding())
            input.builder.withQueryItem(recoveryWindowInDaysQueryItem)
        }
        let forceDeleteWithoutRecoveryQueryItem = URLQueryItem(name: "force-delete-without-recovery".urlPercentEncoding(), value: String(input.operationInput.forceDeleteWithoutRecovery).urlPercentEncoding())
        input.builder.withQueryItem(forceDeleteWithoutRecoveryQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAnalysisInput>
    public typealias MOutput = OperationOutput<DeleteAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAnalysisOutputError>
}

public struct DeleteAnalysisInput: Equatable {
    /// <p>The ID of the analysis that you're deleting.</p>
    public let analysisId: String?
    /// <p>The ID of the AWS account where you want to delete an analysis.</p>
    public let awsAccountId: String?
    /// <p>This option defaults to the value <code>NoForceDeleteWithoutRecovery</code>. To
    ///             immediately delete the analysis, add the <code>ForceDeleteWithoutRecovery</code> option.
    ///             You can't restore an analysis after it's deleted. </p>
    public let forceDeleteWithoutRecovery: Bool
    /// <p>A value that specifies the number of days that QuickSight waits before it deletes the
    ///             analysis. You can't use this parameter with the <code>ForceDeleteWithoutRecovery</code>
    ///             option in the same API call. The default value is 30.</p>
    public let recoveryWindowInDays: Int?

    public init (
        analysisId: String? = nil,
        awsAccountId: String? = nil,
        forceDeleteWithoutRecovery: Bool = false,
        recoveryWindowInDays: Int? = nil
    )
    {
        self.analysisId = analysisId
        self.awsAccountId = awsAccountId
        self.forceDeleteWithoutRecovery = forceDeleteWithoutRecovery
        self.recoveryWindowInDays = recoveryWindowInDays
    }
}

struct DeleteAnalysisInputBody: Equatable {
}

extension DeleteAnalysisInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAnalysisOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAnalysisOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAnalysisOutputError: Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAnalysisOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAnalysisOutputResponse(analysisId: \(String(describing: analysisId)), arn: \(String(describing: arn)), deletionTime: \(String(describing: deletionTime)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension DeleteAnalysisOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.analysisId = output.analysisId
            self.arn = output.arn
            self.deletionTime = output.deletionTime
            self.requestId = output.requestId
        } else {
            self.analysisId = nil
            self.arn = nil
            self.deletionTime = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteAnalysisOutputResponse: Equatable {
    /// <p>The ID of the deleted analysis.</p>
    public let analysisId: String?
    /// <p>The Amazon Resource Name (ARN) of the deleted analysis.</p>
    public let arn: String?
    /// <p>The date and time that the analysis is scheduled to be deleted.</p>
    public let deletionTime: Date?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        analysisId: String? = nil,
        arn: String? = nil,
        deletionTime: Date? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.analysisId = analysisId
        self.arn = arn
        self.deletionTime = deletionTime
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteAnalysisOutputResponseBody: Equatable {
    public let status: Int
    public let arn: String?
    public let analysisId: String?
    public let deletionTime: Date?
    public let requestId: String?
}

extension DeleteAnalysisOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analysisId = "AnalysisId"
        case arn = "Arn"
        case deletionTime = "DeletionTime"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let analysisIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .analysisId)
        analysisId = analysisIdDecoded
        let deletionTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .deletionTime)
        deletionTime = deletionTimeDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DeleteDashboardInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDashboardInput(awsAccountId: \(String(describing: awsAccountId)), dashboardId: \(String(describing: dashboardId)), versionNumber: \(String(describing: versionNumber)))"}
}

extension DeleteDashboardInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDashboardInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDashboardInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDashboardInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDashboardInput>
    public typealias MOutput = OperationOutput<DeleteDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDashboardOutputError>
}

public struct DeleteDashboardInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDashboardInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDashboardInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let versionNumber = input.operationInput.versionNumber {
            let versionNumberQueryItem = URLQueryItem(name: "version-number".urlPercentEncoding(), value: String(versionNumber).urlPercentEncoding())
            input.builder.withQueryItem(versionNumberQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDashboardInput>
    public typealias MOutput = OperationOutput<DeleteDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDashboardOutputError>
}

public struct DeleteDashboardInput: Equatable {
    /// <p>The ID of the AWS account that contains the dashboard that you're
    ///             deleting.</p>
    public let awsAccountId: String?
    /// <p>The ID for the dashboard.</p>
    public let dashboardId: String?
    /// <p>The version number of the dashboard. If the version number property is provided, only
    ///             the specified version of the dashboard is deleted.</p>
    public let versionNumber: Int?

    public init (
        awsAccountId: String? = nil,
        dashboardId: String? = nil,
        versionNumber: Int? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.versionNumber = versionNumber
    }
}

struct DeleteDashboardInputBody: Equatable {
}

extension DeleteDashboardInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDashboardOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDashboardOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDashboardOutputError: Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDashboardOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDashboardOutputResponse(arn: \(String(describing: arn)), dashboardId: \(String(describing: dashboardId)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension DeleteDashboardOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteDashboardOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.dashboardId = output.dashboardId
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.dashboardId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteDashboardOutputResponse: Equatable {
    /// <p>The Secure Socket Layer (SSL) properties that apply for the resource.</p>
    public let arn: String?
    /// <p>The ID of the dashboard.</p>
    public let dashboardId: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        arn: String? = nil,
        dashboardId: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.arn = arn
        self.dashboardId = dashboardId
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteDashboardOutputResponseBody: Equatable {
    public let status: Int
    public let arn: String?
    public let dashboardId: String?
    public let requestId: String?
}

extension DeleteDashboardOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case dashboardId = "DashboardId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let dashboardIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DeleteDataSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDataSetInput(awsAccountId: \(String(describing: awsAccountId)), dataSetId: \(String(describing: dataSetId)))"}
}

extension DeleteDataSetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDataSetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDataSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDataSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDataSetInput>
    public typealias MOutput = OperationOutput<DeleteDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDataSetOutputError>
}

public struct DeleteDataSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDataSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDataSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDataSetInput>
    public typealias MOutput = OperationOutput<DeleteDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDataSetOutputError>
}

public struct DeleteDataSetInput: Equatable {
    /// <p>The AWS account ID.</p>
    public let awsAccountId: String?
    /// <p>The ID for the dataset that you want to create. This ID is unique per AWS Region for each AWS account.</p>
    public let dataSetId: String?

    public init (
        awsAccountId: String? = nil,
        dataSetId: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
    }
}

struct DeleteDataSetInputBody: Equatable {
}

extension DeleteDataSetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDataSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDataSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDataSetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDataSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDataSetOutputResponse(arn: \(String(describing: arn)), dataSetId: \(String(describing: dataSetId)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension DeleteDataSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteDataSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.dataSetId = output.dataSetId
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.dataSetId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteDataSetOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset.</p>
    public let arn: String?
    /// <p>The ID for the dataset that you want to create. This ID is unique per AWS Region for each AWS account.</p>
    public let dataSetId: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        arn: String? = nil,
        dataSetId: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.arn = arn
        self.dataSetId = dataSetId
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteDataSetOutputResponseBody: Equatable {
    public let arn: String?
    public let dataSetId: String?
    public let requestId: String?
    public let status: Int
}

extension DeleteDataSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case dataSetId = "DataSetId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteDataSourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDataSourceInput(awsAccountId: \(String(describing: awsAccountId)), dataSourceId: \(String(describing: dataSourceId)))"}
}

extension DeleteDataSourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDataSourceInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDataSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDataSourceInput>
    public typealias MOutput = OperationOutput<DeleteDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDataSourceOutputError>
}

public struct DeleteDataSourceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDataSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDataSourceInput>
    public typealias MOutput = OperationOutput<DeleteDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDataSourceOutputError>
}

public struct DeleteDataSourceInput: Equatable {
    /// <p>The AWS account ID.</p>
    public let awsAccountId: String?
    /// <p>The ID of the data source. This ID is unique per AWS Region for each AWS account.</p>
    public let dataSourceId: String?

    public init (
        awsAccountId: String? = nil,
        dataSourceId: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSourceId = dataSourceId
    }
}

struct DeleteDataSourceInputBody: Equatable {
}

extension DeleteDataSourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDataSourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDataSourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDataSourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDataSourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDataSourceOutputResponse(arn: \(String(describing: arn)), dataSourceId: \(String(describing: dataSourceId)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension DeleteDataSourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteDataSourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.dataSourceId = output.dataSourceId
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.dataSourceId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteDataSourceOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the data source that you deleted.</p>
    public let arn: String?
    /// <p>The ID of the data source. This ID is unique per AWS Region for each AWS account.</p>
    public let dataSourceId: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        arn: String? = nil,
        dataSourceId: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.arn = arn
        self.dataSourceId = dataSourceId
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteDataSourceOutputResponseBody: Equatable {
    public let arn: String?
    public let dataSourceId: String?
    public let requestId: String?
    public let status: Int
}

extension DeleteDataSourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case dataSourceId = "DataSourceId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGroupInput(awsAccountId: \(String(describing: awsAccountId)), groupName: \(String(describing: groupName)), namespace: \(String(describing: namespace)))"}
}

extension DeleteGroupInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGroupInput>
    public typealias MOutput = OperationOutput<DeleteGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGroupOutputError>
}

public struct DeleteGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGroupInput>
    public typealias MOutput = OperationOutput<DeleteGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGroupOutputError>
}

public struct DeleteGroupInput: Equatable {
    /// <p>The ID for the AWS account that the group is in. Currently, you use the ID for the AWS
    /// 			account that contains your Amazon QuickSight account.</p>
    public let awsAccountId: String?
    /// <p>The name of the group that you want to delete.</p>
    public let groupName: String?
    /// <p>The namespace. Currently, you should set this to <code>default</code>.</p>
    public let namespace: String?

    public init (
        awsAccountId: String? = nil,
        groupName: String? = nil,
        namespace: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.groupName = groupName
        self.namespace = namespace
    }
}

struct DeleteGroupInputBody: Equatable {
}

extension DeleteGroupInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteGroupMembershipInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGroupMembershipInput(awsAccountId: \(String(describing: awsAccountId)), groupName: \(String(describing: groupName)), memberName: \(String(describing: memberName)), namespace: \(String(describing: namespace)))"}
}

extension DeleteGroupMembershipInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteGroupMembershipInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteGroupMembershipInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGroupMembershipInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGroupMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGroupMembershipInput>
    public typealias MOutput = OperationOutput<DeleteGroupMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGroupMembershipOutputError>
}

public struct DeleteGroupMembershipInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteGroupMembershipInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGroupMembershipInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGroupMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGroupMembershipInput>
    public typealias MOutput = OperationOutput<DeleteGroupMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGroupMembershipOutputError>
}

public struct DeleteGroupMembershipInput: Equatable {
    /// <p>The ID for the AWS account that the group is in. Currently, you use the ID for the AWS
    /// 			account that contains your Amazon QuickSight account.</p>
    public let awsAccountId: String?
    /// <p>The name of the group that you want to delete the user from.</p>
    public let groupName: String?
    /// <p>The name of the user that you want to delete from the group membership.</p>
    public let memberName: String?
    /// <p>The namespace. Currently, you should set this to <code>default</code>.</p>
    public let namespace: String?

    public init (
        awsAccountId: String? = nil,
        groupName: String? = nil,
        memberName: String? = nil,
        namespace: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.groupName = groupName
        self.memberName = memberName
        self.namespace = namespace
    }
}

struct DeleteGroupMembershipInputBody: Equatable {
}

extension DeleteGroupMembershipInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteGroupMembershipOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGroupMembershipOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGroupMembershipOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGroupMembershipOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGroupMembershipOutputResponse(requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension DeleteGroupMembershipOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteGroupMembershipOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.requestId = output.requestId
        } else {
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteGroupMembershipOutputResponse: Equatable {
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteGroupMembershipOutputResponseBody: Equatable {
    public let requestId: String?
    public let status: Int
}

extension DeleteGroupMembershipOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGroupOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGroupOutputResponse(requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension DeleteGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.requestId = output.requestId
        } else {
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteGroupOutputResponse: Equatable {
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteGroupOutputResponseBody: Equatable {
    public let requestId: String?
    public let status: Int
}

extension DeleteGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteIAMPolicyAssignmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIAMPolicyAssignmentInput(assignmentName: \(String(describing: assignmentName)), awsAccountId: \(String(describing: awsAccountId)), namespace: \(String(describing: namespace)))"}
}

extension DeleteIAMPolicyAssignmentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteIAMPolicyAssignmentInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteIAMPolicyAssignmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIAMPolicyAssignmentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIAMPolicyAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIAMPolicyAssignmentInput>
    public typealias MOutput = OperationOutput<DeleteIAMPolicyAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIAMPolicyAssignmentOutputError>
}

public struct DeleteIAMPolicyAssignmentInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteIAMPolicyAssignmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIAMPolicyAssignmentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIAMPolicyAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIAMPolicyAssignmentInput>
    public typealias MOutput = OperationOutput<DeleteIAMPolicyAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIAMPolicyAssignmentOutputError>
}

public struct DeleteIAMPolicyAssignmentInput: Equatable {
    /// <p>The name of the assignment. </p>
    public let assignmentName: String?
    /// <p>The AWS account ID where you want to delete the IAM policy assignment.</p>
    public let awsAccountId: String?
    /// <p>The namespace that contains the assignment.</p>
    public let namespace: String?

    public init (
        assignmentName: String? = nil,
        awsAccountId: String? = nil,
        namespace: String? = nil
    )
    {
        self.assignmentName = assignmentName
        self.awsAccountId = awsAccountId
        self.namespace = namespace
    }
}

struct DeleteIAMPolicyAssignmentInputBody: Equatable {
}

extension DeleteIAMPolicyAssignmentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteIAMPolicyAssignmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIAMPolicyAssignmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentUpdatingException" : self = .concurrentUpdatingException(try ConcurrentUpdatingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIAMPolicyAssignmentOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case concurrentUpdatingException(ConcurrentUpdatingException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIAMPolicyAssignmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIAMPolicyAssignmentOutputResponse(assignmentName: \(String(describing: assignmentName)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension DeleteIAMPolicyAssignmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteIAMPolicyAssignmentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assignmentName = output.assignmentName
            self.requestId = output.requestId
        } else {
            self.assignmentName = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteIAMPolicyAssignmentOutputResponse: Equatable {
    /// <p>The name of the assignment. </p>
    public let assignmentName: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        assignmentName: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.assignmentName = assignmentName
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteIAMPolicyAssignmentOutputResponseBody: Equatable {
    public let assignmentName: String?
    public let requestId: String?
    public let status: Int
}

extension DeleteIAMPolicyAssignmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assignmentName = "AssignmentName"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assignmentName)
        assignmentName = assignmentNameDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteNamespaceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteNamespaceInput(awsAccountId: \(String(describing: awsAccountId)), namespace: \(String(describing: namespace)))"}
}

extension DeleteNamespaceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteNamespaceInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteNamespaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteNamespaceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteNamespaceInput>
    public typealias MOutput = OperationOutput<DeleteNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteNamespaceOutputError>
}

public struct DeleteNamespaceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteNamespaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteNamespaceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteNamespaceInput>
    public typealias MOutput = OperationOutput<DeleteNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteNamespaceOutputError>
}

public struct DeleteNamespaceInput: Equatable {
    /// <p>The ID for the AWS account that you want to delete the QuickSight namespace from.</p>
    public let awsAccountId: String?
    /// <p>The namespace that you want to delete.</p>
    public let namespace: String?

    public init (
        awsAccountId: String? = nil,
        namespace: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.namespace = namespace
    }
}

struct DeleteNamespaceInputBody: Equatable {
}

extension DeleteNamespaceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteNamespaceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNamespaceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteNamespaceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNamespaceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteNamespaceOutputResponse(requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension DeleteNamespaceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.requestId = output.requestId
        } else {
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteNamespaceOutputResponse: Equatable {
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteNamespaceOutputResponseBody: Equatable {
    public let requestId: String?
    public let status: Int
}

extension DeleteNamespaceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteTemplateAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTemplateAliasInput(aliasName: \(String(describing: aliasName)), awsAccountId: \(String(describing: awsAccountId)), templateId: \(String(describing: templateId)))"}
}

extension DeleteTemplateAliasInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteTemplateAliasInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTemplateAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTemplateAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTemplateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTemplateAliasInput>
    public typealias MOutput = OperationOutput<DeleteTemplateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTemplateAliasOutputError>
}

public struct DeleteTemplateAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTemplateAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTemplateAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTemplateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTemplateAliasInput>
    public typealias MOutput = OperationOutput<DeleteTemplateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTemplateAliasOutputError>
}

public struct DeleteTemplateAliasInput: Equatable {
    /// <p>The name for the template alias. To delete a specific alias, you delete the version that the
    /// 			alias points to. You can specify the alias name, or specify the latest version of the
    /// 			template by providing the keyword <code>$LATEST</code> in the <code>AliasName</code>
    /// 			parameter. </p>
    public let aliasName: String?
    /// <p>The ID of the AWS account that contains the item to delete.</p>
    public let awsAccountId: String?
    /// <p>The ID for the template that the specified alias is for.</p>
    public let templateId: String?

    public init (
        aliasName: String? = nil,
        awsAccountId: String? = nil,
        templateId: String? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.templateId = templateId
    }
}

struct DeleteTemplateAliasInputBody: Equatable {
}

extension DeleteTemplateAliasInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteTemplateAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTemplateAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTemplateAliasOutputError: Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTemplateAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTemplateAliasOutputResponse(aliasName: \(String(describing: aliasName)), arn: \(String(describing: arn)), requestId: \(String(describing: requestId)), status: \(String(describing: status)), templateId: \(String(describing: templateId)))"}
}

extension DeleteTemplateAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteTemplateAliasOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.aliasName = output.aliasName
            self.arn = output.arn
            self.requestId = output.requestId
            self.templateId = output.templateId
        } else {
            self.aliasName = nil
            self.arn = nil
            self.requestId = nil
            self.templateId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteTemplateAliasOutputResponse: Equatable {
    /// <p>The name for the template alias.</p>
    public let aliasName: String?
    /// <p>The Amazon Resource Name (ARN) of the template you want to delete.</p>
    public let arn: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>An ID for the template associated with the deletion.</p>
    public let templateId: String?

    public init (
        aliasName: String? = nil,
        arn: String? = nil,
        requestId: String? = nil,
        status: Int = 0,
        templateId: String? = nil
    )
    {
        self.aliasName = aliasName
        self.arn = arn
        self.requestId = requestId
        self.status = status
        self.templateId = templateId
    }
}

struct DeleteTemplateAliasOutputResponseBody: Equatable {
    public let status: Int
    public let templateId: String?
    public let aliasName: String?
    public let arn: String?
    public let requestId: String?
}

extension DeleteTemplateAliasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aliasName = "AliasName"
        case arn = "Arn"
        case requestId = "RequestId"
        case status = "Status"
        case templateId = "TemplateId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let aliasNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aliasName)
        aliasName = aliasNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DeleteTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTemplateInput(awsAccountId: \(String(describing: awsAccountId)), templateId: \(String(describing: templateId)), versionNumber: \(String(describing: versionNumber)))"}
}

extension DeleteTemplateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTemplateInput>
    public typealias MOutput = OperationOutput<DeleteTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTemplateOutputError>
}

public struct DeleteTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let versionNumber = input.operationInput.versionNumber {
            let versionNumberQueryItem = URLQueryItem(name: "version-number".urlPercentEncoding(), value: String(versionNumber).urlPercentEncoding())
            input.builder.withQueryItem(versionNumberQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTemplateInput>
    public typealias MOutput = OperationOutput<DeleteTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTemplateOutputError>
}

public struct DeleteTemplateInput: Equatable {
    /// <p>The ID of the AWS account that contains the template that you're deleting.</p>
    public let awsAccountId: String?
    /// <p>An ID for the template you want to delete.</p>
    public let templateId: String?
    /// <p>Specifies the version of the template that you want to delete.
    /// 			If you don't provide a version number, <code>DeleteTemplate</code> deletes all versions of the template.
    /// 	 </p>
    public let versionNumber: Int?

    public init (
        awsAccountId: String? = nil,
        templateId: String? = nil,
        versionNumber: Int? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.templateId = templateId
        self.versionNumber = versionNumber
    }
}

struct DeleteTemplateInputBody: Equatable {
}

extension DeleteTemplateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTemplateOutputError: Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTemplateOutputResponse(arn: \(String(describing: arn)), requestId: \(String(describing: requestId)), status: \(String(describing: status)), templateId: \(String(describing: templateId)))"}
}

extension DeleteTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.requestId = output.requestId
            self.templateId = output.templateId
        } else {
            self.arn = nil
            self.requestId = nil
            self.templateId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteTemplateOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let arn: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>An ID for the template.</p>
    public let templateId: String?

    public init (
        arn: String? = nil,
        requestId: String? = nil,
        status: Int = 0,
        templateId: String? = nil
    )
    {
        self.arn = arn
        self.requestId = requestId
        self.status = status
        self.templateId = templateId
    }
}

struct DeleteTemplateOutputResponseBody: Equatable {
    public let requestId: String?
    public let arn: String?
    public let templateId: String?
    public let status: Int
}

extension DeleteTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case requestId = "RequestId"
        case status = "Status"
        case templateId = "TemplateId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteThemeAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteThemeAliasInput(aliasName: \(String(describing: aliasName)), awsAccountId: \(String(describing: awsAccountId)), themeId: \(String(describing: themeId)))"}
}

extension DeleteThemeAliasInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteThemeAliasInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteThemeAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteThemeAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteThemeAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteThemeAliasInput>
    public typealias MOutput = OperationOutput<DeleteThemeAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteThemeAliasOutputError>
}

public struct DeleteThemeAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteThemeAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteThemeAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteThemeAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteThemeAliasInput>
    public typealias MOutput = OperationOutput<DeleteThemeAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteThemeAliasOutputError>
}

public struct DeleteThemeAliasInput: Equatable {
    /// <p>The unique name for the theme alias to delete.</p>
    public let aliasName: String?
    /// <p>The ID of the AWS account that contains the theme alias to delete.</p>
    public let awsAccountId: String?
    /// <p>The ID for the theme that the specified alias is for.</p>
    public let themeId: String?

    public init (
        aliasName: String? = nil,
        awsAccountId: String? = nil,
        themeId: String? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.themeId = themeId
    }
}

struct DeleteThemeAliasInputBody: Equatable {
}

extension DeleteThemeAliasInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteThemeAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteThemeAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteThemeAliasOutputError: Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteThemeAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteThemeAliasOutputResponse(aliasName: \(String(describing: aliasName)), arn: \(String(describing: arn)), requestId: \(String(describing: requestId)), status: \(String(describing: status)), themeId: \(String(describing: themeId)))"}
}

extension DeleteThemeAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteThemeAliasOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.aliasName = output.aliasName
            self.arn = output.arn
            self.requestId = output.requestId
            self.themeId = output.themeId
        } else {
            self.aliasName = nil
            self.arn = nil
            self.requestId = nil
            self.themeId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteThemeAliasOutputResponse: Equatable {
    /// <p>The name for the theme alias.</p>
    public let aliasName: String?
    /// <p>The Amazon Resource Name (ARN) of the theme resource using the deleted alias.</p>
    public let arn: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>An ID for the theme associated with the deletion.</p>
    public let themeId: String?

    public init (
        aliasName: String? = nil,
        arn: String? = nil,
        requestId: String? = nil,
        status: Int = 0,
        themeId: String? = nil
    )
    {
        self.aliasName = aliasName
        self.arn = arn
        self.requestId = requestId
        self.status = status
        self.themeId = themeId
    }
}

struct DeleteThemeAliasOutputResponseBody: Equatable {
    public let aliasName: String?
    public let arn: String?
    public let requestId: String?
    public let status: Int
    public let themeId: String?
}

extension DeleteThemeAliasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aliasName = "AliasName"
        case arn = "Arn"
        case requestId = "RequestId"
        case status = "Status"
        case themeId = "ThemeId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aliasName)
        aliasName = aliasNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let themeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .themeId)
        themeId = themeIdDecoded
    }
}

extension DeleteThemeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteThemeInput(awsAccountId: \(String(describing: awsAccountId)), themeId: \(String(describing: themeId)), versionNumber: \(String(describing: versionNumber)))"}
}

extension DeleteThemeInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteThemeInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteThemeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteThemeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteThemeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteThemeInput>
    public typealias MOutput = OperationOutput<DeleteThemeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteThemeOutputError>
}

public struct DeleteThemeInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteThemeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteThemeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteThemeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let versionNumber = input.operationInput.versionNumber {
            let versionNumberQueryItem = URLQueryItem(name: "version-number".urlPercentEncoding(), value: String(versionNumber).urlPercentEncoding())
            input.builder.withQueryItem(versionNumberQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteThemeInput>
    public typealias MOutput = OperationOutput<DeleteThemeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteThemeOutputError>
}

public struct DeleteThemeInput: Equatable {
    /// <p>The ID of the AWS account that contains the theme that you're deleting.</p>
    public let awsAccountId: String?
    /// <p>An ID for the theme that you want to delete.</p>
    public let themeId: String?
    /// <p>The version of the theme that you want to delete. </p>
    /// 		       <p>
    ///             <b>Note:</b> If you don't provide a version number, you're
    /// 			using this call to <code>DeleteTheme</code> to delete all versions of the theme.</p>
    public let versionNumber: Int?

    public init (
        awsAccountId: String? = nil,
        themeId: String? = nil,
        versionNumber: Int? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.themeId = themeId
        self.versionNumber = versionNumber
    }
}

struct DeleteThemeInputBody: Equatable {
}

extension DeleteThemeInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteThemeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteThemeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteThemeOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteThemeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteThemeOutputResponse(arn: \(String(describing: arn)), requestId: \(String(describing: requestId)), status: \(String(describing: status)), themeId: \(String(describing: themeId)))"}
}

extension DeleteThemeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteThemeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.requestId = output.requestId
            self.themeId = output.themeId
        } else {
            self.arn = nil
            self.requestId = nil
            self.themeId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteThemeOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let arn: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>An ID for the theme.</p>
    public let themeId: String?

    public init (
        arn: String? = nil,
        requestId: String? = nil,
        status: Int = 0,
        themeId: String? = nil
    )
    {
        self.arn = arn
        self.requestId = requestId
        self.status = status
        self.themeId = themeId
    }
}

struct DeleteThemeOutputResponseBody: Equatable {
    public let arn: String?
    public let requestId: String?
    public let status: Int
    public let themeId: String?
}

extension DeleteThemeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case requestId = "RequestId"
        case status = "Status"
        case themeId = "ThemeId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let themeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .themeId)
        themeId = themeIdDecoded
    }
}

extension DeleteUserByPrincipalIdInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserByPrincipalIdInput(awsAccountId: \(String(describing: awsAccountId)), namespace: \(String(describing: namespace)), principalId: \(String(describing: principalId)))"}
}

extension DeleteUserByPrincipalIdInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteUserByPrincipalIdInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteUserByPrincipalIdInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserByPrincipalIdInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserByPrincipalIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserByPrincipalIdInput>
    public typealias MOutput = OperationOutput<DeleteUserByPrincipalIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserByPrincipalIdOutputError>
}

public struct DeleteUserByPrincipalIdInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteUserByPrincipalIdInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserByPrincipalIdInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserByPrincipalIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserByPrincipalIdInput>
    public typealias MOutput = OperationOutput<DeleteUserByPrincipalIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserByPrincipalIdOutputError>
}

/// <p></p>
public struct DeleteUserByPrincipalIdInput: Equatable {
    /// <p>The ID for the AWS account that the user is in. Currently, you use the ID for the AWS
    /// 			account that contains your Amazon QuickSight account.</p>
    public let awsAccountId: String?
    /// <p>The namespace. Currently, you should set this to <code>default</code>.</p>
    public let namespace: String?
    /// <p>The principal ID of the user.</p>
    public let principalId: String?

    public init (
        awsAccountId: String? = nil,
        namespace: String? = nil,
        principalId: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.principalId = principalId
    }
}

struct DeleteUserByPrincipalIdInputBody: Equatable {
}

extension DeleteUserByPrincipalIdInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteUserByPrincipalIdOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserByPrincipalIdOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserByPrincipalIdOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserByPrincipalIdOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserByPrincipalIdOutputResponse(requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension DeleteUserByPrincipalIdOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteUserByPrincipalIdOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.requestId = output.requestId
        } else {
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteUserByPrincipalIdOutputResponse: Equatable {
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteUserByPrincipalIdOutputResponseBody: Equatable {
    public let requestId: String?
    public let status: Int
}

extension DeleteUserByPrincipalIdOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserInput(awsAccountId: \(String(describing: awsAccountId)), namespace: \(String(describing: namespace)), userName: \(String(describing: userName)))"}
}

extension DeleteUserInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteUserInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserInput>
    public typealias MOutput = OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserOutputError>
}

public struct DeleteUserInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserInput>
    public typealias MOutput = OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserOutputError>
}

public struct DeleteUserInput: Equatable {
    /// <p>The ID for the AWS account that the user is in. Currently, you use the ID for the AWS
    /// 			account that contains your Amazon QuickSight account.</p>
    public let awsAccountId: String?
    /// <p>The namespace. Currently, you should set this to <code>default</code>.</p>
    public let namespace: String?
    /// <p>The name of the user that you want to delete.</p>
    public let userName: String?

    public init (
        awsAccountId: String? = nil,
        namespace: String? = nil,
        userName: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.userName = userName
    }
}

struct DeleteUserInputBody: Equatable {
}

extension DeleteUserInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserOutputResponse(requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension DeleteUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteUserOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.requestId = output.requestId
        } else {
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteUserOutputResponse: Equatable {
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteUserOutputResponseBody: Equatable {
    public let requestId: String?
    public let status: Int
}

extension DeleteUserOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeAccountCustomizationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountCustomizationInput(awsAccountId: \(String(describing: awsAccountId)), namespace: \(String(describing: namespace)), resolved: \(String(describing: resolved)))"}
}

extension DescribeAccountCustomizationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeAccountCustomizationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAccountCustomizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountCustomizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountCustomizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountCustomizationInput>
    public typealias MOutput = OperationOutput<DescribeAccountCustomizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountCustomizationOutputError>
}

public struct DescribeAccountCustomizationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAccountCustomizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountCustomizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountCustomizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let resolvedQueryItem = URLQueryItem(name: "resolved".urlPercentEncoding(), value: String(input.operationInput.resolved).urlPercentEncoding())
        input.builder.withQueryItem(resolvedQueryItem)
        if let namespace = input.operationInput.namespace {
            let namespaceQueryItem = URLQueryItem(name: "namespace".urlPercentEncoding(), value: String(namespace).urlPercentEncoding())
            input.builder.withQueryItem(namespaceQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountCustomizationInput>
    public typealias MOutput = OperationOutput<DescribeAccountCustomizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountCustomizationOutputError>
}

public struct DescribeAccountCustomizationInput: Equatable {
    /// <p>The ID for the AWS account that you want to describe QuickSight customizations
    ///             for.</p>
    public let awsAccountId: String?
    /// <p>The QuickSight namespace that you want to describe QuickSight customizations
    ///             for.</p>
    public let namespace: String?
    /// <p>The <code>Resolved</code> flag works with the other parameters to determine which view
    ///             of QuickSight customizations is returned. You can add this flag to your command to use
    ///             the same view that QuickSight uses to identify which customizations to apply to the
    ///             console. Omit this flag, or set it to <code>no-resolved</code>, to reveal customizations
    ///             that are configured at different levels. </p>
    public let resolved: Bool

    public init (
        awsAccountId: String? = nil,
        namespace: String? = nil,
        resolved: Bool = false
    )
    {
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.resolved = resolved
    }
}

struct DescribeAccountCustomizationInputBody: Equatable {
}

extension DescribeAccountCustomizationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeAccountCustomizationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccountCustomizationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountCustomizationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountCustomizationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountCustomizationOutputResponse(accountCustomization: \(String(describing: accountCustomization)), arn: \(String(describing: arn)), awsAccountId: \(String(describing: awsAccountId)), namespace: \(String(describing: namespace)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension DescribeAccountCustomizationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAccountCustomizationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountCustomization = output.accountCustomization
            self.arn = output.arn
            self.awsAccountId = output.awsAccountId
            self.namespace = output.namespace
            self.requestId = output.requestId
        } else {
            self.accountCustomization = nil
            self.arn = nil
            self.awsAccountId = nil
            self.namespace = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeAccountCustomizationOutputResponse: Equatable {
    /// <p>The QuickSight customizations that exist in the current AWS Region. </p>
    public let accountCustomization: AccountCustomization?
    /// <p>The Amazon Resource Name (ARN) of the customization that's associated with this AWS account.</p>
    public let arn: String?
    /// <p>The ID for the AWS account that you're describing.</p>
    public let awsAccountId: String?
    /// <p>The QuickSight namespace that you're describing. </p>
    public let namespace: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        accountCustomization: AccountCustomization? = nil,
        arn: String? = nil,
        awsAccountId: String? = nil,
        namespace: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.accountCustomization = accountCustomization
        self.arn = arn
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeAccountCustomizationOutputResponseBody: Equatable {
    public let arn: String?
    public let awsAccountId: String?
    public let namespace: String?
    public let accountCustomization: AccountCustomization?
    public let requestId: String?
    public let status: Int
}

extension DescribeAccountCustomizationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountCustomization = "AccountCustomization"
        case arn = "Arn"
        case awsAccountId = "AwsAccountId"
        case namespace = "Namespace"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let accountCustomizationDecoded = try containerValues.decodeIfPresent(AccountCustomization.self, forKey: .accountCustomization)
        accountCustomization = accountCustomizationDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeAccountSettingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountSettingsInput(awsAccountId: \(String(describing: awsAccountId)))"}
}

extension DescribeAccountSettingsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeAccountSettingsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAccountSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountSettingsInput>
    public typealias MOutput = OperationOutput<DescribeAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountSettingsOutputError>
}

public struct DescribeAccountSettingsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAccountSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountSettingsInput>
    public typealias MOutput = OperationOutput<DescribeAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountSettingsOutputError>
}

public struct DescribeAccountSettingsInput: Equatable {
    /// <p>The ID for the AWS account that contains the settings that you want to list.</p>
    public let awsAccountId: String?

    public init (
        awsAccountId: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
    }
}

struct DescribeAccountSettingsInputBody: Equatable {
}

extension DescribeAccountSettingsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeAccountSettingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccountSettingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountSettingsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountSettingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountSettingsOutputResponse(accountSettings: \(String(describing: accountSettings)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension DescribeAccountSettingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAccountSettingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountSettings = output.accountSettings
            self.requestId = output.requestId
        } else {
            self.accountSettings = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeAccountSettingsOutputResponse: Equatable {
    /// <p>The QuickSight settings for this AWS account. This information includes the edition of Amazon
    ///             QuickSight that you subscribed to (Standard or Enterprise) and the notification email for the
    ///             QuickSight subscription. In the QuickSight console, the QuickSight subscription is sometimes
    ///             referred to as a QuickSight "account" even though it's technically not an account
    ///             by itself. Instead, it's a subscription to the QuickSight service for your AWS account. The
    ///             edition that you subscribe to applies to QuickSight in every AWS Region where you use it.</p>
    public let accountSettings: AccountSettings?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        accountSettings: AccountSettings? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.accountSettings = accountSettings
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeAccountSettingsOutputResponseBody: Equatable {
    public let accountSettings: AccountSettings?
    public let requestId: String?
    public let status: Int
}

extension DescribeAccountSettingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountSettings = "AccountSettings"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountSettingsDecoded = try containerValues.decodeIfPresent(AccountSettings.self, forKey: .accountSettings)
        accountSettings = accountSettingsDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeAnalysisInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAnalysisInput(analysisId: \(String(describing: analysisId)), awsAccountId: \(String(describing: awsAccountId)))"}
}

extension DescribeAnalysisInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeAnalysisInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAnalysisInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAnalysisInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAnalysisInput>
    public typealias MOutput = OperationOutput<DescribeAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAnalysisOutputError>
}

public struct DescribeAnalysisInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAnalysisInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAnalysisInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAnalysisInput>
    public typealias MOutput = OperationOutput<DescribeAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAnalysisOutputError>
}

public struct DescribeAnalysisInput: Equatable {
    /// <p>The ID of the analysis that you're describing. The ID is part of the URL of the
    ///             analysis.</p>
    public let analysisId: String?
    /// <p>The ID of the AWS account that contains the analysis. You must be using the AWS
    ///             account that the analysis is in.</p>
    public let awsAccountId: String?

    public init (
        analysisId: String? = nil,
        awsAccountId: String? = nil
    )
    {
        self.analysisId = analysisId
        self.awsAccountId = awsAccountId
    }
}

struct DescribeAnalysisInputBody: Equatable {
}

extension DescribeAnalysisInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeAnalysisOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAnalysisOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAnalysisOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAnalysisOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAnalysisOutputResponse(analysis: \(String(describing: analysis)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension DescribeAnalysisOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.analysis = output.analysis
            self.requestId = output.requestId
        } else {
            self.analysis = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeAnalysisOutputResponse: Equatable {
    /// <p>A metadata structure that contains summary information for the analysis that you're
    ///             describing.</p>
    public let analysis: Analysis?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        analysis: Analysis? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.analysis = analysis
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeAnalysisOutputResponseBody: Equatable {
    public let analysis: Analysis?
    public let status: Int
    public let requestId: String?
}

extension DescribeAnalysisOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analysis = "Analysis"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisDecoded = try containerValues.decodeIfPresent(Analysis.self, forKey: .analysis)
        analysis = analysisDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeAnalysisPermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAnalysisPermissionsInput(analysisId: \(String(describing: analysisId)), awsAccountId: \(String(describing: awsAccountId)))"}
}

extension DescribeAnalysisPermissionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeAnalysisPermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAnalysisPermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAnalysisPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAnalysisPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAnalysisPermissionsInput>
    public typealias MOutput = OperationOutput<DescribeAnalysisPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAnalysisPermissionsOutputError>
}

public struct DescribeAnalysisPermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAnalysisPermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAnalysisPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAnalysisPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAnalysisPermissionsInput>
    public typealias MOutput = OperationOutput<DescribeAnalysisPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAnalysisPermissionsOutputError>
}

public struct DescribeAnalysisPermissionsInput: Equatable {
    /// <p>The ID of the analysis whose permissions you're describing. The ID is part of the
    ///             analysis URL.</p>
    public let analysisId: String?
    /// <p>The ID of the AWS account that contains the analysis whose permissions you're
    ///             describing. You must be using the AWS account that the analysis is in.</p>
    public let awsAccountId: String?

    public init (
        analysisId: String? = nil,
        awsAccountId: String? = nil
    )
    {
        self.analysisId = analysisId
        self.awsAccountId = awsAccountId
    }
}

struct DescribeAnalysisPermissionsInputBody: Equatable {
}

extension DescribeAnalysisPermissionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeAnalysisPermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAnalysisPermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAnalysisPermissionsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAnalysisPermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAnalysisPermissionsOutputResponse(analysisArn: \(String(describing: analysisArn)), analysisId: \(String(describing: analysisId)), permissions: \(String(describing: permissions)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension DescribeAnalysisPermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAnalysisPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.analysisArn = output.analysisArn
            self.analysisId = output.analysisId
            self.permissions = output.permissions
            self.requestId = output.requestId
        } else {
            self.analysisArn = nil
            self.analysisId = nil
            self.permissions = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeAnalysisPermissionsOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the analysis whose permissions you're
    ///             describing.</p>
    public let analysisArn: String?
    /// <p>The ID of the analysis whose permissions you're describing.</p>
    public let analysisId: String?
    /// <p>A structure that describes the principals and the resource-level permissions on an
    ///             analysis.</p>
    public let permissions: [ResourcePermission]?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        analysisArn: String? = nil,
        analysisId: String? = nil,
        permissions: [ResourcePermission]? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.analysisArn = analysisArn
        self.analysisId = analysisId
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeAnalysisPermissionsOutputResponseBody: Equatable {
    public let analysisId: String?
    public let analysisArn: String?
    public let permissions: [ResourcePermission]?
    public let status: Int
    public let requestId: String?
}

extension DescribeAnalysisPermissionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analysisArn = "AnalysisArn"
        case analysisId = "AnalysisId"
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .analysisId)
        analysisId = analysisIdDecoded
        let analysisArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .analysisArn)
        analysisArn = analysisArnDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeDashboardInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDashboardInput(aliasName: \(String(describing: aliasName)), awsAccountId: \(String(describing: awsAccountId)), dashboardId: \(String(describing: dashboardId)), versionNumber: \(String(describing: versionNumber)))"}
}

extension DescribeDashboardInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeDashboardInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDashboardInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDashboardInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDashboardInput>
    public typealias MOutput = OperationOutput<DescribeDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDashboardOutputError>
}

public struct DescribeDashboardInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDashboardInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDashboardInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let aliasName = input.operationInput.aliasName {
            let aliasNameQueryItem = URLQueryItem(name: "alias-name".urlPercentEncoding(), value: String(aliasName).urlPercentEncoding())
            input.builder.withQueryItem(aliasNameQueryItem)
        }
        if let versionNumber = input.operationInput.versionNumber {
            let versionNumberQueryItem = URLQueryItem(name: "version-number".urlPercentEncoding(), value: String(versionNumber).urlPercentEncoding())
            input.builder.withQueryItem(versionNumberQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDashboardInput>
    public typealias MOutput = OperationOutput<DescribeDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDashboardOutputError>
}

public struct DescribeDashboardInput: Equatable {
    /// <p>The alias name.</p>
    public let aliasName: String?
    /// <p>The ID of the AWS account that contains the dashboard that you're
    ///             describing.</p>
    public let awsAccountId: String?
    /// <p>The ID for the dashboard.</p>
    public let dashboardId: String?
    /// <p>The version number for the dashboard. If a version number isn't passed, the
    ///             latest published dashboard version is described. </p>
    public let versionNumber: Int?

    public init (
        aliasName: String? = nil,
        awsAccountId: String? = nil,
        dashboardId: String? = nil,
        versionNumber: Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.versionNumber = versionNumber
    }
}

struct DescribeDashboardInputBody: Equatable {
}

extension DescribeDashboardInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeDashboardOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDashboardOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDashboardOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDashboardOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDashboardOutputResponse(dashboard: \(String(describing: dashboard)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension DescribeDashboardOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDashboardOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dashboard = output.dashboard
            self.requestId = output.requestId
        } else {
            self.dashboard = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeDashboardOutputResponse: Equatable {
    /// <p>Information about the dashboard.</p>
    public let dashboard: Dashboard?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of this request.</p>
    public let status: Int

    public init (
        dashboard: Dashboard? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.dashboard = dashboard
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeDashboardOutputResponseBody: Equatable {
    public let dashboard: Dashboard?
    public let status: Int
    public let requestId: String?
}

extension DescribeDashboardOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dashboard = "Dashboard"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardDecoded = try containerValues.decodeIfPresent(Dashboard.self, forKey: .dashboard)
        dashboard = dashboardDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeDashboardPermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDashboardPermissionsInput(awsAccountId: \(String(describing: awsAccountId)), dashboardId: \(String(describing: dashboardId)))"}
}

extension DescribeDashboardPermissionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeDashboardPermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDashboardPermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDashboardPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDashboardPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDashboardPermissionsInput>
    public typealias MOutput = OperationOutput<DescribeDashboardPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDashboardPermissionsOutputError>
}

public struct DescribeDashboardPermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDashboardPermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDashboardPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDashboardPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDashboardPermissionsInput>
    public typealias MOutput = OperationOutput<DescribeDashboardPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDashboardPermissionsOutputError>
}

public struct DescribeDashboardPermissionsInput: Equatable {
    /// <p>The ID of the AWS account that contains the dashboard that you're describing
    ///             permissions for.</p>
    public let awsAccountId: String?
    /// <p>The ID for the dashboard, also added to the IAM policy.</p>
    public let dashboardId: String?

    public init (
        awsAccountId: String? = nil,
        dashboardId: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
    }
}

struct DescribeDashboardPermissionsInputBody: Equatable {
}

extension DescribeDashboardPermissionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeDashboardPermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDashboardPermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDashboardPermissionsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDashboardPermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDashboardPermissionsOutputResponse(dashboardArn: \(String(describing: dashboardArn)), dashboardId: \(String(describing: dashboardId)), permissions: \(String(describing: permissions)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension DescribeDashboardPermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDashboardPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dashboardArn = output.dashboardArn
            self.dashboardId = output.dashboardId
            self.permissions = output.permissions
            self.requestId = output.requestId
        } else {
            self.dashboardArn = nil
            self.dashboardId = nil
            self.permissions = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeDashboardPermissionsOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dashboard.</p>
    public let dashboardArn: String?
    /// <p>The ID for the dashboard.</p>
    public let dashboardId: String?
    /// <p>A structure that contains the permissions for the dashboard.</p>
    public let permissions: [ResourcePermission]?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        dashboardArn: String? = nil,
        dashboardId: String? = nil,
        permissions: [ResourcePermission]? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.dashboardArn = dashboardArn
        self.dashboardId = dashboardId
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeDashboardPermissionsOutputResponseBody: Equatable {
    public let dashboardId: String?
    public let dashboardArn: String?
    public let permissions: [ResourcePermission]?
    public let status: Int
    public let requestId: String?
}

extension DescribeDashboardPermissionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dashboardArn = "DashboardArn"
        case dashboardId = "DashboardId"
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let dashboardArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dashboardArn)
        dashboardArn = dashboardArnDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeDataSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDataSetInput(awsAccountId: \(String(describing: awsAccountId)), dataSetId: \(String(describing: dataSetId)))"}
}

extension DescribeDataSetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeDataSetInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDataSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDataSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDataSetInput>
    public typealias MOutput = OperationOutput<DescribeDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDataSetOutputError>
}

public struct DescribeDataSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDataSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDataSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDataSetInput>
    public typealias MOutput = OperationOutput<DescribeDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDataSetOutputError>
}

public struct DescribeDataSetInput: Equatable {
    /// <p>The AWS account ID.</p>
    public let awsAccountId: String?
    /// <p>The ID for the dataset that you want to create. This ID is unique per AWS Region for each AWS account.</p>
    public let dataSetId: String?

    public init (
        awsAccountId: String? = nil,
        dataSetId: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
    }
}

struct DescribeDataSetInputBody: Equatable {
}

extension DescribeDataSetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeDataSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDataSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDataSetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDataSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDataSetOutputResponse(dataSet: \(String(describing: dataSet)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension DescribeDataSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDataSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dataSet = output.dataSet
            self.requestId = output.requestId
        } else {
            self.dataSet = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeDataSetOutputResponse: Equatable {
    /// <p>Information on the dataset.</p>
    public let dataSet: DataSet?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        dataSet: DataSet? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.dataSet = dataSet
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeDataSetOutputResponseBody: Equatable {
    public let dataSet: DataSet?
    public let requestId: String?
    public let status: Int
}

extension DescribeDataSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataSet = "DataSet"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetDecoded = try containerValues.decodeIfPresent(DataSet.self, forKey: .dataSet)
        dataSet = dataSetDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeDataSetPermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDataSetPermissionsInput(awsAccountId: \(String(describing: awsAccountId)), dataSetId: \(String(describing: dataSetId)))"}
}

extension DescribeDataSetPermissionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeDataSetPermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDataSetPermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDataSetPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDataSetPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDataSetPermissionsInput>
    public typealias MOutput = OperationOutput<DescribeDataSetPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDataSetPermissionsOutputError>
}

public struct DescribeDataSetPermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDataSetPermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDataSetPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDataSetPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDataSetPermissionsInput>
    public typealias MOutput = OperationOutput<DescribeDataSetPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDataSetPermissionsOutputError>
}

public struct DescribeDataSetPermissionsInput: Equatable {
    /// <p>The AWS account ID.</p>
    public let awsAccountId: String?
    /// <p>The ID for the dataset that you want to create. This ID is unique per AWS Region for each AWS account.</p>
    public let dataSetId: String?

    public init (
        awsAccountId: String? = nil,
        dataSetId: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
    }
}

struct DescribeDataSetPermissionsInputBody: Equatable {
}

extension DescribeDataSetPermissionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeDataSetPermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDataSetPermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDataSetPermissionsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDataSetPermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDataSetPermissionsOutputResponse(dataSetArn: \(String(describing: dataSetArn)), dataSetId: \(String(describing: dataSetId)), permissions: \(String(describing: permissions)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension DescribeDataSetPermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDataSetPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dataSetArn = output.dataSetArn
            self.dataSetId = output.dataSetId
            self.permissions = output.permissions
            self.requestId = output.requestId
        } else {
            self.dataSetArn = nil
            self.dataSetId = nil
            self.permissions = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeDataSetPermissionsOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset.</p>
    public let dataSetArn: String?
    /// <p>The ID for the dataset that you want to create. This ID is unique per AWS Region for each AWS account.</p>
    public let dataSetId: String?
    /// <p>A list of resource permissions on the dataset.</p>
    public let permissions: [ResourcePermission]?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        dataSetArn: String? = nil,
        dataSetId: String? = nil,
        permissions: [ResourcePermission]? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.dataSetArn = dataSetArn
        self.dataSetId = dataSetId
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeDataSetPermissionsOutputResponseBody: Equatable {
    public let dataSetArn: String?
    public let dataSetId: String?
    public let permissions: [ResourcePermission]?
    public let requestId: String?
    public let status: Int
}

extension DescribeDataSetPermissionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataSetArn = "DataSetArn"
        case dataSetId = "DataSetId"
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetArn)
        dataSetArn = dataSetArnDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeDataSourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDataSourceInput(awsAccountId: \(String(describing: awsAccountId)), dataSourceId: \(String(describing: dataSourceId)))"}
}

extension DescribeDataSourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeDataSourceInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDataSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDataSourceInput>
    public typealias MOutput = OperationOutput<DescribeDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDataSourceOutputError>
}

public struct DescribeDataSourceInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDataSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDataSourceInput>
    public typealias MOutput = OperationOutput<DescribeDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDataSourceOutputError>
}

public struct DescribeDataSourceInput: Equatable {
    /// <p>The AWS account ID.</p>
    public let awsAccountId: String?
    /// <p>The ID of the data source. This ID is unique per AWS Region for each AWS account.</p>
    public let dataSourceId: String?

    public init (
        awsAccountId: String? = nil,
        dataSourceId: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSourceId = dataSourceId
    }
}

struct DescribeDataSourceInputBody: Equatable {
}

extension DescribeDataSourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeDataSourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDataSourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDataSourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDataSourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDataSourceOutputResponse(dataSource: \(String(describing: dataSource)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension DescribeDataSourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDataSourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dataSource = output.dataSource
            self.requestId = output.requestId
        } else {
            self.dataSource = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeDataSourceOutputResponse: Equatable {
    /// <p>The information on the data source.</p>
    public let dataSource: DataSource?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        dataSource: DataSource? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.dataSource = dataSource
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeDataSourceOutputResponseBody: Equatable {
    public let dataSource: DataSource?
    public let requestId: String?
    public let status: Int
}

extension DescribeDataSourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataSource = "DataSource"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeDataSourcePermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDataSourcePermissionsInput(awsAccountId: \(String(describing: awsAccountId)), dataSourceId: \(String(describing: dataSourceId)))"}
}

extension DescribeDataSourcePermissionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeDataSourcePermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDataSourcePermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDataSourcePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDataSourcePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDataSourcePermissionsInput>
    public typealias MOutput = OperationOutput<DescribeDataSourcePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDataSourcePermissionsOutputError>
}

public struct DescribeDataSourcePermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDataSourcePermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDataSourcePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDataSourcePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDataSourcePermissionsInput>
    public typealias MOutput = OperationOutput<DescribeDataSourcePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDataSourcePermissionsOutputError>
}

public struct DescribeDataSourcePermissionsInput: Equatable {
    /// <p>The AWS account ID.</p>
    public let awsAccountId: String?
    /// <p>The ID of the data source. This ID is unique per AWS Region for each AWS account.</p>
    public let dataSourceId: String?

    public init (
        awsAccountId: String? = nil,
        dataSourceId: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSourceId = dataSourceId
    }
}

struct DescribeDataSourcePermissionsInputBody: Equatable {
}

extension DescribeDataSourcePermissionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeDataSourcePermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDataSourcePermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDataSourcePermissionsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDataSourcePermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDataSourcePermissionsOutputResponse(dataSourceArn: \(String(describing: dataSourceArn)), dataSourceId: \(String(describing: dataSourceId)), permissions: \(String(describing: permissions)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension DescribeDataSourcePermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDataSourcePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dataSourceArn = output.dataSourceArn
            self.dataSourceId = output.dataSourceId
            self.permissions = output.permissions
            self.requestId = output.requestId
        } else {
            self.dataSourceArn = nil
            self.dataSourceId = nil
            self.permissions = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeDataSourcePermissionsOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the data source.</p>
    public let dataSourceArn: String?
    /// <p>The ID of the data source. This ID is unique per AWS Region for each AWS account.</p>
    public let dataSourceId: String?
    /// <p>A list of resource permissions on the data source.</p>
    public let permissions: [ResourcePermission]?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        dataSourceArn: String? = nil,
        dataSourceId: String? = nil,
        permissions: [ResourcePermission]? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.dataSourceArn = dataSourceArn
        self.dataSourceId = dataSourceId
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeDataSourcePermissionsOutputResponseBody: Equatable {
    public let dataSourceArn: String?
    public let dataSourceId: String?
    public let permissions: [ResourcePermission]?
    public let requestId: String?
    public let status: Int
}

extension DescribeDataSourcePermissionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataSourceArn = "DataSourceArn"
        case dataSourceId = "DataSourceId"
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSourceArn)
        dataSourceArn = dataSourceArnDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeGroupInput(awsAccountId: \(String(describing: awsAccountId)), groupName: \(String(describing: groupName)), namespace: \(String(describing: namespace)))"}
}

extension DescribeGroupInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeGroupInput>
    public typealias MOutput = OperationOutput<DescribeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeGroupOutputError>
}

public struct DescribeGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeGroupInput>
    public typealias MOutput = OperationOutput<DescribeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeGroupOutputError>
}

public struct DescribeGroupInput: Equatable {
    /// <p>The ID for the AWS account that the group is in. Currently, you use the ID for the AWS
    /// 			account that contains your Amazon QuickSight account.</p>
    public let awsAccountId: String?
    /// <p>The name of the group that you want to describe.</p>
    public let groupName: String?
    /// <p>The namespace. Currently, you should set this to <code>default</code>.</p>
    public let namespace: String?

    public init (
        awsAccountId: String? = nil,
        groupName: String? = nil,
        namespace: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.groupName = groupName
        self.namespace = namespace
    }
}

struct DescribeGroupInputBody: Equatable {
}

extension DescribeGroupInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeGroupOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeGroupOutputResponse(group: \(String(describing: group)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension DescribeGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.group = output.group
            self.requestId = output.requestId
        } else {
            self.group = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeGroupOutputResponse: Equatable {
    /// <p>The name of the group.</p>
    public let group: Group?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        group: Group? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.group = group
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeGroupOutputResponseBody: Equatable {
    public let group: Group?
    public let requestId: String?
    public let status: Int
}

extension DescribeGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(Group.self, forKey: .group)
        group = groupDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeIAMPolicyAssignmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeIAMPolicyAssignmentInput(assignmentName: \(String(describing: assignmentName)), awsAccountId: \(String(describing: awsAccountId)), namespace: \(String(describing: namespace)))"}
}

extension DescribeIAMPolicyAssignmentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeIAMPolicyAssignmentInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeIAMPolicyAssignmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIAMPolicyAssignmentInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIAMPolicyAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIAMPolicyAssignmentInput>
    public typealias MOutput = OperationOutput<DescribeIAMPolicyAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIAMPolicyAssignmentOutputError>
}

public struct DescribeIAMPolicyAssignmentInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeIAMPolicyAssignmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIAMPolicyAssignmentInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIAMPolicyAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIAMPolicyAssignmentInput>
    public typealias MOutput = OperationOutput<DescribeIAMPolicyAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIAMPolicyAssignmentOutputError>
}

public struct DescribeIAMPolicyAssignmentInput: Equatable {
    /// <p>The name of the assignment, also called a rule.</p>
    public let assignmentName: String?
    /// <p>The ID of the AWS account that contains the assignment that you want to describe.</p>
    public let awsAccountId: String?
    /// <p>The namespace that contains the assignment.</p>
    public let namespace: String?

    public init (
        assignmentName: String? = nil,
        awsAccountId: String? = nil,
        namespace: String? = nil
    )
    {
        self.assignmentName = assignmentName
        self.awsAccountId = awsAccountId
        self.namespace = namespace
    }
}

struct DescribeIAMPolicyAssignmentInputBody: Equatable {
}

extension DescribeIAMPolicyAssignmentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeIAMPolicyAssignmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeIAMPolicyAssignmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeIAMPolicyAssignmentOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIAMPolicyAssignmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeIAMPolicyAssignmentOutputResponse(iAMPolicyAssignment: \(String(describing: iAMPolicyAssignment)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension DescribeIAMPolicyAssignmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeIAMPolicyAssignmentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.iAMPolicyAssignment = output.iAMPolicyAssignment
            self.requestId = output.requestId
        } else {
            self.iAMPolicyAssignment = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeIAMPolicyAssignmentOutputResponse: Equatable {
    /// <p>Information describing the IAM policy assignment.</p>
    public let iAMPolicyAssignment: IAMPolicyAssignment?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        iAMPolicyAssignment: IAMPolicyAssignment? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.iAMPolicyAssignment = iAMPolicyAssignment
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeIAMPolicyAssignmentOutputResponseBody: Equatable {
    public let iAMPolicyAssignment: IAMPolicyAssignment?
    public let requestId: String?
    public let status: Int
}

extension DescribeIAMPolicyAssignmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case iAMPolicyAssignment = "IAMPolicyAssignment"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iAMPolicyAssignmentDecoded = try containerValues.decodeIfPresent(IAMPolicyAssignment.self, forKey: .iAMPolicyAssignment)
        iAMPolicyAssignment = iAMPolicyAssignmentDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeIngestionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeIngestionInput(awsAccountId: \(String(describing: awsAccountId)), dataSetId: \(String(describing: dataSetId)), ingestionId: \(String(describing: ingestionId)))"}
}

extension DescribeIngestionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeIngestionInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeIngestionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIngestionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIngestionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIngestionInput>
    public typealias MOutput = OperationOutput<DescribeIngestionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIngestionOutputError>
}

public struct DescribeIngestionInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeIngestionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIngestionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIngestionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIngestionInput>
    public typealias MOutput = OperationOutput<DescribeIngestionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIngestionOutputError>
}

public struct DescribeIngestionInput: Equatable {
    /// <p>The AWS account ID.</p>
    public let awsAccountId: String?
    /// <p>The ID of the dataset used in the ingestion.</p>
    public let dataSetId: String?
    /// <p>An ID for the ingestion.</p>
    public let ingestionId: String?

    public init (
        awsAccountId: String? = nil,
        dataSetId: String? = nil,
        ingestionId: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
        self.ingestionId = ingestionId
    }
}

struct DescribeIngestionInputBody: Equatable {
}

extension DescribeIngestionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeIngestionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeIngestionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeIngestionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIngestionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeIngestionOutputResponse(ingestion: \(String(describing: ingestion)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension DescribeIngestionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeIngestionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.ingestion = output.ingestion
            self.requestId = output.requestId
        } else {
            self.ingestion = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeIngestionOutputResponse: Equatable {
    /// <p>Information about the ingestion.</p>
    public let ingestion: Ingestion?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        ingestion: Ingestion? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.ingestion = ingestion
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeIngestionOutputResponseBody: Equatable {
    public let ingestion: Ingestion?
    public let requestId: String?
    public let status: Int
}

extension DescribeIngestionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ingestion = "Ingestion"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ingestionDecoded = try containerValues.decodeIfPresent(Ingestion.self, forKey: .ingestion)
        ingestion = ingestionDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeNamespaceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeNamespaceInput(awsAccountId: \(String(describing: awsAccountId)), namespace: \(String(describing: namespace)))"}
}

extension DescribeNamespaceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeNamespaceInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeNamespaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeNamespaceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeNamespaceInput>
    public typealias MOutput = OperationOutput<DescribeNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeNamespaceOutputError>
}

public struct DescribeNamespaceInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeNamespaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeNamespaceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeNamespaceInput>
    public typealias MOutput = OperationOutput<DescribeNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeNamespaceOutputError>
}

public struct DescribeNamespaceInput: Equatable {
    /// <p>The ID for the AWS account that contains the QuickSight namespace that you want to describe.</p>
    public let awsAccountId: String?
    /// <p>The namespace that you want to describe.</p>
    public let namespace: String?

    public init (
        awsAccountId: String? = nil,
        namespace: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.namespace = namespace
    }
}

struct DescribeNamespaceInputBody: Equatable {
}

extension DescribeNamespaceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeNamespaceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeNamespaceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeNamespaceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeNamespaceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeNamespaceOutputResponse(namespace: \(String(describing: namespace)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension DescribeNamespaceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.namespace = output.namespace
            self.requestId = output.requestId
        } else {
            self.namespace = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeNamespaceOutputResponse: Equatable {
    /// <p>The information about the namespace that you're describing. The response includes
    ///         the namespace ARN, name, AWS Region, creation status, and identity store. <code>DescribeNamespace</code> also
    ///         works for namespaces that are in the process of being created. For incomplete namespaces,
    ///         this API operation lists the namespace error types and messages associated with the creation process.</p>
    public let namespace: NamespaceInfoV2?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        namespace: NamespaceInfoV2? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.namespace = namespace
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeNamespaceOutputResponseBody: Equatable {
    public let namespace: NamespaceInfoV2?
    public let requestId: String?
    public let status: Int
}

extension DescribeNamespaceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case namespace = "Namespace"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(NamespaceInfoV2.self, forKey: .namespace)
        namespace = namespaceDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeTemplateAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTemplateAliasInput(aliasName: \(String(describing: aliasName)), awsAccountId: \(String(describing: awsAccountId)), templateId: \(String(describing: templateId)))"}
}

extension DescribeTemplateAliasInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeTemplateAliasInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTemplateAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTemplateAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTemplateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTemplateAliasInput>
    public typealias MOutput = OperationOutput<DescribeTemplateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTemplateAliasOutputError>
}

public struct DescribeTemplateAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTemplateAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTemplateAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTemplateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTemplateAliasInput>
    public typealias MOutput = OperationOutput<DescribeTemplateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTemplateAliasOutputError>
}

public struct DescribeTemplateAliasInput: Equatable {
    /// <p>The name of the template alias that you want to describe. If you name a specific alias, you
    /// 			describe the version that the alias points to. You can specify the latest version of the
    /// 			template by providing the keyword <code>$LATEST</code> in the <code>AliasName</code>
    /// 			parameter. The keyword <code>$PUBLISHED</code> doesn't apply to templates.</p>
    public let aliasName: String?
    /// <p>The ID of the AWS account that contains the template alias that you're
    /// 			describing.</p>
    public let awsAccountId: String?
    /// <p>The ID for the template.</p>
    public let templateId: String?

    public init (
        aliasName: String? = nil,
        awsAccountId: String? = nil,
        templateId: String? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.templateId = templateId
    }
}

struct DescribeTemplateAliasInputBody: Equatable {
}

extension DescribeTemplateAliasInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeTemplateAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTemplateAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTemplateAliasOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTemplateAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTemplateAliasOutputResponse(requestId: \(String(describing: requestId)), status: \(String(describing: status)), templateAlias: \(String(describing: templateAlias)))"}
}

extension DescribeTemplateAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeTemplateAliasOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.requestId = output.requestId
            self.templateAlias = output.templateAlias
        } else {
            self.requestId = nil
            self.templateAlias = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeTemplateAliasOutputResponse: Equatable {
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>Information about the template alias.</p>
    public let templateAlias: TemplateAlias?

    public init (
        requestId: String? = nil,
        status: Int = 0,
        templateAlias: TemplateAlias? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.templateAlias = templateAlias
    }
}

struct DescribeTemplateAliasOutputResponseBody: Equatable {
    public let templateAlias: TemplateAlias?
    public let status: Int
    public let requestId: String?
}

extension DescribeTemplateAliasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case templateAlias = "TemplateAlias"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateAliasDecoded = try containerValues.decodeIfPresent(TemplateAlias.self, forKey: .templateAlias)
        templateAlias = templateAliasDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTemplateInput(aliasName: \(String(describing: aliasName)), awsAccountId: \(String(describing: awsAccountId)), templateId: \(String(describing: templateId)), versionNumber: \(String(describing: versionNumber)))"}
}

extension DescribeTemplateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTemplateInput>
    public typealias MOutput = OperationOutput<DescribeTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTemplateOutputError>
}

public struct DescribeTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let aliasName = input.operationInput.aliasName {
            let aliasNameQueryItem = URLQueryItem(name: "alias-name".urlPercentEncoding(), value: String(aliasName).urlPercentEncoding())
            input.builder.withQueryItem(aliasNameQueryItem)
        }
        if let versionNumber = input.operationInput.versionNumber {
            let versionNumberQueryItem = URLQueryItem(name: "version-number".urlPercentEncoding(), value: String(versionNumber).urlPercentEncoding())
            input.builder.withQueryItem(versionNumberQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTemplateInput>
    public typealias MOutput = OperationOutput<DescribeTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTemplateOutputError>
}

public struct DescribeTemplateInput: Equatable {
    /// <p>The alias of the template that you want to describe. If you name a specific alias, you
    /// 			describe the version that the alias points to. You can specify the latest version of the
    /// 			template by providing the keyword <code>$LATEST</code> in the <code>AliasName</code>
    /// 			parameter. The keyword <code>$PUBLISHED</code> doesn't apply to templates.</p>
    public let aliasName: String?
    /// <p>The ID of the AWS account that contains the template that you're describing.</p>
    public let awsAccountId: String?
    /// <p>The ID for the template.</p>
    public let templateId: String?
    /// <p>(Optional) The number for the version to describe. If a <code>VersionNumber</code> parameter
    /// 			value isn't provided, the latest version of the template is described.</p>
    public let versionNumber: Int?

    public init (
        aliasName: String? = nil,
        awsAccountId: String? = nil,
        templateId: String? = nil,
        versionNumber: Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.templateId = templateId
        self.versionNumber = versionNumber
    }
}

struct DescribeTemplateInputBody: Equatable {
}

extension DescribeTemplateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTemplateOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTemplateOutputResponse(requestId: \(String(describing: requestId)), status: \(String(describing: status)), template: \(String(describing: template)))"}
}

extension DescribeTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.requestId = output.requestId
            self.template = output.template
        } else {
            self.requestId = nil
            self.template = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeTemplateOutputResponse: Equatable {
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>The template structure for the object you want to describe.</p>
    public let template: Template?

    public init (
        requestId: String? = nil,
        status: Int = 0,
        template: Template? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.template = template
    }
}

struct DescribeTemplateOutputResponseBody: Equatable {
    public let template: Template?
    public let status: Int
    public let requestId: String?
}

extension DescribeTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case template = "Template"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateDecoded = try containerValues.decodeIfPresent(Template.self, forKey: .template)
        template = templateDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeTemplatePermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTemplatePermissionsInput(awsAccountId: \(String(describing: awsAccountId)), templateId: \(String(describing: templateId)))"}
}

extension DescribeTemplatePermissionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeTemplatePermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTemplatePermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTemplatePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTemplatePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTemplatePermissionsInput>
    public typealias MOutput = OperationOutput<DescribeTemplatePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTemplatePermissionsOutputError>
}

public struct DescribeTemplatePermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTemplatePermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTemplatePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTemplatePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTemplatePermissionsInput>
    public typealias MOutput = OperationOutput<DescribeTemplatePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTemplatePermissionsOutputError>
}

public struct DescribeTemplatePermissionsInput: Equatable {
    /// <p>The ID of the AWS account that contains the template that you're describing.</p>
    public let awsAccountId: String?
    /// <p>The ID for the template.</p>
    public let templateId: String?

    public init (
        awsAccountId: String? = nil,
        templateId: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.templateId = templateId
    }
}

struct DescribeTemplatePermissionsInputBody: Equatable {
}

extension DescribeTemplatePermissionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeTemplatePermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTemplatePermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTemplatePermissionsOutputError: Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTemplatePermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTemplatePermissionsOutputResponse(permissions: \(String(describing: permissions)), requestId: \(String(describing: requestId)), status: \(String(describing: status)), templateArn: \(String(describing: templateArn)), templateId: \(String(describing: templateId)))"}
}

extension DescribeTemplatePermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeTemplatePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.permissions = output.permissions
            self.requestId = output.requestId
            self.templateArn = output.templateArn
            self.templateId = output.templateId
        } else {
            self.permissions = nil
            self.requestId = nil
            self.templateArn = nil
            self.templateId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeTemplatePermissionsOutputResponse: Equatable {
    /// <p>A list of resource permissions to be set on the template. </p>
    public let permissions: [ResourcePermission]?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>The Amazon Resource Name (ARN) of the template.</p>
    public let templateArn: String?
    /// <p>The ID for the template.</p>
    public let templateId: String?

    public init (
        permissions: [ResourcePermission]? = nil,
        requestId: String? = nil,
        status: Int = 0,
        templateArn: String? = nil,
        templateId: String? = nil
    )
    {
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
        self.templateArn = templateArn
        self.templateId = templateId
    }
}

struct DescribeTemplatePermissionsOutputResponseBody: Equatable {
    public let templateId: String?
    public let templateArn: String?
    public let permissions: [ResourcePermission]?
    public let requestId: String?
    public let status: Int
}

extension DescribeTemplatePermissionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
        case templateArn = "TemplateArn"
        case templateId = "TemplateId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let templateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeThemeAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeThemeAliasInput(aliasName: \(String(describing: aliasName)), awsAccountId: \(String(describing: awsAccountId)), themeId: \(String(describing: themeId)))"}
}

extension DescribeThemeAliasInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeThemeAliasInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeThemeAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeThemeAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeThemeAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeThemeAliasInput>
    public typealias MOutput = OperationOutput<DescribeThemeAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeThemeAliasOutputError>
}

public struct DescribeThemeAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeThemeAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeThemeAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeThemeAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeThemeAliasInput>
    public typealias MOutput = OperationOutput<DescribeThemeAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeThemeAliasOutputError>
}

public struct DescribeThemeAliasInput: Equatable {
    /// <p>The name of the theme alias that you want to describe.</p>
    public let aliasName: String?
    /// <p>The ID of the AWS account that contains the theme alias that you're
    /// 			describing.</p>
    public let awsAccountId: String?
    /// <p>The ID for the theme.</p>
    public let themeId: String?

    public init (
        aliasName: String? = nil,
        awsAccountId: String? = nil,
        themeId: String? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.themeId = themeId
    }
}

struct DescribeThemeAliasInputBody: Equatable {
}

extension DescribeThemeAliasInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeThemeAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeThemeAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeThemeAliasOutputError: Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeThemeAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeThemeAliasOutputResponse(requestId: \(String(describing: requestId)), status: \(String(describing: status)), themeAlias: \(String(describing: themeAlias)))"}
}

extension DescribeThemeAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeThemeAliasOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.requestId = output.requestId
            self.themeAlias = output.themeAlias
        } else {
            self.requestId = nil
            self.themeAlias = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeThemeAliasOutputResponse: Equatable {
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>Information about the theme alias.</p>
    public let themeAlias: ThemeAlias?

    public init (
        requestId: String? = nil,
        status: Int = 0,
        themeAlias: ThemeAlias? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.themeAlias = themeAlias
    }
}

struct DescribeThemeAliasOutputResponseBody: Equatable {
    public let themeAlias: ThemeAlias?
    public let status: Int
    public let requestId: String?
}

extension DescribeThemeAliasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case themeAlias = "ThemeAlias"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeAliasDecoded = try containerValues.decodeIfPresent(ThemeAlias.self, forKey: .themeAlias)
        themeAlias = themeAliasDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeThemeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeThemeInput(aliasName: \(String(describing: aliasName)), awsAccountId: \(String(describing: awsAccountId)), themeId: \(String(describing: themeId)), versionNumber: \(String(describing: versionNumber)))"}
}

extension DescribeThemeInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeThemeInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeThemeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeThemeInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeThemeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeThemeInput>
    public typealias MOutput = OperationOutput<DescribeThemeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeThemeOutputError>
}

public struct DescribeThemeInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeThemeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeThemeInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeThemeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let aliasName = input.operationInput.aliasName {
            let aliasNameQueryItem = URLQueryItem(name: "alias-name".urlPercentEncoding(), value: String(aliasName).urlPercentEncoding())
            input.builder.withQueryItem(aliasNameQueryItem)
        }
        if let versionNumber = input.operationInput.versionNumber {
            let versionNumberQueryItem = URLQueryItem(name: "version-number".urlPercentEncoding(), value: String(versionNumber).urlPercentEncoding())
            input.builder.withQueryItem(versionNumberQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeThemeInput>
    public typealias MOutput = OperationOutput<DescribeThemeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeThemeOutputError>
}

public struct DescribeThemeInput: Equatable {
    /// <p>The alias of the theme that you want to describe. If you name a specific alias, you
    /// 			describe the version that the alias points to. You can specify the latest version of the
    /// 			theme by providing the keyword <code>$LATEST</code> in the <code>AliasName</code>
    /// 			parameter. The keyword <code>$PUBLISHED</code> doesn't apply to themes.</p>
    public let aliasName: String?
    /// <p>The ID of the AWS account that contains the theme that you're describing.</p>
    public let awsAccountId: String?
    /// <p>The ID for the theme.</p>
    public let themeId: String?
    /// <p>The version number for the version to describe. If a <code>VersionNumber</code> parameter
    /// 			value isn't provided, the latest version of the theme is described.</p>
    public let versionNumber: Int?

    public init (
        aliasName: String? = nil,
        awsAccountId: String? = nil,
        themeId: String? = nil,
        versionNumber: Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.themeId = themeId
        self.versionNumber = versionNumber
    }
}

struct DescribeThemeInputBody: Equatable {
}

extension DescribeThemeInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeThemeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeThemeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeThemeOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeThemeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeThemeOutputResponse(requestId: \(String(describing: requestId)), status: \(String(describing: status)), theme: \(String(describing: theme)))"}
}

extension DescribeThemeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeThemeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.requestId = output.requestId
            self.theme = output.theme
        } else {
            self.requestId = nil
            self.theme = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeThemeOutputResponse: Equatable {
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>The information about the theme that you are describing.</p>
    public let theme: Theme?

    public init (
        requestId: String? = nil,
        status: Int = 0,
        theme: Theme? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.theme = theme
    }
}

struct DescribeThemeOutputResponseBody: Equatable {
    public let theme: Theme?
    public let status: Int
    public let requestId: String?
}

extension DescribeThemeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case theme = "Theme"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeDecoded = try containerValues.decodeIfPresent(Theme.self, forKey: .theme)
        theme = themeDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeThemePermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeThemePermissionsInput(awsAccountId: \(String(describing: awsAccountId)), themeId: \(String(describing: themeId)))"}
}

extension DescribeThemePermissionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeThemePermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeThemePermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeThemePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeThemePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeThemePermissionsInput>
    public typealias MOutput = OperationOutput<DescribeThemePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeThemePermissionsOutputError>
}

public struct DescribeThemePermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeThemePermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeThemePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeThemePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeThemePermissionsInput>
    public typealias MOutput = OperationOutput<DescribeThemePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeThemePermissionsOutputError>
}

public struct DescribeThemePermissionsInput: Equatable {
    /// <p>The ID of the AWS account that contains the theme that you're describing.</p>
    public let awsAccountId: String?
    /// <p>The ID for the theme that you want to describe permissions for.</p>
    public let themeId: String?

    public init (
        awsAccountId: String? = nil,
        themeId: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.themeId = themeId
    }
}

struct DescribeThemePermissionsInputBody: Equatable {
}

extension DescribeThemePermissionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeThemePermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeThemePermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeThemePermissionsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeThemePermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeThemePermissionsOutputResponse(permissions: \(String(describing: permissions)), requestId: \(String(describing: requestId)), status: \(String(describing: status)), themeArn: \(String(describing: themeArn)), themeId: \(String(describing: themeId)))"}
}

extension DescribeThemePermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeThemePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.permissions = output.permissions
            self.requestId = output.requestId
            self.themeArn = output.themeArn
            self.themeId = output.themeId
        } else {
            self.permissions = nil
            self.requestId = nil
            self.themeArn = nil
            self.themeId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeThemePermissionsOutputResponse: Equatable {
    /// <p>A list of resource permissions set on the theme. </p>
    public let permissions: [ResourcePermission]?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>The Amazon Resource Name (ARN) of the theme.</p>
    public let themeArn: String?
    /// <p>The ID for the theme.</p>
    public let themeId: String?

    public init (
        permissions: [ResourcePermission]? = nil,
        requestId: String? = nil,
        status: Int = 0,
        themeArn: String? = nil,
        themeId: String? = nil
    )
    {
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
        self.themeArn = themeArn
        self.themeId = themeId
    }
}

struct DescribeThemePermissionsOutputResponseBody: Equatable {
    public let themeId: String?
    public let themeArn: String?
    public let permissions: [ResourcePermission]?
    public let requestId: String?
    public let status: Int
}

extension DescribeThemePermissionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
        case themeArn = "ThemeArn"
        case themeId = "ThemeId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .themeId)
        themeId = themeIdDecoded
        let themeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .themeArn)
        themeArn = themeArnDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUserInput(awsAccountId: \(String(describing: awsAccountId)), namespace: \(String(describing: namespace)), userName: \(String(describing: userName)))"}
}

extension DescribeUserInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeUserInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserInput>
    public typealias MOutput = OperationOutput<DescribeUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserOutputError>
}

public struct DescribeUserInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserInput>
    public typealias MOutput = OperationOutput<DescribeUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserOutputError>
}

public struct DescribeUserInput: Equatable {
    /// <p>The ID for the AWS account that the user is in. Currently, you use the ID for the AWS
    /// 			account that contains your Amazon QuickSight account.</p>
    public let awsAccountId: String?
    /// <p>The namespace. Currently, you should set this to <code>default</code>.</p>
    public let namespace: String?
    /// <p>The name of the user that you want to describe.</p>
    public let userName: String?

    public init (
        awsAccountId: String? = nil,
        namespace: String? = nil,
        userName: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.userName = userName
    }
}

struct DescribeUserInputBody: Equatable {
}

extension DescribeUserInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUserOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUserOutputResponse(requestId: \(String(describing: requestId)), status: \(String(describing: status)), user: \(String(describing: user)))"}
}

extension DescribeUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeUserOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.requestId = output.requestId
            self.user = output.user
        } else {
            self.requestId = nil
            self.user = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeUserOutputResponse: Equatable {
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>The user name.</p>
    public let user: User?

    public init (
        requestId: String? = nil,
        status: Int = 0,
        user: User? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.user = user
    }
}

struct DescribeUserOutputResponseBody: Equatable {
    public let user: User?
    public let requestId: String?
    public let status: Int
}

extension DescribeUserOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case user = "User"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(User.self, forKey: .user)
        user = userDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DomainNotWhitelistedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainNotWhitelistedException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension DomainNotWhitelistedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DomainNotWhitelistedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The domain specified isn't on the allow list. All domains for embedded dashboards must be
/// 			added to the approved list by an Amazon QuickSight admin.</p>
public struct DomainNotWhitelistedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The AWS request ID for this request.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct DomainNotWhitelistedExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension DomainNotWhitelistedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

public enum Edition {
    case enterprise
    case standard
    case sdkUnknown(String)
}

extension Edition : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Edition] {
        return [
            .enterprise,
            .standard,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .enterprise: return "ENTERPRISE"
        case .standard: return "STANDARD"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Edition(rawValue: rawValue) ?? Edition.sdkUnknown(rawValue)
    }
}

public enum EmbeddingIdentityType {
    case anonymous
    case iam
    case quicksight
    case sdkUnknown(String)
}

extension EmbeddingIdentityType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EmbeddingIdentityType] {
        return [
            .anonymous,
            .iam,
            .quicksight,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .anonymous: return "ANONYMOUS"
        case .iam: return "IAM"
        case .quicksight: return "QUICKSIGHT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EmbeddingIdentityType(rawValue: rawValue) ?? EmbeddingIdentityType.sdkUnknown(rawValue)
    }
}

extension ErrorInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(IngestionErrorType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ErrorInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ErrorInfo(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

/// <p>Error information for the SPICE ingestion of a dataset.</p>
public struct ErrorInfo: Equatable {
    /// <p>Error message.</p>
    public let message: String?
    /// <p>Error type.</p>
    public let type: IngestionErrorType?

    public init (
        message: String? = nil,
        type: IngestionErrorType? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

public enum ExceptionResourceType {
    case accountSettings
    case dataSet
    case dataSource
    case group
    case iampolicyAssignment
    case ingestion
    case namespace
    case user
    case vpcConnection
    case sdkUnknown(String)
}

extension ExceptionResourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExceptionResourceType] {
        return [
            .accountSettings,
            .dataSet,
            .dataSource,
            .group,
            .iampolicyAssignment,
            .ingestion,
            .namespace,
            .user,
            .vpcConnection,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accountSettings: return "ACCOUNT_SETTINGS"
        case .dataSet: return "DATA_SET"
        case .dataSource: return "DATA_SOURCE"
        case .group: return "GROUP"
        case .iampolicyAssignment: return "IAMPOLICY_ASSIGNMENT"
        case .ingestion: return "INGESTION"
        case .namespace: return "NAMESPACE"
        case .user: return "USER"
        case .vpcConnection: return "VPC_CONNECTION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExceptionResourceType(rawValue: rawValue) ?? ExceptionResourceType.sdkUnknown(rawValue)
    }
}

extension ExportToCSVOption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityStatus = "AvailabilityStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityStatus = availabilityStatus {
            try encodeContainer.encode(availabilityStatus.rawValue, forKey: .availabilityStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityStatusDecoded = try containerValues.decodeIfPresent(DashboardBehavior.self, forKey: .availabilityStatus)
        availabilityStatus = availabilityStatusDecoded
    }
}

extension ExportToCSVOption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportToCSVOption(availabilityStatus: \(String(describing: availabilityStatus)))"}
}

/// <p>Export to .csv option.</p>
public struct ExportToCSVOption: Equatable {
    /// <p>Availability status.</p>
    public let availabilityStatus: DashboardBehavior?

    public init (
        availabilityStatus: DashboardBehavior? = nil
    )
    {
        self.availabilityStatus = availabilityStatus
    }
}

extension FieldFolder: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case columns
        case description
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columns = columns {
            var columnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columns)
            for foldercolumnlist0 in columns {
                try columnsContainer.encode(foldercolumnlist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let columnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .columns)
        var columnsDecoded0:[String]? = nil
        if let columnsContainer = columnsContainer {
            columnsDecoded0 = [String]()
            for string0 in columnsContainer {
                if let string0 = string0 {
                    columnsDecoded0?.append(string0)
                }
            }
        }
        columns = columnsDecoded0
    }
}

extension FieldFolder: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FieldFolder(columns: \(String(describing: columns)), description: \(String(describing: description)))"}
}

/// <p>A FieldFolder element is a folder that contains fields and nested subfolders.</p>
public struct FieldFolder: Equatable {
    /// <p>A folder has a list of columns. A column can only be in one folder.</p>
    public let columns: [String]?
    /// <p>The description for a field folder.</p>
    public let description: String?

    public init (
        columns: [String]? = nil,
        description: String? = nil
    )
    {
        self.columns = columns
        self.description = description
    }
}

public enum FileFormat {
    case clf
    case csv
    case elf
    case json
    case tsv
    case xlsx
    case sdkUnknown(String)
}

extension FileFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FileFormat] {
        return [
            .clf,
            .csv,
            .elf,
            .json,
            .tsv,
            .xlsx,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .clf: return "CLF"
        case .csv: return "CSV"
        case .elf: return "ELF"
        case .json: return "JSON"
        case .tsv: return "TSV"
        case .xlsx: return "XLSX"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FileFormat(rawValue: rawValue) ?? FileFormat.sdkUnknown(rawValue)
    }
}

extension FilterOperation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case conditionExpression = "ConditionExpression"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conditionExpression = conditionExpression {
            try encodeContainer.encode(conditionExpression, forKey: .conditionExpression)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conditionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conditionExpression)
        conditionExpression = conditionExpressionDecoded
    }
}

extension FilterOperation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FilterOperation(conditionExpression: \(String(describing: conditionExpression)))"}
}

/// <p>A transform operation that filters rows based on a condition.</p>
public struct FilterOperation: Equatable {
    /// <p>An expression that must evaluate to a Boolean value. Rows for which the expression
    ///             evaluates to true are kept in the dataset.</p>
    public let conditionExpression: String?

    public init (
        conditionExpression: String? = nil
    )
    {
        self.conditionExpression = conditionExpression
    }
}

public enum FilterOperator {
    case stringequals
    case sdkUnknown(String)
}

extension FilterOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FilterOperator] {
        return [
            .stringequals,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .stringequals: return "StringEquals"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FilterOperator(rawValue: rawValue) ?? FilterOperator.sdkUnknown(rawValue)
    }
}

extension GeoSpatialColumnGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case columns = "Columns"
        case countryCode = "CountryCode"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columns = columns {
            var columnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columns)
            for columnlist0 in columns {
                try columnsContainer.encode(columnlist0)
            }
        }
        if let countryCode = countryCode {
            try encodeContainer.encode(countryCode.rawValue, forKey: .countryCode)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let countryCodeDecoded = try containerValues.decodeIfPresent(GeoSpatialCountryCode.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let columnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .columns)
        var columnsDecoded0:[String]? = nil
        if let columnsContainer = columnsContainer {
            columnsDecoded0 = [String]()
            for string0 in columnsContainer {
                if let string0 = string0 {
                    columnsDecoded0?.append(string0)
                }
            }
        }
        columns = columnsDecoded0
    }
}

extension GeoSpatialColumnGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GeoSpatialColumnGroup(columns: \(String(describing: columns)), countryCode: \(String(describing: countryCode)), name: \(String(describing: name)))"}
}

/// <p>Geospatial column group that denotes a hierarchy.</p>
public struct GeoSpatialColumnGroup: Equatable {
    /// <p>Columns in this hierarchy.</p>
    public let columns: [String]?
    /// <p>Country code.</p>
    public let countryCode: GeoSpatialCountryCode?
    /// <p>A display name for the hierarchy.</p>
    public let name: String?

    public init (
        columns: [String]? = nil,
        countryCode: GeoSpatialCountryCode? = nil,
        name: String? = nil
    )
    {
        self.columns = columns
        self.countryCode = countryCode
        self.name = name
    }
}

public enum GeoSpatialCountryCode {
    case us
    case sdkUnknown(String)
}

extension GeoSpatialCountryCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [GeoSpatialCountryCode] {
        return [
            .us,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .us: return "US"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = GeoSpatialCountryCode(rawValue: rawValue) ?? GeoSpatialCountryCode.sdkUnknown(rawValue)
    }
}

public enum GeoSpatialDataRole {
    case city
    case country
    case county
    case latitude
    case longitude
    case postcode
    case state
    case sdkUnknown(String)
}

extension GeoSpatialDataRole : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [GeoSpatialDataRole] {
        return [
            .city,
            .country,
            .county,
            .latitude,
            .longitude,
            .postcode,
            .state,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .city: return "CITY"
        case .country: return "COUNTRY"
        case .county: return "COUNTY"
        case .latitude: return "LATITUDE"
        case .longitude: return "LONGITUDE"
        case .postcode: return "POSTCODE"
        case .state: return "STATE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = GeoSpatialDataRole(rawValue: rawValue) ?? GeoSpatialDataRole.sdkUnknown(rawValue)
    }
}

extension GetDashboardEmbedUrlInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDashboardEmbedUrlInput(additionalDashboardIds: \(String(describing: additionalDashboardIds)), awsAccountId: \(String(describing: awsAccountId)), dashboardId: \(String(describing: dashboardId)), identityType: \(String(describing: identityType)), namespace: \(String(describing: namespace)), resetDisabled: \(String(describing: resetDisabled)), sessionLifetimeInMinutes: \(String(describing: sessionLifetimeInMinutes)), statePersistenceEnabled: \(String(describing: statePersistenceEnabled)), undoRedoDisabled: \(String(describing: undoRedoDisabled)), userArn: \(String(describing: userArn)))"}
}

extension GetDashboardEmbedUrlInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDashboardEmbedUrlInputHeadersMiddleware: Middleware {
    public let id: String = "GetDashboardEmbedUrlInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDashboardEmbedUrlInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDashboardEmbedUrlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDashboardEmbedUrlInput>
    public typealias MOutput = OperationOutput<GetDashboardEmbedUrlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDashboardEmbedUrlOutputError>
}

public struct GetDashboardEmbedUrlInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDashboardEmbedUrlInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDashboardEmbedUrlInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDashboardEmbedUrlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let identityType = input.operationInput.identityType {
            let identityTypeQueryItem = URLQueryItem(name: "creds-type".urlPercentEncoding(), value: String(identityType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(identityTypeQueryItem)
        }
        let statePersistenceEnabledQueryItem = URLQueryItem(name: "state-persistence-enabled".urlPercentEncoding(), value: String(input.operationInput.statePersistenceEnabled).urlPercentEncoding())
        input.builder.withQueryItem(statePersistenceEnabledQueryItem)
        if let userArn = input.operationInput.userArn {
            let userArnQueryItem = URLQueryItem(name: "user-arn".urlPercentEncoding(), value: String(userArn).urlPercentEncoding())
            input.builder.withQueryItem(userArnQueryItem)
        }
        let undoRedoDisabledQueryItem = URLQueryItem(name: "undo-redo-disabled".urlPercentEncoding(), value: String(input.operationInput.undoRedoDisabled).urlPercentEncoding())
        input.builder.withQueryItem(undoRedoDisabledQueryItem)
        if let additionalDashboardIds = input.operationInput.additionalDashboardIds {
            additionalDashboardIds.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "additional-dashboard-ids".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let sessionLifetimeInMinutes = input.operationInput.sessionLifetimeInMinutes {
            let sessionLifetimeInMinutesQueryItem = URLQueryItem(name: "session-lifetime".urlPercentEncoding(), value: String(sessionLifetimeInMinutes).urlPercentEncoding())
            input.builder.withQueryItem(sessionLifetimeInMinutesQueryItem)
        }
        let resetDisabledQueryItem = URLQueryItem(name: "reset-disabled".urlPercentEncoding(), value: String(input.operationInput.resetDisabled).urlPercentEncoding())
        input.builder.withQueryItem(resetDisabledQueryItem)
        if let namespace = input.operationInput.namespace {
            let namespaceQueryItem = URLQueryItem(name: "namespace".urlPercentEncoding(), value: String(namespace).urlPercentEncoding())
            input.builder.withQueryItem(namespaceQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDashboardEmbedUrlInput>
    public typealias MOutput = OperationOutput<GetDashboardEmbedUrlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDashboardEmbedUrlOutputError>
}

public struct GetDashboardEmbedUrlInput: Equatable {
    /// <p>A list of one or more dashboard IDs that you want to add to a session that includes
    ///             anonymous users. The <code>IdentityType</code> parameter must be set to
    ///                 <code>ANONYMOUS</code> for this to work, because other identity types authenticate
    ///             as QuickSight or IAM users. For example, if you set "<code>--dashboard-id dash_id1
    ///                 --dashboard-id dash_id2 dash_id3 identity-type ANONYMOUS</code>", the session
    ///             can access all three dashboards. </p>
    public let additionalDashboardIds: [String]?
    /// <p>The ID for the AWS account that contains the dashboard that you're embedding.</p>
    public let awsAccountId: String?
    /// <p>The ID for the dashboard, also added to the AWS Identity and Access Management (IAM)
    ///             policy.</p>
    public let dashboardId: String?
    /// <p>The authentication method that the user uses to sign in.</p>
    public let identityType: EmbeddingIdentityType?
    /// <p>The QuickSight namespace that contains the dashboard IDs in this request.
    ///     	   If you're not using a custom namespace, set this to
    ///     	    "<code>default</code>".</p>
    public let namespace: String?
    /// <p>Remove the reset button on the embedded dashboard. The default is FALSE, which enables the
    /// 			reset button.</p>
    public let resetDisabled: Bool
    /// <p>How many minutes the session is valid. The session lifetime must be 15-600 minutes.</p>
    public let sessionLifetimeInMinutes: Int?
    /// <p>Adds persistence of state for the user session in an embedded dashboard. Persistence
    ///             applies to the sheet and the parameter settings. These are control settings that the
    ///             dashboard subscriber (QuickSight reader) chooses while viewing the dashboard. If this is
    ///             set to <code>TRUE</code>, the settings are the same when the subscriber reopens the same
    ///             dashboard URL. The state is stored in QuickSight, not in a browser cookie. If this is
    ///             set to FALSE, the state of the user session is not persisted. The default is
    ///                 <code>FALSE</code>.</p>
    public let statePersistenceEnabled: Bool
    /// <p>Remove the undo/redo button on the embedded dashboard. The default is FALSE, which enables
    /// 			the undo/redo button.</p>
    public let undoRedoDisabled: Bool
    /// <p>The Amazon QuickSight user's Amazon Resource Name (ARN), for use with <code>QUICKSIGHT</code> identity type.
    /// 			You can use this for any Amazon QuickSight users in your account (readers, authors, or
    /// 			admins) authenticated as one of the following:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>Active Directory (AD) users or group members</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Invited nonfederated users</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>IAM users and IAM role-based sessions authenticated through Federated Single Sign-On using
    /// 					SAML, OpenID Connect, or IAM federation.</p>
    /// 			         </li>
    ///          </ul>
    ///          <p>Omit this parameter for users in the third group – IAM users and IAM
    ///             role-based sessions.</p>
    public let userArn: String?

    public init (
        additionalDashboardIds: [String]? = nil,
        awsAccountId: String? = nil,
        dashboardId: String? = nil,
        identityType: EmbeddingIdentityType? = nil,
        namespace: String? = nil,
        resetDisabled: Bool = false,
        sessionLifetimeInMinutes: Int? = nil,
        statePersistenceEnabled: Bool = false,
        undoRedoDisabled: Bool = false,
        userArn: String? = nil
    )
    {
        self.additionalDashboardIds = additionalDashboardIds
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.identityType = identityType
        self.namespace = namespace
        self.resetDisabled = resetDisabled
        self.sessionLifetimeInMinutes = sessionLifetimeInMinutes
        self.statePersistenceEnabled = statePersistenceEnabled
        self.undoRedoDisabled = undoRedoDisabled
        self.userArn = userArn
    }
}

struct GetDashboardEmbedUrlInputBody: Equatable {
}

extension GetDashboardEmbedUrlInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDashboardEmbedUrlOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDashboardEmbedUrlOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotWhitelistedException" : self = .domainNotWhitelistedException(try DomainNotWhitelistedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdentityTypeNotSupportedException" : self = .identityTypeNotSupportedException(try IdentityTypeNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "QuickSightUserNotFoundException" : self = .quickSightUserNotFoundException(try QuickSightUserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SessionLifetimeInMinutesInvalidException" : self = .sessionLifetimeInMinutesInvalidException(try SessionLifetimeInMinutesInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedPricingPlanException" : self = .unsupportedPricingPlanException(try UnsupportedPricingPlanException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDashboardEmbedUrlOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case domainNotWhitelistedException(DomainNotWhitelistedException)
    case identityTypeNotSupportedException(IdentityTypeNotSupportedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case quickSightUserNotFoundException(QuickSightUserNotFoundException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case sessionLifetimeInMinutesInvalidException(SessionLifetimeInMinutesInvalidException)
    case throttlingException(ThrottlingException)
    case unsupportedPricingPlanException(UnsupportedPricingPlanException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDashboardEmbedUrlOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDashboardEmbedUrlOutputResponse(embedUrl: \(String(describing: embedUrl)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension GetDashboardEmbedUrlOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDashboardEmbedUrlOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.embedUrl = output.embedUrl
            self.requestId = output.requestId
        } else {
            self.embedUrl = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

/// <p>Output returned from the <code>GetDashboardEmbedUrl</code> operation.</p>
public struct GetDashboardEmbedUrlOutputResponse: Equatable {
    /// <p>A single-use URL that you can put into your server-side webpage to embed your
    /// 			dashboard. This URL is valid for 5 minutes. The API operation provides the URL with an
    /// 			<code>auth_code</code> value that enables one (and only one) sign-on to a user session
    /// 			that is valid for 10 hours. </p>
    public let embedUrl: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        embedUrl: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.embedUrl = embedUrl
        self.requestId = requestId
        self.status = status
    }
}

struct GetDashboardEmbedUrlOutputResponseBody: Equatable {
    public let embedUrl: String?
    public let status: Int
    public let requestId: String?
}

extension GetDashboardEmbedUrlOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case embedUrl = "EmbedUrl"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let embedUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .embedUrl)
        embedUrl = embedUrlDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension GetSessionEmbedUrlInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSessionEmbedUrlInput(awsAccountId: \(String(describing: awsAccountId)), entryPoint: \(String(describing: entryPoint)), sessionLifetimeInMinutes: \(String(describing: sessionLifetimeInMinutes)), userArn: \(String(describing: userArn)))"}
}

extension GetSessionEmbedUrlInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSessionEmbedUrlInputHeadersMiddleware: Middleware {
    public let id: String = "GetSessionEmbedUrlInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSessionEmbedUrlInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSessionEmbedUrlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSessionEmbedUrlInput>
    public typealias MOutput = OperationOutput<GetSessionEmbedUrlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSessionEmbedUrlOutputError>
}

public struct GetSessionEmbedUrlInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSessionEmbedUrlInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSessionEmbedUrlInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSessionEmbedUrlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let userArn = input.operationInput.userArn {
            let userArnQueryItem = URLQueryItem(name: "user-arn".urlPercentEncoding(), value: String(userArn).urlPercentEncoding())
            input.builder.withQueryItem(userArnQueryItem)
        }
        if let entryPoint = input.operationInput.entryPoint {
            let entryPointQueryItem = URLQueryItem(name: "entry-point".urlPercentEncoding(), value: String(entryPoint).urlPercentEncoding())
            input.builder.withQueryItem(entryPointQueryItem)
        }
        if let sessionLifetimeInMinutes = input.operationInput.sessionLifetimeInMinutes {
            let sessionLifetimeInMinutesQueryItem = URLQueryItem(name: "session-lifetime".urlPercentEncoding(), value: String(sessionLifetimeInMinutes).urlPercentEncoding())
            input.builder.withQueryItem(sessionLifetimeInMinutesQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSessionEmbedUrlInput>
    public typealias MOutput = OperationOutput<GetSessionEmbedUrlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSessionEmbedUrlOutputError>
}

public struct GetSessionEmbedUrlInput: Equatable {
    /// <p>The ID for the AWS account associated with your QuickSight subscription.</p>
    public let awsAccountId: String?
    /// <p>The URL you use to access the embedded session. The entry point URL is constrained to
    ///           the following paths:</p>
    ///          <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>/start</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>/start/analyses</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>/start/dashboards</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>/start/favorites</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>/dashboards/<i>DashboardId</i>
    ///                   </code> - where <code>DashboardId</code> is the actual ID key from the QuickSight console URL of the dashboard</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>/analyses/<i>AnalysisId</i>
    ///                   </code> - where <code>AnalysisId</code> is the actual ID key from the QuickSight console URL of the analysis</p>
    ///             </li>
    ///          </ul>
    public let entryPoint: String?
    /// <p>How many minutes the session is valid. The session lifetime must be 15-600 minutes.</p>
    public let sessionLifetimeInMinutes: Int?
    /// <p>The Amazon QuickSight user's Amazon Resource Name (ARN), for use with <code>QUICKSIGHT</code> identity type.
    /// 			You can use this for any type of Amazon QuickSight users in your account (readers, authors, or
    /// 			admins). They need to be authenticated as one of the following:</p>
    /// 		       <ol>
    ///             <li>
    /// 				           <p>Active Directory (AD) users or group members</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Invited nonfederated users</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>AWS Identity and Access Management (IAM) users and IAM role-based sessions authenticated
    ///                     through Federated Single Sign-On using SAML, OpenID Connect, or IAM
    ///                     federation</p>
    /// 			         </li>
    ///          </ol>
    ///          <p>Omit this parameter for users in the third group, IAM users and IAM role-based
    ///             sessions.</p>
    public let userArn: String?

    public init (
        awsAccountId: String? = nil,
        entryPoint: String? = nil,
        sessionLifetimeInMinutes: Int? = nil,
        userArn: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.entryPoint = entryPoint
        self.sessionLifetimeInMinutes = sessionLifetimeInMinutes
        self.userArn = userArn
    }
}

struct GetSessionEmbedUrlInputBody: Equatable {
}

extension GetSessionEmbedUrlInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSessionEmbedUrlOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSessionEmbedUrlOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "QuickSightUserNotFoundException" : self = .quickSightUserNotFoundException(try QuickSightUserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SessionLifetimeInMinutesInvalidException" : self = .sessionLifetimeInMinutesInvalidException(try SessionLifetimeInMinutesInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSessionEmbedUrlOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case quickSightUserNotFoundException(QuickSightUserNotFoundException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case sessionLifetimeInMinutesInvalidException(SessionLifetimeInMinutesInvalidException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSessionEmbedUrlOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSessionEmbedUrlOutputResponse(embedUrl: \(String(describing: embedUrl)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension GetSessionEmbedUrlOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSessionEmbedUrlOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.embedUrl = output.embedUrl
            self.requestId = output.requestId
        } else {
            self.embedUrl = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct GetSessionEmbedUrlOutputResponse: Equatable {
    /// <p>A single-use URL that you can put into your server-side web page to embed your
    /// 			QuickSight session. This URL is valid for 5 minutes. The API operation provides the URL with an
    /// 			<code>auth_code</code> value that enables one (and only one) sign-on to a user session
    /// 			that is valid for 10 hours. </p>
    public let embedUrl: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        embedUrl: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.embedUrl = embedUrl
        self.requestId = requestId
        self.status = status
    }
}

struct GetSessionEmbedUrlOutputResponseBody: Equatable {
    public let embedUrl: String?
    public let status: Int
    public let requestId: String?
}

extension GetSessionEmbedUrlOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case embedUrl = "EmbedUrl"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let embedUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .embedUrl)
        embedUrl = embedUrlDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension Group: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case description = "Description"
        case groupName = "GroupName"
        case principalId = "PrincipalId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension Group: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Group(arn: \(String(describing: arn)), description: \(String(describing: description)), groupName: \(String(describing: groupName)), principalId: \(String(describing: principalId)))"}
}

/// <p>A <i>group</i> in Amazon QuickSight consists of a set of users. You can
///             use groups to make it easier to manage access and security. </p>
public struct Group: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the group.</p>
    public let arn: String?
    /// <p>The group description.</p>
    public let description: String?
    /// <p>The name of the group.</p>
    public let groupName: String?
    /// <p>The principal ID of the group.</p>
    public let principalId: String?

    public init (
        arn: String? = nil,
        description: String? = nil,
        groupName: String? = nil,
        principalId: String? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.groupName = groupName
        self.principalId = principalId
    }
}

extension GroupMember: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case memberName = "MemberName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let memberName = memberName {
            try encodeContainer.encode(memberName, forKey: .memberName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let memberNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .memberName)
        memberName = memberNameDecoded
    }
}

extension GroupMember: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GroupMember(arn: \(String(describing: arn)), memberName: \(String(describing: memberName)))"}
}

/// <p>A member of an Amazon QuickSight group. Currently, group members must be users. Groups
///             can't be members of another group. .</p>
public struct GroupMember: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the group member (user).</p>
    public let arn: String?
    /// <p>The name of the group member (user).</p>
    public let memberName: String?

    public init (
        arn: String? = nil,
        memberName: String? = nil
    )
    {
        self.arn = arn
        self.memberName = memberName
    }
}

extension GutterStyle: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case show = "Show"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if show != false {
            try encodeContainer.encode(show, forKey: .show)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let showDecoded = try containerValues.decode(Bool.self, forKey: .show)
        show = showDecoded
    }
}

extension GutterStyle: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GutterStyle(show: \(String(describing: show)))"}
}

/// <p>The display options for gutter spacing between tiles on a sheet.</p>
public struct GutterStyle: Equatable {
    /// <p>This Boolean value controls whether to display a gutter space between sheet tiles.
    ///         </p>
    public let show: Bool

    public init (
        show: Bool = false
    )
    {
        self.show = show
    }
}

extension IAMPolicyAssignment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assignmentId = "AssignmentId"
        case assignmentName = "AssignmentName"
        case assignmentStatus = "AssignmentStatus"
        case awsAccountId = "AwsAccountId"
        case identities = "Identities"
        case policyArn = "PolicyArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentId = assignmentId {
            try encodeContainer.encode(assignmentId, forKey: .assignmentId)
        }
        if let assignmentName = assignmentName {
            try encodeContainer.encode(assignmentName, forKey: .assignmentName)
        }
        if let assignmentStatus = assignmentStatus {
            try encodeContainer.encode(assignmentStatus.rawValue, forKey: .assignmentStatus)
        }
        if let awsAccountId = awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let identities = identities {
            var identitiesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .identities)
            for (dictKey0, identitymap0) in identities {
                try identitiesContainer.encode(identitymap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let policyArn = policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let assignmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assignmentId)
        assignmentId = assignmentIdDecoded
        let assignmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assignmentName)
        assignmentName = assignmentNameDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let identitiesContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .identities)
        var identitiesDecoded0: [String:[String]]? = nil
        if let identitiesContainer = identitiesContainer {
            identitiesDecoded0 = [String:[String]]()
            for (key0, identitynamelist0) in identitiesContainer {
                var identitynamelist0Decoded0: [String]? = nil
                if let identitynamelist0 = identitynamelist0 {
                    identitynamelist0Decoded0 = [String]()
                    for string1 in identitynamelist0 {
                        if let string1 = string1 {
                            identitynamelist0Decoded0?.append(string1)
                        }
                    }
                }
                identitiesDecoded0?[key0] = identitynamelist0Decoded0
            }
        }
        identities = identitiesDecoded0
        let assignmentStatusDecoded = try containerValues.decodeIfPresent(AssignmentStatus.self, forKey: .assignmentStatus)
        assignmentStatus = assignmentStatusDecoded
    }
}

extension IAMPolicyAssignment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IAMPolicyAssignment(assignmentId: \(String(describing: assignmentId)), assignmentName: \(String(describing: assignmentName)), assignmentStatus: \(String(describing: assignmentStatus)), awsAccountId: \(String(describing: awsAccountId)), identities: \(String(describing: identities)), policyArn: \(String(describing: policyArn)))"}
}

/// <p>An AWS Identity and Access Management (IAM) policy assignment.</p>
public struct IAMPolicyAssignment: Equatable {
    /// <p>Assignment ID.</p>
    public let assignmentId: String?
    /// <p>Assignment name.</p>
    public let assignmentName: String?
    /// <p>Assignment status.</p>
    public let assignmentStatus: AssignmentStatus?
    /// <p>The AWS account ID.</p>
    public let awsAccountId: String?
    /// <p>Identities.</p>
    public let identities: [String:[String]]?
    /// <p>The Amazon Resource Name (ARN) for the IAM policy.</p>
    public let policyArn: String?

    public init (
        assignmentId: String? = nil,
        assignmentName: String? = nil,
        assignmentStatus: AssignmentStatus? = nil,
        awsAccountId: String? = nil,
        identities: [String:[String]]? = nil,
        policyArn: String? = nil
    )
    {
        self.assignmentId = assignmentId
        self.assignmentName = assignmentName
        self.assignmentStatus = assignmentStatus
        self.awsAccountId = awsAccountId
        self.identities = identities
        self.policyArn = policyArn
    }
}

extension IAMPolicyAssignmentSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assignmentName = "AssignmentName"
        case assignmentStatus = "AssignmentStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentName = assignmentName {
            try encodeContainer.encode(assignmentName, forKey: .assignmentName)
        }
        if let assignmentStatus = assignmentStatus {
            try encodeContainer.encode(assignmentStatus.rawValue, forKey: .assignmentStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assignmentName)
        assignmentName = assignmentNameDecoded
        let assignmentStatusDecoded = try containerValues.decodeIfPresent(AssignmentStatus.self, forKey: .assignmentStatus)
        assignmentStatus = assignmentStatusDecoded
    }
}

extension IAMPolicyAssignmentSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IAMPolicyAssignmentSummary(assignmentName: \(String(describing: assignmentName)), assignmentStatus: \(String(describing: assignmentStatus)))"}
}

/// <p>IAM policy assignment summary.</p>
public struct IAMPolicyAssignmentSummary: Equatable {
    /// <p>Assignment name.</p>
    public let assignmentName: String?
    /// <p>Assignment status.</p>
    public let assignmentStatus: AssignmentStatus?

    public init (
        assignmentName: String? = nil,
        assignmentStatus: AssignmentStatus? = nil
    )
    {
        self.assignmentName = assignmentName
        self.assignmentStatus = assignmentStatus
    }
}

public enum IdentityStore {
    case quicksight
    case sdkUnknown(String)
}

extension IdentityStore : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IdentityStore] {
        return [
            .quicksight,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .quicksight: return "QUICKSIGHT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IdentityStore(rawValue: rawValue) ?? IdentityStore.sdkUnknown(rawValue)
    }
}

public enum IdentityType {
    case iam
    case quicksight
    case sdkUnknown(String)
}

extension IdentityType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IdentityType] {
        return [
            .iam,
            .quicksight,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .iam: return "IAM"
        case .quicksight: return "QUICKSIGHT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IdentityType(rawValue: rawValue) ?? IdentityType.sdkUnknown(rawValue)
    }
}

extension IdentityTypeNotSupportedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IdentityTypeNotSupportedException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension IdentityTypeNotSupportedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IdentityTypeNotSupportedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The identity type specified isn't supported. Supported identity types include
/// 				<code>IAM</code> and <code>QUICKSIGHT</code>.</p>
public struct IdentityTypeNotSupportedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The AWS request ID for this request.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct IdentityTypeNotSupportedExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension IdentityTypeNotSupportedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension Ingestion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case errorInfo = "ErrorInfo"
        case ingestionId = "IngestionId"
        case ingestionSizeInBytes = "IngestionSizeInBytes"
        case ingestionStatus = "IngestionStatus"
        case ingestionTimeInSeconds = "IngestionTimeInSeconds"
        case queueInfo = "QueueInfo"
        case requestSource = "RequestSource"
        case requestType = "RequestType"
        case rowInfo = "RowInfo"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let errorInfo = errorInfo {
            try encodeContainer.encode(errorInfo, forKey: .errorInfo)
        }
        if let ingestionId = ingestionId {
            try encodeContainer.encode(ingestionId, forKey: .ingestionId)
        }
        if ingestionSizeInBytes != 0 {
            try encodeContainer.encode(ingestionSizeInBytes, forKey: .ingestionSizeInBytes)
        }
        if let ingestionStatus = ingestionStatus {
            try encodeContainer.encode(ingestionStatus.rawValue, forKey: .ingestionStatus)
        }
        if ingestionTimeInSeconds != 0 {
            try encodeContainer.encode(ingestionTimeInSeconds, forKey: .ingestionTimeInSeconds)
        }
        if let queueInfo = queueInfo {
            try encodeContainer.encode(queueInfo, forKey: .queueInfo)
        }
        if let requestSource = requestSource {
            try encodeContainer.encode(requestSource.rawValue, forKey: .requestSource)
        }
        if let requestType = requestType {
            try encodeContainer.encode(requestType.rawValue, forKey: .requestType)
        }
        if let rowInfo = rowInfo {
            try encodeContainer.encode(rowInfo, forKey: .rowInfo)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let ingestionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ingestionId)
        ingestionId = ingestionIdDecoded
        let ingestionStatusDecoded = try containerValues.decodeIfPresent(IngestionStatus.self, forKey: .ingestionStatus)
        ingestionStatus = ingestionStatusDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(ErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let rowInfoDecoded = try containerValues.decodeIfPresent(RowInfo.self, forKey: .rowInfo)
        rowInfo = rowInfoDecoded
        let queueInfoDecoded = try containerValues.decodeIfPresent(QueueInfo.self, forKey: .queueInfo)
        queueInfo = queueInfoDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let ingestionTimeInSecondsDecoded = try containerValues.decode(Int.self, forKey: .ingestionTimeInSeconds)
        ingestionTimeInSeconds = ingestionTimeInSecondsDecoded
        let ingestionSizeInBytesDecoded = try containerValues.decode(Int.self, forKey: .ingestionSizeInBytes)
        ingestionSizeInBytes = ingestionSizeInBytesDecoded
        let requestSourceDecoded = try containerValues.decodeIfPresent(IngestionRequestSource.self, forKey: .requestSource)
        requestSource = requestSourceDecoded
        let requestTypeDecoded = try containerValues.decodeIfPresent(IngestionRequestType.self, forKey: .requestType)
        requestType = requestTypeDecoded
    }
}

extension Ingestion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Ingestion(arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), errorInfo: \(String(describing: errorInfo)), ingestionId: \(String(describing: ingestionId)), ingestionSizeInBytes: \(String(describing: ingestionSizeInBytes)), ingestionStatus: \(String(describing: ingestionStatus)), ingestionTimeInSeconds: \(String(describing: ingestionTimeInSeconds)), queueInfo: \(String(describing: queueInfo)), requestSource: \(String(describing: requestSource)), requestType: \(String(describing: requestType)), rowInfo: \(String(describing: rowInfo)))"}
}

/// <p>Information about the SPICE ingestion for a dataset.</p>
public struct Ingestion: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let arn: String?
    /// <p>The time that this ingestion started.</p>
    public let createdTime: Date?
    /// <p>Error information for this ingestion.</p>
    public let errorInfo: ErrorInfo?
    /// <p>Ingestion ID.</p>
    public let ingestionId: String?
    /// <p>The size of the data ingested, in bytes.</p>
    public let ingestionSizeInBytes: Int
    /// <p>Ingestion status.</p>
    public let ingestionStatus: IngestionStatus?
    /// <p>The time that this ingestion took, measured in seconds.</p>
    public let ingestionTimeInSeconds: Int
    /// <p>Information about a queued dataset SPICE ingestion.</p>
    public let queueInfo: QueueInfo?
    /// <p>Event source for this ingestion.</p>
    public let requestSource: IngestionRequestSource?
    /// <p>Type of this ingestion.</p>
    public let requestType: IngestionRequestType?
    /// <p>Information about rows for a data set SPICE ingestion.</p>
    public let rowInfo: RowInfo?

    public init (
        arn: String? = nil,
        createdTime: Date? = nil,
        errorInfo: ErrorInfo? = nil,
        ingestionId: String? = nil,
        ingestionSizeInBytes: Int = 0,
        ingestionStatus: IngestionStatus? = nil,
        ingestionTimeInSeconds: Int = 0,
        queueInfo: QueueInfo? = nil,
        requestSource: IngestionRequestSource? = nil,
        requestType: IngestionRequestType? = nil,
        rowInfo: RowInfo? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.errorInfo = errorInfo
        self.ingestionId = ingestionId
        self.ingestionSizeInBytes = ingestionSizeInBytes
        self.ingestionStatus = ingestionStatus
        self.ingestionTimeInSeconds = ingestionTimeInSeconds
        self.queueInfo = queueInfo
        self.requestSource = requestSource
        self.requestType = requestType
        self.rowInfo = rowInfo
    }
}

public enum IngestionErrorType {
    case accountCapacityLimitExceeded
    case connectionFailure
    case customerError
    case dataSetDeleted
    case dataSetNotSpice
    case dataSetSizeLimitExceeded
    case dataSourceAuthFailed
    case dataSourceConnectionFailed
    case dataSourceNotFound
    case dataToleranceException
    case failureToAssumeRole
    case failureToProcessJsonFile
    case iamRoleNotAvailable
    case ingestionCanceled
    case ingestionSuperseded
    case internalServiceError
    case invalidDataprepSyntax
    case invalidDataSourceConfig
    case invalidDateFormat
    case iotDataSetFileEmpty
    case iotFileNotFound
    case oauthTokenFailure
    case passwordAuthenticationFailure
    case permissionDenied
    case queryTimeout
    case rowSizeLimitExceeded
    case s3FileInaccessible
    case s3ManifestError
    case s3UploadedFileDeleted
    case sourceApiLimitExceededFailure
    case sourceResourceLimitExceeded
    case spiceTableNotFound
    case sqlException
    case sqlInvalidParameterValue
    case sqlNumericOverflow
    case sqlSchemaMismatchError
    case sqlTableNotFound
    case sslCertificateValidationFailure
    case unresolvableHost
    case unroutableHost
    case sdkUnknown(String)
}

extension IngestionErrorType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IngestionErrorType] {
        return [
            .accountCapacityLimitExceeded,
            .connectionFailure,
            .customerError,
            .dataSetDeleted,
            .dataSetNotSpice,
            .dataSetSizeLimitExceeded,
            .dataSourceAuthFailed,
            .dataSourceConnectionFailed,
            .dataSourceNotFound,
            .dataToleranceException,
            .failureToAssumeRole,
            .failureToProcessJsonFile,
            .iamRoleNotAvailable,
            .ingestionCanceled,
            .ingestionSuperseded,
            .internalServiceError,
            .invalidDataprepSyntax,
            .invalidDataSourceConfig,
            .invalidDateFormat,
            .iotDataSetFileEmpty,
            .iotFileNotFound,
            .oauthTokenFailure,
            .passwordAuthenticationFailure,
            .permissionDenied,
            .queryTimeout,
            .rowSizeLimitExceeded,
            .s3FileInaccessible,
            .s3ManifestError,
            .s3UploadedFileDeleted,
            .sourceApiLimitExceededFailure,
            .sourceResourceLimitExceeded,
            .spiceTableNotFound,
            .sqlException,
            .sqlInvalidParameterValue,
            .sqlNumericOverflow,
            .sqlSchemaMismatchError,
            .sqlTableNotFound,
            .sslCertificateValidationFailure,
            .unresolvableHost,
            .unroutableHost,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accountCapacityLimitExceeded: return "ACCOUNT_CAPACITY_LIMIT_EXCEEDED"
        case .connectionFailure: return "CONNECTION_FAILURE"
        case .customerError: return "CUSTOMER_ERROR"
        case .dataSetDeleted: return "DATA_SET_DELETED"
        case .dataSetNotSpice: return "DATA_SET_NOT_SPICE"
        case .dataSetSizeLimitExceeded: return "DATA_SET_SIZE_LIMIT_EXCEEDED"
        case .dataSourceAuthFailed: return "DATA_SOURCE_AUTH_FAILED"
        case .dataSourceConnectionFailed: return "DATA_SOURCE_CONNECTION_FAILED"
        case .dataSourceNotFound: return "DATA_SOURCE_NOT_FOUND"
        case .dataToleranceException: return "DATA_TOLERANCE_EXCEPTION"
        case .failureToAssumeRole: return "FAILURE_TO_ASSUME_ROLE"
        case .failureToProcessJsonFile: return "FAILURE_TO_PROCESS_JSON_FILE"
        case .iamRoleNotAvailable: return "IAM_ROLE_NOT_AVAILABLE"
        case .ingestionCanceled: return "INGESTION_CANCELED"
        case .ingestionSuperseded: return "INGESTION_SUPERSEDED"
        case .internalServiceError: return "INTERNAL_SERVICE_ERROR"
        case .invalidDataprepSyntax: return "INVALID_DATAPREP_SYNTAX"
        case .invalidDataSourceConfig: return "INVALID_DATA_SOURCE_CONFIG"
        case .invalidDateFormat: return "INVALID_DATE_FORMAT"
        case .iotDataSetFileEmpty: return "IOT_DATA_SET_FILE_EMPTY"
        case .iotFileNotFound: return "IOT_FILE_NOT_FOUND"
        case .oauthTokenFailure: return "OAUTH_TOKEN_FAILURE"
        case .passwordAuthenticationFailure: return "PASSWORD_AUTHENTICATION_FAILURE"
        case .permissionDenied: return "PERMISSION_DENIED"
        case .queryTimeout: return "QUERY_TIMEOUT"
        case .rowSizeLimitExceeded: return "ROW_SIZE_LIMIT_EXCEEDED"
        case .s3FileInaccessible: return "S3_FILE_INACCESSIBLE"
        case .s3ManifestError: return "S3_MANIFEST_ERROR"
        case .s3UploadedFileDeleted: return "S3_UPLOADED_FILE_DELETED"
        case .sourceApiLimitExceededFailure: return "SOURCE_API_LIMIT_EXCEEDED_FAILURE"
        case .sourceResourceLimitExceeded: return "SOURCE_RESOURCE_LIMIT_EXCEEDED"
        case .spiceTableNotFound: return "SPICE_TABLE_NOT_FOUND"
        case .sqlException: return "SQL_EXCEPTION"
        case .sqlInvalidParameterValue: return "SQL_INVALID_PARAMETER_VALUE"
        case .sqlNumericOverflow: return "SQL_NUMERIC_OVERFLOW"
        case .sqlSchemaMismatchError: return "SQL_SCHEMA_MISMATCH_ERROR"
        case .sqlTableNotFound: return "SQL_TABLE_NOT_FOUND"
        case .sslCertificateValidationFailure: return "SSL_CERTIFICATE_VALIDATION_FAILURE"
        case .unresolvableHost: return "UNRESOLVABLE_HOST"
        case .unroutableHost: return "UNROUTABLE_HOST"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IngestionErrorType(rawValue: rawValue) ?? IngestionErrorType.sdkUnknown(rawValue)
    }
}

public enum IngestionRequestSource {
    case manual
    case scheduled
    case sdkUnknown(String)
}

extension IngestionRequestSource : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IngestionRequestSource] {
        return [
            .manual,
            .scheduled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .manual: return "MANUAL"
        case .scheduled: return "SCHEDULED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IngestionRequestSource(rawValue: rawValue) ?? IngestionRequestSource.sdkUnknown(rawValue)
    }
}

public enum IngestionRequestType {
    case edit
    case fullRefresh
    case incrementalRefresh
    case initialIngestion
    case sdkUnknown(String)
}

extension IngestionRequestType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IngestionRequestType] {
        return [
            .edit,
            .fullRefresh,
            .incrementalRefresh,
            .initialIngestion,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .edit: return "EDIT"
        case .fullRefresh: return "FULL_REFRESH"
        case .incrementalRefresh: return "INCREMENTAL_REFRESH"
        case .initialIngestion: return "INITIAL_INGESTION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IngestionRequestType(rawValue: rawValue) ?? IngestionRequestType.sdkUnknown(rawValue)
    }
}

public enum IngestionStatus {
    case cancelled
    case completed
    case failed
    case initialized
    case queued
    case running
    case sdkUnknown(String)
}

extension IngestionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IngestionStatus] {
        return [
            .cancelled,
            .completed,
            .failed,
            .initialized,
            .queued,
            .running,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancelled: return "CANCELLED"
        case .completed: return "COMPLETED"
        case .failed: return "FAILED"
        case .initialized: return "INITIALIZED"
        case .queued: return "QUEUED"
        case .running: return "RUNNING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IngestionStatus(rawValue: rawValue) ?? IngestionStatus.sdkUnknown(rawValue)
    }
}

extension InputColumn: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(InputColumnDataType.self, forKey: .type)
        type = typeDecoded
    }
}

extension InputColumn: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputColumn(name: \(String(describing: name)), type: \(String(describing: type)))"}
}

/// <p>Metadata for a column that is used as the input of a transform operation.</p>
public struct InputColumn: Equatable {
    /// <p>The name of this column in the underlying data source.</p>
    public let name: String?
    /// <p>The data type of the column.</p>
    public let type: InputColumnDataType?

    public init (
        name: String? = nil,
        type: InputColumnDataType? = nil
    )
    {
        self.name = name
        self.type = type
    }
}

public enum InputColumnDataType {
    case bit
    case boolean
    case datetime
    case decimal
    case integer
    case json
    case string
    case sdkUnknown(String)
}

extension InputColumnDataType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InputColumnDataType] {
        return [
            .bit,
            .boolean,
            .datetime,
            .decimal,
            .integer,
            .json,
            .string,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bit: return "BIT"
        case .boolean: return "BOOLEAN"
        case .datetime: return "DATETIME"
        case .decimal: return "DECIMAL"
        case .integer: return "INTEGER"
        case .json: return "JSON"
        case .string: return "STRING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InputColumnDataType(rawValue: rawValue) ?? InputColumnDataType.sdkUnknown(rawValue)
    }
}

extension IntegerParameter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for longlist0 in values {
                try valuesContainer.encode(longlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Int?].self, forKey: .values)
        var valuesDecoded0:[Int]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Int]()
            for long0 in valuesContainer {
                if let long0 = long0 {
                    valuesDecoded0?.append(long0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension IntegerParameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IntegerParameter(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>An integer parameter.</p>
public struct IntegerParameter: Equatable {
    /// <p>The name of the integer parameter.</p>
    public let name: String?
    /// <p>The values for the integer parameter.</p>
    public let values: [Int]?

    public init (
        name: String? = nil,
        values: [Int]? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

extension InternalFailureException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalFailureException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension InternalFailureException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal failure occurred.</p>
public struct InternalFailureException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?
    /// <p>The AWS request ID for this request.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct InternalFailureExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension InternalFailureExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension InvalidNextTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidNextTokenException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension InvalidNextTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The <code>NextToken</code> value isn't valid.</p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The AWS request ID for this request.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct InvalidNextTokenExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension InvalidNextTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension InvalidParameterValueException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterValueException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension InvalidParameterValueException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more parameters has a value that isn't valid.</p>
public struct InvalidParameterValueException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The AWS request ID for this request.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct InvalidParameterValueExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension InvalidParameterValueExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension JiraParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case siteBaseUrl = "SiteBaseUrl"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let siteBaseUrl = siteBaseUrl {
            try encodeContainer.encode(siteBaseUrl, forKey: .siteBaseUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteBaseUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .siteBaseUrl)
        siteBaseUrl = siteBaseUrlDecoded
    }
}

extension JiraParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JiraParameters(siteBaseUrl: \(String(describing: siteBaseUrl)))"}
}

/// <p>Jira parameters.</p>
public struct JiraParameters: Equatable {
    /// <p>The base URL of the Jira site.</p>
    public let siteBaseUrl: String?

    public init (
        siteBaseUrl: String? = nil
    )
    {
        self.siteBaseUrl = siteBaseUrl
    }
}

extension JoinInstruction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case leftJoinKeyProperties = "LeftJoinKeyProperties"
        case leftOperand = "LeftOperand"
        case onClause = "OnClause"
        case rightJoinKeyProperties = "RightJoinKeyProperties"
        case rightOperand = "RightOperand"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let leftJoinKeyProperties = leftJoinKeyProperties {
            try encodeContainer.encode(leftJoinKeyProperties, forKey: .leftJoinKeyProperties)
        }
        if let leftOperand = leftOperand {
            try encodeContainer.encode(leftOperand, forKey: .leftOperand)
        }
        if let onClause = onClause {
            try encodeContainer.encode(onClause, forKey: .onClause)
        }
        if let rightJoinKeyProperties = rightJoinKeyProperties {
            try encodeContainer.encode(rightJoinKeyProperties, forKey: .rightJoinKeyProperties)
        }
        if let rightOperand = rightOperand {
            try encodeContainer.encode(rightOperand, forKey: .rightOperand)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let leftOperandDecoded = try containerValues.decodeIfPresent(String.self, forKey: .leftOperand)
        leftOperand = leftOperandDecoded
        let rightOperandDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rightOperand)
        rightOperand = rightOperandDecoded
        let leftJoinKeyPropertiesDecoded = try containerValues.decodeIfPresent(JoinKeyProperties.self, forKey: .leftJoinKeyProperties)
        leftJoinKeyProperties = leftJoinKeyPropertiesDecoded
        let rightJoinKeyPropertiesDecoded = try containerValues.decodeIfPresent(JoinKeyProperties.self, forKey: .rightJoinKeyProperties)
        rightJoinKeyProperties = rightJoinKeyPropertiesDecoded
        let typeDecoded = try containerValues.decodeIfPresent(JoinType.self, forKey: .type)
        type = typeDecoded
        let onClauseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .onClause)
        onClause = onClauseDecoded
    }
}

extension JoinInstruction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JoinInstruction(leftJoinKeyProperties: \(String(describing: leftJoinKeyProperties)), leftOperand: \(String(describing: leftOperand)), onClause: \(String(describing: onClause)), rightJoinKeyProperties: \(String(describing: rightJoinKeyProperties)), rightOperand: \(String(describing: rightOperand)), type: \(String(describing: type)))"}
}

/// <p>The instructions associated with a join. </p>
public struct JoinInstruction: Equatable {
    /// <p>Join key properties of the left operand.</p>
    public let leftJoinKeyProperties: JoinKeyProperties?
    /// <p>The operand on the left side of a join.</p>
    public let leftOperand: String?
    /// <p>The join instructions provided in the <code>ON</code> clause of a join.</p>
    public let onClause: String?
    /// <p>Join key properties of the right operand.</p>
    public let rightJoinKeyProperties: JoinKeyProperties?
    /// <p>The operand on the right side of a join.</p>
    public let rightOperand: String?
    /// <p>The type of join that it is.</p>
    public let type: JoinType?

    public init (
        leftJoinKeyProperties: JoinKeyProperties? = nil,
        leftOperand: String? = nil,
        onClause: String? = nil,
        rightJoinKeyProperties: JoinKeyProperties? = nil,
        rightOperand: String? = nil,
        type: JoinType? = nil
    )
    {
        self.leftJoinKeyProperties = leftJoinKeyProperties
        self.leftOperand = leftOperand
        self.onClause = onClause
        self.rightJoinKeyProperties = rightJoinKeyProperties
        self.rightOperand = rightOperand
        self.type = type
    }
}

extension JoinKeyProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case uniqueKey = "UniqueKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if uniqueKey != false {
            try encodeContainer.encode(uniqueKey, forKey: .uniqueKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uniqueKeyDecoded = try containerValues.decode(Bool.self, forKey: .uniqueKey)
        uniqueKey = uniqueKeyDecoded
    }
}

extension JoinKeyProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JoinKeyProperties(uniqueKey: \(String(describing: uniqueKey)))"}
}

/// <p>Properties associated with the columns participating in a join.</p>
public struct JoinKeyProperties: Equatable {
    /// <p>A value that indicates that a row in a table is uniquely identified by the columns in
    ///             a join key. This is used by QuickSight to optimize query performance.</p>
    public let uniqueKey: Bool

    public init (
        uniqueKey: Bool = false
    )
    {
        self.uniqueKey = uniqueKey
    }
}

public enum JoinType {
    case inner
    case `left`
    case outer
    case `right`
    case sdkUnknown(String)
}

extension JoinType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JoinType] {
        return [
            .inner,
            .left,
            .outer,
            .right,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .inner: return "INNER"
        case .left: return "LEFT"
        case .outer: return "OUTER"
        case .right: return "RIGHT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JoinType(rawValue: rawValue) ?? JoinType.sdkUnknown(rawValue)
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)), requestId: \(String(describing: requestId)), resourceType: \(String(describing: resourceType)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.requestId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A limit is exceeded.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The AWS request ID for this request.</p>
    public var requestId: String?
    /// <p>Limit exceeded.</p>
    public var resourceType: ExceptionResourceType?

    public init (
        message: String? = nil,
        requestId: String? = nil,
        resourceType: ExceptionResourceType? = nil
    )
    {
        self.message = message
        self.requestId = requestId
        self.resourceType = resourceType
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
    public let resourceType: ExceptionResourceType?
    public let requestId: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ExceptionResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ListAnalysesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAnalysesInput(awsAccountId: \(String(describing: awsAccountId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAnalysesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListAnalysesInputHeadersMiddleware: Middleware {
    public let id: String = "ListAnalysesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAnalysesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAnalysesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAnalysesInput>
    public typealias MOutput = OperationOutput<ListAnalysesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAnalysesOutputError>
}

public struct ListAnalysesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAnalysesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAnalysesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAnalysesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "max-results".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAnalysesInput>
    public typealias MOutput = OperationOutput<ListAnalysesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAnalysesOutputError>
}

public struct ListAnalysesInput: Equatable {
    /// <p>The ID of the AWS account that contains the analyses.</p>
    public let awsAccountId: String?
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int
    /// <p>A pagination token that can be used in a subsequent request.</p>
    public let nextToken: String?

    public init (
        awsAccountId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAnalysesInputBody: Equatable {
}

extension ListAnalysesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListAnalysesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAnalysesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAnalysesOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAnalysesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAnalysesOutputResponse(analysisSummaryList: \(String(describing: analysisSummaryList)), nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension ListAnalysesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAnalysesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.analysisSummaryList = output.analysisSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.analysisSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListAnalysesOutputResponse: Equatable {
    /// <p>Metadata describing each of the analyses that are listed.</p>
    public let analysisSummaryList: [AnalysisSummary]?
    /// <p>A pagination token that can be used in a subsequent request.</p>
    public let nextToken: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        analysisSummaryList: [AnalysisSummary]? = nil,
        nextToken: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.analysisSummaryList = analysisSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListAnalysesOutputResponseBody: Equatable {
    public let analysisSummaryList: [AnalysisSummary]?
    public let nextToken: String?
    public let status: Int
    public let requestId: String?
}

extension ListAnalysesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analysisSummaryList = "AnalysisSummaryList"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisSummaryListContainer = try containerValues.decodeIfPresent([AnalysisSummary?].self, forKey: .analysisSummaryList)
        var analysisSummaryListDecoded0:[AnalysisSummary]? = nil
        if let analysisSummaryListContainer = analysisSummaryListContainer {
            analysisSummaryListDecoded0 = [AnalysisSummary]()
            for structure0 in analysisSummaryListContainer {
                if let structure0 = structure0 {
                    analysisSummaryListDecoded0?.append(structure0)
                }
            }
        }
        analysisSummaryList = analysisSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ListDashboardVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDashboardVersionsInput(awsAccountId: \(String(describing: awsAccountId)), dashboardId: \(String(describing: dashboardId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDashboardVersionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDashboardVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDashboardVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDashboardVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDashboardVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDashboardVersionsInput>
    public typealias MOutput = OperationOutput<ListDashboardVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDashboardVersionsOutputError>
}

public struct ListDashboardVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDashboardVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDashboardVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDashboardVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "max-results".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDashboardVersionsInput>
    public typealias MOutput = OperationOutput<ListDashboardVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDashboardVersionsOutputError>
}

public struct ListDashboardVersionsInput: Equatable {
    /// <p>The ID of the AWS account that contains the dashboard that you're listing versions
    ///             for.</p>
    public let awsAccountId: String?
    /// <p>The ID for the dashboard.</p>
    public let dashboardId: String?
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?

    public init (
        awsAccountId: String? = nil,
        dashboardId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDashboardVersionsInputBody: Equatable {
}

extension ListDashboardVersionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDashboardVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDashboardVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDashboardVersionsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDashboardVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDashboardVersionsOutputResponse(dashboardVersionSummaryList: \(String(describing: dashboardVersionSummaryList)), nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension ListDashboardVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDashboardVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dashboardVersionSummaryList = output.dashboardVersionSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.dashboardVersionSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListDashboardVersionsOutputResponse: Equatable {
    /// <p>A structure that contains information about each version of the dashboard.</p>
    public let dashboardVersionSummaryList: [DashboardVersionSummary]?
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        dashboardVersionSummaryList: [DashboardVersionSummary]? = nil,
        nextToken: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.dashboardVersionSummaryList = dashboardVersionSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListDashboardVersionsOutputResponseBody: Equatable {
    public let dashboardVersionSummaryList: [DashboardVersionSummary]?
    public let nextToken: String?
    public let status: Int
    public let requestId: String?
}

extension ListDashboardVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dashboardVersionSummaryList = "DashboardVersionSummaryList"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardVersionSummaryListContainer = try containerValues.decodeIfPresent([DashboardVersionSummary?].self, forKey: .dashboardVersionSummaryList)
        var dashboardVersionSummaryListDecoded0:[DashboardVersionSummary]? = nil
        if let dashboardVersionSummaryListContainer = dashboardVersionSummaryListContainer {
            dashboardVersionSummaryListDecoded0 = [DashboardVersionSummary]()
            for structure0 in dashboardVersionSummaryListContainer {
                if let structure0 = structure0 {
                    dashboardVersionSummaryListDecoded0?.append(structure0)
                }
            }
        }
        dashboardVersionSummaryList = dashboardVersionSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ListDashboardsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDashboardsInput(awsAccountId: \(String(describing: awsAccountId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDashboardsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDashboardsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDashboardsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDashboardsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDashboardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDashboardsInput>
    public typealias MOutput = OperationOutput<ListDashboardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDashboardsOutputError>
}

public struct ListDashboardsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDashboardsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDashboardsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDashboardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "max-results".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDashboardsInput>
    public typealias MOutput = OperationOutput<ListDashboardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDashboardsOutputError>
}

public struct ListDashboardsInput: Equatable {
    /// <p>The ID of the AWS account that contains the dashboards that you're
    ///             listing.</p>
    public let awsAccountId: String?
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?

    public init (
        awsAccountId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDashboardsInputBody: Equatable {
}

extension ListDashboardsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDashboardsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDashboardsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDashboardsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDashboardsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDashboardsOutputResponse(dashboardSummaryList: \(String(describing: dashboardSummaryList)), nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension ListDashboardsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDashboardsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dashboardSummaryList = output.dashboardSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.dashboardSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListDashboardsOutputResponse: Equatable {
    /// <p>A structure that contains all of the dashboards in your AWS account. This structure
    ///             provides basic information about the dashboards.</p>
    public let dashboardSummaryList: [DashboardSummary]?
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        dashboardSummaryList: [DashboardSummary]? = nil,
        nextToken: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.dashboardSummaryList = dashboardSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListDashboardsOutputResponseBody: Equatable {
    public let dashboardSummaryList: [DashboardSummary]?
    public let nextToken: String?
    public let status: Int
    public let requestId: String?
}

extension ListDashboardsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dashboardSummaryList = "DashboardSummaryList"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardSummaryListContainer = try containerValues.decodeIfPresent([DashboardSummary?].self, forKey: .dashboardSummaryList)
        var dashboardSummaryListDecoded0:[DashboardSummary]? = nil
        if let dashboardSummaryListContainer = dashboardSummaryListContainer {
            dashboardSummaryListDecoded0 = [DashboardSummary]()
            for structure0 in dashboardSummaryListContainer {
                if let structure0 = structure0 {
                    dashboardSummaryListDecoded0?.append(structure0)
                }
            }
        }
        dashboardSummaryList = dashboardSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ListDataSetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDataSetsInput(awsAccountId: \(String(describing: awsAccountId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDataSetsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDataSetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDataSetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDataSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDataSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDataSetsInput>
    public typealias MOutput = OperationOutput<ListDataSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDataSetsOutputError>
}

public struct ListDataSetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDataSetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDataSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDataSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "max-results".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDataSetsInput>
    public typealias MOutput = OperationOutput<ListDataSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDataSetsOutputError>
}

public struct ListDataSetsInput: Equatable {
    /// <p>The AWS account ID.</p>
    public let awsAccountId: String?
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?

    public init (
        awsAccountId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataSetsInputBody: Equatable {
}

extension ListDataSetsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDataSetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDataSetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDataSetsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDataSetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDataSetsOutputResponse(dataSetSummaries: \(String(describing: dataSetSummaries)), nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension ListDataSetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDataSetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dataSetSummaries = output.dataSetSummaries
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.dataSetSummaries = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListDataSetsOutputResponse: Equatable {
    /// <p>The list of dataset summaries.</p>
    public let dataSetSummaries: [DataSetSummary]?
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        dataSetSummaries: [DataSetSummary]? = nil,
        nextToken: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.dataSetSummaries = dataSetSummaries
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListDataSetsOutputResponseBody: Equatable {
    public let dataSetSummaries: [DataSetSummary]?
    public let nextToken: String?
    public let requestId: String?
    public let status: Int
}

extension ListDataSetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataSetSummaries = "DataSetSummaries"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetSummariesContainer = try containerValues.decodeIfPresent([DataSetSummary?].self, forKey: .dataSetSummaries)
        var dataSetSummariesDecoded0:[DataSetSummary]? = nil
        if let dataSetSummariesContainer = dataSetSummariesContainer {
            dataSetSummariesDecoded0 = [DataSetSummary]()
            for structure0 in dataSetSummariesContainer {
                if let structure0 = structure0 {
                    dataSetSummariesDecoded0?.append(structure0)
                }
            }
        }
        dataSetSummaries = dataSetSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension ListDataSourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDataSourcesInput(awsAccountId: \(String(describing: awsAccountId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDataSourcesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDataSourcesInputHeadersMiddleware: Middleware {
    public let id: String = "ListDataSourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDataSourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDataSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDataSourcesInput>
    public typealias MOutput = OperationOutput<ListDataSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDataSourcesOutputError>
}

public struct ListDataSourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDataSourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDataSourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDataSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "max-results".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDataSourcesInput>
    public typealias MOutput = OperationOutput<ListDataSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDataSourcesOutputError>
}

public struct ListDataSourcesInput: Equatable {
    /// <p>The AWS account ID.</p>
    public let awsAccountId: String?
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?

    public init (
        awsAccountId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataSourcesInputBody: Equatable {
}

extension ListDataSourcesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDataSourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDataSourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDataSourcesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDataSourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDataSourcesOutputResponse(dataSources: \(String(describing: dataSources)), nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension ListDataSourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDataSourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dataSources = output.dataSources
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.dataSources = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListDataSourcesOutputResponse: Equatable {
    /// <p>A list of data sources.</p>
    public let dataSources: [DataSource]?
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        dataSources: [DataSource]? = nil,
        nextToken: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.dataSources = dataSources
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListDataSourcesOutputResponseBody: Equatable {
    public let dataSources: [DataSource]?
    public let nextToken: String?
    public let requestId: String?
    public let status: Int
}

extension ListDataSourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataSources = "DataSources"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourcesContainer = try containerValues.decodeIfPresent([DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [DataSource]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension ListGroupMembershipsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGroupMembershipsInput(awsAccountId: \(String(describing: awsAccountId)), groupName: \(String(describing: groupName)), maxResults: \(String(describing: maxResults)), namespace: \(String(describing: namespace)), nextToken: \(String(describing: nextToken)))"}
}

extension ListGroupMembershipsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListGroupMembershipsInputHeadersMiddleware: Middleware {
    public let id: String = "ListGroupMembershipsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupMembershipsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupMembershipsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupMembershipsInput>
    public typealias MOutput = OperationOutput<ListGroupMembershipsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupMembershipsOutputError>
}

public struct ListGroupMembershipsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListGroupMembershipsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupMembershipsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupMembershipsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "max-results".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupMembershipsInput>
    public typealias MOutput = OperationOutput<ListGroupMembershipsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupMembershipsOutputError>
}

public struct ListGroupMembershipsInput: Equatable {
    /// <p>The ID for the AWS account that the group is in. Currently, you use the ID for the AWS
    /// 			account that contains your Amazon QuickSight account.</p>
    public let awsAccountId: String?
    /// <p>The name of the group that you want to see a membership list of.</p>
    public let groupName: String?
    /// <p>The maximum number of results to return from this request.</p>
    public let maxResults: Int
    /// <p>The namespace. Currently, you should set this to <code>default</code>.</p>
    public let namespace: String?
    /// <p>A pagination token that can be used in a subsequent request.</p>
    public let nextToken: String?

    public init (
        awsAccountId: String? = nil,
        groupName: String? = nil,
        maxResults: Int = 0,
        namespace: String? = nil,
        nextToken: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.groupName = groupName
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
    }
}

struct ListGroupMembershipsInputBody: Equatable {
}

extension ListGroupMembershipsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListGroupMembershipsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGroupMembershipsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGroupMembershipsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroupMembershipsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGroupMembershipsOutputResponse(groupMemberList: \(String(describing: groupMemberList)), nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension ListGroupMembershipsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListGroupMembershipsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.groupMemberList = output.groupMemberList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.groupMemberList = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListGroupMembershipsOutputResponse: Equatable {
    /// <p>The list of the members of the group.</p>
    public let groupMemberList: [GroupMember]?
    /// <p>A pagination token that can be used in a subsequent request.</p>
    public let nextToken: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        groupMemberList: [GroupMember]? = nil,
        nextToken: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.groupMemberList = groupMemberList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListGroupMembershipsOutputResponseBody: Equatable {
    public let groupMemberList: [GroupMember]?
    public let nextToken: String?
    public let requestId: String?
    public let status: Int
}

extension ListGroupMembershipsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupMemberList = "GroupMemberList"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupMemberListContainer = try containerValues.decodeIfPresent([GroupMember?].self, forKey: .groupMemberList)
        var groupMemberListDecoded0:[GroupMember]? = nil
        if let groupMemberListContainer = groupMemberListContainer {
            groupMemberListDecoded0 = [GroupMember]()
            for structure0 in groupMemberListContainer {
                if let structure0 = structure0 {
                    groupMemberListDecoded0?.append(structure0)
                }
            }
        }
        groupMemberList = groupMemberListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension ListGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGroupsInput(awsAccountId: \(String(describing: awsAccountId)), maxResults: \(String(describing: maxResults)), namespace: \(String(describing: namespace)), nextToken: \(String(describing: nextToken)))"}
}

extension ListGroupsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ListGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupsInput>
    public typealias MOutput = OperationOutput<ListGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupsOutputError>
}

public struct ListGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "max-results".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupsInput>
    public typealias MOutput = OperationOutput<ListGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupsOutputError>
}

public struct ListGroupsInput: Equatable {
    /// <p>The ID for the AWS account that the group is in. Currently, you use the ID for the AWS
    /// 			account that contains your Amazon QuickSight account.</p>
    public let awsAccountId: String?
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int
    /// <p>The namespace. Currently, you should set this to <code>default</code>.</p>
    public let namespace: String?
    /// <p>A pagination token that can be used in a subsequent request.</p>
    public let nextToken: String?

    public init (
        awsAccountId: String? = nil,
        maxResults: Int = 0,
        namespace: String? = nil,
        nextToken: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
    }
}

struct ListGroupsInputBody: Equatable {
}

extension ListGroupsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGroupsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGroupsOutputResponse(groupList: \(String(describing: groupList)), nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension ListGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.groupList = output.groupList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.groupList = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListGroupsOutputResponse: Equatable {
    /// <p>The list of the groups.</p>
    public let groupList: [Group]?
    /// <p>A pagination token that can be used in a subsequent request.</p>
    public let nextToken: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        groupList: [Group]? = nil,
        nextToken: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.groupList = groupList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListGroupsOutputResponseBody: Equatable {
    public let groupList: [Group]?
    public let nextToken: String?
    public let requestId: String?
    public let status: Int
}

extension ListGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupList = "GroupList"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupListContainer = try containerValues.decodeIfPresent([Group?].self, forKey: .groupList)
        var groupListDecoded0:[Group]? = nil
        if let groupListContainer = groupListContainer {
            groupListDecoded0 = [Group]()
            for structure0 in groupListContainer {
                if let structure0 = structure0 {
                    groupListDecoded0?.append(structure0)
                }
            }
        }
        groupList = groupListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension ListIAMPolicyAssignmentsForUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIAMPolicyAssignmentsForUserInput(awsAccountId: \(String(describing: awsAccountId)), maxResults: \(String(describing: maxResults)), namespace: \(String(describing: namespace)), nextToken: \(String(describing: nextToken)), userName: \(String(describing: userName)))"}
}

extension ListIAMPolicyAssignmentsForUserInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListIAMPolicyAssignmentsForUserInputHeadersMiddleware: Middleware {
    public let id: String = "ListIAMPolicyAssignmentsForUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIAMPolicyAssignmentsForUserInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIAMPolicyAssignmentsForUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIAMPolicyAssignmentsForUserInput>
    public typealias MOutput = OperationOutput<ListIAMPolicyAssignmentsForUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIAMPolicyAssignmentsForUserOutputError>
}

public struct ListIAMPolicyAssignmentsForUserInputQueryItemMiddleware: Middleware {
    public let id: String = "ListIAMPolicyAssignmentsForUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIAMPolicyAssignmentsForUserInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIAMPolicyAssignmentsForUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "max-results".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIAMPolicyAssignmentsForUserInput>
    public typealias MOutput = OperationOutput<ListIAMPolicyAssignmentsForUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIAMPolicyAssignmentsForUserOutputError>
}

public struct ListIAMPolicyAssignmentsForUserInput: Equatable {
    /// <p>The ID of the AWS account that contains the assignments.</p>
    public let awsAccountId: String?
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Int
    /// <p>The namespace of the assignment.</p>
    public let namespace: String?
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?
    /// <p>The name of the user.</p>
    public let userName: String?

    public init (
        awsAccountId: String? = nil,
        maxResults: Int = 0,
        namespace: String? = nil,
        nextToken: String? = nil,
        userName: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
        self.userName = userName
    }
}

struct ListIAMPolicyAssignmentsForUserInputBody: Equatable {
}

extension ListIAMPolicyAssignmentsForUserInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListIAMPolicyAssignmentsForUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIAMPolicyAssignmentsForUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentUpdatingException" : self = .concurrentUpdatingException(try ConcurrentUpdatingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIAMPolicyAssignmentsForUserOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case concurrentUpdatingException(ConcurrentUpdatingException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIAMPolicyAssignmentsForUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIAMPolicyAssignmentsForUserOutputResponse(activeAssignments: \(String(describing: activeAssignments)), nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension ListIAMPolicyAssignmentsForUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListIAMPolicyAssignmentsForUserOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.activeAssignments = output.activeAssignments
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.activeAssignments = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListIAMPolicyAssignmentsForUserOutputResponse: Equatable {
    /// <p>The active assignments for this user.</p>
    public let activeAssignments: [ActiveIAMPolicyAssignment]?
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        activeAssignments: [ActiveIAMPolicyAssignment]? = nil,
        nextToken: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.activeAssignments = activeAssignments
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListIAMPolicyAssignmentsForUserOutputResponseBody: Equatable {
    public let activeAssignments: [ActiveIAMPolicyAssignment]?
    public let requestId: String?
    public let nextToken: String?
    public let status: Int
}

extension ListIAMPolicyAssignmentsForUserOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case activeAssignments = "ActiveAssignments"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeAssignmentsContainer = try containerValues.decodeIfPresent([ActiveIAMPolicyAssignment?].self, forKey: .activeAssignments)
        var activeAssignmentsDecoded0:[ActiveIAMPolicyAssignment]? = nil
        if let activeAssignmentsContainer = activeAssignmentsContainer {
            activeAssignmentsDecoded0 = [ActiveIAMPolicyAssignment]()
            for structure0 in activeAssignmentsContainer {
                if let structure0 = structure0 {
                    activeAssignmentsDecoded0?.append(structure0)
                }
            }
        }
        activeAssignments = activeAssignmentsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

public struct ListIAMPolicyAssignmentsInputBodyMiddleware: Middleware {
    public let id: String = "ListIAMPolicyAssignmentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIAMPolicyAssignmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIAMPolicyAssignmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIAMPolicyAssignmentsInput>
    public typealias MOutput = OperationOutput<ListIAMPolicyAssignmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIAMPolicyAssignmentsOutputError>
}

extension ListIAMPolicyAssignmentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIAMPolicyAssignmentsInput(assignmentStatus: \(String(describing: assignmentStatus)), awsAccountId: \(String(describing: awsAccountId)), maxResults: \(String(describing: maxResults)), namespace: \(String(describing: namespace)), nextToken: \(String(describing: nextToken)))"}
}

extension ListIAMPolicyAssignmentsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assignmentStatus = "AssignmentStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentStatus = assignmentStatus {
            try encodeContainer.encode(assignmentStatus.rawValue, forKey: .assignmentStatus)
        }
    }
}

public struct ListIAMPolicyAssignmentsInputHeadersMiddleware: Middleware {
    public let id: String = "ListIAMPolicyAssignmentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIAMPolicyAssignmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIAMPolicyAssignmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIAMPolicyAssignmentsInput>
    public typealias MOutput = OperationOutput<ListIAMPolicyAssignmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIAMPolicyAssignmentsOutputError>
}

public struct ListIAMPolicyAssignmentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListIAMPolicyAssignmentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIAMPolicyAssignmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIAMPolicyAssignmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "max-results".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIAMPolicyAssignmentsInput>
    public typealias MOutput = OperationOutput<ListIAMPolicyAssignmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIAMPolicyAssignmentsOutputError>
}

public struct ListIAMPolicyAssignmentsInput: Equatable {
    /// <p>The status of the assignments.</p>
    public let assignmentStatus: AssignmentStatus?
    /// <p>The ID of the AWS account that contains these IAM policy assignments.</p>
    public let awsAccountId: String?
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Int
    /// <p>The namespace for the assignments.</p>
    public let namespace: String?
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?

    public init (
        assignmentStatus: AssignmentStatus? = nil,
        awsAccountId: String? = nil,
        maxResults: Int = 0,
        namespace: String? = nil,
        nextToken: String? = nil
    )
    {
        self.assignmentStatus = assignmentStatus
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
    }
}

struct ListIAMPolicyAssignmentsInputBody: Equatable {
    public let assignmentStatus: AssignmentStatus?
}

extension ListIAMPolicyAssignmentsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assignmentStatus = "AssignmentStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentStatusDecoded = try containerValues.decodeIfPresent(AssignmentStatus.self, forKey: .assignmentStatus)
        assignmentStatus = assignmentStatusDecoded
    }
}

extension ListIAMPolicyAssignmentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIAMPolicyAssignmentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIAMPolicyAssignmentsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIAMPolicyAssignmentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIAMPolicyAssignmentsOutputResponse(iAMPolicyAssignments: \(String(describing: iAMPolicyAssignments)), nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension ListIAMPolicyAssignmentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListIAMPolicyAssignmentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.iAMPolicyAssignments = output.iAMPolicyAssignments
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.iAMPolicyAssignments = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListIAMPolicyAssignmentsOutputResponse: Equatable {
    /// <p>Information describing the IAM policy assignments.</p>
    public let iAMPolicyAssignments: [IAMPolicyAssignmentSummary]?
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        iAMPolicyAssignments: [IAMPolicyAssignmentSummary]? = nil,
        nextToken: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.iAMPolicyAssignments = iAMPolicyAssignments
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListIAMPolicyAssignmentsOutputResponseBody: Equatable {
    public let iAMPolicyAssignments: [IAMPolicyAssignmentSummary]?
    public let nextToken: String?
    public let requestId: String?
    public let status: Int
}

extension ListIAMPolicyAssignmentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case iAMPolicyAssignments = "IAMPolicyAssignments"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iAMPolicyAssignmentsContainer = try containerValues.decodeIfPresent([IAMPolicyAssignmentSummary?].self, forKey: .iAMPolicyAssignments)
        var iAMPolicyAssignmentsDecoded0:[IAMPolicyAssignmentSummary]? = nil
        if let iAMPolicyAssignmentsContainer = iAMPolicyAssignmentsContainer {
            iAMPolicyAssignmentsDecoded0 = [IAMPolicyAssignmentSummary]()
            for structure0 in iAMPolicyAssignmentsContainer {
                if let structure0 = structure0 {
                    iAMPolicyAssignmentsDecoded0?.append(structure0)
                }
            }
        }
        iAMPolicyAssignments = iAMPolicyAssignmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension ListIngestionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIngestionsInput(awsAccountId: \(String(describing: awsAccountId)), dataSetId: \(String(describing: dataSetId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListIngestionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListIngestionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListIngestionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIngestionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIngestionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIngestionsInput>
    public typealias MOutput = OperationOutput<ListIngestionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIngestionsOutputError>
}

public struct ListIngestionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListIngestionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIngestionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIngestionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "max-results".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIngestionsInput>
    public typealias MOutput = OperationOutput<ListIngestionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIngestionsOutputError>
}

public struct ListIngestionsInput: Equatable {
    /// <p>The AWS account ID.</p>
    public let awsAccountId: String?
    /// <p>The ID of the dataset used in the ingestion.</p>
    public let dataSetId: String?
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?

    public init (
        awsAccountId: String? = nil,
        dataSetId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIngestionsInputBody: Equatable {
}

extension ListIngestionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListIngestionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIngestionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIngestionsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIngestionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIngestionsOutputResponse(ingestions: \(String(describing: ingestions)), nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension ListIngestionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListIngestionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.ingestions = output.ingestions
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.ingestions = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListIngestionsOutputResponse: Equatable {
    /// <p>A list of the ingestions.</p>
    public let ingestions: [Ingestion]?
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        ingestions: [Ingestion]? = nil,
        nextToken: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.ingestions = ingestions
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListIngestionsOutputResponseBody: Equatable {
    public let ingestions: [Ingestion]?
    public let nextToken: String?
    public let requestId: String?
    public let status: Int
}

extension ListIngestionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ingestions = "Ingestions"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ingestionsContainer = try containerValues.decodeIfPresent([Ingestion?].self, forKey: .ingestions)
        var ingestionsDecoded0:[Ingestion]? = nil
        if let ingestionsContainer = ingestionsContainer {
            ingestionsDecoded0 = [Ingestion]()
            for structure0 in ingestionsContainer {
                if let structure0 = structure0 {
                    ingestionsDecoded0?.append(structure0)
                }
            }
        }
        ingestions = ingestionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension ListNamespacesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListNamespacesInput(awsAccountId: \(String(describing: awsAccountId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListNamespacesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListNamespacesInputHeadersMiddleware: Middleware {
    public let id: String = "ListNamespacesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListNamespacesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListNamespacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListNamespacesInput>
    public typealias MOutput = OperationOutput<ListNamespacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListNamespacesOutputError>
}

public struct ListNamespacesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListNamespacesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListNamespacesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListNamespacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "max-results".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListNamespacesInput>
    public typealias MOutput = OperationOutput<ListNamespacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListNamespacesOutputError>
}

public struct ListNamespacesInput: Equatable {
    /// <p>The ID for the AWS account that contains the QuickSight namespaces that you want to list.</p>
    public let awsAccountId: String?
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int
    /// <p>A pagination token that can be used in a subsequent request.</p>
    public let nextToken: String?

    public init (
        awsAccountId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListNamespacesInputBody: Equatable {
}

extension ListNamespacesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListNamespacesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNamespacesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListNamespacesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNamespacesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListNamespacesOutputResponse(namespaces: \(String(describing: namespaces)), nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension ListNamespacesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListNamespacesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.namespaces = output.namespaces
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.namespaces = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListNamespacesOutputResponse: Equatable {
    /// <p>The information about the namespaces in this AWS account. The response includes
    ///         the namespace ARN, name, AWS Region, notification email address, creation status, and
    ///         identity store.</p>
    public let namespaces: [NamespaceInfoV2]?
    /// <p>A pagination token that can be used in a subsequent request.</p>
    public let nextToken: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        namespaces: [NamespaceInfoV2]? = nil,
        nextToken: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.namespaces = namespaces
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListNamespacesOutputResponseBody: Equatable {
    public let namespaces: [NamespaceInfoV2]?
    public let nextToken: String?
    public let requestId: String?
    public let status: Int
}

extension ListNamespacesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case namespaces = "Namespaces"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespacesContainer = try containerValues.decodeIfPresent([NamespaceInfoV2?].self, forKey: .namespaces)
        var namespacesDecoded0:[NamespaceInfoV2]? = nil
        if let namespacesContainer = namespacesContainer {
            namespacesDecoded0 = [NamespaceInfoV2]()
            for structure0 in namespacesContainer {
                if let structure0 = structure0 {
                    namespacesDecoded0?.append(structure0)
                }
            }
        }
        namespaces = namespacesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want a list of tags for.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(requestId: \(String(describing: requestId)), status: \(String(describing: status)), tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.requestId = output.requestId
            self.tags = output.tags
        } else {
            self.requestId = nil
            self.tags = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>Contains a map of the key-value pairs for the resource tag or tags assigned to the
    /// 			resource.</p>
    public let tags: [Tag]?

    public init (
        requestId: String? = nil,
        status: Int = 0,
        tags: [Tag]? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
    public let requestId: String?
    public let status: Int
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension ListTemplateAliasesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTemplateAliasesInput(awsAccountId: \(String(describing: awsAccountId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), templateId: \(String(describing: templateId)))"}
}

extension ListTemplateAliasesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTemplateAliasesInputHeadersMiddleware: Middleware {
    public let id: String = "ListTemplateAliasesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTemplateAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTemplateAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTemplateAliasesInput>
    public typealias MOutput = OperationOutput<ListTemplateAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTemplateAliasesOutputError>
}

public struct ListTemplateAliasesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTemplateAliasesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTemplateAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTemplateAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "max-result".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTemplateAliasesInput>
    public typealias MOutput = OperationOutput<ListTemplateAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTemplateAliasesOutputError>
}

public struct ListTemplateAliasesInput: Equatable {
    /// <p>The ID of the AWS account that contains the template aliases that you're listing.</p>
    public let awsAccountId: String?
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?
    /// <p>The ID for the template.</p>
    public let templateId: String?

    public init (
        awsAccountId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        templateId: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.templateId = templateId
    }
}

struct ListTemplateAliasesInputBody: Equatable {
}

extension ListTemplateAliasesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTemplateAliasesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTemplateAliasesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTemplateAliasesOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTemplateAliasesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTemplateAliasesOutputResponse(nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)), status: \(String(describing: status)), templateAliasList: \(String(describing: templateAliasList)))"}
}

extension ListTemplateAliasesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTemplateAliasesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.requestId = output.requestId
            self.templateAliasList = output.templateAliasList
        } else {
            self.nextToken = nil
            self.requestId = nil
            self.templateAliasList = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListTemplateAliasesOutputResponse: Equatable {
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>A structure containing the list of the template's aliases.</p>
    public let templateAliasList: [TemplateAlias]?

    public init (
        nextToken: String? = nil,
        requestId: String? = nil,
        status: Int = 0,
        templateAliasList: [TemplateAlias]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
        self.templateAliasList = templateAliasList
    }
}

struct ListTemplateAliasesOutputResponseBody: Equatable {
    public let templateAliasList: [TemplateAlias]?
    public let status: Int
    public let requestId: String?
    public let nextToken: String?
}

extension ListTemplateAliasesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
        case templateAliasList = "TemplateAliasList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateAliasListContainer = try containerValues.decodeIfPresent([TemplateAlias?].self, forKey: .templateAliasList)
        var templateAliasListDecoded0:[TemplateAlias]? = nil
        if let templateAliasListContainer = templateAliasListContainer {
            templateAliasListDecoded0 = [TemplateAlias]()
            for structure0 in templateAliasListContainer {
                if let structure0 = structure0 {
                    templateAliasListDecoded0?.append(structure0)
                }
            }
        }
        templateAliasList = templateAliasListDecoded0
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTemplateVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTemplateVersionsInput(awsAccountId: \(String(describing: awsAccountId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), templateId: \(String(describing: templateId)))"}
}

extension ListTemplateVersionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTemplateVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListTemplateVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTemplateVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTemplateVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTemplateVersionsInput>
    public typealias MOutput = OperationOutput<ListTemplateVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTemplateVersionsOutputError>
}

public struct ListTemplateVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTemplateVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTemplateVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTemplateVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "max-results".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTemplateVersionsInput>
    public typealias MOutput = OperationOutput<ListTemplateVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTemplateVersionsOutputError>
}

public struct ListTemplateVersionsInput: Equatable {
    /// <p>The ID of the AWS account that contains the templates that you're listing.</p>
    public let awsAccountId: String?
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?
    /// <p>The ID for the template.</p>
    public let templateId: String?

    public init (
        awsAccountId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        templateId: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.templateId = templateId
    }
}

struct ListTemplateVersionsInputBody: Equatable {
}

extension ListTemplateVersionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTemplateVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTemplateVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTemplateVersionsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTemplateVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTemplateVersionsOutputResponse(nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)), status: \(String(describing: status)), templateVersionSummaryList: \(String(describing: templateVersionSummaryList)))"}
}

extension ListTemplateVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTemplateVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.requestId = output.requestId
            self.templateVersionSummaryList = output.templateVersionSummaryList
        } else {
            self.nextToken = nil
            self.requestId = nil
            self.templateVersionSummaryList = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListTemplateVersionsOutputResponse: Equatable {
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>A structure containing a list of all the versions of the specified template.</p>
    public let templateVersionSummaryList: [TemplateVersionSummary]?

    public init (
        nextToken: String? = nil,
        requestId: String? = nil,
        status: Int = 0,
        templateVersionSummaryList: [TemplateVersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
        self.templateVersionSummaryList = templateVersionSummaryList
    }
}

struct ListTemplateVersionsOutputResponseBody: Equatable {
    public let templateVersionSummaryList: [TemplateVersionSummary]?
    public let nextToken: String?
    public let status: Int
    public let requestId: String?
}

extension ListTemplateVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
        case templateVersionSummaryList = "TemplateVersionSummaryList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateVersionSummaryListContainer = try containerValues.decodeIfPresent([TemplateVersionSummary?].self, forKey: .templateVersionSummaryList)
        var templateVersionSummaryListDecoded0:[TemplateVersionSummary]? = nil
        if let templateVersionSummaryListContainer = templateVersionSummaryListContainer {
            templateVersionSummaryListDecoded0 = [TemplateVersionSummary]()
            for structure0 in templateVersionSummaryListContainer {
                if let structure0 = structure0 {
                    templateVersionSummaryListDecoded0?.append(structure0)
                }
            }
        }
        templateVersionSummaryList = templateVersionSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ListTemplatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTemplatesInput(awsAccountId: \(String(describing: awsAccountId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListTemplatesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTemplatesInputHeadersMiddleware: Middleware {
    public let id: String = "ListTemplatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTemplatesInput>
    public typealias MOutput = OperationOutput<ListTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTemplatesOutputError>
}

public struct ListTemplatesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTemplatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "max-result".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTemplatesInput>
    public typealias MOutput = OperationOutput<ListTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTemplatesOutputError>
}

public struct ListTemplatesInput: Equatable {
    /// <p>The ID of the AWS account that contains the templates that you're listing.</p>
    public let awsAccountId: String?
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?

    public init (
        awsAccountId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTemplatesInputBody: Equatable {
}

extension ListTemplatesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTemplatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTemplatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTemplatesOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTemplatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTemplatesOutputResponse(nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)), status: \(String(describing: status)), templateSummaryList: \(String(describing: templateSummaryList)))"}
}

extension ListTemplatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.requestId = output.requestId
            self.templateSummaryList = output.templateSummaryList
        } else {
            self.nextToken = nil
            self.requestId = nil
            self.templateSummaryList = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListTemplatesOutputResponse: Equatable {
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>A structure containing information about the templates in the list.</p>
    public let templateSummaryList: [TemplateSummary]?

    public init (
        nextToken: String? = nil,
        requestId: String? = nil,
        status: Int = 0,
        templateSummaryList: [TemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
        self.templateSummaryList = templateSummaryList
    }
}

struct ListTemplatesOutputResponseBody: Equatable {
    public let templateSummaryList: [TemplateSummary]?
    public let nextToken: String?
    public let status: Int
    public let requestId: String?
}

extension ListTemplatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
        case templateSummaryList = "TemplateSummaryList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateSummaryListContainer = try containerValues.decodeIfPresent([TemplateSummary?].self, forKey: .templateSummaryList)
        var templateSummaryListDecoded0:[TemplateSummary]? = nil
        if let templateSummaryListContainer = templateSummaryListContainer {
            templateSummaryListDecoded0 = [TemplateSummary]()
            for structure0 in templateSummaryListContainer {
                if let structure0 = structure0 {
                    templateSummaryListDecoded0?.append(structure0)
                }
            }
        }
        templateSummaryList = templateSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ListThemeAliasesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListThemeAliasesInput(awsAccountId: \(String(describing: awsAccountId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), themeId: \(String(describing: themeId)))"}
}

extension ListThemeAliasesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListThemeAliasesInputHeadersMiddleware: Middleware {
    public let id: String = "ListThemeAliasesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListThemeAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListThemeAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListThemeAliasesInput>
    public typealias MOutput = OperationOutput<ListThemeAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListThemeAliasesOutputError>
}

public struct ListThemeAliasesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListThemeAliasesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListThemeAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListThemeAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "max-result".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListThemeAliasesInput>
    public typealias MOutput = OperationOutput<ListThemeAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListThemeAliasesOutputError>
}

public struct ListThemeAliasesInput: Equatable {
    /// <p>The ID of the AWS account that contains the theme aliases that you're listing.</p>
    public let awsAccountId: String?
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?
    /// <p>The ID for the theme.</p>
    public let themeId: String?

    public init (
        awsAccountId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        themeId: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.themeId = themeId
    }
}

struct ListThemeAliasesInputBody: Equatable {
}

extension ListThemeAliasesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListThemeAliasesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListThemeAliasesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListThemeAliasesOutputError: Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListThemeAliasesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListThemeAliasesOutputResponse(nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)), status: \(String(describing: status)), themeAliasList: \(String(describing: themeAliasList)))"}
}

extension ListThemeAliasesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListThemeAliasesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.requestId = output.requestId
            self.themeAliasList = output.themeAliasList
        } else {
            self.nextToken = nil
            self.requestId = nil
            self.themeAliasList = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListThemeAliasesOutputResponse: Equatable {
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>A structure containing the list of the theme's aliases.</p>
    public let themeAliasList: [ThemeAlias]?

    public init (
        nextToken: String? = nil,
        requestId: String? = nil,
        status: Int = 0,
        themeAliasList: [ThemeAlias]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
        self.themeAliasList = themeAliasList
    }
}

struct ListThemeAliasesOutputResponseBody: Equatable {
    public let themeAliasList: [ThemeAlias]?
    public let status: Int
    public let requestId: String?
    public let nextToken: String?
}

extension ListThemeAliasesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
        case themeAliasList = "ThemeAliasList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeAliasListContainer = try containerValues.decodeIfPresent([ThemeAlias?].self, forKey: .themeAliasList)
        var themeAliasListDecoded0:[ThemeAlias]? = nil
        if let themeAliasListContainer = themeAliasListContainer {
            themeAliasListDecoded0 = [ThemeAlias]()
            for structure0 in themeAliasListContainer {
                if let structure0 = structure0 {
                    themeAliasListDecoded0?.append(structure0)
                }
            }
        }
        themeAliasList = themeAliasListDecoded0
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListThemeVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListThemeVersionsInput(awsAccountId: \(String(describing: awsAccountId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), themeId: \(String(describing: themeId)))"}
}

extension ListThemeVersionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListThemeVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListThemeVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListThemeVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListThemeVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListThemeVersionsInput>
    public typealias MOutput = OperationOutput<ListThemeVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListThemeVersionsOutputError>
}

public struct ListThemeVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListThemeVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListThemeVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListThemeVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "max-results".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListThemeVersionsInput>
    public typealias MOutput = OperationOutput<ListThemeVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListThemeVersionsOutputError>
}

public struct ListThemeVersionsInput: Equatable {
    /// <p>The ID of the AWS account that contains the themes that you're listing.</p>
    public let awsAccountId: String?
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?
    /// <p>The ID for the theme.</p>
    public let themeId: String?

    public init (
        awsAccountId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        themeId: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.themeId = themeId
    }
}

struct ListThemeVersionsInputBody: Equatable {
}

extension ListThemeVersionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListThemeVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListThemeVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListThemeVersionsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListThemeVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListThemeVersionsOutputResponse(nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)), status: \(String(describing: status)), themeVersionSummaryList: \(String(describing: themeVersionSummaryList)))"}
}

extension ListThemeVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListThemeVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.requestId = output.requestId
            self.themeVersionSummaryList = output.themeVersionSummaryList
        } else {
            self.nextToken = nil
            self.requestId = nil
            self.themeVersionSummaryList = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListThemeVersionsOutputResponse: Equatable {
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>A structure containing a list of all the versions of the specified theme.</p>
    public let themeVersionSummaryList: [ThemeVersionSummary]?

    public init (
        nextToken: String? = nil,
        requestId: String? = nil,
        status: Int = 0,
        themeVersionSummaryList: [ThemeVersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
        self.themeVersionSummaryList = themeVersionSummaryList
    }
}

struct ListThemeVersionsOutputResponseBody: Equatable {
    public let themeVersionSummaryList: [ThemeVersionSummary]?
    public let nextToken: String?
    public let status: Int
    public let requestId: String?
}

extension ListThemeVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
        case themeVersionSummaryList = "ThemeVersionSummaryList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeVersionSummaryListContainer = try containerValues.decodeIfPresent([ThemeVersionSummary?].self, forKey: .themeVersionSummaryList)
        var themeVersionSummaryListDecoded0:[ThemeVersionSummary]? = nil
        if let themeVersionSummaryListContainer = themeVersionSummaryListContainer {
            themeVersionSummaryListDecoded0 = [ThemeVersionSummary]()
            for structure0 in themeVersionSummaryListContainer {
                if let structure0 = structure0 {
                    themeVersionSummaryListDecoded0?.append(structure0)
                }
            }
        }
        themeVersionSummaryList = themeVersionSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ListThemesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListThemesInput(awsAccountId: \(String(describing: awsAccountId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), type: \(String(describing: type)))"}
}

extension ListThemesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListThemesInputHeadersMiddleware: Middleware {
    public let id: String = "ListThemesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListThemesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListThemesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListThemesInput>
    public typealias MOutput = OperationOutput<ListThemesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListThemesOutputError>
}

public struct ListThemesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListThemesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListThemesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListThemesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let type = input.operationInput.type {
            let typeQueryItem = URLQueryItem(name: "type".urlPercentEncoding(), value: String(type.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(typeQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "max-results".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListThemesInput>
    public typealias MOutput = OperationOutput<ListThemesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListThemesOutputError>
}

public struct ListThemesInput: Equatable {
    /// <p>The ID of the AWS account that contains the themes that you're listing.</p>
    public let awsAccountId: String?
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?
    /// <p>The type of themes that you want to list. Valid options include the following:</p>
    ///     	    <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ALL (default)</code>- Display all existing themes.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CUSTOM</code> - Display only the themes created by people using Amazon QuickSight.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>QUICKSIGHT</code> - Display only the starting themes defined by QuickSight.</p>
    ///             </li>
    ///          </ul>
    public let type: ThemeType?

    public init (
        awsAccountId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        type: ThemeType? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
    }
}

struct ListThemesInputBody: Equatable {
}

extension ListThemesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListThemesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListThemesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListThemesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListThemesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListThemesOutputResponse(nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)), status: \(String(describing: status)), themeSummaryList: \(String(describing: themeSummaryList)))"}
}

extension ListThemesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListThemesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.requestId = output.requestId
            self.themeSummaryList = output.themeSummaryList
        } else {
            self.nextToken = nil
            self.requestId = nil
            self.themeSummaryList = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListThemesOutputResponse: Equatable {
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>Information about the themes in the list.</p>
    public let themeSummaryList: [ThemeSummary]?

    public init (
        nextToken: String? = nil,
        requestId: String? = nil,
        status: Int = 0,
        themeSummaryList: [ThemeSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
        self.themeSummaryList = themeSummaryList
    }
}

struct ListThemesOutputResponseBody: Equatable {
    public let themeSummaryList: [ThemeSummary]?
    public let nextToken: String?
    public let status: Int
    public let requestId: String?
}

extension ListThemesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
        case themeSummaryList = "ThemeSummaryList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeSummaryListContainer = try containerValues.decodeIfPresent([ThemeSummary?].self, forKey: .themeSummaryList)
        var themeSummaryListDecoded0:[ThemeSummary]? = nil
        if let themeSummaryListContainer = themeSummaryListContainer {
            themeSummaryListDecoded0 = [ThemeSummary]()
            for structure0 in themeSummaryListContainer {
                if let structure0 = structure0 {
                    themeSummaryListDecoded0?.append(structure0)
                }
            }
        }
        themeSummaryList = themeSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ListUserGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUserGroupsInput(awsAccountId: \(String(describing: awsAccountId)), maxResults: \(String(describing: maxResults)), namespace: \(String(describing: namespace)), nextToken: \(String(describing: nextToken)), userName: \(String(describing: userName)))"}
}

extension ListUserGroupsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListUserGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ListUserGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUserGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUserGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUserGroupsInput>
    public typealias MOutput = OperationOutput<ListUserGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUserGroupsOutputError>
}

public struct ListUserGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListUserGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUserGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUserGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "max-results".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUserGroupsInput>
    public typealias MOutput = OperationOutput<ListUserGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUserGroupsOutputError>
}

public struct ListUserGroupsInput: Equatable {
    /// <p>The AWS account ID that the user is in. Currently, you use the ID for the AWS account
    /// 			that contains your Amazon QuickSight account.</p>
    public let awsAccountId: String?
    /// <p>The maximum number of results to return from this request.</p>
    public let maxResults: Int
    /// <p>The namespace. Currently, you should set this to <code>default</code>.</p>
    public let namespace: String?
    /// <p>A pagination token that can be used in a subsequent request.</p>
    public let nextToken: String?
    /// <p>The Amazon QuickSight user name that you want to list group memberships for.</p>
    public let userName: String?

    public init (
        awsAccountId: String? = nil,
        maxResults: Int = 0,
        namespace: String? = nil,
        nextToken: String? = nil,
        userName: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
        self.userName = userName
    }
}

struct ListUserGroupsInputBody: Equatable {
}

extension ListUserGroupsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListUserGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUserGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUserGroupsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUserGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUserGroupsOutputResponse(groupList: \(String(describing: groupList)), nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension ListUserGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListUserGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.groupList = output.groupList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.groupList = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListUserGroupsOutputResponse: Equatable {
    /// <p>The list of groups the user is a member of.</p>
    public let groupList: [Group]?
    /// <p>A pagination token that can be used in a subsequent request.</p>
    public let nextToken: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        groupList: [Group]? = nil,
        nextToken: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.groupList = groupList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListUserGroupsOutputResponseBody: Equatable {
    public let groupList: [Group]?
    public let nextToken: String?
    public let requestId: String?
    public let status: Int
}

extension ListUserGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupList = "GroupList"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupListContainer = try containerValues.decodeIfPresent([Group?].self, forKey: .groupList)
        var groupListDecoded0:[Group]? = nil
        if let groupListContainer = groupListContainer {
            groupListDecoded0 = [Group]()
            for structure0 in groupListContainer {
                if let structure0 = structure0 {
                    groupListDecoded0?.append(structure0)
                }
            }
        }
        groupList = groupListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension ListUsersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUsersInput(awsAccountId: \(String(describing: awsAccountId)), maxResults: \(String(describing: maxResults)), namespace: \(String(describing: namespace)), nextToken: \(String(describing: nextToken)))"}
}

extension ListUsersInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListUsersInputHeadersMiddleware: Middleware {
    public let id: String = "ListUsersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUsersInput>
    public typealias MOutput = OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUsersOutputError>
}

public struct ListUsersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListUsersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "max-results".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUsersInput>
    public typealias MOutput = OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUsersOutputError>
}

public struct ListUsersInput: Equatable {
    /// <p>The ID for the AWS account that the user is in. Currently, you use the ID for the AWS
    /// 			account that contains your Amazon QuickSight account.</p>
    public let awsAccountId: String?
    /// <p>The maximum number of results to return from this request.</p>
    public let maxResults: Int
    /// <p>The namespace. Currently, you should set this to <code>default</code>.</p>
    public let namespace: String?
    /// <p>A pagination token that can be used in a subsequent request.</p>
    public let nextToken: String?

    public init (
        awsAccountId: String? = nil,
        maxResults: Int = 0,
        namespace: String? = nil,
        nextToken: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
    }
}

struct ListUsersInputBody: Equatable {
}

extension ListUsersInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListUsersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUsersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUsersOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUsersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUsersOutputResponse(nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)), status: \(String(describing: status)), userList: \(String(describing: userList)))"}
}

extension ListUsersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListUsersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.requestId = output.requestId
            self.userList = output.userList
        } else {
            self.nextToken = nil
            self.requestId = nil
            self.userList = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListUsersOutputResponse: Equatable {
    /// <p>A pagination token that can be used in a subsequent request.</p>
    public let nextToken: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>The list of users.</p>
    public let userList: [User]?

    public init (
        nextToken: String? = nil,
        requestId: String? = nil,
        status: Int = 0,
        userList: [User]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
        self.userList = userList
    }
}

struct ListUsersOutputResponseBody: Equatable {
    public let userList: [User]?
    public let nextToken: String?
    public let requestId: String?
    public let status: Int
}

extension ListUsersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
        case userList = "UserList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userListContainer = try containerValues.decodeIfPresent([User?].self, forKey: .userList)
        var userListDecoded0:[User]? = nil
        if let userListContainer = userListContainer {
            userListDecoded0 = [User]()
            for structure0 in userListContainer {
                if let structure0 = structure0 {
                    userListDecoded0?.append(structure0)
                }
            }
        }
        userList = userListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension LogicalTable: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alias = "Alias"
        case dataTransforms = "DataTransforms"
        case source = "Source"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let dataTransforms = dataTransforms {
            var dataTransformsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataTransforms)
            for transformoperationlist0 in dataTransforms {
                try dataTransformsContainer.encode(transformoperationlist0)
            }
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alias)
        alias = aliasDecoded
        let dataTransformsContainer = try containerValues.decodeIfPresent([TransformOperation?].self, forKey: .dataTransforms)
        var dataTransformsDecoded0:[TransformOperation]? = nil
        if let dataTransformsContainer = dataTransformsContainer {
            dataTransformsDecoded0 = [TransformOperation]()
            for union0 in dataTransformsContainer {
                if let union0 = union0 {
                    dataTransformsDecoded0?.append(union0)
                }
            }
        }
        dataTransforms = dataTransformsDecoded0
        let sourceDecoded = try containerValues.decodeIfPresent(LogicalTableSource.self, forKey: .source)
        source = sourceDecoded
    }
}

extension LogicalTable: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LogicalTable(alias: \(String(describing: alias)), dataTransforms: \(String(describing: dataTransforms)), source: \(String(describing: source)))"}
}

/// <p>A <i>logical table</i> is a unit that joins and that data
///             transformations operate on. A logical table has a source, which can be either a physical
///             table or result of a join. When a logical table points to a physical table, the logical
///             table acts as a mutable copy of that physical table through transform operations.</p>
public struct LogicalTable: Equatable {
    /// <p>A display name for the logical table.</p>
    public let alias: String?
    /// <p>Transform operations that act on this logical table.</p>
    public let dataTransforms: [TransformOperation]?
    /// <p>Source of this logical table.</p>
    public let source: LogicalTableSource?

    public init (
        alias: String? = nil,
        dataTransforms: [TransformOperation]? = nil,
        source: LogicalTableSource? = nil
    )
    {
        self.alias = alias
        self.dataTransforms = dataTransforms
        self.source = source
    }
}

extension LogicalTableSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case joinInstruction = "JoinInstruction"
        case physicalTableId = "PhysicalTableId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let joinInstruction = joinInstruction {
            try encodeContainer.encode(joinInstruction, forKey: .joinInstruction)
        }
        if let physicalTableId = physicalTableId {
            try encodeContainer.encode(physicalTableId, forKey: .physicalTableId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let joinInstructionDecoded = try containerValues.decodeIfPresent(JoinInstruction.self, forKey: .joinInstruction)
        joinInstruction = joinInstructionDecoded
        let physicalTableIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .physicalTableId)
        physicalTableId = physicalTableIdDecoded
    }
}

extension LogicalTableSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LogicalTableSource(joinInstruction: \(String(describing: joinInstruction)), physicalTableId: \(String(describing: physicalTableId)))"}
}

/// <p>Information about the source of a logical table. This is a variant type structure. For
///             this structure to be valid, only one of the attributes can be non-null.</p>
public struct LogicalTableSource: Equatable {
    /// <p>Specifies the result of a join of two logical tables.</p>
    public let joinInstruction: JoinInstruction?
    /// <p>Physical table ID.</p>
    public let physicalTableId: String?

    public init (
        joinInstruction: JoinInstruction? = nil,
        physicalTableId: String? = nil
    )
    {
        self.joinInstruction = joinInstruction
        self.physicalTableId = physicalTableId
    }
}

extension ManifestFileLocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case key = "Key"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
    }
}

extension ManifestFileLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ManifestFileLocation(bucket: \(String(describing: bucket)), key: \(String(describing: key)))"}
}

/// <p>Amazon S3 manifest file location.</p>
public struct ManifestFileLocation: Equatable {
    /// <p>Amazon S3 bucket.</p>
    public let bucket: String?
    /// <p>Amazon S3 key that identifies an object.</p>
    public let key: String?

    public init (
        bucket: String? = nil,
        key: String? = nil
    )
    {
        self.bucket = bucket
        self.key = key
    }
}

extension MarginStyle: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case show = "Show"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if show != false {
            try encodeContainer.encode(show, forKey: .show)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let showDecoded = try containerValues.decode(Bool.self, forKey: .show)
        show = showDecoded
    }
}

extension MarginStyle: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MarginStyle(show: \(String(describing: show)))"}
}

/// <p>The display options for margins around the outside edge of sheets.</p>
public struct MarginStyle: Equatable {
    /// <p>This Boolean value controls whether to display sheet margins.</p>
    public let show: Bool

    public init (
        show: Bool = false
    )
    {
        self.show = show
    }
}

extension MariaDbParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case database = "Database"
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let host = host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .database)
        database = databaseDecoded
    }
}

extension MariaDbParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MariaDbParameters(database: \(String(describing: database)), host: \(String(describing: host)), port: \(String(describing: port)))"}
}

/// <p>MariaDB parameters.</p>
public struct MariaDbParameters: Equatable {
    /// <p>Database.</p>
    public let database: String?
    /// <p>Host.</p>
    public let host: String?
    /// <p>Port.</p>
    public let port: Int

    public init (
        database: String? = nil,
        host: String? = nil,
        port: Int = 0
    )
    {
        self.database = database
        self.host = host
        self.port = port
    }
}

extension MySqlParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case database = "Database"
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let host = host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .database)
        database = databaseDecoded
    }
}

extension MySqlParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MySqlParameters(database: \(String(describing: database)), host: \(String(describing: host)), port: \(String(describing: port)))"}
}

/// <p>MySQL parameters.</p>
public struct MySqlParameters: Equatable {
    /// <p>Database.</p>
    public let database: String?
    /// <p>Host.</p>
    public let host: String?
    /// <p>Port.</p>
    public let port: Int

    public init (
        database: String? = nil,
        host: String? = nil,
        port: Int = 0
    )
    {
        self.database = database
        self.host = host
        self.port = port
    }
}

extension NamespaceError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(NamespaceErrorType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NamespaceError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NamespaceError(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

/// <p>Errors that occur during namespace creation.</p>
public struct NamespaceError: Equatable {
    /// <p>The message for the error.</p>
    public let message: String?
    /// <p>The error type.</p>
    public let type: NamespaceErrorType?

    public init (
        message: String? = nil,
        type: NamespaceErrorType? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

public enum NamespaceErrorType {
    case internalServiceError
    case permissionDenied
    case sdkUnknown(String)
}

extension NamespaceErrorType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [NamespaceErrorType] {
        return [
            .internalServiceError,
            .permissionDenied,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .internalServiceError: return "INTERNAL_SERVICE_ERROR"
        case .permissionDenied: return "PERMISSION_DENIED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = NamespaceErrorType(rawValue: rawValue) ?? NamespaceErrorType.sdkUnknown(rawValue)
    }
}

extension NamespaceInfoV2: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case capacityRegion = "CapacityRegion"
        case creationStatus = "CreationStatus"
        case identityStore = "IdentityStore"
        case name = "Name"
        case namespaceError = "NamespaceError"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let capacityRegion = capacityRegion {
            try encodeContainer.encode(capacityRegion, forKey: .capacityRegion)
        }
        if let creationStatus = creationStatus {
            try encodeContainer.encode(creationStatus.rawValue, forKey: .creationStatus)
        }
        if let identityStore = identityStore {
            try encodeContainer.encode(identityStore.rawValue, forKey: .identityStore)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namespaceError = namespaceError {
            try encodeContainer.encode(namespaceError, forKey: .namespaceError)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let capacityRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .capacityRegion)
        capacityRegion = capacityRegionDecoded
        let creationStatusDecoded = try containerValues.decodeIfPresent(NamespaceStatus.self, forKey: .creationStatus)
        creationStatus = creationStatusDecoded
        let identityStoreDecoded = try containerValues.decodeIfPresent(IdentityStore.self, forKey: .identityStore)
        identityStore = identityStoreDecoded
        let namespaceErrorDecoded = try containerValues.decodeIfPresent(NamespaceError.self, forKey: .namespaceError)
        namespaceError = namespaceErrorDecoded
    }
}

extension NamespaceInfoV2: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NamespaceInfoV2(arn: \(String(describing: arn)), capacityRegion: \(String(describing: capacityRegion)), creationStatus: \(String(describing: creationStatus)), identityStore: \(String(describing: identityStore)), name: \(String(describing: name)), namespaceError: \(String(describing: namespaceError)))"}
}

/// <p>The error type.</p>
public struct NamespaceInfoV2: Equatable {
    /// <p>The namespace ARN.</p>
    public let arn: String?
    /// <p>The namespace AWS Region.</p>
    public let capacityRegion: String?
    /// <p>The creation status of a namespace that is not yet completely created.</p>
    public let creationStatus: NamespaceStatus?
    /// <p>The identity store used for the namespace.</p>
    public let identityStore: IdentityStore?
    /// <p>The name of the error.</p>
    public let name: String?
    /// <p>An error that occurred when the namespace was created.</p>
    public let namespaceError: NamespaceError?

    public init (
        arn: String? = nil,
        capacityRegion: String? = nil,
        creationStatus: NamespaceStatus? = nil,
        identityStore: IdentityStore? = nil,
        name: String? = nil,
        namespaceError: NamespaceError? = nil
    )
    {
        self.arn = arn
        self.capacityRegion = capacityRegion
        self.creationStatus = creationStatus
        self.identityStore = identityStore
        self.name = name
        self.namespaceError = namespaceError
    }
}

public enum NamespaceStatus {
    case created
    case creating
    case deleting
    case nonRetryableFailure
    case retryableFailure
    case sdkUnknown(String)
}

extension NamespaceStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [NamespaceStatus] {
        return [
            .created,
            .creating,
            .deleting,
            .nonRetryableFailure,
            .retryableFailure,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .created: return "CREATED"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case .nonRetryableFailure: return "NON_RETRYABLE_FAILURE"
        case .retryableFailure: return "RETRYABLE_FAILURE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = NamespaceStatus(rawValue: rawValue) ?? NamespaceStatus.sdkUnknown(rawValue)
    }
}

extension OracleParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case database = "Database"
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let host = host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .database)
        database = databaseDecoded
    }
}

extension OracleParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OracleParameters(database: \(String(describing: database)), host: \(String(describing: host)), port: \(String(describing: port)))"}
}

/// <p>Oracle parameters.</p>
public struct OracleParameters: Equatable {
    /// <p>Database.</p>
    public let database: String?
    /// <p>An Oracle host.</p>
    public let host: String?
    /// <p>Port.</p>
    public let port: Int

    public init (
        database: String? = nil,
        host: String? = nil,
        port: Int = 0
    )
    {
        self.database = database
        self.host = host
        self.port = port
    }
}

extension OutputColumn: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ColumnDataType.self, forKey: .type)
        type = typeDecoded
    }
}

extension OutputColumn: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OutputColumn(description: \(String(describing: description)), name: \(String(describing: name)), type: \(String(describing: type)))"}
}

/// <p>Output column.</p>
public struct OutputColumn: Equatable {
    /// <p>A description for a column.</p>
    public let description: String?
    /// <p>A display name for the dataset.</p>
    public let name: String?
    /// <p>Type.</p>
    public let type: ColumnDataType?

    public init (
        description: String? = nil,
        name: String? = nil,
        type: ColumnDataType? = nil
    )
    {
        self.description = description
        self.name = name
        self.type = type
    }
}

extension Parameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dateTimeParameters = "DateTimeParameters"
        case decimalParameters = "DecimalParameters"
        case integerParameters = "IntegerParameters"
        case stringParameters = "StringParameters"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateTimeParameters = dateTimeParameters {
            var dateTimeParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dateTimeParameters)
            for datetimeparameterlist0 in dateTimeParameters {
                try dateTimeParametersContainer.encode(datetimeparameterlist0)
            }
        }
        if let decimalParameters = decimalParameters {
            var decimalParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .decimalParameters)
            for decimalparameterlist0 in decimalParameters {
                try decimalParametersContainer.encode(decimalparameterlist0)
            }
        }
        if let integerParameters = integerParameters {
            var integerParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .integerParameters)
            for integerparameterlist0 in integerParameters {
                try integerParametersContainer.encode(integerparameterlist0)
            }
        }
        if let stringParameters = stringParameters {
            var stringParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stringParameters)
            for stringparameterlist0 in stringParameters {
                try stringParametersContainer.encode(stringparameterlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stringParametersContainer = try containerValues.decodeIfPresent([StringParameter?].self, forKey: .stringParameters)
        var stringParametersDecoded0:[StringParameter]? = nil
        if let stringParametersContainer = stringParametersContainer {
            stringParametersDecoded0 = [StringParameter]()
            for structure0 in stringParametersContainer {
                if let structure0 = structure0 {
                    stringParametersDecoded0?.append(structure0)
                }
            }
        }
        stringParameters = stringParametersDecoded0
        let integerParametersContainer = try containerValues.decodeIfPresent([IntegerParameter?].self, forKey: .integerParameters)
        var integerParametersDecoded0:[IntegerParameter]? = nil
        if let integerParametersContainer = integerParametersContainer {
            integerParametersDecoded0 = [IntegerParameter]()
            for structure0 in integerParametersContainer {
                if let structure0 = structure0 {
                    integerParametersDecoded0?.append(structure0)
                }
            }
        }
        integerParameters = integerParametersDecoded0
        let decimalParametersContainer = try containerValues.decodeIfPresent([DecimalParameter?].self, forKey: .decimalParameters)
        var decimalParametersDecoded0:[DecimalParameter]? = nil
        if let decimalParametersContainer = decimalParametersContainer {
            decimalParametersDecoded0 = [DecimalParameter]()
            for structure0 in decimalParametersContainer {
                if let structure0 = structure0 {
                    decimalParametersDecoded0?.append(structure0)
                }
            }
        }
        decimalParameters = decimalParametersDecoded0
        let dateTimeParametersContainer = try containerValues.decodeIfPresent([DateTimeParameter?].self, forKey: .dateTimeParameters)
        var dateTimeParametersDecoded0:[DateTimeParameter]? = nil
        if let dateTimeParametersContainer = dateTimeParametersContainer {
            dateTimeParametersDecoded0 = [DateTimeParameter]()
            for structure0 in dateTimeParametersContainer {
                if let structure0 = structure0 {
                    dateTimeParametersDecoded0?.append(structure0)
                }
            }
        }
        dateTimeParameters = dateTimeParametersDecoded0
    }
}

extension Parameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Parameters(dateTimeParameters: \(String(describing: dateTimeParameters)), decimalParameters: \(String(describing: decimalParameters)), integerParameters: \(String(describing: integerParameters)), stringParameters: \(String(describing: stringParameters)))"}
}

/// <p>A list of QuickSight parameters and the list's override values.</p>
public struct Parameters: Equatable {
    /// <p>Date-time parameters.</p>
    public let dateTimeParameters: [DateTimeParameter]?
    /// <p>Decimal parameters.</p>
    public let decimalParameters: [DecimalParameter]?
    /// <p>Integer parameters.</p>
    public let integerParameters: [IntegerParameter]?
    /// <p>String parameters.</p>
    public let stringParameters: [StringParameter]?

    public init (
        dateTimeParameters: [DateTimeParameter]? = nil,
        decimalParameters: [DecimalParameter]? = nil,
        integerParameters: [IntegerParameter]? = nil,
        stringParameters: [StringParameter]? = nil
    )
    {
        self.dateTimeParameters = dateTimeParameters
        self.decimalParameters = decimalParameters
        self.integerParameters = integerParameters
        self.stringParameters = stringParameters
    }
}

extension PhysicalTable: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customSql = "CustomSql"
        case relationalTable = "RelationalTable"
        case s3Source = "S3Source"
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .customSql(customSql):
                if let customSql = customSql {
                    try container.encode(customSql, forKey: .customSql)
                }
            case let .relationalTable(relationalTable):
                if let relationalTable = relationalTable {
                    try container.encode(relationalTable, forKey: .relationalTable)
                }
            case let .s3Source(s3Source):
                if let s3Source = s3Source {
                    try container.encode(s3Source, forKey: .s3Source)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let relationalTableDecoded = try values.decodeIfPresent(RelationalTable.self, forKey: .relationalTable)
        if let relationalTable = relationalTableDecoded {
            self = .relationalTable(relationalTable)
            return
        }
        let customSqlDecoded = try values.decodeIfPresent(CustomSql.self, forKey: .customSql)
        if let customSql = customSqlDecoded {
            self = .customSql(customSql)
            return
        }
        let s3SourceDecoded = try values.decodeIfPresent(S3Source.self, forKey: .s3Source)
        if let s3Source = s3SourceDecoded {
            self = .s3Source(s3Source)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>A view of a data source that contains information about the shape of the data in the
///             underlying source. This is a variant type structure. For this structure to be valid,
///             only one of the attributes can be non-null.</p>
public enum PhysicalTable: Equatable {
    /// <p>A physical table type for relational data sources.</p>
    case relationalTable(RelationalTable?)
    /// <p>A physical table type built from the results of the custom SQL query.</p>
    case customSql(CustomSql?)
    /// <p>A physical table type for as S3 data source.</p>
    case s3Source(S3Source?)
    case sdkUnknown(String?)
}

extension PostgreSqlParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case database = "Database"
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let host = host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .database)
        database = databaseDecoded
    }
}

extension PostgreSqlParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PostgreSqlParameters(database: \(String(describing: database)), host: \(String(describing: host)), port: \(String(describing: port)))"}
}

/// <p>PostgreSQL parameters.</p>
public struct PostgreSqlParameters: Equatable {
    /// <p>Database.</p>
    public let database: String?
    /// <p>Host.</p>
    public let host: String?
    /// <p>Port.</p>
    public let port: Int

    public init (
        database: String? = nil,
        host: String? = nil,
        port: Int = 0
    )
    {
        self.database = database
        self.host = host
        self.port = port
    }
}

extension PreconditionNotMetException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PreconditionNotMetException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension PreconditionNotMetException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PreconditionNotMetExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more preconditions aren't met.</p>
public struct PreconditionNotMetException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The AWS request ID for this request.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct PreconditionNotMetExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension PreconditionNotMetExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension PrestoParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalog = "Catalog"
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalog = catalog {
            try encodeContainer.encode(catalog, forKey: .catalog)
        }
        if let host = host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let catalogDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalog)
        catalog = catalogDecoded
    }
}

extension PrestoParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PrestoParameters(catalog: \(String(describing: catalog)), host: \(String(describing: host)), port: \(String(describing: port)))"}
}

/// <p>Presto parameters.</p>
public struct PrestoParameters: Equatable {
    /// <p>Catalog.</p>
    public let catalog: String?
    /// <p>Host.</p>
    public let host: String?
    /// <p>Port.</p>
    public let port: Int

    public init (
        catalog: String? = nil,
        host: String? = nil,
        port: Int = 0
    )
    {
        self.catalog = catalog
        self.host = host
        self.port = port
    }
}

extension ProjectOperation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case projectedColumns = "ProjectedColumns"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectedColumns = projectedColumns {
            var projectedColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .projectedColumns)
            for projectedcolumnlist0 in projectedColumns {
                try projectedColumnsContainer.encode(projectedcolumnlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectedColumnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .projectedColumns)
        var projectedColumnsDecoded0:[String]? = nil
        if let projectedColumnsContainer = projectedColumnsContainer {
            projectedColumnsDecoded0 = [String]()
            for string0 in projectedColumnsContainer {
                if let string0 = string0 {
                    projectedColumnsDecoded0?.append(string0)
                }
            }
        }
        projectedColumns = projectedColumnsDecoded0
    }
}

extension ProjectOperation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProjectOperation(projectedColumns: \(String(describing: projectedColumns)))"}
}

/// <p>A transform operation that projects columns. Operations that come after a projection
///             can only refer to projected columns.</p>
public struct ProjectOperation: Equatable {
    /// <p>Projected columns.</p>
    public let projectedColumns: [String]?

    public init (
        projectedColumns: [String]? = nil
    )
    {
        self.projectedColumns = projectedColumns
    }
}

extension QueueInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case queuedIngestion = "QueuedIngestion"
        case waitingOnIngestion = "WaitingOnIngestion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queuedIngestion = queuedIngestion {
            try encodeContainer.encode(queuedIngestion, forKey: .queuedIngestion)
        }
        if let waitingOnIngestion = waitingOnIngestion {
            try encodeContainer.encode(waitingOnIngestion, forKey: .waitingOnIngestion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waitingOnIngestionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .waitingOnIngestion)
        waitingOnIngestion = waitingOnIngestionDecoded
        let queuedIngestionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queuedIngestion)
        queuedIngestion = queuedIngestionDecoded
    }
}

extension QueueInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueueInfo(queuedIngestion: \(String(describing: queuedIngestion)), waitingOnIngestion: \(String(describing: waitingOnIngestion)))"}
}

/// <p>Information about a queued dataset SPICE ingestion.</p>
public struct QueueInfo: Equatable {
    /// <p>The ID of the ongoing ingestion. The queued ingestion is waiting for the ongoing
    ///             ingestion to complete.</p>
    public let queuedIngestion: String?
    /// <p>The ID of the queued ingestion.</p>
    public let waitingOnIngestion: String?

    public init (
        queuedIngestion: String? = nil,
        waitingOnIngestion: String? = nil
    )
    {
        self.queuedIngestion = queuedIngestion
        self.waitingOnIngestion = waitingOnIngestion
    }
}

extension QuickSightUserNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QuickSightUserNotFoundException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension QuickSightUserNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: QuickSightUserNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The user with the provided name isn't found. This error can happen in any operation
/// 			that requires finding a user based on a provided user name, such as
/// 				<code>DeleteUser</code>, <code>DescribeUser</code>, and so on.</p>
public struct QuickSightUserNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The AWS request ID for this request.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct QuickSightUserNotFoundExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension QuickSightUserNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension RdsParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case database = "Database"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .database)
        database = databaseDecoded
    }
}

extension RdsParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RdsParameters(database: \(String(describing: database)), instanceId: \(String(describing: instanceId)))"}
}

/// <p>Amazon RDS parameters.</p>
public struct RdsParameters: Equatable {
    /// <p>Database.</p>
    public let database: String?
    /// <p>Instance ID.</p>
    public let instanceId: String?

    public init (
        database: String? = nil,
        instanceId: String? = nil
    )
    {
        self.database = database
        self.instanceId = instanceId
    }
}

extension RedshiftParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clusterId = "ClusterId"
        case database = "Database"
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterId = clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let host = host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .database)
        database = databaseDecoded
        let clusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
    }
}

extension RedshiftParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RedshiftParameters(clusterId: \(String(describing: clusterId)), database: \(String(describing: database)), host: \(String(describing: host)), port: \(String(describing: port)))"}
}

/// <p>Amazon Redshift parameters. The <code>ClusterId</code> field can be blank if
///             <code>Host</code> and <code>Port</code> are both set. The <code>Host</code> and
///             <code>Port</code> fields can be blank if the <code>ClusterId</code> field is set.</p>
public struct RedshiftParameters: Equatable {
    /// <p>Cluster ID. This field can be blank if the <code>Host</code> and <code>Port</code> are
    ///             provided.</p>
    public let clusterId: String?
    /// <p>Database.</p>
    public let database: String?
    /// <p>Host. This field can be blank if <code>ClusterId</code> is provided.</p>
    public let host: String?
    /// <p>Port. This field can be blank if the <code>ClusterId</code> is provided.</p>
    public let port: Int

    public init (
        clusterId: String? = nil,
        database: String? = nil,
        host: String? = nil,
        port: Int = 0
    )
    {
        self.clusterId = clusterId
        self.database = database
        self.host = host
        self.port = port
    }
}

public struct RegisterUserInputBodyMiddleware: Middleware {
    public let id: String = "RegisterUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterUserInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterUserInput>
    public typealias MOutput = OperationOutput<RegisterUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterUserOutputError>
}

extension RegisterUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterUserInput(awsAccountId: \(String(describing: awsAccountId)), customFederationProviderUrl: \(String(describing: customFederationProviderUrl)), customPermissionsName: \(String(describing: customPermissionsName)), email: \(String(describing: email)), externalLoginFederationProviderType: \(String(describing: externalLoginFederationProviderType)), externalLoginId: \(String(describing: externalLoginId)), iamArn: \(String(describing: iamArn)), identityType: \(String(describing: identityType)), namespace: \(String(describing: namespace)), sessionName: \(String(describing: sessionName)), userName: \(String(describing: userName)), userRole: \(String(describing: userRole)))"}
}

extension RegisterUserInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customFederationProviderUrl = "CustomFederationProviderUrl"
        case customPermissionsName = "CustomPermissionsName"
        case email = "Email"
        case externalLoginFederationProviderType = "ExternalLoginFederationProviderType"
        case externalLoginId = "ExternalLoginId"
        case iamArn = "IamArn"
        case identityType = "IdentityType"
        case sessionName = "SessionName"
        case userName = "UserName"
        case userRole = "UserRole"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customFederationProviderUrl = customFederationProviderUrl {
            try encodeContainer.encode(customFederationProviderUrl, forKey: .customFederationProviderUrl)
        }
        if let customPermissionsName = customPermissionsName {
            try encodeContainer.encode(customPermissionsName, forKey: .customPermissionsName)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let externalLoginFederationProviderType = externalLoginFederationProviderType {
            try encodeContainer.encode(externalLoginFederationProviderType, forKey: .externalLoginFederationProviderType)
        }
        if let externalLoginId = externalLoginId {
            try encodeContainer.encode(externalLoginId, forKey: .externalLoginId)
        }
        if let iamArn = iamArn {
            try encodeContainer.encode(iamArn, forKey: .iamArn)
        }
        if let identityType = identityType {
            try encodeContainer.encode(identityType.rawValue, forKey: .identityType)
        }
        if let sessionName = sessionName {
            try encodeContainer.encode(sessionName, forKey: .sessionName)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let userRole = userRole {
            try encodeContainer.encode(userRole.rawValue, forKey: .userRole)
        }
    }
}

public struct RegisterUserInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterUserInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterUserInput>
    public typealias MOutput = OperationOutput<RegisterUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterUserOutputError>
}

public struct RegisterUserInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterUserInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterUserInput>
    public typealias MOutput = OperationOutput<RegisterUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterUserOutputError>
}

public struct RegisterUserInput: Equatable {
    /// <p>The ID for the AWS account that the user is in. Currently, you use the ID for the AWS
    /// 			account that contains your Amazon QuickSight account.</p>
    public let awsAccountId: String?
    /// <p>The URL of the custom OpenID Connect (OIDC) provider that provides identity to let a user federate
    ///          into QuickSight with an associated AWS Identity and Access Management (IAM) role. This parameter should
    ///          only be used when <code>ExternalLoginFederationProviderType</code> parameter is set to <code>CUSTOM_OIDC</code>.</p>
    public let customFederationProviderUrl: String?
    /// <p>(Enterprise edition only) The name of the custom permissions profile that you want to
    ///             assign to this user. Customized permissions allows you to control a user's access by
    ///             restricting access the following operations:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Create and update data sources</p>
    ///             </li>
    ///             <li>
    ///                 <p>Create and update datasets</p>
    ///             </li>
    ///             <li>
    ///                 <p>Create and update email reports</p>
    ///             </li>
    ///             <li>
    ///                 <p>Subscribe to email reports</p>
    ///             </li>
    ///          </ul>
    ///         <p>To add custom permissions to an existing user, use <code>
    ///                <a>UpdateUser</a>
    ///             </code> instead.</p>
    ///         <p>A set of custom permissions includes any combination of these restrictions. Currently,
    ///             you need to create the profile names for custom permission sets by using the QuickSight
    ///             console. Then, you use the <code>RegisterUser</code> API operation to assign the named set of
    ///             permissions to a QuickSight user. </p>
    ///         <p>QuickSight custom permissions are applied through IAM policies. Therefore, they
    ///             override the permissions typically granted by assigning QuickSight users to one of the
    ///             default security cohorts in QuickSight (admin, author, reader).</p>
    ///         <p>This feature is available only to QuickSight Enterprise edition subscriptions that use
    ///             SAML 2.0-Based Federation for Single Sign-On (SSO).</p>
    public let customPermissionsName: String?
    /// <p>The email address of the user that you want to register.</p>
    public let email: String?
    /// <p>The type of supported external login provider that provides identity to let a user federate into Amazon QuickSight with an associated AWS Identity and Access Management (IAM) role. The type of supported external login provider can be one of the following.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>COGNITO</code>: Amazon Cognito. The provider URL is cognito-identity.amazonaws.com. When choosing the <code>COGNITO</code> provider type, don’t use the "CustomFederationProviderUrl" parameter which is only needed when the external provider is custom.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CUSTOM_OIDC</code>: Custom OpenID Connect (OIDC) provider. When choosing <code>CUSTOM_OIDC</code> type, use the <code>CustomFederationProviderUrl</code> parameter to provide the custom OIDC provider URL.</p>
    ///             </li>
    ///          </ul>
    public let externalLoginFederationProviderType: String?
    /// <p>The identity ID for a user in the external login provider.</p>
    public let externalLoginId: String?
    /// <p>The ARN of the IAM user or role that you are registering with Amazon QuickSight. </p>
    public let iamArn: String?
    /// <p>Amazon QuickSight supports several ways of managing the identity of users. This
    /// 			parameter accepts two values:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>
    ///                   <code>IAM</code>: A user whose identity maps to an existing IAM user or role.
    /// 				</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>QUICKSIGHT</code>: A user whose identity is owned and managed internally by
    /// 					Amazon QuickSight. </p>
    /// 			         </li>
    ///          </ul>
    public let identityType: IdentityType?
    /// <p>The namespace. Currently, you should set this to <code>default</code>.</p>
    public let namespace: String?
    /// <p>You need to use this parameter only when you register one or more users using an assumed
    /// 			IAM role. You don't need to provide the session name for other scenarios, for example when
    /// 			you are registering an IAM user or an Amazon QuickSight user. You can register multiple
    /// 			users using the same IAM role if each user has a different session name. For more
    /// 			information on assuming IAM roles, see <a href="https://docs.aws.amazon.com/cli/latest/reference/sts/assume-role.html">
    ///                <code>assume-role</code>
    ///             </a> in the <i>AWS CLI Reference.</i>
    ///          </p>
    public let sessionName: String?
    /// <p>The Amazon QuickSight user name that you want to create for the user you are
    /// 			registering.</p>
    public let userName: String?
    /// <p>The Amazon QuickSight role for the user. The user role can be one of the
    /// 			following:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>
    ///                   <code>READER</code>: A user who has read-only access to dashboards.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>AUTHOR</code>: A user who can create data sources, datasets, analyses, and
    /// 					dashboards.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>ADMIN</code>: A user who is an author, who can also manage Amazon QuickSight
    /// 					settings.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>RESTRICTED_READER</code>: This role isn't currently available for
    /// 					use.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>RESTRICTED_AUTHOR</code>: This role isn't currently available for
    /// 					use.</p>
    /// 			         </li>
    ///          </ul>
    public let userRole: UserRole?

    public init (
        awsAccountId: String? = nil,
        customFederationProviderUrl: String? = nil,
        customPermissionsName: String? = nil,
        email: String? = nil,
        externalLoginFederationProviderType: String? = nil,
        externalLoginId: String? = nil,
        iamArn: String? = nil,
        identityType: IdentityType? = nil,
        namespace: String? = nil,
        sessionName: String? = nil,
        userName: String? = nil,
        userRole: UserRole? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.customFederationProviderUrl = customFederationProviderUrl
        self.customPermissionsName = customPermissionsName
        self.email = email
        self.externalLoginFederationProviderType = externalLoginFederationProviderType
        self.externalLoginId = externalLoginId
        self.iamArn = iamArn
        self.identityType = identityType
        self.namespace = namespace
        self.sessionName = sessionName
        self.userName = userName
        self.userRole = userRole
    }
}

struct RegisterUserInputBody: Equatable {
    public let identityType: IdentityType?
    public let email: String?
    public let userRole: UserRole?
    public let iamArn: String?
    public let sessionName: String?
    public let userName: String?
    public let customPermissionsName: String?
    public let externalLoginFederationProviderType: String?
    public let customFederationProviderUrl: String?
    public let externalLoginId: String?
}

extension RegisterUserInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customFederationProviderUrl = "CustomFederationProviderUrl"
        case customPermissionsName = "CustomPermissionsName"
        case email = "Email"
        case externalLoginFederationProviderType = "ExternalLoginFederationProviderType"
        case externalLoginId = "ExternalLoginId"
        case iamArn = "IamArn"
        case identityType = "IdentityType"
        case sessionName = "SessionName"
        case userName = "UserName"
        case userRole = "UserRole"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityTypeDecoded = try containerValues.decodeIfPresent(IdentityType.self, forKey: .identityType)
        identityType = identityTypeDecoded
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
        let userRoleDecoded = try containerValues.decodeIfPresent(UserRole.self, forKey: .userRole)
        userRole = userRoleDecoded
        let iamArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamArn)
        iamArn = iamArnDecoded
        let sessionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionName)
        sessionName = sessionNameDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let customPermissionsNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customPermissionsName)
        customPermissionsName = customPermissionsNameDecoded
        let externalLoginFederationProviderTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalLoginFederationProviderType)
        externalLoginFederationProviderType = externalLoginFederationProviderTypeDecoded
        let customFederationProviderUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customFederationProviderUrl)
        customFederationProviderUrl = customFederationProviderUrlDecoded
        let externalLoginIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalLoginId)
        externalLoginId = externalLoginIdDecoded
    }
}

extension RegisterUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterUserOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterUserOutputResponse(requestId: \(String(describing: requestId)), status: \(String(describing: status)), user: \(String(describing: user)), userInvitationUrl: \(String(describing: userInvitationUrl)))"}
}

extension RegisterUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegisterUserOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.requestId = output.requestId
            self.user = output.user
            self.userInvitationUrl = output.userInvitationUrl
        } else {
            self.requestId = nil
            self.user = nil
            self.userInvitationUrl = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct RegisterUserOutputResponse: Equatable {
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>The user's user name.</p>
    public let user: User?
    /// <p>The URL the user visits to complete registration and provide a password. This is
    /// 			returned only for users with an identity type of <code>QUICKSIGHT</code>.</p>
    public let userInvitationUrl: String?

    public init (
        requestId: String? = nil,
        status: Int = 0,
        user: User? = nil,
        userInvitationUrl: String? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.user = user
        self.userInvitationUrl = userInvitationUrl
    }
}

struct RegisterUserOutputResponseBody: Equatable {
    public let user: User?
    public let userInvitationUrl: String?
    public let requestId: String?
    public let status: Int
}

extension RegisterUserOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case user = "User"
        case userInvitationUrl = "UserInvitationUrl"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(User.self, forKey: .user)
        user = userDecoded
        let userInvitationUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userInvitationUrl)
        userInvitationUrl = userInvitationUrlDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension RelationalTable: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalog = "Catalog"
        case dataSourceArn = "DataSourceArn"
        case inputColumns = "InputColumns"
        case name = "Name"
        case schema = "Schema"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalog = catalog {
            try encodeContainer.encode(catalog, forKey: .catalog)
        }
        if let dataSourceArn = dataSourceArn {
            try encodeContainer.encode(dataSourceArn, forKey: .dataSourceArn)
        }
        if let inputColumns = inputColumns {
            var inputColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputColumns)
            for inputcolumnlist0 in inputColumns {
                try inputColumnsContainer.encode(inputcolumnlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSourceArn)
        dataSourceArn = dataSourceArnDecoded
        let catalogDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalog)
        catalog = catalogDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schema)
        schema = schemaDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let inputColumnsContainer = try containerValues.decodeIfPresent([InputColumn?].self, forKey: .inputColumns)
        var inputColumnsDecoded0:[InputColumn]? = nil
        if let inputColumnsContainer = inputColumnsContainer {
            inputColumnsDecoded0 = [InputColumn]()
            for structure0 in inputColumnsContainer {
                if let structure0 = structure0 {
                    inputColumnsDecoded0?.append(structure0)
                }
            }
        }
        inputColumns = inputColumnsDecoded0
    }
}

extension RelationalTable: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RelationalTable(catalog: \(String(describing: catalog)), dataSourceArn: \(String(describing: dataSourceArn)), inputColumns: \(String(describing: inputColumns)), name: \(String(describing: name)), schema: \(String(describing: schema)))"}
}

/// <p>A physical table type for relational data sources.</p>
public struct RelationalTable: Equatable {
    /// <p>The catalog associated with a table.</p>
    public let catalog: String?
    /// <p>The Amazon Resource Name (ARN) for the data source.</p>
    public let dataSourceArn: String?
    /// <p>The column schema of the table.</p>
    public let inputColumns: [InputColumn]?
    /// <p>The name of the relational table.</p>
    public let name: String?
    /// <p>The schema name. This name applies to certain relational database engines.</p>
    public let schema: String?

    public init (
        catalog: String? = nil,
        dataSourceArn: String? = nil,
        inputColumns: [InputColumn]? = nil,
        name: String? = nil,
        schema: String? = nil
    )
    {
        self.catalog = catalog
        self.dataSourceArn = dataSourceArn
        self.inputColumns = inputColumns
        self.name = name
        self.schema = schema
    }
}

extension RenameColumnOperation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case columnName = "ColumnName"
        case newColumnName = "NewColumnName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnName = columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
        if let newColumnName = newColumnName {
            try encodeContainer.encode(newColumnName, forKey: .newColumnName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .columnName)
        columnName = columnNameDecoded
        let newColumnNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .newColumnName)
        newColumnName = newColumnNameDecoded
    }
}

extension RenameColumnOperation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RenameColumnOperation(columnName: \(String(describing: columnName)), newColumnName: \(String(describing: newColumnName)))"}
}

/// <p>A transform operation that renames a column.</p>
public struct RenameColumnOperation: Equatable {
    /// <p>The name of the column to be renamed.</p>
    public let columnName: String?
    /// <p>The new name for the column.</p>
    public let newColumnName: String?

    public init (
        columnName: String? = nil,
        newColumnName: String? = nil
    )
    {
        self.columnName = columnName
        self.newColumnName = newColumnName
    }
}

extension ResourceExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceExistsException(message: \(String(describing: message)), requestId: \(String(describing: requestId)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourceExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.requestId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource specified already exists. </p>
public struct ResourceExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The AWS request ID for this request.</p>
    public var requestId: String?
    /// <p>The resource type for this request.</p>
    public var resourceType: ExceptionResourceType?

    public init (
        message: String? = nil,
        requestId: String? = nil,
        resourceType: ExceptionResourceType? = nil
    )
    {
        self.message = message
        self.requestId = requestId
        self.resourceType = resourceType
    }
}

struct ResourceExistsExceptionBody: Equatable {
    public let message: String?
    public let resourceType: ExceptionResourceType?
    public let requestId: String?
}

extension ResourceExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ExceptionResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)), requestId: \(String(describing: requestId)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.requestId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more resources can't be found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The AWS request ID for this request.</p>
    public var requestId: String?
    /// <p>The resource type for this request.</p>
    public var resourceType: ExceptionResourceType?

    public init (
        message: String? = nil,
        requestId: String? = nil,
        resourceType: ExceptionResourceType? = nil
    )
    {
        self.message = message
        self.requestId = requestId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
    public let resourceType: ExceptionResourceType?
    public let requestId: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ExceptionResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ResourcePermission: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions = "Actions"
        case principal = "Principal"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for actionlist0 in actions {
                try actionsContainer.encode(actionlist0)
            }
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principal)
        principal = principalDecoded
        let actionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .actions)
        var actionsDecoded0:[String]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [String]()
            for string0 in actionsContainer {
                if let string0 = string0 {
                    actionsDecoded0?.append(string0)
                }
            }
        }
        actions = actionsDecoded0
    }
}

extension ResourcePermission: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourcePermission(actions: \(String(describing: actions)), principal: \(String(describing: principal)))"}
}

/// <p>Permission for the resource.</p>
public struct ResourcePermission: Equatable {
    /// <p>The IAM action to grant or revoke permissions on.</p>
    public let actions: [String]?
    /// <p>The Amazon Resource Name (ARN) of the principal. This can be one of the
    ///             following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)</p>
    ///             </li>
    ///             <li>
    ///                 <p>The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)</p>
    ///             </li>
    ///             <li>
    ///                 <p>The ARN of an AWS account root: This is an IAM ARN rather than a QuickSight
    ///                     ARN. Use this option only to share resources (templates) across AWS accounts.
    ///                     (This is less common.) </p>
    ///             </li>
    ///          </ul>
    public let principal: String?

    public init (
        actions: [String]? = nil,
        principal: String? = nil
    )
    {
        self.actions = actions
        self.principal = principal
    }
}

public enum ResourceStatus {
    case creationFailed
    case creationInProgress
    case creationSuccessful
    case deleted
    case updateFailed
    case updateInProgress
    case updateSuccessful
    case sdkUnknown(String)
}

extension ResourceStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceStatus] {
        return [
            .creationFailed,
            .creationInProgress,
            .creationSuccessful,
            .deleted,
            .updateFailed,
            .updateInProgress,
            .updateSuccessful,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .creationFailed: return "CREATION_FAILED"
        case .creationInProgress: return "CREATION_IN_PROGRESS"
        case .creationSuccessful: return "CREATION_SUCCESSFUL"
        case .deleted: return "DELETED"
        case .updateFailed: return "UPDATE_FAILED"
        case .updateInProgress: return "UPDATE_IN_PROGRESS"
        case .updateSuccessful: return "UPDATE_SUCCESSFUL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceStatus(rawValue: rawValue) ?? ResourceStatus.sdkUnknown(rawValue)
    }
}

extension ResourceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceUnavailableException(message: \(String(describing: message)), requestId: \(String(describing: requestId)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.requestId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This resource is currently unavailable.</p>
public struct ResourceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?
    /// <p>The AWS request ID for this request.</p>
    public var requestId: String?
    /// <p>The resource type for this request.</p>
    public var resourceType: ExceptionResourceType?

    public init (
        message: String? = nil,
        requestId: String? = nil,
        resourceType: ExceptionResourceType? = nil
    )
    {
        self.message = message
        self.requestId = requestId
        self.resourceType = resourceType
    }
}

struct ResourceUnavailableExceptionBody: Equatable {
    public let message: String?
    public let resourceType: ExceptionResourceType?
    public let requestId: String?
}

extension ResourceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ExceptionResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension RestoreAnalysisInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreAnalysisInput(analysisId: \(String(describing: analysisId)), awsAccountId: \(String(describing: awsAccountId)))"}
}

extension RestoreAnalysisInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct RestoreAnalysisInputHeadersMiddleware: Middleware {
    public let id: String = "RestoreAnalysisInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreAnalysisInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreAnalysisInput>
    public typealias MOutput = OperationOutput<RestoreAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreAnalysisOutputError>
}

public struct RestoreAnalysisInputQueryItemMiddleware: Middleware {
    public let id: String = "RestoreAnalysisInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreAnalysisInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreAnalysisInput>
    public typealias MOutput = OperationOutput<RestoreAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreAnalysisOutputError>
}

public struct RestoreAnalysisInput: Equatable {
    /// <p>The ID of the analysis that you're restoring.</p>
    public let analysisId: String?
    /// <p>The ID of the AWS account that contains the analysis.</p>
    public let awsAccountId: String?

    public init (
        analysisId: String? = nil,
        awsAccountId: String? = nil
    )
    {
        self.analysisId = analysisId
        self.awsAccountId = awsAccountId
    }
}

struct RestoreAnalysisInputBody: Equatable {
}

extension RestoreAnalysisInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RestoreAnalysisOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RestoreAnalysisOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreAnalysisOutputError: Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreAnalysisOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreAnalysisOutputResponse(analysisId: \(String(describing: analysisId)), arn: \(String(describing: arn)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension RestoreAnalysisOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RestoreAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.analysisId = output.analysisId
            self.arn = output.arn
            self.requestId = output.requestId
        } else {
            self.analysisId = nil
            self.arn = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct RestoreAnalysisOutputResponse: Equatable {
    /// <p>The ID of the analysis that you're restoring.
    ///         </p>
    public let analysisId: String?
    /// <p>The Amazon Resource Name (ARN) of the analysis that you're restoring.</p>
    public let arn: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        analysisId: String? = nil,
        arn: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.analysisId = analysisId
        self.arn = arn
        self.requestId = requestId
        self.status = status
    }
}

struct RestoreAnalysisOutputResponseBody: Equatable {
    public let status: Int
    public let arn: String?
    public let analysisId: String?
    public let requestId: String?
}

extension RestoreAnalysisOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analysisId = "AnalysisId"
        case arn = "Arn"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let analysisIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .analysisId)
        analysisId = analysisIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension RowInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case rowsDropped = "RowsDropped"
        case rowsIngested = "RowsIngested"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if rowsDropped != 0 {
            try encodeContainer.encode(rowsDropped, forKey: .rowsDropped)
        }
        if rowsIngested != 0 {
            try encodeContainer.encode(rowsIngested, forKey: .rowsIngested)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowsIngestedDecoded = try containerValues.decode(Int.self, forKey: .rowsIngested)
        rowsIngested = rowsIngestedDecoded
        let rowsDroppedDecoded = try containerValues.decode(Int.self, forKey: .rowsDropped)
        rowsDropped = rowsDroppedDecoded
    }
}

extension RowInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RowInfo(rowsDropped: \(String(describing: rowsDropped)), rowsIngested: \(String(describing: rowsIngested)))"}
}

/// <p>Information about rows for a data set SPICE ingestion.</p>
public struct RowInfo: Equatable {
    /// <p>The number of rows that were not ingested.</p>
    public let rowsDropped: Int
    /// <p>The number of rows that were ingested.</p>
    public let rowsIngested: Int

    public init (
        rowsDropped: Int = 0,
        rowsIngested: Int = 0
    )
    {
        self.rowsDropped = rowsDropped
        self.rowsIngested = rowsIngested
    }
}

extension RowLevelPermissionDataSet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case formatVersion = "FormatVersion"
        case namespace = "Namespace"
        case permissionPolicy = "PermissionPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let formatVersion = formatVersion {
            try encodeContainer.encode(formatVersion.rawValue, forKey: .formatVersion)
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let permissionPolicy = permissionPolicy {
            try encodeContainer.encode(permissionPolicy.rawValue, forKey: .permissionPolicy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let permissionPolicyDecoded = try containerValues.decodeIfPresent(RowLevelPermissionPolicy.self, forKey: .permissionPolicy)
        permissionPolicy = permissionPolicyDecoded
        let formatVersionDecoded = try containerValues.decodeIfPresent(RowLevelPermissionFormatVersion.self, forKey: .formatVersion)
        formatVersion = formatVersionDecoded
    }
}

extension RowLevelPermissionDataSet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RowLevelPermissionDataSet(arn: \(String(describing: arn)), formatVersion: \(String(describing: formatVersion)), namespace: \(String(describing: namespace)), permissionPolicy: \(String(describing: permissionPolicy)))"}
}

/// <p>Information about a dataset that contains permissions for row-level security (RLS).
///             The permissions dataset maps fields to users or groups. For more information, see
///             <a href="https://docs.aws.amazon.com/quicksight/latest/user/restrict-access-to-a-data-set-using-row-level-security.html">Using Row-Level Security (RLS) to Restrict Access to a Dataset</a> in the <i>Amazon QuickSight User
///                 Guide</i>.</p>
///             <p>The option to deny permissions by setting <code>PermissionPolicy</code> to <code>DENY_ACCESS</code> is
///             not supported for new RLS datasets.</p>
public struct RowLevelPermissionDataSet: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset that contains permissions for RLS.</p>
    public let arn: String?
    /// <p>The user or group rules associated with the dataset that contains permissions for RLS.</p>
    ///          <p>By default, <code>FormatVersion</code> is <code>VERSION_1</code>. When <code>FormatVersion</code> is <code>VERSION_1</code>, <code>UserName</code> and <code>GroupName</code> are required. When <code>FormatVersion</code> is <code>VERSION_2</code>, <code>UserARN</code> and <code>GroupARN</code> are required, and <code>Namespace</code> must not exist.</p>
    public let formatVersion: RowLevelPermissionFormatVersion?
    /// <p>The namespace associated with the dataset that contains permissions for RLS.</p>
    public let namespace: String?
    /// <p>The type of permissions to use when interpretting the permissions for RLS. <code>DENY_ACCESS</code>
    ///         is included for backward compatibility only.</p>
    public let permissionPolicy: RowLevelPermissionPolicy?

    public init (
        arn: String? = nil,
        formatVersion: RowLevelPermissionFormatVersion? = nil,
        namespace: String? = nil,
        permissionPolicy: RowLevelPermissionPolicy? = nil
    )
    {
        self.arn = arn
        self.formatVersion = formatVersion
        self.namespace = namespace
        self.permissionPolicy = permissionPolicy
    }
}

public enum RowLevelPermissionFormatVersion {
    case version1
    case version2
    case sdkUnknown(String)
}

extension RowLevelPermissionFormatVersion : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RowLevelPermissionFormatVersion] {
        return [
            .version1,
            .version2,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .version1: return "VERSION_1"
        case .version2: return "VERSION_2"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RowLevelPermissionFormatVersion(rawValue: rawValue) ?? RowLevelPermissionFormatVersion.sdkUnknown(rawValue)
    }
}

public enum RowLevelPermissionPolicy {
    case denyAccess
    case grantAccess
    case sdkUnknown(String)
}

extension RowLevelPermissionPolicy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RowLevelPermissionPolicy] {
        return [
            .denyAccess,
            .grantAccess,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .denyAccess: return "DENY_ACCESS"
        case .grantAccess: return "GRANT_ACCESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RowLevelPermissionPolicy(rawValue: rawValue) ?? RowLevelPermissionPolicy.sdkUnknown(rawValue)
    }
}

extension S3Parameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case manifestFileLocation = "ManifestFileLocation"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let manifestFileLocation = manifestFileLocation {
            try encodeContainer.encode(manifestFileLocation, forKey: .manifestFileLocation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestFileLocationDecoded = try containerValues.decodeIfPresent(ManifestFileLocation.self, forKey: .manifestFileLocation)
        manifestFileLocation = manifestFileLocationDecoded
    }
}

extension S3Parameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Parameters(manifestFileLocation: \(String(describing: manifestFileLocation)))"}
}

/// <p>S3 parameters.</p>
public struct S3Parameters: Equatable {
    /// <p>Location of the Amazon S3 manifest file. This is NULL if the manifest file was
    ///             uploaded in the console.</p>
    public let manifestFileLocation: ManifestFileLocation?

    public init (
        manifestFileLocation: ManifestFileLocation? = nil
    )
    {
        self.manifestFileLocation = manifestFileLocation
    }
}

extension S3Source: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataSourceArn = "DataSourceArn"
        case inputColumns = "InputColumns"
        case uploadSettings = "UploadSettings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceArn = dataSourceArn {
            try encodeContainer.encode(dataSourceArn, forKey: .dataSourceArn)
        }
        if let inputColumns = inputColumns {
            var inputColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputColumns)
            for inputcolumnlist0 in inputColumns {
                try inputColumnsContainer.encode(inputcolumnlist0)
            }
        }
        if let uploadSettings = uploadSettings {
            try encodeContainer.encode(uploadSettings, forKey: .uploadSettings)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSourceArn)
        dataSourceArn = dataSourceArnDecoded
        let uploadSettingsDecoded = try containerValues.decodeIfPresent(UploadSettings.self, forKey: .uploadSettings)
        uploadSettings = uploadSettingsDecoded
        let inputColumnsContainer = try containerValues.decodeIfPresent([InputColumn?].self, forKey: .inputColumns)
        var inputColumnsDecoded0:[InputColumn]? = nil
        if let inputColumnsContainer = inputColumnsContainer {
            inputColumnsDecoded0 = [InputColumn]()
            for structure0 in inputColumnsContainer {
                if let structure0 = structure0 {
                    inputColumnsDecoded0?.append(structure0)
                }
            }
        }
        inputColumns = inputColumnsDecoded0
    }
}

extension S3Source: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Source(dataSourceArn: \(String(describing: dataSourceArn)), inputColumns: \(String(describing: inputColumns)), uploadSettings: \(String(describing: uploadSettings)))"}
}

/// <p>A physical table type for as S3 data source.</p>
public struct S3Source: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the data source.</p>
    public let dataSourceArn: String?
    /// <p>A physical table type for as S3 data source.</p>
    public let inputColumns: [InputColumn]?
    /// <p>Information about the format for the S3 source file or files.</p>
    public let uploadSettings: UploadSettings?

    public init (
        dataSourceArn: String? = nil,
        inputColumns: [InputColumn]? = nil,
        uploadSettings: UploadSettings? = nil
    )
    {
        self.dataSourceArn = dataSourceArn
        self.inputColumns = inputColumns
        self.uploadSettings = uploadSettings
    }
}

public struct SearchAnalysesInputBodyMiddleware: Middleware {
    public let id: String = "SearchAnalysesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchAnalysesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchAnalysesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchAnalysesInput>
    public typealias MOutput = OperationOutput<SearchAnalysesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchAnalysesOutputError>
}

extension SearchAnalysesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchAnalysesInput(awsAccountId: \(String(describing: awsAccountId)), filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension SearchAnalysesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for analysissearchfilterlist0 in filters {
                try filtersContainer.encode(analysissearchfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct SearchAnalysesInputHeadersMiddleware: Middleware {
    public let id: String = "SearchAnalysesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchAnalysesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchAnalysesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchAnalysesInput>
    public typealias MOutput = OperationOutput<SearchAnalysesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchAnalysesOutputError>
}

public struct SearchAnalysesInputQueryItemMiddleware: Middleware {
    public let id: String = "SearchAnalysesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchAnalysesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchAnalysesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchAnalysesInput>
    public typealias MOutput = OperationOutput<SearchAnalysesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchAnalysesOutputError>
}

public struct SearchAnalysesInput: Equatable {
    /// <p>The ID of the AWS account that contains the analyses that you're searching
    ///             for.</p>
    public let awsAccountId: String?
    /// <p>The structure for the search filters that you want to apply to your search. </p>
    public let filters: [AnalysisSearchFilter]?
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int
    /// <p>A pagination token that can be used in a subsequent request.</p>
    public let nextToken: String?

    public init (
        awsAccountId: String? = nil,
        filters: [AnalysisSearchFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchAnalysesInputBody: Equatable {
    public let filters: [AnalysisSearchFilter]?
    public let nextToken: String?
    public let maxResults: Int
}

extension SearchAnalysesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([AnalysisSearchFilter?].self, forKey: .filters)
        var filtersDecoded0:[AnalysisSearchFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [AnalysisSearchFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension SearchAnalysesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchAnalysesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchAnalysesOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchAnalysesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchAnalysesOutputResponse(analysisSummaryList: \(String(describing: analysisSummaryList)), nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension SearchAnalysesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SearchAnalysesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.analysisSummaryList = output.analysisSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.analysisSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct SearchAnalysesOutputResponse: Equatable {
    /// <p>Metadata describing the analyses that you searched for.</p>
    public let analysisSummaryList: [AnalysisSummary]?
    /// <p>A pagination token that can be used in a subsequent request.
    ///             </p>
    public let nextToken: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        analysisSummaryList: [AnalysisSummary]? = nil,
        nextToken: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.analysisSummaryList = analysisSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct SearchAnalysesOutputResponseBody: Equatable {
    public let analysisSummaryList: [AnalysisSummary]?
    public let nextToken: String?
    public let status: Int
    public let requestId: String?
}

extension SearchAnalysesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analysisSummaryList = "AnalysisSummaryList"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisSummaryListContainer = try containerValues.decodeIfPresent([AnalysisSummary?].self, forKey: .analysisSummaryList)
        var analysisSummaryListDecoded0:[AnalysisSummary]? = nil
        if let analysisSummaryListContainer = analysisSummaryListContainer {
            analysisSummaryListDecoded0 = [AnalysisSummary]()
            for structure0 in analysisSummaryListContainer {
                if let structure0 = structure0 {
                    analysisSummaryListDecoded0?.append(structure0)
                }
            }
        }
        analysisSummaryList = analysisSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

public struct SearchDashboardsInputBodyMiddleware: Middleware {
    public let id: String = "SearchDashboardsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchDashboardsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchDashboardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchDashboardsInput>
    public typealias MOutput = OperationOutput<SearchDashboardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchDashboardsOutputError>
}

extension SearchDashboardsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchDashboardsInput(awsAccountId: \(String(describing: awsAccountId)), filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension SearchDashboardsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for dashboardsearchfilterlist0 in filters {
                try filtersContainer.encode(dashboardsearchfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct SearchDashboardsInputHeadersMiddleware: Middleware {
    public let id: String = "SearchDashboardsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchDashboardsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchDashboardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchDashboardsInput>
    public typealias MOutput = OperationOutput<SearchDashboardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchDashboardsOutputError>
}

public struct SearchDashboardsInputQueryItemMiddleware: Middleware {
    public let id: String = "SearchDashboardsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchDashboardsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchDashboardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchDashboardsInput>
    public typealias MOutput = OperationOutput<SearchDashboardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchDashboardsOutputError>
}

public struct SearchDashboardsInput: Equatable {
    /// <p>The ID of the AWS account that contains the user whose dashboards you're searching
    ///             for. </p>
    public let awsAccountId: String?
    /// <p>The filters to apply to the search. Currently, you can search only by user name, for
    ///             example, <code>"Filters": [ { "Name": "QUICKSIGHT_USER", "Operator": "StringEquals",
    ///             "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1" } ]</code>
    ///          </p>
    public let filters: [DashboardSearchFilter]?
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?

    public init (
        awsAccountId: String? = nil,
        filters: [DashboardSearchFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchDashboardsInputBody: Equatable {
    public let filters: [DashboardSearchFilter]?
    public let nextToken: String?
    public let maxResults: Int
}

extension SearchDashboardsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DashboardSearchFilter?].self, forKey: .filters)
        var filtersDecoded0:[DashboardSearchFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DashboardSearchFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension SearchDashboardsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchDashboardsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchDashboardsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchDashboardsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchDashboardsOutputResponse(dashboardSummaryList: \(String(describing: dashboardSummaryList)), nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension SearchDashboardsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SearchDashboardsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dashboardSummaryList = output.dashboardSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.dashboardSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct SearchDashboardsOutputResponse: Equatable {
    /// <p>The list of dashboards owned by the user specified in <code>Filters</code> in your
    ///             request.</p>
    public let dashboardSummaryList: [DashboardSummary]?
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        dashboardSummaryList: [DashboardSummary]? = nil,
        nextToken: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.dashboardSummaryList = dashboardSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct SearchDashboardsOutputResponseBody: Equatable {
    public let dashboardSummaryList: [DashboardSummary]?
    public let nextToken: String?
    public let status: Int
    public let requestId: String?
}

extension SearchDashboardsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dashboardSummaryList = "DashboardSummaryList"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardSummaryListContainer = try containerValues.decodeIfPresent([DashboardSummary?].self, forKey: .dashboardSummaryList)
        var dashboardSummaryListDecoded0:[DashboardSummary]? = nil
        if let dashboardSummaryListContainer = dashboardSummaryListContainer {
            dashboardSummaryListDecoded0 = [DashboardSummary]()
            for structure0 in dashboardSummaryListContainer {
                if let structure0 = structure0 {
                    dashboardSummaryListDecoded0?.append(structure0)
                }
            }
        }
        dashboardSummaryList = dashboardSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ServiceNowParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case siteBaseUrl = "SiteBaseUrl"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let siteBaseUrl = siteBaseUrl {
            try encodeContainer.encode(siteBaseUrl, forKey: .siteBaseUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteBaseUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .siteBaseUrl)
        siteBaseUrl = siteBaseUrlDecoded
    }
}

extension ServiceNowParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceNowParameters(siteBaseUrl: \(String(describing: siteBaseUrl)))"}
}

/// <p>ServiceNow parameters.</p>
public struct ServiceNowParameters: Equatable {
    /// <p>URL of the base site.</p>
    public let siteBaseUrl: String?

    public init (
        siteBaseUrl: String? = nil
    )
    {
        self.siteBaseUrl = siteBaseUrl
    }
}

extension SessionLifetimeInMinutesInvalidException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SessionLifetimeInMinutesInvalidException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension SessionLifetimeInMinutesInvalidException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SessionLifetimeInMinutesInvalidExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of minutes specified for the lifetime of a session isn't valid. The session
/// 			lifetime must be 15-600 minutes.</p>
public struct SessionLifetimeInMinutesInvalidException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The AWS request ID for this request.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct SessionLifetimeInMinutesInvalidExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension SessionLifetimeInMinutesInvalidExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension Sheet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case sheetId = "SheetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sheetId = sheetId {
            try encodeContainer.encode(sheetId, forKey: .sheetId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sheetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sheetId)
        sheetId = sheetIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension Sheet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Sheet(name: \(String(describing: name)), sheetId: \(String(describing: sheetId)))"}
}

/// <p>A <i>sheet</i>, which is an object that contains a set of visuals that
///             are viewed together on one page in the Amazon QuickSight console. Every analysis and dashboard
///             contains at least one sheet. Each sheet contains at least one visualization widget, for
///             example a chart, pivot table, or narrative insight. Sheets can be associated with other
///             components, such as controls, filters, and so on.</p>
public struct Sheet: Equatable {
    /// <p>The name of a sheet. This name is displayed on the sheet's tab in the QuickSight
    ///             console.</p>
    public let name: String?
    /// <p>The unique identifier associated with a sheet.</p>
    public let sheetId: String?

    public init (
        name: String? = nil,
        sheetId: String? = nil
    )
    {
        self.name = name
        self.sheetId = sheetId
    }
}

extension SheetControlsOption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case visibilityState = "VisibilityState"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let visibilityState = visibilityState {
            try encodeContainer.encode(visibilityState.rawValue, forKey: .visibilityState)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visibilityStateDecoded = try containerValues.decodeIfPresent(DashboardUIState.self, forKey: .visibilityState)
        visibilityState = visibilityStateDecoded
    }
}

extension SheetControlsOption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SheetControlsOption(visibilityState: \(String(describing: visibilityState)))"}
}

/// <p>Sheet controls option.</p>
public struct SheetControlsOption: Equatable {
    /// <p>Visibility state.</p>
    public let visibilityState: DashboardUIState?

    public init (
        visibilityState: DashboardUIState? = nil
    )
    {
        self.visibilityState = visibilityState
    }
}

extension SheetStyle: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tile = "Tile"
        case tileLayout = "TileLayout"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tile = tile {
            try encodeContainer.encode(tile, forKey: .tile)
        }
        if let tileLayout = tileLayout {
            try encodeContainer.encode(tileLayout, forKey: .tileLayout)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tileDecoded = try containerValues.decodeIfPresent(TileStyle.self, forKey: .tile)
        tile = tileDecoded
        let tileLayoutDecoded = try containerValues.decodeIfPresent(TileLayoutStyle.self, forKey: .tileLayout)
        tileLayout = tileLayoutDecoded
    }
}

extension SheetStyle: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SheetStyle(tile: \(String(describing: tile)), tileLayout: \(String(describing: tileLayout)))"}
}

/// <p>The theme display options for sheets. </p>
public struct SheetStyle: Equatable {
    /// <p>The display options for tiles.</p>
    public let tile: TileStyle?
    /// <p>The layout options for tiles.</p>
    public let tileLayout: TileLayoutStyle?

    public init (
        tile: TileStyle? = nil,
        tileLayout: TileLayoutStyle? = nil
    )
    {
        self.tile = tile
        self.tileLayout = tileLayout
    }
}

extension SnowflakeParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case database = "Database"
        case host = "Host"
        case warehouse = "Warehouse"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let host = host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if let warehouse = warehouse {
            try encodeContainer.encode(warehouse, forKey: .warehouse)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .host)
        host = hostDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .database)
        database = databaseDecoded
        let warehouseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .warehouse)
        warehouse = warehouseDecoded
    }
}

extension SnowflakeParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnowflakeParameters(database: \(String(describing: database)), host: \(String(describing: host)), warehouse: \(String(describing: warehouse)))"}
}

/// <p>Snowflake parameters.</p>
public struct SnowflakeParameters: Equatable {
    /// <p>Database.</p>
    public let database: String?
    /// <p>Host.</p>
    public let host: String?
    /// <p>Warehouse.</p>
    public let warehouse: String?

    public init (
        database: String? = nil,
        host: String? = nil,
        warehouse: String? = nil
    )
    {
        self.database = database
        self.host = host
        self.warehouse = warehouse
    }
}

extension SparkParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let host = host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
    }
}

extension SparkParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SparkParameters(host: \(String(describing: host)), port: \(String(describing: port)))"}
}

/// <p>Spark parameters.</p>
public struct SparkParameters: Equatable {
    /// <p>Host.</p>
    public let host: String?
    /// <p>Port.</p>
    public let port: Int

    public init (
        host: String? = nil,
        port: Int = 0
    )
    {
        self.host = host
        self.port = port
    }
}

extension SqlServerParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case database = "Database"
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let host = host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .database)
        database = databaseDecoded
    }
}

extension SqlServerParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SqlServerParameters(database: \(String(describing: database)), host: \(String(describing: host)), port: \(String(describing: port)))"}
}

/// <p>SQL Server parameters.</p>
public struct SqlServerParameters: Equatable {
    /// <p>Database.</p>
    public let database: String?
    /// <p>Host.</p>
    public let host: String?
    /// <p>Port.</p>
    public let port: Int

    public init (
        database: String? = nil,
        host: String? = nil,
        port: Int = 0
    )
    {
        self.database = database
        self.host = host
        self.port = port
    }
}

extension SslProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case disableSsl = "DisableSsl"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if disableSsl != false {
            try encodeContainer.encode(disableSsl, forKey: .disableSsl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disableSslDecoded = try containerValues.decode(Bool.self, forKey: .disableSsl)
        disableSsl = disableSslDecoded
    }
}

extension SslProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SslProperties(disableSsl: \(String(describing: disableSsl)))"}
}

/// <p>Secure Socket Layer (SSL) properties that apply when QuickSight connects to your
///             underlying data source.</p>
public struct SslProperties: Equatable {
    /// <p>A Boolean option to control whether SSL should be disabled.</p>
    public let disableSsl: Bool

    public init (
        disableSsl: Bool = false
    )
    {
        self.disableSsl = disableSsl
    }
}

extension StringParameter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for stringlist0 in values {
                try valuesContainer.encode(stringlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension StringParameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StringParameter(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>A string parameter.</p>
public struct StringParameter: Equatable {
    /// <p>A display name for a string parameter.</p>
    public let name: String?
    /// <p>The values of a string parameter.</p>
    public let values: [String]?

    public init (
        name: String? = nil,
        values: [String]? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>The key or keys of the key-value pairs for the resource tag or tags assigned to the
///             resource.</p>
public struct Tag: Equatable {
    /// <p>Tag key.</p>
    public let key: String?
    /// <p>Tag value.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension TagColumnOperation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case columnName = "ColumnName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnName = columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for columntaglist0 in tags {
                try tagsContainer.encode(columntaglist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .columnName)
        columnName = columnNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ColumnTag?].self, forKey: .tags)
        var tagsDecoded0:[ColumnTag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ColumnTag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagColumnOperation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagColumnOperation(columnName: \(String(describing: columnName)), tags: \(String(describing: tags)))"}
}

/// <p>A transform operation that tags a column with additional information.</p>
public struct TagColumnOperation: Equatable {
    /// <p>The column that this operation acts on.</p>
    public let columnName: String?
    /// <p>The dataset column tag, currently only used for geospatial type tagging. .</p>
    ///         <note>
    ///             <p>This is not tags for the AWS tagging feature. .</p>
    ///         </note>
    public let tags: [ColumnTag]?

    public init (
        columnName: String? = nil,
        tags: [ColumnTag]? = nil
    )
    {
        self.columnName = columnName
        self.tags = tags
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to tag.</p>
    public let resourceArn: String?
    /// <p>Contains a map of the key-value pairs for the resource tag or tags assigned to the resource.</p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse(requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TagResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.requestId = output.requestId
        } else {
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct TagResourceOutputResponse: Equatable {
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

struct TagResourceOutputResponseBody: Equatable {
    public let requestId: String?
    public let status: Int
}

extension TagResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension Template: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case templateId = "TemplateId"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let templateId = templateId {
            try encodeContainer.encode(templateId, forKey: .templateId)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(TemplateVersion.self, forKey: .version)
        version = versionDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension Template: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Template(arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), name: \(String(describing: name)), templateId: \(String(describing: templateId)), version: \(String(describing: version)))"}
}

/// <p>A template object. A <i>template</i> is an entity in QuickSight that
///             encapsulates the metadata required to create an analysis and that you can use to create
///             a dashboard. A template adds a layer of abstraction by using placeholders to replace the
///             dataset associated with an analysis. You can use templates to create dashboards by
///             replacing dataset placeholders with datasets that follow the same schema that was used
///             to create the source analysis and template.</p>
///         <p>You can share templates across AWS accounts by allowing users in other AWS accounts to
///             create a template or a dashboard from an existing template.</p>
public struct Template: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the template.</p>
    public let arn: String?
    /// <p>Time when this was created.</p>
    public let createdTime: Date?
    /// <p>Time when this was last updated.</p>
    public let lastUpdatedTime: Date?
    /// <p>The display name of the template.</p>
    public let name: String?
    /// <p>The ID for the template. This is unique per AWS Region for each AWS account.</p>
    public let templateId: String?
    /// <p>A structure describing the versions of the template.</p>
    public let version: TemplateVersion?

    public init (
        arn: String? = nil,
        createdTime: Date? = nil,
        lastUpdatedTime: Date? = nil,
        name: String? = nil,
        templateId: String? = nil,
        version: TemplateVersion? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.templateId = templateId
        self.version = version
    }
}

extension TemplateAlias: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aliasName = "AliasName"
        case arn = "Arn"
        case templateVersionNumber = "TemplateVersionNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasName = aliasName {
            try encodeContainer.encode(aliasName, forKey: .aliasName)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let templateVersionNumber = templateVersionNumber {
            try encodeContainer.encode(templateVersionNumber, forKey: .templateVersionNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aliasName)
        aliasName = aliasNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let templateVersionNumberDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .templateVersionNumber)
        templateVersionNumber = templateVersionNumberDecoded
    }
}

extension TemplateAlias: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TemplateAlias(aliasName: \(String(describing: aliasName)), arn: \(String(describing: arn)), templateVersionNumber: \(String(describing: templateVersionNumber)))"}
}

/// <p>The template alias.</p>
public struct TemplateAlias: Equatable {
    /// <p>The display name of the template alias.</p>
    public let aliasName: String?
    /// <p>The Amazon Resource Name (ARN) of the template alias.</p>
    public let arn: String?
    /// <p>The version number of the template alias.</p>
    public let templateVersionNumber: Int?

    public init (
        aliasName: String? = nil,
        arn: String? = nil,
        templateVersionNumber: Int? = nil
    )
    {
        self.aliasName = aliasName
        self.arn = arn
        self.templateVersionNumber = templateVersionNumber
    }
}

extension TemplateError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(TemplateErrorType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TemplateError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TemplateError(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

/// <p>List of errors that occurred when the template version creation failed.</p>
public struct TemplateError: Equatable {
    /// <p>Description of the error type.</p>
    public let message: String?
    /// <p>Type of error.</p>
    public let type: TemplateErrorType?

    public init (
        message: String? = nil,
        type: TemplateErrorType? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

public enum TemplateErrorType {
    case accessDenied
    case dataSetNotFound
    case internalFailure
    case sourceNotFound
    case sdkUnknown(String)
}

extension TemplateErrorType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TemplateErrorType] {
        return [
            .accessDenied,
            .dataSetNotFound,
            .internalFailure,
            .sourceNotFound,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accessDenied: return "ACCESS_DENIED"
        case .dataSetNotFound: return "DATA_SET_NOT_FOUND"
        case .internalFailure: return "INTERNAL_FAILURE"
        case .sourceNotFound: return "SOURCE_NOT_FOUND"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TemplateErrorType(rawValue: rawValue) ?? TemplateErrorType.sdkUnknown(rawValue)
    }
}

extension TemplateSourceAnalysis: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case dataSetReferences = "DataSetReferences"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dataSetReferences = dataSetReferences {
            var dataSetReferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSetReferences)
            for datasetreferencelist0 in dataSetReferences {
                try dataSetReferencesContainer.encode(datasetreferencelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let dataSetReferencesContainer = try containerValues.decodeIfPresent([DataSetReference?].self, forKey: .dataSetReferences)
        var dataSetReferencesDecoded0:[DataSetReference]? = nil
        if let dataSetReferencesContainer = dataSetReferencesContainer {
            dataSetReferencesDecoded0 = [DataSetReference]()
            for structure0 in dataSetReferencesContainer {
                if let structure0 = structure0 {
                    dataSetReferencesDecoded0?.append(structure0)
                }
            }
        }
        dataSetReferences = dataSetReferencesDecoded0
    }
}

extension TemplateSourceAnalysis: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TemplateSourceAnalysis(arn: \(String(describing: arn)), dataSetReferences: \(String(describing: dataSetReferences)))"}
}

/// <p>The source analysis of the template.</p>
public struct TemplateSourceAnalysis: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let arn: String?
    /// <p>A structure containing information about the dataset references used as placeholders
    ///             in the template.</p>
    public let dataSetReferences: [DataSetReference]?

    public init (
        arn: String? = nil,
        dataSetReferences: [DataSetReference]? = nil
    )
    {
        self.arn = arn
        self.dataSetReferences = dataSetReferences
    }
}

extension TemplateSourceEntity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sourceAnalysis = "SourceAnalysis"
        case sourceTemplate = "SourceTemplate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceAnalysis = sourceAnalysis {
            try encodeContainer.encode(sourceAnalysis, forKey: .sourceAnalysis)
        }
        if let sourceTemplate = sourceTemplate {
            try encodeContainer.encode(sourceTemplate, forKey: .sourceTemplate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceAnalysisDecoded = try containerValues.decodeIfPresent(TemplateSourceAnalysis.self, forKey: .sourceAnalysis)
        sourceAnalysis = sourceAnalysisDecoded
        let sourceTemplateDecoded = try containerValues.decodeIfPresent(TemplateSourceTemplate.self, forKey: .sourceTemplate)
        sourceTemplate = sourceTemplateDecoded
    }
}

extension TemplateSourceEntity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TemplateSourceEntity(sourceAnalysis: \(String(describing: sourceAnalysis)), sourceTemplate: \(String(describing: sourceTemplate)))"}
}

/// <p>The source entity of the template.</p>
public struct TemplateSourceEntity: Equatable {
    /// <p>The source analysis, if it is based on an analysis.</p>
    public let sourceAnalysis: TemplateSourceAnalysis?
    /// <p>The source template, if it is based on an template.</p>
    public let sourceTemplate: TemplateSourceTemplate?

    public init (
        sourceAnalysis: TemplateSourceAnalysis? = nil,
        sourceTemplate: TemplateSourceTemplate? = nil
    )
    {
        self.sourceAnalysis = sourceAnalysis
        self.sourceTemplate = sourceTemplate
    }
}

extension TemplateSourceTemplate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension TemplateSourceTemplate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TemplateSourceTemplate(arn: \(String(describing: arn)))"}
}

/// <p>The source template of the template.</p>
public struct TemplateSourceTemplate: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

extension TemplateSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case lastUpdatedTime = "LastUpdatedTime"
        case latestVersionNumber = "LatestVersionNumber"
        case name = "Name"
        case templateId = "TemplateId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let latestVersionNumber = latestVersionNumber {
            try encodeContainer.encode(latestVersionNumber, forKey: .latestVersionNumber)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let templateId = templateId {
            try encodeContainer.encode(templateId, forKey: .templateId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let latestVersionNumberDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .latestVersionNumber)
        latestVersionNumber = latestVersionNumberDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension TemplateSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TemplateSummary(arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), latestVersionNumber: \(String(describing: latestVersionNumber)), name: \(String(describing: name)), templateId: \(String(describing: templateId)))"}
}

/// <p>The template summary.</p>
public struct TemplateSummary: Equatable {
    /// <p>A summary of a template.</p>
    public let arn: String?
    /// <p>The last time that this template was created.</p>
    public let createdTime: Date?
    /// <p>The last time that this template was updated.</p>
    public let lastUpdatedTime: Date?
    /// <p>A structure containing a list of version numbers for the template summary.</p>
    public let latestVersionNumber: Int?
    /// <p>A display name for the template.</p>
    public let name: String?
    /// <p>The ID of the template. This ID is unique per AWS Region for each AWS account.</p>
    public let templateId: String?

    public init (
        arn: String? = nil,
        createdTime: Date? = nil,
        lastUpdatedTime: Date? = nil,
        latestVersionNumber: Int? = nil,
        name: String? = nil,
        templateId: String? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.lastUpdatedTime = lastUpdatedTime
        self.latestVersionNumber = latestVersionNumber
        self.name = name
        self.templateId = templateId
    }
}

extension TemplateVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdTime = "CreatedTime"
        case dataSetConfigurations = "DataSetConfigurations"
        case description = "Description"
        case errors = "Errors"
        case sheets = "Sheets"
        case sourceEntityArn = "SourceEntityArn"
        case status = "Status"
        case themeArn = "ThemeArn"
        case versionNumber = "VersionNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let dataSetConfigurations = dataSetConfigurations {
            var dataSetConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSetConfigurations)
            for datasetconfigurationlist0 in dataSetConfigurations {
                try dataSetConfigurationsContainer.encode(datasetconfigurationlist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let errors = errors {
            var errorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errors)
            for templateerrorlist0 in errors {
                try errorsContainer.encode(templateerrorlist0)
            }
        }
        if let sheets = sheets {
            var sheetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sheets)
            for sheetlist0 in sheets {
                try sheetsContainer.encode(sheetlist0)
            }
        }
        if let sourceEntityArn = sourceEntityArn {
            try encodeContainer.encode(sourceEntityArn, forKey: .sourceEntityArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let themeArn = themeArn {
            try encodeContainer.encode(themeArn, forKey: .themeArn)
        }
        if let versionNumber = versionNumber {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let errorsContainer = try containerValues.decodeIfPresent([TemplateError?].self, forKey: .errors)
        var errorsDecoded0:[TemplateError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [TemplateError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let versionNumberDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResourceStatus.self, forKey: .status)
        status = statusDecoded
        let dataSetConfigurationsContainer = try containerValues.decodeIfPresent([DataSetConfiguration?].self, forKey: .dataSetConfigurations)
        var dataSetConfigurationsDecoded0:[DataSetConfiguration]? = nil
        if let dataSetConfigurationsContainer = dataSetConfigurationsContainer {
            dataSetConfigurationsDecoded0 = [DataSetConfiguration]()
            for structure0 in dataSetConfigurationsContainer {
                if let structure0 = structure0 {
                    dataSetConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        dataSetConfigurations = dataSetConfigurationsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let sourceEntityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceEntityArn)
        sourceEntityArn = sourceEntityArnDecoded
        let themeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .themeArn)
        themeArn = themeArnDecoded
        let sheetsContainer = try containerValues.decodeIfPresent([Sheet?].self, forKey: .sheets)
        var sheetsDecoded0:[Sheet]? = nil
        if let sheetsContainer = sheetsContainer {
            sheetsDecoded0 = [Sheet]()
            for structure0 in sheetsContainer {
                if let structure0 = structure0 {
                    sheetsDecoded0?.append(structure0)
                }
            }
        }
        sheets = sheetsDecoded0
    }
}

extension TemplateVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TemplateVersion(createdTime: \(String(describing: createdTime)), dataSetConfigurations: \(String(describing: dataSetConfigurations)), description: \(String(describing: description)), errors: \(String(describing: errors)), sheets: \(String(describing: sheets)), sourceEntityArn: \(String(describing: sourceEntityArn)), status: \(String(describing: status)), themeArn: \(String(describing: themeArn)), versionNumber: \(String(describing: versionNumber)))"}
}

/// <p>A version of a template.</p>
public struct TemplateVersion: Equatable {
    /// <p>The time that this template version was created.</p>
    public let createdTime: Date?
    /// <p>Schema of the dataset identified by the placeholder. Any dashboard created from this
    ///             template should be bound to new datasets matching the same schema described through this
    ///             API operation.</p>
    public let dataSetConfigurations: [DataSetConfiguration]?
    /// <p>The description of the template.</p>
    public let description: String?
    /// <p>Errors associated with this template version.</p>
    public let errors: [TemplateError]?
    /// <p>A list of the associated sheets with the unique identifier and name of each sheet.</p>
    public let sheets: [Sheet]?
    /// <p>The Amazon Resource Name (ARN) of an analysis or template that was used to create this
    ///             template.</p>
    public let sourceEntityArn: String?
    /// <p>The HTTP status of the request.</p>
    public let status: ResourceStatus?
    /// <p>The ARN of the theme associated with this version of the template.</p>
    public let themeArn: String?
    /// <p>The version number of the template version.</p>
    public let versionNumber: Int?

    public init (
        createdTime: Date? = nil,
        dataSetConfigurations: [DataSetConfiguration]? = nil,
        description: String? = nil,
        errors: [TemplateError]? = nil,
        sheets: [Sheet]? = nil,
        sourceEntityArn: String? = nil,
        status: ResourceStatus? = nil,
        themeArn: String? = nil,
        versionNumber: Int? = nil
    )
    {
        self.createdTime = createdTime
        self.dataSetConfigurations = dataSetConfigurations
        self.description = description
        self.errors = errors
        self.sheets = sheets
        self.sourceEntityArn = sourceEntityArn
        self.status = status
        self.themeArn = themeArn
        self.versionNumber = versionNumber
    }
}

extension TemplateVersionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case status = "Status"
        case versionNumber = "VersionNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let versionNumber = versionNumber {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let versionNumberDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResourceStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension TemplateVersionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TemplateVersionSummary(arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), description: \(String(describing: description)), status: \(String(describing: status)), versionNumber: \(String(describing: versionNumber)))"}
}

/// <p>The template version.</p>
public struct TemplateVersionSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the template version.</p>
    public let arn: String?
    /// <p>The time that this template version was created.</p>
    public let createdTime: Date?
    /// <p>The description of the template version.</p>
    public let description: String?
    /// <p>The status of the template version.</p>
    public let status: ResourceStatus?
    /// <p>The version number of the template version.</p>
    public let versionNumber: Int?

    public init (
        arn: String? = nil,
        createdTime: Date? = nil,
        description: String? = nil,
        status: ResourceStatus? = nil,
        versionNumber: Int? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.description = description
        self.status = status
        self.versionNumber = versionNumber
    }
}

extension TeradataParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case database = "Database"
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let host = host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .database)
        database = databaseDecoded
    }
}

extension TeradataParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TeradataParameters(database: \(String(describing: database)), host: \(String(describing: host)), port: \(String(describing: port)))"}
}

/// <p>Teradata parameters.</p>
public struct TeradataParameters: Equatable {
    /// <p>Database.</p>
    public let database: String?
    /// <p>Host.</p>
    public let host: String?
    /// <p>Port.</p>
    public let port: Int

    public init (
        database: String? = nil,
        host: String? = nil,
        port: Int = 0
    )
    {
        self.database = database
        self.host = host
        self.port = port
    }
}

public enum TextQualifier {
    case doubleQuote
    case singleQuote
    case sdkUnknown(String)
}

extension TextQualifier : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TextQualifier] {
        return [
            .doubleQuote,
            .singleQuote,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .doubleQuote: return "DOUBLE_QUOTE"
        case .singleQuote: return "SINGLE_QUOTE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TextQualifier(rawValue: rawValue) ?? TextQualifier.sdkUnknown(rawValue)
    }
}

extension Theme: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case themeId = "ThemeId"
        case type = "Type"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let themeId = themeId {
            try encodeContainer.encode(themeId, forKey: .themeId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let themeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .themeId)
        themeId = themeIdDecoded
        let versionDecoded = try containerValues.decodeIfPresent(ThemeVersion.self, forKey: .version)
        version = versionDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ThemeType.self, forKey: .type)
        type = typeDecoded
    }
}

extension Theme: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Theme(arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), name: \(String(describing: name)), themeId: \(String(describing: themeId)), type: \(String(describing: type)), version: \(String(describing: version)))"}
}

/// <p>Summary information about a theme.</p>
public struct Theme: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the theme.</p>
    public let arn: String?
    /// <p>The date and time that the theme was created.</p>
    public let createdTime: Date?
    /// <p>The date and time that the theme was last updated.</p>
    public let lastUpdatedTime: Date?
    /// <p>The name that the user gives to the theme.</p>
    public let name: String?
    /// <p>The identifier that the user gives to the theme.</p>
    public let themeId: String?
    /// <p>The type of theme, based on how it was created. Valid values include:
    ///             <code>QUICKSIGHT</code> and <code>CUSTOM</code>.</p>
    public let type: ThemeType?
    /// <p>A version of a theme.</p>
    public let version: ThemeVersion?

    public init (
        arn: String? = nil,
        createdTime: Date? = nil,
        lastUpdatedTime: Date? = nil,
        name: String? = nil,
        themeId: String? = nil,
        type: ThemeType? = nil,
        version: ThemeVersion? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.themeId = themeId
        self.type = type
        self.version = version
    }
}

extension ThemeAlias: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aliasName = "AliasName"
        case arn = "Arn"
        case themeVersionNumber = "ThemeVersionNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasName = aliasName {
            try encodeContainer.encode(aliasName, forKey: .aliasName)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let themeVersionNumber = themeVersionNumber {
            try encodeContainer.encode(themeVersionNumber, forKey: .themeVersionNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let aliasNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aliasName)
        aliasName = aliasNameDecoded
        let themeVersionNumberDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .themeVersionNumber)
        themeVersionNumber = themeVersionNumberDecoded
    }
}

extension ThemeAlias: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThemeAlias(aliasName: \(String(describing: aliasName)), arn: \(String(describing: arn)), themeVersionNumber: \(String(describing: themeVersionNumber)))"}
}

/// <p>An alias for a theme.</p>
public struct ThemeAlias: Equatable {
    /// <p>The display name of the theme alias.</p>
    public let aliasName: String?
    /// <p>The Amazon Resource Name (ARN) of the theme alias.</p>
    public let arn: String?
    /// <p>The version number of the theme alias.</p>
    public let themeVersionNumber: Int?

    public init (
        aliasName: String? = nil,
        arn: String? = nil,
        themeVersionNumber: Int? = nil
    )
    {
        self.aliasName = aliasName
        self.arn = arn
        self.themeVersionNumber = themeVersionNumber
    }
}

extension ThemeConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataColorPalette = "DataColorPalette"
        case sheet = "Sheet"
        case uIColorPalette = "UIColorPalette"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataColorPalette = dataColorPalette {
            try encodeContainer.encode(dataColorPalette, forKey: .dataColorPalette)
        }
        if let sheet = sheet {
            try encodeContainer.encode(sheet, forKey: .sheet)
        }
        if let uIColorPalette = uIColorPalette {
            try encodeContainer.encode(uIColorPalette, forKey: .uIColorPalette)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataColorPaletteDecoded = try containerValues.decodeIfPresent(DataColorPalette.self, forKey: .dataColorPalette)
        dataColorPalette = dataColorPaletteDecoded
        let uIColorPaletteDecoded = try containerValues.decodeIfPresent(UIColorPalette.self, forKey: .uIColorPalette)
        uIColorPalette = uIColorPaletteDecoded
        let sheetDecoded = try containerValues.decodeIfPresent(SheetStyle.self, forKey: .sheet)
        sheet = sheetDecoded
    }
}

extension ThemeConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThemeConfiguration(dataColorPalette: \(String(describing: dataColorPalette)), sheet: \(String(describing: sheet)), uIColorPalette: \(String(describing: uIColorPalette)))"}
}

/// <p>The theme configuration. This configuration contains all of the display properties for
///             a theme.</p>
public struct ThemeConfiguration: Equatable {
    /// <p>Color properties that apply to chart data colors.</p>
    public let dataColorPalette: DataColorPalette?
    /// <p>Display options related to sheets.</p>
    public let sheet: SheetStyle?
    /// <p>Color properties that apply to the UI and to charts, excluding the colors that apply
    ///             to data. </p>
    public let uIColorPalette: UIColorPalette?

    public init (
        dataColorPalette: DataColorPalette? = nil,
        sheet: SheetStyle? = nil,
        uIColorPalette: UIColorPalette? = nil
    )
    {
        self.dataColorPalette = dataColorPalette
        self.sheet = sheet
        self.uIColorPalette = uIColorPalette
    }
}

extension ThemeError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ThemeErrorType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ThemeError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThemeError(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

/// <p>Theme error.</p>
public struct ThemeError: Equatable {
    /// <p>The error message.</p>
    public let message: String?
    /// <p>The type of error.</p>
    public let type: ThemeErrorType?

    public init (
        message: String? = nil,
        type: ThemeErrorType? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

public enum ThemeErrorType {
    case internalFailure
    case sdkUnknown(String)
}

extension ThemeErrorType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ThemeErrorType] {
        return [
            .internalFailure,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .internalFailure: return "INTERNAL_FAILURE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ThemeErrorType(rawValue: rawValue) ?? ThemeErrorType.sdkUnknown(rawValue)
    }
}

extension ThemeSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case lastUpdatedTime = "LastUpdatedTime"
        case latestVersionNumber = "LatestVersionNumber"
        case name = "Name"
        case themeId = "ThemeId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let latestVersionNumber = latestVersionNumber {
            try encodeContainer.encode(latestVersionNumber, forKey: .latestVersionNumber)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let themeId = themeId {
            try encodeContainer.encode(themeId, forKey: .themeId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let themeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .themeId)
        themeId = themeIdDecoded
        let latestVersionNumberDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .latestVersionNumber)
        latestVersionNumber = latestVersionNumberDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension ThemeSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThemeSummary(arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), latestVersionNumber: \(String(describing: latestVersionNumber)), name: \(String(describing: name)), themeId: \(String(describing: themeId)))"}
}

/// <p>The theme summary.</p>
public struct ThemeSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let arn: String?
    /// <p>The date and time that this theme was created.</p>
    public let createdTime: Date?
    /// <p>The last date and time that this theme was updated.</p>
    public let lastUpdatedTime: Date?
    /// <p>The latest version number for the theme. </p>
    public let latestVersionNumber: Int?
    /// <p>the display name for the theme.</p>
    public let name: String?
    /// <p>The ID of the theme. This ID is unique per AWS Region for each AWS account.</p>
    public let themeId: String?

    public init (
        arn: String? = nil,
        createdTime: Date? = nil,
        lastUpdatedTime: Date? = nil,
        latestVersionNumber: Int? = nil,
        name: String? = nil,
        themeId: String? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.lastUpdatedTime = lastUpdatedTime
        self.latestVersionNumber = latestVersionNumber
        self.name = name
        self.themeId = themeId
    }
}

public enum ThemeType {
    case all
    case custom
    case quicksight
    case sdkUnknown(String)
}

extension ThemeType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ThemeType] {
        return [
            .all,
            .custom,
            .quicksight,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "ALL"
        case .custom: return "CUSTOM"
        case .quicksight: return "QUICKSIGHT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ThemeType(rawValue: rawValue) ?? ThemeType.sdkUnknown(rawValue)
    }
}

extension ThemeVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case baseThemeId = "BaseThemeId"
        case configuration = "Configuration"
        case createdTime = "CreatedTime"
        case description = "Description"
        case errors = "Errors"
        case status = "Status"
        case versionNumber = "VersionNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let baseThemeId = baseThemeId {
            try encodeContainer.encode(baseThemeId, forKey: .baseThemeId)
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let errors = errors {
            var errorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errors)
            for themeerrorlist0 in errors {
                try errorsContainer.encode(themeerrorlist0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let versionNumber = versionNumber {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionNumberDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let baseThemeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baseThemeId)
        baseThemeId = baseThemeIdDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(ThemeConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let errorsContainer = try containerValues.decodeIfPresent([ThemeError?].self, forKey: .errors)
        var errorsDecoded0:[ThemeError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [ThemeError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(ResourceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ThemeVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThemeVersion(arn: \(String(describing: arn)), baseThemeId: \(String(describing: baseThemeId)), configuration: \(String(describing: configuration)), createdTime: \(String(describing: createdTime)), description: \(String(describing: description)), errors: \(String(describing: errors)), status: \(String(describing: status)), versionNumber: \(String(describing: versionNumber)))"}
}

/// <p>A version of a theme.</p>
public struct ThemeVersion: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let arn: String?
    /// <p>The Amazon QuickSight-defined ID of the theme that a custom theme inherits from. All
    ///             themes initially inherit from a default QuickSight theme.</p>
    public let baseThemeId: String?
    /// <p>The theme configuration, which contains all the theme display properties.</p>
    public let configuration: ThemeConfiguration?
    /// <p>The date and time that this theme version was created.</p>
    public let createdTime: Date?
    /// <p>The description of the theme.</p>
    public let description: String?
    /// <p>Errors associated with the theme.</p>
    public let errors: [ThemeError]?
    /// <p>The status of the theme version.</p>
    public let status: ResourceStatus?
    /// <p>The version number of the theme.</p>
    public let versionNumber: Int?

    public init (
        arn: String? = nil,
        baseThemeId: String? = nil,
        configuration: ThemeConfiguration? = nil,
        createdTime: Date? = nil,
        description: String? = nil,
        errors: [ThemeError]? = nil,
        status: ResourceStatus? = nil,
        versionNumber: Int? = nil
    )
    {
        self.arn = arn
        self.baseThemeId = baseThemeId
        self.configuration = configuration
        self.createdTime = createdTime
        self.description = description
        self.errors = errors
        self.status = status
        self.versionNumber = versionNumber
    }
}

extension ThemeVersionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case status = "Status"
        case versionNumber = "VersionNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let versionNumber = versionNumber {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionNumberDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResourceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ThemeVersionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThemeVersionSummary(arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), description: \(String(describing: description)), status: \(String(describing: status)), versionNumber: \(String(describing: versionNumber)))"}
}

/// <p>The theme version.</p>
public struct ThemeVersionSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the theme version.</p>
    public let arn: String?
    /// <p>The date and time that this theme version was created.</p>
    public let createdTime: Date?
    /// <p>The description of the theme version.</p>
    public let description: String?
    /// <p>The status of the theme version.</p>
    public let status: ResourceStatus?
    /// <p>The version number of the theme version.</p>
    public let versionNumber: Int?

    public init (
        arn: String? = nil,
        createdTime: Date? = nil,
        description: String? = nil,
        status: ResourceStatus? = nil,
        versionNumber: Int? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.description = description
        self.status = status
        self.versionNumber = versionNumber
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Access is throttled.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The AWS request ID for this request.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension TileLayoutStyle: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gutter = "Gutter"
        case margin = "Margin"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gutter = gutter {
            try encodeContainer.encode(gutter, forKey: .gutter)
        }
        if let margin = margin {
            try encodeContainer.encode(margin, forKey: .margin)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gutterDecoded = try containerValues.decodeIfPresent(GutterStyle.self, forKey: .gutter)
        gutter = gutterDecoded
        let marginDecoded = try containerValues.decodeIfPresent(MarginStyle.self, forKey: .margin)
        margin = marginDecoded
    }
}

extension TileLayoutStyle: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TileLayoutStyle(gutter: \(String(describing: gutter)), margin: \(String(describing: margin)))"}
}

/// <p>The display options for the layout of tiles on a sheet.</p>
public struct TileLayoutStyle: Equatable {
    /// <p>The gutter settings that apply between tiles. </p>
    public let gutter: GutterStyle?
    /// <p>The margin settings that apply around the outside edge of sheets.</p>
    public let margin: MarginStyle?

    public init (
        gutter: GutterStyle? = nil,
        margin: MarginStyle? = nil
    )
    {
        self.gutter = gutter
        self.margin = margin
    }
}

extension TileStyle: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case border = "Border"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let border = border {
            try encodeContainer.encode(border, forKey: .border)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let borderDecoded = try containerValues.decodeIfPresent(BorderStyle.self, forKey: .border)
        border = borderDecoded
    }
}

extension TileStyle: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TileStyle(border: \(String(describing: border)))"}
}

/// <p>Display options related to tiles on a sheet.</p>
public struct TileStyle: Equatable {
    /// <p>The border around a tile.</p>
    public let border: BorderStyle?

    public init (
        border: BorderStyle? = nil
    )
    {
        self.border = border
    }
}

extension TransformOperation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case castColumnTypeOperation = "CastColumnTypeOperation"
        case createColumnsOperation = "CreateColumnsOperation"
        case filterOperation = "FilterOperation"
        case projectOperation = "ProjectOperation"
        case renameColumnOperation = "RenameColumnOperation"
        case tagColumnOperation = "TagColumnOperation"
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .castColumnTypeOperation(castColumnTypeOperation):
                if let castColumnTypeOperation = castColumnTypeOperation {
                    try container.encode(castColumnTypeOperation, forKey: .castColumnTypeOperation)
                }
            case let .createColumnsOperation(createColumnsOperation):
                if let createColumnsOperation = createColumnsOperation {
                    try container.encode(createColumnsOperation, forKey: .createColumnsOperation)
                }
            case let .filterOperation(filterOperation):
                if let filterOperation = filterOperation {
                    try container.encode(filterOperation, forKey: .filterOperation)
                }
            case let .projectOperation(projectOperation):
                if let projectOperation = projectOperation {
                    try container.encode(projectOperation, forKey: .projectOperation)
                }
            case let .renameColumnOperation(renameColumnOperation):
                if let renameColumnOperation = renameColumnOperation {
                    try container.encode(renameColumnOperation, forKey: .renameColumnOperation)
                }
            case let .tagColumnOperation(tagColumnOperation):
                if let tagColumnOperation = tagColumnOperation {
                    try container.encode(tagColumnOperation, forKey: .tagColumnOperation)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let projectOperationDecoded = try values.decodeIfPresent(ProjectOperation.self, forKey: .projectOperation)
        if let projectOperation = projectOperationDecoded {
            self = .projectOperation(projectOperation)
            return
        }
        let filterOperationDecoded = try values.decodeIfPresent(FilterOperation.self, forKey: .filterOperation)
        if let filterOperation = filterOperationDecoded {
            self = .filterOperation(filterOperation)
            return
        }
        let createColumnsOperationDecoded = try values.decodeIfPresent(CreateColumnsOperation.self, forKey: .createColumnsOperation)
        if let createColumnsOperation = createColumnsOperationDecoded {
            self = .createColumnsOperation(createColumnsOperation)
            return
        }
        let renameColumnOperationDecoded = try values.decodeIfPresent(RenameColumnOperation.self, forKey: .renameColumnOperation)
        if let renameColumnOperation = renameColumnOperationDecoded {
            self = .renameColumnOperation(renameColumnOperation)
            return
        }
        let castColumnTypeOperationDecoded = try values.decodeIfPresent(CastColumnTypeOperation.self, forKey: .castColumnTypeOperation)
        if let castColumnTypeOperation = castColumnTypeOperationDecoded {
            self = .castColumnTypeOperation(castColumnTypeOperation)
            return
        }
        let tagColumnOperationDecoded = try values.decodeIfPresent(TagColumnOperation.self, forKey: .tagColumnOperation)
        if let tagColumnOperation = tagColumnOperationDecoded {
            self = .tagColumnOperation(tagColumnOperation)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>A data transformation on a logical table. This is a variant type structure. For this
///             structure to be valid, only one of the attributes can be non-null.</p>
public enum TransformOperation: Equatable {
    /// <p>An operation that projects columns. Operations that come after a projection can only
    ///             refer to projected columns.</p>
    case projectOperation(ProjectOperation?)
    /// <p>An operation that filters rows based on some condition.</p>
    case filterOperation(FilterOperation?)
    /// <p>An operation that creates calculated columns. Columns created in one such operation
    ///             form a lexical closure.</p>
    case createColumnsOperation(CreateColumnsOperation?)
    /// <p>An operation that renames a column.</p>
    case renameColumnOperation(RenameColumnOperation?)
    /// <p>A transform operation that casts a column to a different type.</p>
    case castColumnTypeOperation(CastColumnTypeOperation?)
    /// <p>An operation that tags a column with additional information.</p>
    case tagColumnOperation(TagColumnOperation?)
    case sdkUnknown(String?)
}

extension TwitterParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxRows = "MaxRows"
        case query = "Query"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxRows != 0 {
            try encodeContainer.encode(maxRows, forKey: .maxRows)
        }
        if let query = query {
            try encodeContainer.encode(query, forKey: .query)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .query)
        query = queryDecoded
        let maxRowsDecoded = try containerValues.decode(Int.self, forKey: .maxRows)
        maxRows = maxRowsDecoded
    }
}

extension TwitterParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TwitterParameters(maxRows: \(String(describing: maxRows)), query: \(String(describing: query)))"}
}

/// <p>Twitter parameters.</p>
public struct TwitterParameters: Equatable {
    /// <p>Maximum number of rows to query Twitter.</p>
    public let maxRows: Int
    /// <p>Twitter query string.</p>
    public let query: String?

    public init (
        maxRows: Int = 0,
        query: String? = nil
    )
    {
        self.maxRows = maxRows
        self.query = query
    }
}

extension UIColorPalette: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accent = "Accent"
        case accentForeground = "AccentForeground"
        case danger = "Danger"
        case dangerForeground = "DangerForeground"
        case dimension = "Dimension"
        case dimensionForeground = "DimensionForeground"
        case measure = "Measure"
        case measureForeground = "MeasureForeground"
        case primaryBackground = "PrimaryBackground"
        case primaryForeground = "PrimaryForeground"
        case secondaryBackground = "SecondaryBackground"
        case secondaryForeground = "SecondaryForeground"
        case success = "Success"
        case successForeground = "SuccessForeground"
        case warning = "Warning"
        case warningForeground = "WarningForeground"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accent = accent {
            try encodeContainer.encode(accent, forKey: .accent)
        }
        if let accentForeground = accentForeground {
            try encodeContainer.encode(accentForeground, forKey: .accentForeground)
        }
        if let danger = danger {
            try encodeContainer.encode(danger, forKey: .danger)
        }
        if let dangerForeground = dangerForeground {
            try encodeContainer.encode(dangerForeground, forKey: .dangerForeground)
        }
        if let dimension = dimension {
            try encodeContainer.encode(dimension, forKey: .dimension)
        }
        if let dimensionForeground = dimensionForeground {
            try encodeContainer.encode(dimensionForeground, forKey: .dimensionForeground)
        }
        if let measure = measure {
            try encodeContainer.encode(measure, forKey: .measure)
        }
        if let measureForeground = measureForeground {
            try encodeContainer.encode(measureForeground, forKey: .measureForeground)
        }
        if let primaryBackground = primaryBackground {
            try encodeContainer.encode(primaryBackground, forKey: .primaryBackground)
        }
        if let primaryForeground = primaryForeground {
            try encodeContainer.encode(primaryForeground, forKey: .primaryForeground)
        }
        if let secondaryBackground = secondaryBackground {
            try encodeContainer.encode(secondaryBackground, forKey: .secondaryBackground)
        }
        if let secondaryForeground = secondaryForeground {
            try encodeContainer.encode(secondaryForeground, forKey: .secondaryForeground)
        }
        if let success = success {
            try encodeContainer.encode(success, forKey: .success)
        }
        if let successForeground = successForeground {
            try encodeContainer.encode(successForeground, forKey: .successForeground)
        }
        if let warning = warning {
            try encodeContainer.encode(warning, forKey: .warning)
        }
        if let warningForeground = warningForeground {
            try encodeContainer.encode(warningForeground, forKey: .warningForeground)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let primaryForegroundDecoded = try containerValues.decodeIfPresent(String.self, forKey: .primaryForeground)
        primaryForeground = primaryForegroundDecoded
        let primaryBackgroundDecoded = try containerValues.decodeIfPresent(String.self, forKey: .primaryBackground)
        primaryBackground = primaryBackgroundDecoded
        let secondaryForegroundDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secondaryForeground)
        secondaryForeground = secondaryForegroundDecoded
        let secondaryBackgroundDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secondaryBackground)
        secondaryBackground = secondaryBackgroundDecoded
        let accentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accent)
        accent = accentDecoded
        let accentForegroundDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accentForeground)
        accentForeground = accentForegroundDecoded
        let dangerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .danger)
        danger = dangerDecoded
        let dangerForegroundDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dangerForeground)
        dangerForeground = dangerForegroundDecoded
        let warningDecoded = try containerValues.decodeIfPresent(String.self, forKey: .warning)
        warning = warningDecoded
        let warningForegroundDecoded = try containerValues.decodeIfPresent(String.self, forKey: .warningForeground)
        warningForeground = warningForegroundDecoded
        let successDecoded = try containerValues.decodeIfPresent(String.self, forKey: .success)
        success = successDecoded
        let successForegroundDecoded = try containerValues.decodeIfPresent(String.self, forKey: .successForeground)
        successForeground = successForegroundDecoded
        let dimensionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dimension)
        dimension = dimensionDecoded
        let dimensionForegroundDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dimensionForeground)
        dimensionForeground = dimensionForegroundDecoded
        let measureDecoded = try containerValues.decodeIfPresent(String.self, forKey: .measure)
        measure = measureDecoded
        let measureForegroundDecoded = try containerValues.decodeIfPresent(String.self, forKey: .measureForeground)
        measureForeground = measureForegroundDecoded
    }
}

extension UIColorPalette: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UIColorPalette(accent: \(String(describing: accent)), accentForeground: \(String(describing: accentForeground)), danger: \(String(describing: danger)), dangerForeground: \(String(describing: dangerForeground)), dimension: \(String(describing: dimension)), dimensionForeground: \(String(describing: dimensionForeground)), measure: \(String(describing: measure)), measureForeground: \(String(describing: measureForeground)), primaryBackground: \(String(describing: primaryBackground)), primaryForeground: \(String(describing: primaryForeground)), secondaryBackground: \(String(describing: secondaryBackground)), secondaryForeground: \(String(describing: secondaryForeground)), success: \(String(describing: success)), successForeground: \(String(describing: successForeground)), warning: \(String(describing: warning)), warningForeground: \(String(describing: warningForeground)))"}
}

/// <p>The theme colors that apply to UI and to charts, excluding data colors. The colors
///             description is a hexadecimal color code that consists of six alphanumerical characters,
///             prefixed with <code>#</code>, for example #37BFF5. For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/themes-in-quicksight.html">Using Themes in Amazon QuickSight</a> in the <i>Amazon QuickSight User
///                 Guide.</i>
///         </p>
public struct UIColorPalette: Equatable {
    /// <p>This color is that applies to selected states and buttons.</p>
    public let accent: String?
    /// <p>The foreground color that applies to any text or other elements that appear over the
    ///             accent color.</p>
    public let accentForeground: String?
    /// <p>The color that applies to error messages.</p>
    public let danger: String?
    /// <p>The foreground color that applies to any text or other elements that appear over the
    ///             error color.</p>
    public let dangerForeground: String?
    /// <p>The color that applies to the names of fields that are identified as
    ///             dimensions.</p>
    public let dimension: String?
    /// <p>The foreground color that applies to any text or other elements that appear over the
    ///             dimension color.</p>
    public let dimensionForeground: String?
    /// <p>The color that applies to the names of fields that are identified as measures.</p>
    public let measure: String?
    /// <p>The foreground color that applies to any text or other elements that appear over the
    ///             measure color.</p>
    public let measureForeground: String?
    /// <p>The background color that applies to visuals and other high emphasis UI.</p>
    public let primaryBackground: String?
    /// <p>The color of text and other foreground elements that appear over the primary
    ///             background regions, such as grid lines, borders, table banding, icons, and so on.</p>
    public let primaryForeground: String?
    /// <p>The background color that applies to the sheet background and sheet controls.</p>
    public let secondaryBackground: String?
    /// <p>The foreground color that applies to any sheet title, sheet control text, or UI that
    ///             appears over the secondary background.</p>
    public let secondaryForeground: String?
    /// <p>The color that applies to success messages, for example the check mark for a
    ///             successful download.</p>
    public let success: String?
    /// <p>The foreground color that applies to any text or other elements that appear over the
    ///             success color.</p>
    public let successForeground: String?
    /// <p>This color that applies to warning and informational messages.</p>
    public let warning: String?
    /// <p>The foreground color that applies to any text or other elements that appear over the
    ///             warning color.</p>
    public let warningForeground: String?

    public init (
        accent: String? = nil,
        accentForeground: String? = nil,
        danger: String? = nil,
        dangerForeground: String? = nil,
        dimension: String? = nil,
        dimensionForeground: String? = nil,
        measure: String? = nil,
        measureForeground: String? = nil,
        primaryBackground: String? = nil,
        primaryForeground: String? = nil,
        secondaryBackground: String? = nil,
        secondaryForeground: String? = nil,
        success: String? = nil,
        successForeground: String? = nil,
        warning: String? = nil,
        warningForeground: String? = nil
    )
    {
        self.accent = accent
        self.accentForeground = accentForeground
        self.danger = danger
        self.dangerForeground = dangerForeground
        self.dimension = dimension
        self.dimensionForeground = dimensionForeground
        self.measure = measure
        self.measureForeground = measureForeground
        self.primaryBackground = primaryBackground
        self.primaryForeground = primaryForeground
        self.secondaryBackground = secondaryBackground
        self.secondaryForeground = secondaryForeground
        self.success = success
        self.successForeground = successForeground
        self.warning = warning
        self.warningForeground = warningForeground
    }
}

extension UnsupportedPricingPlanException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedPricingPlanException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension UnsupportedPricingPlanException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedPricingPlanExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This error indicates that you are calling an embedding operation in Amazon QuickSight
/// 			without the required pricing plan on your AWS account. Before you can use embedding
/// 			for anonymous users, a QuickSight administrator needs to add capacity pricing to QuickSight. You
/// 		    can do this on the <b>Manage QuickSight</b> page. </p>
///         <p>After capacity pricing is added, you can use the
///             <a>GetDashboardEmbedUrl</a> API operation with the
///             <code>--identity-type ANONYMOUS</code> option.</p>
public struct UnsupportedPricingPlanException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The AWS request ID for this request.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct UnsupportedPricingPlanExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension UnsupportedPricingPlanExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension UnsupportedUserEditionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedUserEditionException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension UnsupportedUserEditionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedUserEditionExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This error indicates that you are calling an operation on an Amazon QuickSight
/// 			subscription where the edition doesn't include support for that operation. Amazon
/// 			QuickSight currently has Standard Edition and Enterprise Edition. Not every operation and
/// 			capability is available in every edition.</p>
public struct UnsupportedUserEditionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The AWS request ID for this request.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct UnsupportedUserEditionExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension UnsupportedUserEditionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "keys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to untag.</p>
    public let resourceArn: String?
    /// <p>The keys of the key-value pairs for the resource tag or tags assigned to the resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse(requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UntagResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.requestId = output.requestId
        } else {
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UntagResourceOutputResponse: Equatable {
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

struct UntagResourceOutputResponseBody: Equatable {
    public let requestId: String?
    public let status: Int
}

extension UntagResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

public struct UpdateAccountCustomizationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAccountCustomizationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAccountCustomizationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAccountCustomizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAccountCustomizationInput>
    public typealias MOutput = OperationOutput<UpdateAccountCustomizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAccountCustomizationOutputError>
}

extension UpdateAccountCustomizationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAccountCustomizationInput(accountCustomization: \(String(describing: accountCustomization)), awsAccountId: \(String(describing: awsAccountId)), namespace: \(String(describing: namespace)))"}
}

extension UpdateAccountCustomizationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountCustomization = "AccountCustomization"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountCustomization = accountCustomization {
            try encodeContainer.encode(accountCustomization, forKey: .accountCustomization)
        }
    }
}

public struct UpdateAccountCustomizationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAccountCustomizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAccountCustomizationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAccountCustomizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAccountCustomizationInput>
    public typealias MOutput = OperationOutput<UpdateAccountCustomizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAccountCustomizationOutputError>
}

public struct UpdateAccountCustomizationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAccountCustomizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAccountCustomizationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAccountCustomizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let namespace = input.operationInput.namespace {
            let namespaceQueryItem = URLQueryItem(name: "namespace".urlPercentEncoding(), value: String(namespace).urlPercentEncoding())
            input.builder.withQueryItem(namespaceQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAccountCustomizationInput>
    public typealias MOutput = OperationOutput<UpdateAccountCustomizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAccountCustomizationOutputError>
}

public struct UpdateAccountCustomizationInput: Equatable {
    /// <p>The QuickSight customizations you're updating in the current AWS Region. </p>
    public let accountCustomization: AccountCustomization?
    /// <p>The ID for the AWS account that you want to update QuickSight customizations
    ///             for.</p>
    public let awsAccountId: String?
    /// <p>The namespace that you want to update QuickSight customizations for.</p>
    public let namespace: String?

    public init (
        accountCustomization: AccountCustomization? = nil,
        awsAccountId: String? = nil,
        namespace: String? = nil
    )
    {
        self.accountCustomization = accountCustomization
        self.awsAccountId = awsAccountId
        self.namespace = namespace
    }
}

struct UpdateAccountCustomizationInputBody: Equatable {
    public let accountCustomization: AccountCustomization?
}

extension UpdateAccountCustomizationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountCustomization = "AccountCustomization"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountCustomizationDecoded = try containerValues.decodeIfPresent(AccountCustomization.self, forKey: .accountCustomization)
        accountCustomization = accountCustomizationDecoded
    }
}

extension UpdateAccountCustomizationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAccountCustomizationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAccountCustomizationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAccountCustomizationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAccountCustomizationOutputResponse(accountCustomization: \(String(describing: accountCustomization)), arn: \(String(describing: arn)), awsAccountId: \(String(describing: awsAccountId)), namespace: \(String(describing: namespace)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension UpdateAccountCustomizationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAccountCustomizationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountCustomization = output.accountCustomization
            self.arn = output.arn
            self.awsAccountId = output.awsAccountId
            self.namespace = output.namespace
            self.requestId = output.requestId
        } else {
            self.accountCustomization = nil
            self.arn = nil
            self.awsAccountId = nil
            self.namespace = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateAccountCustomizationOutputResponse: Equatable {
    /// <p>The QuickSight customizations you're updating in the current AWS Region. </p>
    public let accountCustomization: AccountCustomization?
    /// <p>The Amazon Resource Name (ARN) for the updated customization for this AWS account.</p>
    public let arn: String?
    /// <p>The ID for the AWS account that you want to update QuickSight customizations
    ///             for.</p>
    public let awsAccountId: String?
    /// <p>The namespace associated with the customization that you're updating.</p>
    public let namespace: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        accountCustomization: AccountCustomization? = nil,
        arn: String? = nil,
        awsAccountId: String? = nil,
        namespace: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.accountCustomization = accountCustomization
        self.arn = arn
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateAccountCustomizationOutputResponseBody: Equatable {
    public let arn: String?
    public let awsAccountId: String?
    public let namespace: String?
    public let accountCustomization: AccountCustomization?
    public let requestId: String?
    public let status: Int
}

extension UpdateAccountCustomizationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountCustomization = "AccountCustomization"
        case arn = "Arn"
        case awsAccountId = "AwsAccountId"
        case namespace = "Namespace"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let accountCustomizationDecoded = try containerValues.decodeIfPresent(AccountCustomization.self, forKey: .accountCustomization)
        accountCustomization = accountCustomizationDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

public struct UpdateAccountSettingsInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAccountSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAccountSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAccountSettingsInput>
    public typealias MOutput = OperationOutput<UpdateAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAccountSettingsOutputError>
}

extension UpdateAccountSettingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAccountSettingsInput(awsAccountId: \(String(describing: awsAccountId)), defaultNamespace: \(String(describing: defaultNamespace)), notificationEmail: \(String(describing: notificationEmail)))"}
}

extension UpdateAccountSettingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultNamespace = "DefaultNamespace"
        case notificationEmail = "NotificationEmail"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultNamespace = defaultNamespace {
            try encodeContainer.encode(defaultNamespace, forKey: .defaultNamespace)
        }
        if let notificationEmail = notificationEmail {
            try encodeContainer.encode(notificationEmail, forKey: .notificationEmail)
        }
    }
}

public struct UpdateAccountSettingsInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAccountSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAccountSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAccountSettingsInput>
    public typealias MOutput = OperationOutput<UpdateAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAccountSettingsOutputError>
}

public struct UpdateAccountSettingsInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAccountSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAccountSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAccountSettingsInput>
    public typealias MOutput = OperationOutput<UpdateAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAccountSettingsOutputError>
}

public struct UpdateAccountSettingsInput: Equatable {
    /// <p>The ID for the AWS account that contains the QuickSight settings that you want to
    ///             list.</p>
    public let awsAccountId: String?
    /// <p>The default namespace for this AWS account. Currently, the default is
    ///                 <code>default</code>. AWS Identity and Access Management (IAM) users that register
    ///             for the first time with QuickSight provide an email that becomes associated with the
    ///             default namespace.</p>
    public let defaultNamespace: String?
    /// <p>The email address that you want QuickSight to send notifications to regarding your AWS
    ///             account or QuickSight subscription.</p>
    public let notificationEmail: String?

    public init (
        awsAccountId: String? = nil,
        defaultNamespace: String? = nil,
        notificationEmail: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.defaultNamespace = defaultNamespace
        self.notificationEmail = notificationEmail
    }
}

struct UpdateAccountSettingsInputBody: Equatable {
    public let defaultNamespace: String?
    public let notificationEmail: String?
}

extension UpdateAccountSettingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case defaultNamespace = "DefaultNamespace"
        case notificationEmail = "NotificationEmail"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultNamespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultNamespace)
        defaultNamespace = defaultNamespaceDecoded
        let notificationEmailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .notificationEmail)
        notificationEmail = notificationEmailDecoded
    }
}

extension UpdateAccountSettingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAccountSettingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAccountSettingsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAccountSettingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAccountSettingsOutputResponse(requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension UpdateAccountSettingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAccountSettingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.requestId = output.requestId
        } else {
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateAccountSettingsOutputResponse: Equatable {
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateAccountSettingsOutputResponseBody: Equatable {
    public let requestId: String?
    public let status: Int
}

extension UpdateAccountSettingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

public struct UpdateAnalysisInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAnalysisInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAnalysisInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAnalysisInput>
    public typealias MOutput = OperationOutput<UpdateAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAnalysisOutputError>
}

extension UpdateAnalysisInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAnalysisInput(analysisId: \(String(describing: analysisId)), awsAccountId: \(String(describing: awsAccountId)), name: \(String(describing: name)), parameters: \(String(describing: parameters)), sourceEntity: \(String(describing: sourceEntity)), themeArn: \(String(describing: themeArn)))"}
}

extension UpdateAnalysisInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case parameters = "Parameters"
        case sourceEntity = "SourceEntity"
        case themeArn = "ThemeArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let sourceEntity = sourceEntity {
            try encodeContainer.encode(sourceEntity, forKey: .sourceEntity)
        }
        if let themeArn = themeArn {
            try encodeContainer.encode(themeArn, forKey: .themeArn)
        }
    }
}

public struct UpdateAnalysisInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAnalysisInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAnalysisInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAnalysisInput>
    public typealias MOutput = OperationOutput<UpdateAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAnalysisOutputError>
}

public struct UpdateAnalysisInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAnalysisInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAnalysisInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAnalysisInput>
    public typealias MOutput = OperationOutput<UpdateAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAnalysisOutputError>
}

public struct UpdateAnalysisInput: Equatable {
    /// <p>The ID for the analysis that you're updating. This ID displays in the URL of the
    ///             analysis.</p>
    public let analysisId: String?
    /// <p>The ID of the AWS account that contains the analysis that you're updating.</p>
    public let awsAccountId: String?
    /// <p>A descriptive name for the analysis that you're updating. This name displays for the
    ///             analysis in the QuickSight console.</p>
    public let name: String?
    /// <p>The parameter names and override values that you want to use. An analysis can have
    ///             any parameter type, and some parameters might accept multiple values. </p>
    public let parameters: Parameters?
    /// <p>A source entity to use for the analysis that you're updating. This metadata structure
    ///             contains details that describe a source template and one or more datasets.</p>
    public let sourceEntity: AnalysisSourceEntity?
    /// <p>The Amazon Resource Name (ARN) for the theme to apply to the analysis that you're
    ///             creating. To see the theme in the QuickSight console, make sure that you have access to
    ///             it.</p>
    public let themeArn: String?

    public init (
        analysisId: String? = nil,
        awsAccountId: String? = nil,
        name: String? = nil,
        parameters: Parameters? = nil,
        sourceEntity: AnalysisSourceEntity? = nil,
        themeArn: String? = nil
    )
    {
        self.analysisId = analysisId
        self.awsAccountId = awsAccountId
        self.name = name
        self.parameters = parameters
        self.sourceEntity = sourceEntity
        self.themeArn = themeArn
    }
}

struct UpdateAnalysisInputBody: Equatable {
    public let name: String?
    public let parameters: Parameters?
    public let sourceEntity: AnalysisSourceEntity?
    public let themeArn: String?
}

extension UpdateAnalysisInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case parameters = "Parameters"
        case sourceEntity = "SourceEntity"
        case themeArn = "ThemeArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(Parameters.self, forKey: .parameters)
        parameters = parametersDecoded
        let sourceEntityDecoded = try containerValues.decodeIfPresent(AnalysisSourceEntity.self, forKey: .sourceEntity)
        sourceEntity = sourceEntityDecoded
        let themeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .themeArn)
        themeArn = themeArnDecoded
    }
}

extension UpdateAnalysisOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAnalysisOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAnalysisOutputError: Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAnalysisOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAnalysisOutputResponse(analysisId: \(String(describing: analysisId)), arn: \(String(describing: arn)), requestId: \(String(describing: requestId)), status: \(String(describing: status)), updateStatus: \(String(describing: updateStatus)))"}
}

extension UpdateAnalysisOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.analysisId = output.analysisId
            self.arn = output.arn
            self.requestId = output.requestId
            self.updateStatus = output.updateStatus
        } else {
            self.analysisId = nil
            self.arn = nil
            self.requestId = nil
            self.updateStatus = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateAnalysisOutputResponse: Equatable {
    /// <p>The ID of the analysis.</p>
    public let analysisId: String?
    /// <p>The ARN of the analysis that you're updating.</p>
    public let arn: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>The update status of the last update that was made to the analysis.</p>
    public let updateStatus: ResourceStatus?

    public init (
        analysisId: String? = nil,
        arn: String? = nil,
        requestId: String? = nil,
        status: Int = 0,
        updateStatus: ResourceStatus? = nil
    )
    {
        self.analysisId = analysisId
        self.arn = arn
        self.requestId = requestId
        self.status = status
        self.updateStatus = updateStatus
    }
}

struct UpdateAnalysisOutputResponseBody: Equatable {
    public let arn: String?
    public let analysisId: String?
    public let updateStatus: ResourceStatus?
    public let status: Int
    public let requestId: String?
}

extension UpdateAnalysisOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analysisId = "AnalysisId"
        case arn = "Arn"
        case requestId = "RequestId"
        case status = "Status"
        case updateStatus = "UpdateStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let analysisIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .analysisId)
        analysisId = analysisIdDecoded
        let updateStatusDecoded = try containerValues.decodeIfPresent(ResourceStatus.self, forKey: .updateStatus)
        updateStatus = updateStatusDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

public struct UpdateAnalysisPermissionsInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAnalysisPermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAnalysisPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAnalysisPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAnalysisPermissionsInput>
    public typealias MOutput = OperationOutput<UpdateAnalysisPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAnalysisPermissionsOutputError>
}

extension UpdateAnalysisPermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAnalysisPermissionsInput(analysisId: \(String(describing: analysisId)), awsAccountId: \(String(describing: awsAccountId)), grantPermissions: \(String(describing: grantPermissions)), revokePermissions: \(String(describing: revokePermissions)))"}
}

extension UpdateAnalysisPermissionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantPermissions = grantPermissions {
            var grantPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantPermissions)
            for updateresourcepermissionlist0 in grantPermissions {
                try grantPermissionsContainer.encode(updateresourcepermissionlist0)
            }
        }
        if let revokePermissions = revokePermissions {
            var revokePermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .revokePermissions)
            for updateresourcepermissionlist0 in revokePermissions {
                try revokePermissionsContainer.encode(updateresourcepermissionlist0)
            }
        }
    }
}

public struct UpdateAnalysisPermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAnalysisPermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAnalysisPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAnalysisPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAnalysisPermissionsInput>
    public typealias MOutput = OperationOutput<UpdateAnalysisPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAnalysisPermissionsOutputError>
}

public struct UpdateAnalysisPermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAnalysisPermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAnalysisPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAnalysisPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAnalysisPermissionsInput>
    public typealias MOutput = OperationOutput<UpdateAnalysisPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAnalysisPermissionsOutputError>
}

public struct UpdateAnalysisPermissionsInput: Equatable {
    /// <p>The ID of the analysis whose permissions you're updating. The ID is part of the
    ///             analysis URL.</p>
    public let analysisId: String?
    /// <p>The ID of the AWS account that contains the analysis whose permissions you're
    ///             updating. You must be using the AWS account that the analysis is in.</p>
    public let awsAccountId: String?
    /// <p>A structure that describes the permissions to add and the principal to add them
    ///             to.</p>
    public let grantPermissions: [ResourcePermission]?
    /// <p>A structure that describes the permissions to remove and the principal to remove them
    ///             from.</p>
    public let revokePermissions: [ResourcePermission]?

    public init (
        analysisId: String? = nil,
        awsAccountId: String? = nil,
        grantPermissions: [ResourcePermission]? = nil,
        revokePermissions: [ResourcePermission]? = nil
    )
    {
        self.analysisId = analysisId
        self.awsAccountId = awsAccountId
        self.grantPermissions = grantPermissions
        self.revokePermissions = revokePermissions
    }
}

struct UpdateAnalysisPermissionsInputBody: Equatable {
    public let grantPermissions: [ResourcePermission]?
    public let revokePermissions: [ResourcePermission]?
}

extension UpdateAnalysisPermissionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantPermissionsContainer = try containerValues.decodeIfPresent([ResourcePermission?].self, forKey: .grantPermissions)
        var grantPermissionsDecoded0:[ResourcePermission]? = nil
        if let grantPermissionsContainer = grantPermissionsContainer {
            grantPermissionsDecoded0 = [ResourcePermission]()
            for structure0 in grantPermissionsContainer {
                if let structure0 = structure0 {
                    grantPermissionsDecoded0?.append(structure0)
                }
            }
        }
        grantPermissions = grantPermissionsDecoded0
        let revokePermissionsContainer = try containerValues.decodeIfPresent([ResourcePermission?].self, forKey: .revokePermissions)
        var revokePermissionsDecoded0:[ResourcePermission]? = nil
        if let revokePermissionsContainer = revokePermissionsContainer {
            revokePermissionsDecoded0 = [ResourcePermission]()
            for structure0 in revokePermissionsContainer {
                if let structure0 = structure0 {
                    revokePermissionsDecoded0?.append(structure0)
                }
            }
        }
        revokePermissions = revokePermissionsDecoded0
    }
}

extension UpdateAnalysisPermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAnalysisPermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAnalysisPermissionsOutputError: Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAnalysisPermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAnalysisPermissionsOutputResponse(analysisArn: \(String(describing: analysisArn)), analysisId: \(String(describing: analysisId)), permissions: \(String(describing: permissions)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension UpdateAnalysisPermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAnalysisPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.analysisArn = output.analysisArn
            self.analysisId = output.analysisId
            self.permissions = output.permissions
            self.requestId = output.requestId
        } else {
            self.analysisArn = nil
            self.analysisId = nil
            self.permissions = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateAnalysisPermissionsOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the analysis that you updated.</p>
    public let analysisArn: String?
    /// <p>The ID of the analysis that you updated permissions for.</p>
    public let analysisId: String?
    /// <p>A structure that describes the principals and the resource-level permissions on an
    ///             analysis.</p>
    public let permissions: [ResourcePermission]?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        analysisArn: String? = nil,
        analysisId: String? = nil,
        permissions: [ResourcePermission]? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.analysisArn = analysisArn
        self.analysisId = analysisId
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateAnalysisPermissionsOutputResponseBody: Equatable {
    public let analysisArn: String?
    public let analysisId: String?
    public let permissions: [ResourcePermission]?
    public let requestId: String?
    public let status: Int
}

extension UpdateAnalysisPermissionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analysisArn = "AnalysisArn"
        case analysisId = "AnalysisId"
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .analysisArn)
        analysisArn = analysisArnDecoded
        let analysisIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .analysisId)
        analysisId = analysisIdDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

public struct UpdateDashboardInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDashboardInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDashboardInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDashboardInput>
    public typealias MOutput = OperationOutput<UpdateDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDashboardOutputError>
}

extension UpdateDashboardInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDashboardInput(awsAccountId: \(String(describing: awsAccountId)), dashboardId: \(String(describing: dashboardId)), dashboardPublishOptions: \(String(describing: dashboardPublishOptions)), name: \(String(describing: name)), parameters: \(String(describing: parameters)), sourceEntity: \(String(describing: sourceEntity)), themeArn: \(String(describing: themeArn)), versionDescription: \(String(describing: versionDescription)))"}
}

extension UpdateDashboardInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dashboardPublishOptions = "DashboardPublishOptions"
        case name = "Name"
        case parameters = "Parameters"
        case sourceEntity = "SourceEntity"
        case themeArn = "ThemeArn"
        case versionDescription = "VersionDescription"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dashboardPublishOptions = dashboardPublishOptions {
            try encodeContainer.encode(dashboardPublishOptions, forKey: .dashboardPublishOptions)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let sourceEntity = sourceEntity {
            try encodeContainer.encode(sourceEntity, forKey: .sourceEntity)
        }
        if let themeArn = themeArn {
            try encodeContainer.encode(themeArn, forKey: .themeArn)
        }
        if let versionDescription = versionDescription {
            try encodeContainer.encode(versionDescription, forKey: .versionDescription)
        }
    }
}

public struct UpdateDashboardInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDashboardInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDashboardInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDashboardInput>
    public typealias MOutput = OperationOutput<UpdateDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDashboardOutputError>
}

public struct UpdateDashboardInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDashboardInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDashboardInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDashboardInput>
    public typealias MOutput = OperationOutput<UpdateDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDashboardOutputError>
}

public struct UpdateDashboardInput: Equatable {
    /// <p>The ID of the AWS account that contains the dashboard that you're
    ///             updating.</p>
    public let awsAccountId: String?
    /// <p>The ID for the dashboard.</p>
    public let dashboardId: String?
    /// <p>Options for publishing the dashboard when you create it:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>AvailabilityStatus</code> for <code>AdHocFilteringOption</code> - This
    ///                     status can be either <code>ENABLED</code> or <code>DISABLED</code>. When this is
    ///                     set to <code>DISABLED</code>, QuickSight disables the left filter pane on the
    ///                     published dashboard, which can be used for ad hoc (one-time) filtering. This
    ///                     option is <code>ENABLED</code> by default. </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>AvailabilityStatus</code> for <code>ExportToCSVOption</code> - This
    ///                     status can be either <code>ENABLED</code> or <code>DISABLED</code>. The visual
    ///                     option to export data to .CSV format isn't enabled when this is set to
    ///                     <code>DISABLED</code>. This option is <code>ENABLED</code> by default. </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>VisibilityState</code> for <code>SheetControlsOption</code> - This
    ///                     visibility state can be either <code>COLLAPSED</code> or <code>EXPANDED</code>.
    ///                     This option is <code>COLLAPSED</code> by default. </p>
    ///             </li>
    ///          </ul>
    public let dashboardPublishOptions: DashboardPublishOptions?
    /// <p>The display name of the dashboard.</p>
    public let name: String?
    /// <p>A structure that contains the parameters of the dashboard. These are parameter
    ///             overrides for a dashboard. A dashboard can have any type of parameters, and some
    ///             parameters might accept multiple values.</p>
    public let parameters: Parameters?
    /// <p>The entity that you are using as a source when you update the dashboard. In
    ///             <code>SourceEntity</code>, you specify the type of object you're using as source. You
    ///             can only update a dashboard from a template, so you use a <code>SourceTemplate</code>
    ///             entity. If you need to update a dashboard from an analysis, first convert the analysis
    ///             to a template by using the <a>CreateTemplate</a> API operation. For
    ///             <code>SourceTemplate</code>, specify the Amazon Resource Name (ARN) of the source
    ///             template. The <code>SourceTemplate</code> ARN can contain any AWS Account and any
    ///             QuickSight-supported AWS Region. </p>
    ///         <p>Use the <code>DataSetReferences</code> entity within <code>SourceTemplate</code> to
    ///             list the replacement datasets for the placeholders listed in the original. The schema in
    ///             each dataset must match its placeholder. </p>
    public let sourceEntity: DashboardSourceEntity?
    /// <p>The Amazon Resource Name (ARN) of the theme that is being used for this dashboard. If
    ///             you add a value for this field, it overrides the value that was originally associated
    ///             with the entity. The theme ARN must exist in the same AWS account where you create the
    ///             dashboard.</p>
    public let themeArn: String?
    /// <p>A description for the first version of the dashboard being created.</p>
    public let versionDescription: String?

    public init (
        awsAccountId: String? = nil,
        dashboardId: String? = nil,
        dashboardPublishOptions: DashboardPublishOptions? = nil,
        name: String? = nil,
        parameters: Parameters? = nil,
        sourceEntity: DashboardSourceEntity? = nil,
        themeArn: String? = nil,
        versionDescription: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.dashboardPublishOptions = dashboardPublishOptions
        self.name = name
        self.parameters = parameters
        self.sourceEntity = sourceEntity
        self.themeArn = themeArn
        self.versionDescription = versionDescription
    }
}

struct UpdateDashboardInputBody: Equatable {
    public let name: String?
    public let sourceEntity: DashboardSourceEntity?
    public let parameters: Parameters?
    public let versionDescription: String?
    public let dashboardPublishOptions: DashboardPublishOptions?
    public let themeArn: String?
}

extension UpdateDashboardInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dashboardPublishOptions = "DashboardPublishOptions"
        case name = "Name"
        case parameters = "Parameters"
        case sourceEntity = "SourceEntity"
        case themeArn = "ThemeArn"
        case versionDescription = "VersionDescription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let sourceEntityDecoded = try containerValues.decodeIfPresent(DashboardSourceEntity.self, forKey: .sourceEntity)
        sourceEntity = sourceEntityDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(Parameters.self, forKey: .parameters)
        parameters = parametersDecoded
        let versionDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionDescription)
        versionDescription = versionDescriptionDecoded
        let dashboardPublishOptionsDecoded = try containerValues.decodeIfPresent(DashboardPublishOptions.self, forKey: .dashboardPublishOptions)
        dashboardPublishOptions = dashboardPublishOptionsDecoded
        let themeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .themeArn)
        themeArn = themeArnDecoded
    }
}

extension UpdateDashboardOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDashboardOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDashboardOutputError: Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDashboardOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDashboardOutputResponse(arn: \(String(describing: arn)), creationStatus: \(String(describing: creationStatus)), dashboardId: \(String(describing: dashboardId)), requestId: \(String(describing: requestId)), status: \(String(describing: status)), versionArn: \(String(describing: versionArn)))"}
}

extension UpdateDashboardOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDashboardOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationStatus = output.creationStatus
            self.dashboardId = output.dashboardId
            self.requestId = output.requestId
            self.status = output.status
            self.versionArn = output.versionArn
        } else {
            self.arn = nil
            self.creationStatus = nil
            self.dashboardId = nil
            self.requestId = nil
            self.status = 0
            self.versionArn = nil
        }
    }
}

public struct UpdateDashboardOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let arn: String?
    /// <p>The creation status of the request.</p>
    public let creationStatus: ResourceStatus?
    /// <p>The ID for the dashboard.</p>
    public let dashboardId: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>The ARN of the dashboard, including the version number.</p>
    public let versionArn: String?

    public init (
        arn: String? = nil,
        creationStatus: ResourceStatus? = nil,
        dashboardId: String? = nil,
        requestId: String? = nil,
        status: Int = 0,
        versionArn: String? = nil
    )
    {
        self.arn = arn
        self.creationStatus = creationStatus
        self.dashboardId = dashboardId
        self.requestId = requestId
        self.status = status
        self.versionArn = versionArn
    }
}

struct UpdateDashboardOutputResponseBody: Equatable {
    public let arn: String?
    public let versionArn: String?
    public let dashboardId: String?
    public let creationStatus: ResourceStatus?
    public let status: Int
    public let requestId: String?
}

extension UpdateDashboardOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationStatus = "CreationStatus"
        case dashboardId = "DashboardId"
        case requestId = "RequestId"
        case status = "Status"
        case versionArn = "VersionArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let versionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionArn)
        versionArn = versionArnDecoded
        let dashboardIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let creationStatusDecoded = try containerValues.decodeIfPresent(ResourceStatus.self, forKey: .creationStatus)
        creationStatus = creationStatusDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

public struct UpdateDashboardPermissionsInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDashboardPermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDashboardPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDashboardPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDashboardPermissionsInput>
    public typealias MOutput = OperationOutput<UpdateDashboardPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDashboardPermissionsOutputError>
}

extension UpdateDashboardPermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDashboardPermissionsInput(awsAccountId: \(String(describing: awsAccountId)), dashboardId: \(String(describing: dashboardId)), grantPermissions: \(String(describing: grantPermissions)), revokePermissions: \(String(describing: revokePermissions)))"}
}

extension UpdateDashboardPermissionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantPermissions = grantPermissions {
            var grantPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantPermissions)
            for updateresourcepermissionlist0 in grantPermissions {
                try grantPermissionsContainer.encode(updateresourcepermissionlist0)
            }
        }
        if let revokePermissions = revokePermissions {
            var revokePermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .revokePermissions)
            for updateresourcepermissionlist0 in revokePermissions {
                try revokePermissionsContainer.encode(updateresourcepermissionlist0)
            }
        }
    }
}

public struct UpdateDashboardPermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDashboardPermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDashboardPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDashboardPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDashboardPermissionsInput>
    public typealias MOutput = OperationOutput<UpdateDashboardPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDashboardPermissionsOutputError>
}

public struct UpdateDashboardPermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDashboardPermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDashboardPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDashboardPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDashboardPermissionsInput>
    public typealias MOutput = OperationOutput<UpdateDashboardPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDashboardPermissionsOutputError>
}

public struct UpdateDashboardPermissionsInput: Equatable {
    /// <p>The ID of the AWS account that contains the dashboard whose permissions you're
    ///             updating.</p>
    public let awsAccountId: String?
    /// <p>The ID for the dashboard.</p>
    public let dashboardId: String?
    /// <p>The permissions that you want to grant on this resource.</p>
    public let grantPermissions: [ResourcePermission]?
    /// <p>The permissions that you want to revoke from this resource.</p>
    public let revokePermissions: [ResourcePermission]?

    public init (
        awsAccountId: String? = nil,
        dashboardId: String? = nil,
        grantPermissions: [ResourcePermission]? = nil,
        revokePermissions: [ResourcePermission]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.grantPermissions = grantPermissions
        self.revokePermissions = revokePermissions
    }
}

struct UpdateDashboardPermissionsInputBody: Equatable {
    public let grantPermissions: [ResourcePermission]?
    public let revokePermissions: [ResourcePermission]?
}

extension UpdateDashboardPermissionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantPermissionsContainer = try containerValues.decodeIfPresent([ResourcePermission?].self, forKey: .grantPermissions)
        var grantPermissionsDecoded0:[ResourcePermission]? = nil
        if let grantPermissionsContainer = grantPermissionsContainer {
            grantPermissionsDecoded0 = [ResourcePermission]()
            for structure0 in grantPermissionsContainer {
                if let structure0 = structure0 {
                    grantPermissionsDecoded0?.append(structure0)
                }
            }
        }
        grantPermissions = grantPermissionsDecoded0
        let revokePermissionsContainer = try containerValues.decodeIfPresent([ResourcePermission?].self, forKey: .revokePermissions)
        var revokePermissionsDecoded0:[ResourcePermission]? = nil
        if let revokePermissionsContainer = revokePermissionsContainer {
            revokePermissionsDecoded0 = [ResourcePermission]()
            for structure0 in revokePermissionsContainer {
                if let structure0 = structure0 {
                    revokePermissionsDecoded0?.append(structure0)
                }
            }
        }
        revokePermissions = revokePermissionsDecoded0
    }
}

extension UpdateDashboardPermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDashboardPermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDashboardPermissionsOutputError: Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDashboardPermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDashboardPermissionsOutputResponse(dashboardArn: \(String(describing: dashboardArn)), dashboardId: \(String(describing: dashboardId)), permissions: \(String(describing: permissions)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension UpdateDashboardPermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDashboardPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dashboardArn = output.dashboardArn
            self.dashboardId = output.dashboardId
            self.permissions = output.permissions
            self.requestId = output.requestId
        } else {
            self.dashboardArn = nil
            self.dashboardId = nil
            self.permissions = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateDashboardPermissionsOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dashboard.</p>
    public let dashboardArn: String?
    /// <p>The ID for the dashboard.</p>
    public let dashboardId: String?
    /// <p>Information about the permissions on the dashboard.</p>
    public let permissions: [ResourcePermission]?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        dashboardArn: String? = nil,
        dashboardId: String? = nil,
        permissions: [ResourcePermission]? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.dashboardArn = dashboardArn
        self.dashboardId = dashboardId
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateDashboardPermissionsOutputResponseBody: Equatable {
    public let dashboardArn: String?
    public let dashboardId: String?
    public let permissions: [ResourcePermission]?
    public let requestId: String?
    public let status: Int
}

extension UpdateDashboardPermissionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dashboardArn = "DashboardArn"
        case dashboardId = "DashboardId"
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dashboardArn)
        dashboardArn = dashboardArnDecoded
        let dashboardIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateDashboardPublishedVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDashboardPublishedVersionInput(awsAccountId: \(String(describing: awsAccountId)), dashboardId: \(String(describing: dashboardId)), versionNumber: \(String(describing: versionNumber)))"}
}

extension UpdateDashboardPublishedVersionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UpdateDashboardPublishedVersionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDashboardPublishedVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDashboardPublishedVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDashboardPublishedVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDashboardPublishedVersionInput>
    public typealias MOutput = OperationOutput<UpdateDashboardPublishedVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDashboardPublishedVersionOutputError>
}

public struct UpdateDashboardPublishedVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDashboardPublishedVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDashboardPublishedVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDashboardPublishedVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDashboardPublishedVersionInput>
    public typealias MOutput = OperationOutput<UpdateDashboardPublishedVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDashboardPublishedVersionOutputError>
}

public struct UpdateDashboardPublishedVersionInput: Equatable {
    /// <p>The ID of the AWS account that contains the dashboard that you're
    ///             updating.</p>
    public let awsAccountId: String?
    /// <p>The ID for the dashboard.</p>
    public let dashboardId: String?
    /// <p>The version number of the dashboard.</p>
    public let versionNumber: Int?

    public init (
        awsAccountId: String? = nil,
        dashboardId: String? = nil,
        versionNumber: Int? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.versionNumber = versionNumber
    }
}

struct UpdateDashboardPublishedVersionInputBody: Equatable {
}

extension UpdateDashboardPublishedVersionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UpdateDashboardPublishedVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDashboardPublishedVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDashboardPublishedVersionOutputError: Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDashboardPublishedVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDashboardPublishedVersionOutputResponse(dashboardArn: \(String(describing: dashboardArn)), dashboardId: \(String(describing: dashboardId)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension UpdateDashboardPublishedVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDashboardPublishedVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dashboardArn = output.dashboardArn
            self.dashboardId = output.dashboardId
            self.requestId = output.requestId
        } else {
            self.dashboardArn = nil
            self.dashboardId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateDashboardPublishedVersionOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dashboard.</p>
    public let dashboardArn: String?
    /// <p>The ID for the dashboard.</p>
    public let dashboardId: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        dashboardArn: String? = nil,
        dashboardId: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.dashboardArn = dashboardArn
        self.dashboardId = dashboardId
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateDashboardPublishedVersionOutputResponseBody: Equatable {
    public let dashboardId: String?
    public let dashboardArn: String?
    public let status: Int
    public let requestId: String?
}

extension UpdateDashboardPublishedVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dashboardArn = "DashboardArn"
        case dashboardId = "DashboardId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let dashboardArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dashboardArn)
        dashboardArn = dashboardArnDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

public struct UpdateDataSetInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDataSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDataSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDataSetInput>
    public typealias MOutput = OperationOutput<UpdateDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDataSetOutputError>
}

extension UpdateDataSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDataSetInput(awsAccountId: \(String(describing: awsAccountId)), columnGroups: \(String(describing: columnGroups)), columnLevelPermissionRules: \(String(describing: columnLevelPermissionRules)), dataSetId: \(String(describing: dataSetId)), fieldFolders: \(String(describing: fieldFolders)), importMode: \(String(describing: importMode)), logicalTableMap: \(String(describing: logicalTableMap)), name: \(String(describing: name)), physicalTableMap: \(String(describing: physicalTableMap)), rowLevelPermissionDataSet: \(String(describing: rowLevelPermissionDataSet)))"}
}

extension UpdateDataSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case columnGroups = "ColumnGroups"
        case columnLevelPermissionRules = "ColumnLevelPermissionRules"
        case fieldFolders = "FieldFolders"
        case importMode = "ImportMode"
        case logicalTableMap = "LogicalTableMap"
        case name = "Name"
        case physicalTableMap = "PhysicalTableMap"
        case rowLevelPermissionDataSet = "RowLevelPermissionDataSet"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnGroups = columnGroups {
            var columnGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnGroups)
            for columngrouplist0 in columnGroups {
                try columnGroupsContainer.encode(columngrouplist0)
            }
        }
        if let columnLevelPermissionRules = columnLevelPermissionRules {
            var columnLevelPermissionRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnLevelPermissionRules)
            for columnlevelpermissionrulelist0 in columnLevelPermissionRules {
                try columnLevelPermissionRulesContainer.encode(columnlevelpermissionrulelist0)
            }
        }
        if let fieldFolders = fieldFolders {
            var fieldFoldersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .fieldFolders)
            for (dictKey0, fieldfoldermap0) in fieldFolders {
                try fieldFoldersContainer.encode(fieldfoldermap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let importMode = importMode {
            try encodeContainer.encode(importMode.rawValue, forKey: .importMode)
        }
        if let logicalTableMap = logicalTableMap {
            var logicalTableMapContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .logicalTableMap)
            for (dictKey0, logicaltablemap0) in logicalTableMap {
                try logicalTableMapContainer.encode(logicaltablemap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let physicalTableMap = physicalTableMap {
            var physicalTableMapContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .physicalTableMap)
            for (dictKey0, physicaltablemap0) in physicalTableMap {
                try physicalTableMapContainer.encode(physicaltablemap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let rowLevelPermissionDataSet = rowLevelPermissionDataSet {
            try encodeContainer.encode(rowLevelPermissionDataSet, forKey: .rowLevelPermissionDataSet)
        }
    }
}

public struct UpdateDataSetInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDataSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDataSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDataSetInput>
    public typealias MOutput = OperationOutput<UpdateDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDataSetOutputError>
}

public struct UpdateDataSetInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDataSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDataSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDataSetInput>
    public typealias MOutput = OperationOutput<UpdateDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDataSetOutputError>
}

public struct UpdateDataSetInput: Equatable {
    /// <p>The AWS account ID.</p>
    public let awsAccountId: String?
    /// <p>Groupings of columns that work together in certain QuickSight features. Currently, only geospatial hierarchy is supported.</p>
    public let columnGroups: [ColumnGroup]?
    /// <p>A set of one or more definitions of a <code>
    ///                <a>ColumnLevelPermissionRule</a>
    ///             </code>.</p>
    public let columnLevelPermissionRules: [ColumnLevelPermissionRule]?
    /// <p>The ID for the dataset that you want to update. This ID is unique per AWS Region for each
    /// 			AWS account.</p>
    public let dataSetId: String?
    /// <p>The folder that contains fields and nested subfolders for your dataset.</p>
    public let fieldFolders: [String:FieldFolder]?
    /// <p>Indicates whether you want to import the data into SPICE.</p>
    public let importMode: DataSetImportMode?
    /// <p>Configures the combination and transformation of the data from the physical tables.</p>
    public let logicalTableMap: [String:LogicalTable]?
    /// <p>The display name for the dataset.</p>
    public let name: String?
    /// <p>Declares the physical tables that are available in the underlying data sources.</p>
    public let physicalTableMap: [String:PhysicalTable]?
    /// <p>The row-level security configuration for the data you want to create.</p>
    public let rowLevelPermissionDataSet: RowLevelPermissionDataSet?

    public init (
        awsAccountId: String? = nil,
        columnGroups: [ColumnGroup]? = nil,
        columnLevelPermissionRules: [ColumnLevelPermissionRule]? = nil,
        dataSetId: String? = nil,
        fieldFolders: [String:FieldFolder]? = nil,
        importMode: DataSetImportMode? = nil,
        logicalTableMap: [String:LogicalTable]? = nil,
        name: String? = nil,
        physicalTableMap: [String:PhysicalTable]? = nil,
        rowLevelPermissionDataSet: RowLevelPermissionDataSet? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.columnGroups = columnGroups
        self.columnLevelPermissionRules = columnLevelPermissionRules
        self.dataSetId = dataSetId
        self.fieldFolders = fieldFolders
        self.importMode = importMode
        self.logicalTableMap = logicalTableMap
        self.name = name
        self.physicalTableMap = physicalTableMap
        self.rowLevelPermissionDataSet = rowLevelPermissionDataSet
    }
}

struct UpdateDataSetInputBody: Equatable {
    public let name: String?
    public let physicalTableMap: [String:PhysicalTable]?
    public let logicalTableMap: [String:LogicalTable]?
    public let importMode: DataSetImportMode?
    public let columnGroups: [ColumnGroup]?
    public let fieldFolders: [String:FieldFolder]?
    public let rowLevelPermissionDataSet: RowLevelPermissionDataSet?
    public let columnLevelPermissionRules: [ColumnLevelPermissionRule]?
}

extension UpdateDataSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case columnGroups = "ColumnGroups"
        case columnLevelPermissionRules = "ColumnLevelPermissionRules"
        case fieldFolders = "FieldFolders"
        case importMode = "ImportMode"
        case logicalTableMap = "LogicalTableMap"
        case name = "Name"
        case physicalTableMap = "PhysicalTableMap"
        case rowLevelPermissionDataSet = "RowLevelPermissionDataSet"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let physicalTableMapContainer = try containerValues.decodeIfPresent([String: PhysicalTable?].self, forKey: .physicalTableMap)
        var physicalTableMapDecoded0: [String:PhysicalTable]? = nil
        if let physicalTableMapContainer = physicalTableMapContainer {
            physicalTableMapDecoded0 = [String:PhysicalTable]()
            for (key0, physicaltable0) in physicalTableMapContainer {
                if let physicaltable0 = physicaltable0 {
                    physicalTableMapDecoded0?[key0] = physicaltable0
                }
            }
        }
        physicalTableMap = physicalTableMapDecoded0
        let logicalTableMapContainer = try containerValues.decodeIfPresent([String: LogicalTable?].self, forKey: .logicalTableMap)
        var logicalTableMapDecoded0: [String:LogicalTable]? = nil
        if let logicalTableMapContainer = logicalTableMapContainer {
            logicalTableMapDecoded0 = [String:LogicalTable]()
            for (key0, logicaltable0) in logicalTableMapContainer {
                if let logicaltable0 = logicaltable0 {
                    logicalTableMapDecoded0?[key0] = logicaltable0
                }
            }
        }
        logicalTableMap = logicalTableMapDecoded0
        let importModeDecoded = try containerValues.decodeIfPresent(DataSetImportMode.self, forKey: .importMode)
        importMode = importModeDecoded
        let columnGroupsContainer = try containerValues.decodeIfPresent([ColumnGroup?].self, forKey: .columnGroups)
        var columnGroupsDecoded0:[ColumnGroup]? = nil
        if let columnGroupsContainer = columnGroupsContainer {
            columnGroupsDecoded0 = [ColumnGroup]()
            for structure0 in columnGroupsContainer {
                if let structure0 = structure0 {
                    columnGroupsDecoded0?.append(structure0)
                }
            }
        }
        columnGroups = columnGroupsDecoded0
        let fieldFoldersContainer = try containerValues.decodeIfPresent([String: FieldFolder?].self, forKey: .fieldFolders)
        var fieldFoldersDecoded0: [String:FieldFolder]? = nil
        if let fieldFoldersContainer = fieldFoldersContainer {
            fieldFoldersDecoded0 = [String:FieldFolder]()
            for (key0, fieldfolder0) in fieldFoldersContainer {
                if let fieldfolder0 = fieldfolder0 {
                    fieldFoldersDecoded0?[key0] = fieldfolder0
                }
            }
        }
        fieldFolders = fieldFoldersDecoded0
        let rowLevelPermissionDataSetDecoded = try containerValues.decodeIfPresent(RowLevelPermissionDataSet.self, forKey: .rowLevelPermissionDataSet)
        rowLevelPermissionDataSet = rowLevelPermissionDataSetDecoded
        let columnLevelPermissionRulesContainer = try containerValues.decodeIfPresent([ColumnLevelPermissionRule?].self, forKey: .columnLevelPermissionRules)
        var columnLevelPermissionRulesDecoded0:[ColumnLevelPermissionRule]? = nil
        if let columnLevelPermissionRulesContainer = columnLevelPermissionRulesContainer {
            columnLevelPermissionRulesDecoded0 = [ColumnLevelPermissionRule]()
            for structure0 in columnLevelPermissionRulesContainer {
                if let structure0 = structure0 {
                    columnLevelPermissionRulesDecoded0?.append(structure0)
                }
            }
        }
        columnLevelPermissionRules = columnLevelPermissionRulesDecoded0
    }
}

extension UpdateDataSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDataSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDataSetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDataSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDataSetOutputResponse(arn: \(String(describing: arn)), dataSetId: \(String(describing: dataSetId)), ingestionArn: \(String(describing: ingestionArn)), ingestionId: \(String(describing: ingestionId)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension UpdateDataSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDataSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.dataSetId = output.dataSetId
            self.ingestionArn = output.ingestionArn
            self.ingestionId = output.ingestionId
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.dataSetId = nil
            self.ingestionArn = nil
            self.ingestionId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateDataSetOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset.</p>
    public let arn: String?
    /// <p>The ID for the dataset that you want to create. This ID is unique per AWS Region for each AWS account.</p>
    public let dataSetId: String?
    /// <p>The ARN for the ingestion, which is triggered as a result of dataset creation if the import
    /// 			mode is SPICE.</p>
    public let ingestionArn: String?
    /// <p>The ID of the ingestion, which is triggered as a result of dataset creation if the import
    /// 			mode is SPICE.</p>
    public let ingestionId: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        arn: String? = nil,
        dataSetId: String? = nil,
        ingestionArn: String? = nil,
        ingestionId: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.arn = arn
        self.dataSetId = dataSetId
        self.ingestionArn = ingestionArn
        self.ingestionId = ingestionId
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateDataSetOutputResponseBody: Equatable {
    public let arn: String?
    public let dataSetId: String?
    public let ingestionArn: String?
    public let ingestionId: String?
    public let requestId: String?
    public let status: Int
}

extension UpdateDataSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case dataSetId = "DataSetId"
        case ingestionArn = "IngestionArn"
        case ingestionId = "IngestionId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let ingestionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ingestionArn)
        ingestionArn = ingestionArnDecoded
        let ingestionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ingestionId)
        ingestionId = ingestionIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

public struct UpdateDataSetPermissionsInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDataSetPermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDataSetPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDataSetPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDataSetPermissionsInput>
    public typealias MOutput = OperationOutput<UpdateDataSetPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDataSetPermissionsOutputError>
}

extension UpdateDataSetPermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDataSetPermissionsInput(awsAccountId: \(String(describing: awsAccountId)), dataSetId: \(String(describing: dataSetId)), grantPermissions: \(String(describing: grantPermissions)), revokePermissions: \(String(describing: revokePermissions)))"}
}

extension UpdateDataSetPermissionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantPermissions = grantPermissions {
            var grantPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantPermissions)
            for resourcepermissionlist0 in grantPermissions {
                try grantPermissionsContainer.encode(resourcepermissionlist0)
            }
        }
        if let revokePermissions = revokePermissions {
            var revokePermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .revokePermissions)
            for resourcepermissionlist0 in revokePermissions {
                try revokePermissionsContainer.encode(resourcepermissionlist0)
            }
        }
    }
}

public struct UpdateDataSetPermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDataSetPermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDataSetPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDataSetPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDataSetPermissionsInput>
    public typealias MOutput = OperationOutput<UpdateDataSetPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDataSetPermissionsOutputError>
}

public struct UpdateDataSetPermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDataSetPermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDataSetPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDataSetPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDataSetPermissionsInput>
    public typealias MOutput = OperationOutput<UpdateDataSetPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDataSetPermissionsOutputError>
}

public struct UpdateDataSetPermissionsInput: Equatable {
    /// <p>The AWS account ID.</p>
    public let awsAccountId: String?
    /// <p>The ID for the dataset whose permissions you want to update. This ID is unique per AWS
    /// 			Region for each AWS account.</p>
    public let dataSetId: String?
    /// <p>The resource permissions that you want to grant to the dataset.</p>
    public let grantPermissions: [ResourcePermission]?
    /// <p>The resource permissions that you want to revoke from the dataset.</p>
    public let revokePermissions: [ResourcePermission]?

    public init (
        awsAccountId: String? = nil,
        dataSetId: String? = nil,
        grantPermissions: [ResourcePermission]? = nil,
        revokePermissions: [ResourcePermission]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
        self.grantPermissions = grantPermissions
        self.revokePermissions = revokePermissions
    }
}

struct UpdateDataSetPermissionsInputBody: Equatable {
    public let grantPermissions: [ResourcePermission]?
    public let revokePermissions: [ResourcePermission]?
}

extension UpdateDataSetPermissionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantPermissionsContainer = try containerValues.decodeIfPresent([ResourcePermission?].self, forKey: .grantPermissions)
        var grantPermissionsDecoded0:[ResourcePermission]? = nil
        if let grantPermissionsContainer = grantPermissionsContainer {
            grantPermissionsDecoded0 = [ResourcePermission]()
            for structure0 in grantPermissionsContainer {
                if let structure0 = structure0 {
                    grantPermissionsDecoded0?.append(structure0)
                }
            }
        }
        grantPermissions = grantPermissionsDecoded0
        let revokePermissionsContainer = try containerValues.decodeIfPresent([ResourcePermission?].self, forKey: .revokePermissions)
        var revokePermissionsDecoded0:[ResourcePermission]? = nil
        if let revokePermissionsContainer = revokePermissionsContainer {
            revokePermissionsDecoded0 = [ResourcePermission]()
            for structure0 in revokePermissionsContainer {
                if let structure0 = structure0 {
                    revokePermissionsDecoded0?.append(structure0)
                }
            }
        }
        revokePermissions = revokePermissionsDecoded0
    }
}

extension UpdateDataSetPermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDataSetPermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDataSetPermissionsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDataSetPermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDataSetPermissionsOutputResponse(dataSetArn: \(String(describing: dataSetArn)), dataSetId: \(String(describing: dataSetId)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension UpdateDataSetPermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDataSetPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dataSetArn = output.dataSetArn
            self.dataSetId = output.dataSetId
            self.requestId = output.requestId
        } else {
            self.dataSetArn = nil
            self.dataSetId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateDataSetPermissionsOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset.</p>
    public let dataSetArn: String?
    /// <p>The ID for the dataset whose permissions you want to update. This ID is unique per AWS
    /// 			Region for each AWS account.</p>
    public let dataSetId: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        dataSetArn: String? = nil,
        dataSetId: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.dataSetArn = dataSetArn
        self.dataSetId = dataSetId
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateDataSetPermissionsOutputResponseBody: Equatable {
    public let dataSetArn: String?
    public let dataSetId: String?
    public let requestId: String?
    public let status: Int
}

extension UpdateDataSetPermissionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataSetArn = "DataSetArn"
        case dataSetId = "DataSetId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetArn)
        dataSetArn = dataSetArnDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

public struct UpdateDataSourceInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDataSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDataSourceInput>
    public typealias MOutput = OperationOutput<UpdateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDataSourceOutputError>
}

extension UpdateDataSourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDataSourceInput(awsAccountId: \(String(describing: awsAccountId)), credentials: \(String(describing: credentials)), dataSourceId: \(String(describing: dataSourceId)), dataSourceParameters: \(String(describing: dataSourceParameters)), name: \(String(describing: name)), sslProperties: \(String(describing: sslProperties)), vpcConnectionProperties: \(String(describing: vpcConnectionProperties)))"}
}

extension UpdateDataSourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case credentials = "Credentials"
        case dataSourceParameters = "DataSourceParameters"
        case name = "Name"
        case sslProperties = "SslProperties"
        case vpcConnectionProperties = "VpcConnectionProperties"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let credentials = credentials {
            try encodeContainer.encode(credentials, forKey: .credentials)
        }
        if let dataSourceParameters = dataSourceParameters {
            try encodeContainer.encode(dataSourceParameters, forKey: .dataSourceParameters)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sslProperties = sslProperties {
            try encodeContainer.encode(sslProperties, forKey: .sslProperties)
        }
        if let vpcConnectionProperties = vpcConnectionProperties {
            try encodeContainer.encode(vpcConnectionProperties, forKey: .vpcConnectionProperties)
        }
    }
}

public struct UpdateDataSourceInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDataSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDataSourceInput>
    public typealias MOutput = OperationOutput<UpdateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDataSourceOutputError>
}

public struct UpdateDataSourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDataSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDataSourceInput>
    public typealias MOutput = OperationOutput<UpdateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDataSourceOutputError>
}

public struct UpdateDataSourceInput: Equatable {
    /// <p>The AWS account ID.</p>
    public let awsAccountId: String?
    /// <p>The credentials that QuickSight that uses to connect to your underlying source. Currently,
    /// 			only credentials based on user name and password are supported.</p>
    public let credentials: DataSourceCredentials?
    /// <p>The ID of the data source. This ID is unique per AWS Region for each AWS account. </p>
    public let dataSourceId: String?
    /// <p>The parameters that QuickSight uses to connect to your underlying source.</p>
    public let dataSourceParameters: DataSourceParameters?
    /// <p>A display name for the data source.</p>
    public let name: String?
    /// <p>Secure Socket Layer (SSL) properties that apply when QuickSight connects to your underlying
    /// 			source.</p>
    public let sslProperties: SslProperties?
    /// <p>Use this parameter only when you want QuickSight to use a VPC connection when connecting to
    /// 			your underlying source.</p>
    public let vpcConnectionProperties: VpcConnectionProperties?

    public init (
        awsAccountId: String? = nil,
        credentials: DataSourceCredentials? = nil,
        dataSourceId: String? = nil,
        dataSourceParameters: DataSourceParameters? = nil,
        name: String? = nil,
        sslProperties: SslProperties? = nil,
        vpcConnectionProperties: VpcConnectionProperties? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.credentials = credentials
        self.dataSourceId = dataSourceId
        self.dataSourceParameters = dataSourceParameters
        self.name = name
        self.sslProperties = sslProperties
        self.vpcConnectionProperties = vpcConnectionProperties
    }
}

struct UpdateDataSourceInputBody: Equatable {
    public let name: String?
    public let dataSourceParameters: DataSourceParameters?
    public let credentials: DataSourceCredentials?
    public let vpcConnectionProperties: VpcConnectionProperties?
    public let sslProperties: SslProperties?
}

extension UpdateDataSourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case credentials = "Credentials"
        case dataSourceParameters = "DataSourceParameters"
        case name = "Name"
        case sslProperties = "SslProperties"
        case vpcConnectionProperties = "VpcConnectionProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let dataSourceParametersDecoded = try containerValues.decodeIfPresent(DataSourceParameters.self, forKey: .dataSourceParameters)
        dataSourceParameters = dataSourceParametersDecoded
        let credentialsDecoded = try containerValues.decodeIfPresent(DataSourceCredentials.self, forKey: .credentials)
        credentials = credentialsDecoded
        let vpcConnectionPropertiesDecoded = try containerValues.decodeIfPresent(VpcConnectionProperties.self, forKey: .vpcConnectionProperties)
        vpcConnectionProperties = vpcConnectionPropertiesDecoded
        let sslPropertiesDecoded = try containerValues.decodeIfPresent(SslProperties.self, forKey: .sslProperties)
        sslProperties = sslPropertiesDecoded
    }
}

extension UpdateDataSourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDataSourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDataSourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDataSourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDataSourceOutputResponse(arn: \(String(describing: arn)), dataSourceId: \(String(describing: dataSourceId)), requestId: \(String(describing: requestId)), status: \(String(describing: status)), updateStatus: \(String(describing: updateStatus)))"}
}

extension UpdateDataSourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDataSourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.dataSourceId = output.dataSourceId
            self.requestId = output.requestId
            self.updateStatus = output.updateStatus
        } else {
            self.arn = nil
            self.dataSourceId = nil
            self.requestId = nil
            self.updateStatus = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateDataSourceOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the data source.</p>
    public let arn: String?
    /// <p>The ID of the data source. This ID is unique per AWS Region for each AWS account.</p>
    public let dataSourceId: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>The update status of the data source's last update.</p>
    public let updateStatus: ResourceStatus?

    public init (
        arn: String? = nil,
        dataSourceId: String? = nil,
        requestId: String? = nil,
        status: Int = 0,
        updateStatus: ResourceStatus? = nil
    )
    {
        self.arn = arn
        self.dataSourceId = dataSourceId
        self.requestId = requestId
        self.status = status
        self.updateStatus = updateStatus
    }
}

struct UpdateDataSourceOutputResponseBody: Equatable {
    public let arn: String?
    public let dataSourceId: String?
    public let updateStatus: ResourceStatus?
    public let requestId: String?
    public let status: Int
}

extension UpdateDataSourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case dataSourceId = "DataSourceId"
        case requestId = "RequestId"
        case status = "Status"
        case updateStatus = "UpdateStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let updateStatusDecoded = try containerValues.decodeIfPresent(ResourceStatus.self, forKey: .updateStatus)
        updateStatus = updateStatusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

public struct UpdateDataSourcePermissionsInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDataSourcePermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDataSourcePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDataSourcePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDataSourcePermissionsInput>
    public typealias MOutput = OperationOutput<UpdateDataSourcePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDataSourcePermissionsOutputError>
}

extension UpdateDataSourcePermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDataSourcePermissionsInput(awsAccountId: \(String(describing: awsAccountId)), dataSourceId: \(String(describing: dataSourceId)), grantPermissions: \(String(describing: grantPermissions)), revokePermissions: \(String(describing: revokePermissions)))"}
}

extension UpdateDataSourcePermissionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantPermissions = grantPermissions {
            var grantPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantPermissions)
            for resourcepermissionlist0 in grantPermissions {
                try grantPermissionsContainer.encode(resourcepermissionlist0)
            }
        }
        if let revokePermissions = revokePermissions {
            var revokePermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .revokePermissions)
            for resourcepermissionlist0 in revokePermissions {
                try revokePermissionsContainer.encode(resourcepermissionlist0)
            }
        }
    }
}

public struct UpdateDataSourcePermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDataSourcePermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDataSourcePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDataSourcePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDataSourcePermissionsInput>
    public typealias MOutput = OperationOutput<UpdateDataSourcePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDataSourcePermissionsOutputError>
}

public struct UpdateDataSourcePermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDataSourcePermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDataSourcePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDataSourcePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDataSourcePermissionsInput>
    public typealias MOutput = OperationOutput<UpdateDataSourcePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDataSourcePermissionsOutputError>
}

public struct UpdateDataSourcePermissionsInput: Equatable {
    /// <p>The AWS account ID.</p>
    public let awsAccountId: String?
    /// <p>The ID of the data source. This ID is unique per AWS Region for each AWS account. </p>
    public let dataSourceId: String?
    /// <p>A list of resource permissions that you want to grant on the data source.</p>
    public let grantPermissions: [ResourcePermission]?
    /// <p>A list of resource permissions that you want to revoke on the data source.</p>
    public let revokePermissions: [ResourcePermission]?

    public init (
        awsAccountId: String? = nil,
        dataSourceId: String? = nil,
        grantPermissions: [ResourcePermission]? = nil,
        revokePermissions: [ResourcePermission]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSourceId = dataSourceId
        self.grantPermissions = grantPermissions
        self.revokePermissions = revokePermissions
    }
}

struct UpdateDataSourcePermissionsInputBody: Equatable {
    public let grantPermissions: [ResourcePermission]?
    public let revokePermissions: [ResourcePermission]?
}

extension UpdateDataSourcePermissionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantPermissionsContainer = try containerValues.decodeIfPresent([ResourcePermission?].self, forKey: .grantPermissions)
        var grantPermissionsDecoded0:[ResourcePermission]? = nil
        if let grantPermissionsContainer = grantPermissionsContainer {
            grantPermissionsDecoded0 = [ResourcePermission]()
            for structure0 in grantPermissionsContainer {
                if let structure0 = structure0 {
                    grantPermissionsDecoded0?.append(structure0)
                }
            }
        }
        grantPermissions = grantPermissionsDecoded0
        let revokePermissionsContainer = try containerValues.decodeIfPresent([ResourcePermission?].self, forKey: .revokePermissions)
        var revokePermissionsDecoded0:[ResourcePermission]? = nil
        if let revokePermissionsContainer = revokePermissionsContainer {
            revokePermissionsDecoded0 = [ResourcePermission]()
            for structure0 in revokePermissionsContainer {
                if let structure0 = structure0 {
                    revokePermissionsDecoded0?.append(structure0)
                }
            }
        }
        revokePermissions = revokePermissionsDecoded0
    }
}

extension UpdateDataSourcePermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDataSourcePermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDataSourcePermissionsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDataSourcePermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDataSourcePermissionsOutputResponse(dataSourceArn: \(String(describing: dataSourceArn)), dataSourceId: \(String(describing: dataSourceId)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension UpdateDataSourcePermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDataSourcePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dataSourceArn = output.dataSourceArn
            self.dataSourceId = output.dataSourceId
            self.requestId = output.requestId
        } else {
            self.dataSourceArn = nil
            self.dataSourceId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateDataSourcePermissionsOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the data source.</p>
    public let dataSourceArn: String?
    /// <p>The ID of the data source. This ID is unique per AWS Region for each AWS account.</p>
    public let dataSourceId: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        dataSourceArn: String? = nil,
        dataSourceId: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.dataSourceArn = dataSourceArn
        self.dataSourceId = dataSourceId
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateDataSourcePermissionsOutputResponseBody: Equatable {
    public let dataSourceArn: String?
    public let dataSourceId: String?
    public let requestId: String?
    public let status: Int
}

extension UpdateDataSourcePermissionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataSourceArn = "DataSourceArn"
        case dataSourceId = "DataSourceId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSourceArn)
        dataSourceArn = dataSourceArnDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

public struct UpdateGroupInputBodyMiddleware: Middleware {
    public let id: String = "UpdateGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGroupInput>
    public typealias MOutput = OperationOutput<UpdateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGroupOutputError>
}

extension UpdateGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGroupInput(awsAccountId: \(String(describing: awsAccountId)), description: \(String(describing: description)), groupName: \(String(describing: groupName)), namespace: \(String(describing: namespace)))"}
}

extension UpdateGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

public struct UpdateGroupInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGroupInput>
    public typealias MOutput = OperationOutput<UpdateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGroupOutputError>
}

public struct UpdateGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGroupInput>
    public typealias MOutput = OperationOutput<UpdateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGroupOutputError>
}

public struct UpdateGroupInput: Equatable {
    /// <p>The ID for the AWS account that the group is in. Currently, you use the ID for the AWS
    /// 			account that contains your Amazon QuickSight account.</p>
    public let awsAccountId: String?
    /// <p>The description for the group that you want to update.</p>
    public let description: String?
    /// <p>The name of the group that you want to update.</p>
    public let groupName: String?
    /// <p>The namespace. Currently, you should set this to <code>default</code>.</p>
    public let namespace: String?

    public init (
        awsAccountId: String? = nil,
        description: String? = nil,
        groupName: String? = nil,
        namespace: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.description = description
        self.groupName = groupName
        self.namespace = namespace
    }
}

struct UpdateGroupInputBody: Equatable {
    public let description: String?
}

extension UpdateGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGroupOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGroupOutputResponse(group: \(String(describing: group)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension UpdateGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.group = output.group
            self.requestId = output.requestId
        } else {
            self.group = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateGroupOutputResponse: Equatable {
    /// <p>The name of the group.</p>
    public let group: Group?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        group: Group? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.group = group
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateGroupOutputResponseBody: Equatable {
    public let group: Group?
    public let requestId: String?
    public let status: Int
}

extension UpdateGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(Group.self, forKey: .group)
        group = groupDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

public struct UpdateIAMPolicyAssignmentInputBodyMiddleware: Middleware {
    public let id: String = "UpdateIAMPolicyAssignmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIAMPolicyAssignmentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIAMPolicyAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIAMPolicyAssignmentInput>
    public typealias MOutput = OperationOutput<UpdateIAMPolicyAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIAMPolicyAssignmentOutputError>
}

extension UpdateIAMPolicyAssignmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateIAMPolicyAssignmentInput(assignmentName: \(String(describing: assignmentName)), assignmentStatus: \(String(describing: assignmentStatus)), awsAccountId: \(String(describing: awsAccountId)), identities: \(String(describing: identities)), namespace: \(String(describing: namespace)), policyArn: \(String(describing: policyArn)))"}
}

extension UpdateIAMPolicyAssignmentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assignmentStatus = "AssignmentStatus"
        case identities = "Identities"
        case policyArn = "PolicyArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentStatus = assignmentStatus {
            try encodeContainer.encode(assignmentStatus.rawValue, forKey: .assignmentStatus)
        }
        if let identities = identities {
            var identitiesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .identities)
            for (dictKey0, identitymap0) in identities {
                try identitiesContainer.encode(identitymap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let policyArn = policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
    }
}

public struct UpdateIAMPolicyAssignmentInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateIAMPolicyAssignmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIAMPolicyAssignmentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIAMPolicyAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIAMPolicyAssignmentInput>
    public typealias MOutput = OperationOutput<UpdateIAMPolicyAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIAMPolicyAssignmentOutputError>
}

public struct UpdateIAMPolicyAssignmentInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateIAMPolicyAssignmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIAMPolicyAssignmentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIAMPolicyAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIAMPolicyAssignmentInput>
    public typealias MOutput = OperationOutput<UpdateIAMPolicyAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIAMPolicyAssignmentOutputError>
}

public struct UpdateIAMPolicyAssignmentInput: Equatable {
    /// <p>The name of the assignment, also called a rule. This name must be unique within an AWS account.</p>
    public let assignmentName: String?
    /// <p>The status of the assignment. Possible values are as follows:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ENABLED</code> - Anything specified in this assignment is used when creating the data
    /// 				source.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DISABLED</code> - This assignment isn't used when creating the data source.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DRAFT</code> - This assignment is an unfinished draft and isn't used when creating the
    /// 				data source.</p>
    ///             </li>
    ///          </ul>
    public let assignmentStatus: AssignmentStatus?
    /// <p>The ID of the AWS account that contains the IAM policy assignment. </p>
    public let awsAccountId: String?
    /// <p>The QuickSight users, groups, or both that you want to assign the policy to.</p>
    public let identities: [String:[String]]?
    /// <p>The namespace of the assignment.</p>
    public let namespace: String?
    /// <p>The ARN for the IAM policy to apply to the QuickSight users and groups
    /// 			specified in this assignment.</p>
    public let policyArn: String?

    public init (
        assignmentName: String? = nil,
        assignmentStatus: AssignmentStatus? = nil,
        awsAccountId: String? = nil,
        identities: [String:[String]]? = nil,
        namespace: String? = nil,
        policyArn: String? = nil
    )
    {
        self.assignmentName = assignmentName
        self.assignmentStatus = assignmentStatus
        self.awsAccountId = awsAccountId
        self.identities = identities
        self.namespace = namespace
        self.policyArn = policyArn
    }
}

struct UpdateIAMPolicyAssignmentInputBody: Equatable {
    public let assignmentStatus: AssignmentStatus?
    public let policyArn: String?
    public let identities: [String:[String]]?
}

extension UpdateIAMPolicyAssignmentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assignmentStatus = "AssignmentStatus"
        case identities = "Identities"
        case policyArn = "PolicyArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentStatusDecoded = try containerValues.decodeIfPresent(AssignmentStatus.self, forKey: .assignmentStatus)
        assignmentStatus = assignmentStatusDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let identitiesContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .identities)
        var identitiesDecoded0: [String:[String]]? = nil
        if let identitiesContainer = identitiesContainer {
            identitiesDecoded0 = [String:[String]]()
            for (key0, identitynamelist0) in identitiesContainer {
                var identitynamelist0Decoded0: [String]? = nil
                if let identitynamelist0 = identitynamelist0 {
                    identitynamelist0Decoded0 = [String]()
                    for string1 in identitynamelist0 {
                        if let string1 = string1 {
                            identitynamelist0Decoded0?.append(string1)
                        }
                    }
                }
                identitiesDecoded0?[key0] = identitynamelist0Decoded0
            }
        }
        identities = identitiesDecoded0
    }
}

extension UpdateIAMPolicyAssignmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIAMPolicyAssignmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentUpdatingException" : self = .concurrentUpdatingException(try ConcurrentUpdatingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateIAMPolicyAssignmentOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case concurrentUpdatingException(ConcurrentUpdatingException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIAMPolicyAssignmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateIAMPolicyAssignmentOutputResponse(assignmentId: \(String(describing: assignmentId)), assignmentName: \(String(describing: assignmentName)), assignmentStatus: \(String(describing: assignmentStatus)), identities: \(String(describing: identities)), policyArn: \(String(describing: policyArn)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

extension UpdateIAMPolicyAssignmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateIAMPolicyAssignmentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assignmentId = output.assignmentId
            self.assignmentName = output.assignmentName
            self.assignmentStatus = output.assignmentStatus
            self.identities = output.identities
            self.policyArn = output.policyArn
            self.requestId = output.requestId
        } else {
            self.assignmentId = nil
            self.assignmentName = nil
            self.assignmentStatus = nil
            self.identities = nil
            self.policyArn = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateIAMPolicyAssignmentOutputResponse: Equatable {
    /// <p>The ID of the assignment.</p>
    public let assignmentId: String?
    /// <p>The name of the assignment or rule.</p>
    public let assignmentName: String?
    /// <p>The status of the assignment. Possible values are as follows:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ENABLED</code> - Anything specified in this assignment is used when creating the data
    /// 				source.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DISABLED</code> - This assignment isn't used when creating the data source.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DRAFT</code> - This assignment is an unfinished draft and isn't used when creating the
    /// 				data source.</p>
    ///             </li>
    ///          </ul>
    public let assignmentStatus: AssignmentStatus?
    /// <p>The QuickSight users, groups, or both that the IAM policy is assigned to.</p>
    public let identities: [String:[String]]?
    /// <p>The ARN for the IAM policy applied to the QuickSight users and groups specified in this
    /// 			assignment.</p>
    public let policyArn: String?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int

    public init (
        assignmentId: String? = nil,
        assignmentName: String? = nil,
        assignmentStatus: AssignmentStatus? = nil,
        identities: [String:[String]]? = nil,
        policyArn: String? = nil,
        requestId: String? = nil,
        status: Int = 0
    )
    {
        self.assignmentId = assignmentId
        self.assignmentName = assignmentName
        self.assignmentStatus = assignmentStatus
        self.identities = identities
        self.policyArn = policyArn
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateIAMPolicyAssignmentOutputResponseBody: Equatable {
    public let assignmentName: String?
    public let assignmentId: String?
    public let policyArn: String?
    public let identities: [String:[String]]?
    public let assignmentStatus: AssignmentStatus?
    public let requestId: String?
    public let status: Int
}

extension UpdateIAMPolicyAssignmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assignmentId = "AssignmentId"
        case assignmentName = "AssignmentName"
        case assignmentStatus = "AssignmentStatus"
        case identities = "Identities"
        case policyArn = "PolicyArn"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assignmentName)
        assignmentName = assignmentNameDecoded
        let assignmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assignmentId)
        assignmentId = assignmentIdDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let identitiesContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .identities)
        var identitiesDecoded0: [String:[String]]? = nil
        if let identitiesContainer = identitiesContainer {
            identitiesDecoded0 = [String:[String]]()
            for (key0, identitynamelist0) in identitiesContainer {
                var identitynamelist0Decoded0: [String]? = nil
                if let identitynamelist0 = identitynamelist0 {
                    identitynamelist0Decoded0 = [String]()
                    for string1 in identitynamelist0 {
                        if let string1 = string1 {
                            identitynamelist0Decoded0?.append(string1)
                        }
                    }
                }
                identitiesDecoded0?[key0] = identitynamelist0Decoded0
            }
        }
        identities = identitiesDecoded0
        let assignmentStatusDecoded = try containerValues.decodeIfPresent(AssignmentStatus.self, forKey: .assignmentStatus)
        assignmentStatus = assignmentStatusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

public struct UpdateTemplateAliasInputBodyMiddleware: Middleware {
    public let id: String = "UpdateTemplateAliasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTemplateAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTemplateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTemplateAliasInput>
    public typealias MOutput = OperationOutput<UpdateTemplateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTemplateAliasOutputError>
}

extension UpdateTemplateAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTemplateAliasInput(aliasName: \(String(describing: aliasName)), awsAccountId: \(String(describing: awsAccountId)), templateId: \(String(describing: templateId)), templateVersionNumber: \(String(describing: templateVersionNumber)))"}
}

extension UpdateTemplateAliasInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case templateVersionNumber = "TemplateVersionNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let templateVersionNumber = templateVersionNumber {
            try encodeContainer.encode(templateVersionNumber, forKey: .templateVersionNumber)
        }
    }
}

public struct UpdateTemplateAliasInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateTemplateAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTemplateAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTemplateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTemplateAliasInput>
    public typealias MOutput = OperationOutput<UpdateTemplateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTemplateAliasOutputError>
}

public struct UpdateTemplateAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateTemplateAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTemplateAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTemplateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTemplateAliasInput>
    public typealias MOutput = OperationOutput<UpdateTemplateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTemplateAliasOutputError>
}

public struct UpdateTemplateAliasInput: Equatable {
    /// <p>The alias of the template that you want to update. If you name a specific alias, you update
    /// 			the version that the alias points to. You can specify the latest version of the template
    /// 			by providing the keyword <code>$LATEST</code> in the <code>AliasName</code> parameter.
    /// 			The keyword <code>$PUBLISHED</code> doesn't apply to templates.</p>
    public let aliasName: String?
    /// <p>The ID of the AWS account that contains the template alias that you're updating.</p>
    public let awsAccountId: String?
    /// <p>The ID for the template.</p>
    public let templateId: String?
    /// <p>The version number of the template.</p>
    public let templateVersionNumber: Int?

    public init (
        aliasName: String? = nil,
        awsAccountId: String? = nil,
        templateId: String? = nil,
        templateVersionNumber: Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.templateId = templateId
        self.templateVersionNumber = templateVersionNumber
    }
}

struct UpdateTemplateAliasInputBody: Equatable {
    public let templateVersionNumber: Int?
}

extension UpdateTemplateAliasInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case templateVersionNumber = "TemplateVersionNumber"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateVersionNumberDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .templateVersionNumber)
        templateVersionNumber = templateVersionNumberDecoded
    }
}

extension UpdateTemplateAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTemplateAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTemplateAliasOutputError: Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTemplateAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTemplateAliasOutputResponse(requestId: \(String(describing: requestId)), status: \(String(describing: status)), templateAlias: \(String(describing: templateAlias)))"}
}

extension UpdateTemplateAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateTemplateAliasOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.requestId = output.requestId
            self.templateAlias = output.templateAlias
        } else {
            self.requestId = nil
            self.templateAlias = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateTemplateAliasOutputResponse: Equatable {
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>The template alias.</p>
    public let templateAlias: TemplateAlias?

    public init (
        requestId: String? = nil,
        status: Int = 0,
        templateAlias: TemplateAlias? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.templateAlias = templateAlias
    }
}

struct UpdateTemplateAliasOutputResponseBody: Equatable {
    public let templateAlias: TemplateAlias?
    public let status: Int
    public let requestId: String?
}

extension UpdateTemplateAliasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case templateAlias = "TemplateAlias"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateAliasDecoded = try containerValues.decodeIfPresent(TemplateAlias.self, forKey: .templateAlias)
        templateAlias = templateAliasDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

public struct UpdateTemplateInputBodyMiddleware: Middleware {
    public let id: String = "UpdateTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTemplateInput>
    public typealias MOutput = OperationOutput<UpdateTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTemplateOutputError>
}

extension UpdateTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTemplateInput(awsAccountId: \(String(describing: awsAccountId)), name: \(String(describing: name)), sourceEntity: \(String(describing: sourceEntity)), templateId: \(String(describing: templateId)), versionDescription: \(String(describing: versionDescription)))"}
}

extension UpdateTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case sourceEntity = "SourceEntity"
        case versionDescription = "VersionDescription"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceEntity = sourceEntity {
            try encodeContainer.encode(sourceEntity, forKey: .sourceEntity)
        }
        if let versionDescription = versionDescription {
            try encodeContainer.encode(versionDescription, forKey: .versionDescription)
        }
    }
}

public struct UpdateTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTemplateInput>
    public typealias MOutput = OperationOutput<UpdateTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTemplateOutputError>
}

public struct UpdateTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTemplateInput>
    public typealias MOutput = OperationOutput<UpdateTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTemplateOutputError>
}

public struct UpdateTemplateInput: Equatable {
    /// <p>The ID of the AWS account that contains the template that you're updating.</p>
    public let awsAccountId: String?
    /// <p>The name for the template.</p>
    public let name: String?
    /// <p>The entity that you are using as a source when you update the template. In
    /// 			<code>SourceEntity</code>, you specify the type of object you're using as source:
    /// 			<code>SourceTemplate</code> for a template or <code>SourceAnalysis</code> for an
    /// 			analysis. Both of these require an Amazon Resource Name (ARN). For
    /// 			<code>SourceTemplate</code>, specify the ARN of the source template. For
    /// 			<code>SourceAnalysis</code>, specify the ARN of the source analysis. The <code>SourceTemplate</code>
    /// 			ARN can contain any AWS Account and any QuickSight-supported AWS Region. </p>
    /// 		       <p>Use the <code>DataSetReferences</code> entity within <code>SourceTemplate</code> or
    /// 			<code>SourceAnalysis</code> to list the replacement datasets for the placeholders listed
    /// 			in the original. The schema in each dataset must match its placeholder. </p>
    public let sourceEntity: TemplateSourceEntity?
    /// <p>The ID for the template.</p>
    public let templateId: String?
    /// <p>A description of the current template version that is being updated. Every time you call
    /// 				<code>UpdateTemplate</code>, you create a new version of the template. Each version
    /// 			of the template maintains a description of the version in the
    /// 				<code>VersionDescription</code> field.</p>
    public let versionDescription: String?

    public init (
        awsAccountId: String? = nil,
        name: String? = nil,
        sourceEntity: TemplateSourceEntity? = nil,
        templateId: String? = nil,
        versionDescription: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.name = name
        self.sourceEntity = sourceEntity
        self.templateId = templateId
        self.versionDescription = versionDescription
    }
}

struct UpdateTemplateInputBody: Equatable {
    public let sourceEntity: TemplateSourceEntity?
    public let versionDescription: String?
    public let name: String?
}

extension UpdateTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case sourceEntity = "SourceEntity"
        case versionDescription = "VersionDescription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceEntityDecoded = try containerValues.decodeIfPresent(TemplateSourceEntity.self, forKey: .sourceEntity)
        sourceEntity = sourceEntityDecoded
        let versionDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionDescription)
        versionDescription = versionDescriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTemplateOutputError: Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTemplateOutputResponse(arn: \(String(describing: arn)), creationStatus: \(String(describing: creationStatus)), requestId: \(String(describing: requestId)), status: \(String(describing: status)), templateId: \(String(describing: templateId)), versionArn: \(String(describing: versionArn)))"}
}

extension UpdateTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationStatus = output.creationStatus
            self.requestId = output.requestId
            self.templateId = output.templateId
            self.versionArn = output.versionArn
        } else {
            self.arn = nil
            self.creationStatus = nil
            self.requestId = nil
            self.templateId = nil
            self.versionArn = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateTemplateOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the template.</p>
    public let arn: String?
    /// <p>The creation status of the template.</p>
    public let creationStatus: ResourceStatus?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>The ID for the template.</p>
    public let templateId: String?
    /// <p>The ARN for the template, including the version information of the first version.</p>
    public let versionArn: String?

    public init (
        arn: String? = nil,
        creationStatus: ResourceStatus? = nil,
        requestId: String? = nil,
        status: Int = 0,
        templateId: String? = nil,
        versionArn: String? = nil
    )
    {
        self.arn = arn
        self.creationStatus = creationStatus
        self.requestId = requestId
        self.status = status
        self.templateId = templateId
        self.versionArn = versionArn
    }
}

struct UpdateTemplateOutputResponseBody: Equatable {
    public let templateId: String?
    public let arn: String?
    public let versionArn: String?
    public let creationStatus: ResourceStatus?
    public let status: Int
    public let requestId: String?
}

extension UpdateTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationStatus = "CreationStatus"
        case requestId = "RequestId"
        case status = "Status"
        case templateId = "TemplateId"
        case versionArn = "VersionArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let versionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionArn)
        versionArn = versionArnDecoded
        let creationStatusDecoded = try containerValues.decodeIfPresent(ResourceStatus.self, forKey: .creationStatus)
        creationStatus = creationStatusDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

public struct UpdateTemplatePermissionsInputBodyMiddleware: Middleware {
    public let id: String = "UpdateTemplatePermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTemplatePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTemplatePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTemplatePermissionsInput>
    public typealias MOutput = OperationOutput<UpdateTemplatePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTemplatePermissionsOutputError>
}

extension UpdateTemplatePermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTemplatePermissionsInput(awsAccountId: \(String(describing: awsAccountId)), grantPermissions: \(String(describing: grantPermissions)), revokePermissions: \(String(describing: revokePermissions)), templateId: \(String(describing: templateId)))"}
}

extension UpdateTemplatePermissionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantPermissions = grantPermissions {
            var grantPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantPermissions)
            for updateresourcepermissionlist0 in grantPermissions {
                try grantPermissionsContainer.encode(updateresourcepermissionlist0)
            }
        }
        if let revokePermissions = revokePermissions {
            var revokePermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .revokePermissions)
            for updateresourcepermissionlist0 in revokePermissions {
                try revokePermissionsContainer.encode(updateresourcepermissionlist0)
            }
        }
    }
}

public struct UpdateTemplatePermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateTemplatePermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTemplatePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTemplatePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTemplatePermissionsInput>
    public typealias MOutput = OperationOutput<UpdateTemplatePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTemplatePermissionsOutputError>
}

public struct UpdateTemplatePermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateTemplatePermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTemplatePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTemplatePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTemplatePermissionsInput>
    public typealias MOutput = OperationOutput<UpdateTemplatePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTemplatePermissionsOutputError>
}

public struct UpdateTemplatePermissionsInput: Equatable {
    /// <p>The ID of the AWS account that contains the template.</p>
    public let awsAccountId: String?
    /// <p>A list of resource permissions to be granted on the template. </p>
    public let grantPermissions: [ResourcePermission]?
    /// <p>A list of resource permissions to be revoked from the template. </p>
    public let revokePermissions: [ResourcePermission]?
    /// <p>The ID for the template.</p>
    public let templateId: String?

    public init (
        awsAccountId: String? = nil,
        grantPermissions: [ResourcePermission]? = nil,
        revokePermissions: [ResourcePermission]? = nil,
        templateId: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.grantPermissions = grantPermissions
        self.revokePermissions = revokePermissions
        self.templateId = templateId
    }
}

struct UpdateTemplatePermissionsInputBody: Equatable {
    public let grantPermissions: [ResourcePermission]?
    public let revokePermissions: [ResourcePermission]?
}

extension UpdateTemplatePermissionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantPermissionsContainer = try containerValues.decodeIfPresent([ResourcePermission?].self, forKey: .grantPermissions)
        var grantPermissionsDecoded0:[ResourcePermission]? = nil
        if let grantPermissionsContainer = grantPermissionsContainer {
            grantPermissionsDecoded0 = [ResourcePermission]()
            for structure0 in grantPermissionsContainer {
                if let structure0 = structure0 {
                    grantPermissionsDecoded0?.append(structure0)
                }
            }
        }
        grantPermissions = grantPermissionsDecoded0
        let revokePermissionsContainer = try containerValues.decodeIfPresent([ResourcePermission?].self, forKey: .revokePermissions)
        var revokePermissionsDecoded0:[ResourcePermission]? = nil
        if let revokePermissionsContainer = revokePermissionsContainer {
            revokePermissionsDecoded0 = [ResourcePermission]()
            for structure0 in revokePermissionsContainer {
                if let structure0 = structure0 {
                    revokePermissionsDecoded0?.append(structure0)
                }
            }
        }
        revokePermissions = revokePermissionsDecoded0
    }
}

extension UpdateTemplatePermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTemplatePermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTemplatePermissionsOutputError: Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTemplatePermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTemplatePermissionsOutputResponse(permissions: \(String(describing: permissions)), requestId: \(String(describing: requestId)), status: \(String(describing: status)), templateArn: \(String(describing: templateArn)), templateId: \(String(describing: templateId)))"}
}

extension UpdateTemplatePermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateTemplatePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.permissions = output.permissions
            self.requestId = output.requestId
            self.templateArn = output.templateArn
            self.templateId = output.templateId
        } else {
            self.permissions = nil
            self.requestId = nil
            self.templateArn = nil
            self.templateId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateTemplatePermissionsOutputResponse: Equatable {
    /// <p>A list of resource permissions to be set on the template.</p>
    public let permissions: [ResourcePermission]?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>The Amazon Resource Name (ARN) of the template.</p>
    public let templateArn: String?
    /// <p>The ID for the template.</p>
    public let templateId: String?

    public init (
        permissions: [ResourcePermission]? = nil,
        requestId: String? = nil,
        status: Int = 0,
        templateArn: String? = nil,
        templateId: String? = nil
    )
    {
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
        self.templateArn = templateArn
        self.templateId = templateId
    }
}

struct UpdateTemplatePermissionsOutputResponseBody: Equatable {
    public let templateId: String?
    public let templateArn: String?
    public let permissions: [ResourcePermission]?
    public let requestId: String?
    public let status: Int
}

extension UpdateTemplatePermissionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
        case templateArn = "TemplateArn"
        case templateId = "TemplateId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let templateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

public struct UpdateThemeAliasInputBodyMiddleware: Middleware {
    public let id: String = "UpdateThemeAliasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateThemeAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateThemeAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateThemeAliasInput>
    public typealias MOutput = OperationOutput<UpdateThemeAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateThemeAliasOutputError>
}

extension UpdateThemeAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateThemeAliasInput(aliasName: \(String(describing: aliasName)), awsAccountId: \(String(describing: awsAccountId)), themeId: \(String(describing: themeId)), themeVersionNumber: \(String(describing: themeVersionNumber)))"}
}

extension UpdateThemeAliasInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case themeVersionNumber = "ThemeVersionNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let themeVersionNumber = themeVersionNumber {
            try encodeContainer.encode(themeVersionNumber, forKey: .themeVersionNumber)
        }
    }
}

public struct UpdateThemeAliasInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateThemeAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateThemeAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateThemeAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateThemeAliasInput>
    public typealias MOutput = OperationOutput<UpdateThemeAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateThemeAliasOutputError>
}

public struct UpdateThemeAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateThemeAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateThemeAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateThemeAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateThemeAliasInput>
    public typealias MOutput = OperationOutput<UpdateThemeAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateThemeAliasOutputError>
}

public struct UpdateThemeAliasInput: Equatable {
    /// <p>The name of the theme alias that you want to update.</p>
    public let aliasName: String?
    /// <p>The ID of the AWS account that contains the theme alias that you're updating.</p>
    public let awsAccountId: String?
    /// <p>The ID for the theme.</p>
    public let themeId: String?
    /// <p>The version number of the theme that the alias should reference.</p>
    public let themeVersionNumber: Int?

    public init (
        aliasName: String? = nil,
        awsAccountId: String? = nil,
        themeId: String? = nil,
        themeVersionNumber: Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.themeId = themeId
        self.themeVersionNumber = themeVersionNumber
    }
}

struct UpdateThemeAliasInputBody: Equatable {
    public let themeVersionNumber: Int?
}

extension UpdateThemeAliasInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case themeVersionNumber = "ThemeVersionNumber"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeVersionNumberDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .themeVersionNumber)
        themeVersionNumber = themeVersionNumberDecoded
    }
}

extension UpdateThemeAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateThemeAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateThemeAliasOutputError: Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateThemeAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateThemeAliasOutputResponse(requestId: \(String(describing: requestId)), status: \(String(describing: status)), themeAlias: \(String(describing: themeAlias)))"}
}

extension UpdateThemeAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateThemeAliasOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.requestId = output.requestId
            self.themeAlias = output.themeAlias
        } else {
            self.requestId = nil
            self.themeAlias = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateThemeAliasOutputResponse: Equatable {
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>Information about the theme alias.</p>
    public let themeAlias: ThemeAlias?

    public init (
        requestId: String? = nil,
        status: Int = 0,
        themeAlias: ThemeAlias? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.themeAlias = themeAlias
    }
}

struct UpdateThemeAliasOutputResponseBody: Equatable {
    public let themeAlias: ThemeAlias?
    public let status: Int
    public let requestId: String?
}

extension UpdateThemeAliasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case themeAlias = "ThemeAlias"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeAliasDecoded = try containerValues.decodeIfPresent(ThemeAlias.self, forKey: .themeAlias)
        themeAlias = themeAliasDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

public struct UpdateThemeInputBodyMiddleware: Middleware {
    public let id: String = "UpdateThemeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateThemeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateThemeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateThemeInput>
    public typealias MOutput = OperationOutput<UpdateThemeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateThemeOutputError>
}

extension UpdateThemeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateThemeInput(awsAccountId: \(String(describing: awsAccountId)), baseThemeId: \(String(describing: baseThemeId)), configuration: \(String(describing: configuration)), name: \(String(describing: name)), themeId: \(String(describing: themeId)), versionDescription: \(String(describing: versionDescription)))"}
}

extension UpdateThemeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case baseThemeId = "BaseThemeId"
        case configuration = "Configuration"
        case name = "Name"
        case versionDescription = "VersionDescription"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseThemeId = baseThemeId {
            try encodeContainer.encode(baseThemeId, forKey: .baseThemeId)
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let versionDescription = versionDescription {
            try encodeContainer.encode(versionDescription, forKey: .versionDescription)
        }
    }
}

public struct UpdateThemeInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateThemeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateThemeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateThemeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateThemeInput>
    public typealias MOutput = OperationOutput<UpdateThemeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateThemeOutputError>
}

public struct UpdateThemeInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateThemeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateThemeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateThemeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateThemeInput>
    public typealias MOutput = OperationOutput<UpdateThemeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateThemeOutputError>
}

public struct UpdateThemeInput: Equatable {
    /// <p>The ID of the AWS account that contains the theme that you're updating.</p>
    public let awsAccountId: String?
    /// <p>The theme ID, defined by Amazon QuickSight, that a custom theme inherits from.
    /// 		All themes initially inherit from a default QuickSight theme.</p>
    public let baseThemeId: String?
    /// <p>The theme configuration, which contains the theme display properties.</p>
    public let configuration: ThemeConfiguration?
    /// <p>The name for the theme.</p>
    public let name: String?
    /// <p>The ID for the theme.</p>
    public let themeId: String?
    /// <p>A description of the theme version that you're updating Every time that you call
    /// 				<code>UpdateTheme</code>, you create a new version of the theme. Each version of the
    /// 			theme maintains a description of the version in <code>VersionDescription</code>.</p>
    public let versionDescription: String?

    public init (
        awsAccountId: String? = nil,
        baseThemeId: String? = nil,
        configuration: ThemeConfiguration? = nil,
        name: String? = nil,
        themeId: String? = nil,
        versionDescription: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.baseThemeId = baseThemeId
        self.configuration = configuration
        self.name = name
        self.themeId = themeId
        self.versionDescription = versionDescription
    }
}

struct UpdateThemeInputBody: Equatable {
    public let name: String?
    public let baseThemeId: String?
    public let versionDescription: String?
    public let configuration: ThemeConfiguration?
}

extension UpdateThemeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case baseThemeId = "BaseThemeId"
        case configuration = "Configuration"
        case name = "Name"
        case versionDescription = "VersionDescription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let baseThemeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baseThemeId)
        baseThemeId = baseThemeIdDecoded
        let versionDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionDescription)
        versionDescription = versionDescriptionDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(ThemeConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension UpdateThemeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateThemeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateThemeOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateThemeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateThemeOutputResponse(arn: \(String(describing: arn)), creationStatus: \(String(describing: creationStatus)), requestId: \(String(describing: requestId)), status: \(String(describing: status)), themeId: \(String(describing: themeId)), versionArn: \(String(describing: versionArn)))"}
}

extension UpdateThemeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateThemeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationStatus = output.creationStatus
            self.requestId = output.requestId
            self.themeId = output.themeId
            self.versionArn = output.versionArn
        } else {
            self.arn = nil
            self.creationStatus = nil
            self.requestId = nil
            self.themeId = nil
            self.versionArn = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateThemeOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the theme.</p>
    public let arn: String?
    /// <p>The creation status of the theme.</p>
    public let creationStatus: ResourceStatus?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>The ID for the theme.</p>
    public let themeId: String?
    /// <p>The Amazon Resource Name (ARN) for the new version of the theme.</p>
    public let versionArn: String?

    public init (
        arn: String? = nil,
        creationStatus: ResourceStatus? = nil,
        requestId: String? = nil,
        status: Int = 0,
        themeId: String? = nil,
        versionArn: String? = nil
    )
    {
        self.arn = arn
        self.creationStatus = creationStatus
        self.requestId = requestId
        self.status = status
        self.themeId = themeId
        self.versionArn = versionArn
    }
}

struct UpdateThemeOutputResponseBody: Equatable {
    public let themeId: String?
    public let arn: String?
    public let versionArn: String?
    public let creationStatus: ResourceStatus?
    public let status: Int
    public let requestId: String?
}

extension UpdateThemeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationStatus = "CreationStatus"
        case requestId = "RequestId"
        case status = "Status"
        case themeId = "ThemeId"
        case versionArn = "VersionArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .themeId)
        themeId = themeIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let versionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionArn)
        versionArn = versionArnDecoded
        let creationStatusDecoded = try containerValues.decodeIfPresent(ResourceStatus.self, forKey: .creationStatus)
        creationStatus = creationStatusDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

public struct UpdateThemePermissionsInputBodyMiddleware: Middleware {
    public let id: String = "UpdateThemePermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateThemePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateThemePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateThemePermissionsInput>
    public typealias MOutput = OperationOutput<UpdateThemePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateThemePermissionsOutputError>
}

extension UpdateThemePermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateThemePermissionsInput(awsAccountId: \(String(describing: awsAccountId)), grantPermissions: \(String(describing: grantPermissions)), revokePermissions: \(String(describing: revokePermissions)), themeId: \(String(describing: themeId)))"}
}

extension UpdateThemePermissionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantPermissions = grantPermissions {
            var grantPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantPermissions)
            for updateresourcepermissionlist0 in grantPermissions {
                try grantPermissionsContainer.encode(updateresourcepermissionlist0)
            }
        }
        if let revokePermissions = revokePermissions {
            var revokePermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .revokePermissions)
            for updateresourcepermissionlist0 in revokePermissions {
                try revokePermissionsContainer.encode(updateresourcepermissionlist0)
            }
        }
    }
}

public struct UpdateThemePermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateThemePermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateThemePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateThemePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateThemePermissionsInput>
    public typealias MOutput = OperationOutput<UpdateThemePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateThemePermissionsOutputError>
}

public struct UpdateThemePermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateThemePermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateThemePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateThemePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateThemePermissionsInput>
    public typealias MOutput = OperationOutput<UpdateThemePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateThemePermissionsOutputError>
}

public struct UpdateThemePermissionsInput: Equatable {
    /// <p>The ID of the AWS account that contains the theme.</p>
    public let awsAccountId: String?
    /// <p>A list of resource permissions to be granted for the theme.</p>
    public let grantPermissions: [ResourcePermission]?
    /// <p>A list of resource permissions to be revoked from the theme.</p>
    public let revokePermissions: [ResourcePermission]?
    /// <p>The ID for the theme.</p>
    public let themeId: String?

    public init (
        awsAccountId: String? = nil,
        grantPermissions: [ResourcePermission]? = nil,
        revokePermissions: [ResourcePermission]? = nil,
        themeId: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.grantPermissions = grantPermissions
        self.revokePermissions = revokePermissions
        self.themeId = themeId
    }
}

struct UpdateThemePermissionsInputBody: Equatable {
    public let grantPermissions: [ResourcePermission]?
    public let revokePermissions: [ResourcePermission]?
}

extension UpdateThemePermissionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantPermissionsContainer = try containerValues.decodeIfPresent([ResourcePermission?].self, forKey: .grantPermissions)
        var grantPermissionsDecoded0:[ResourcePermission]? = nil
        if let grantPermissionsContainer = grantPermissionsContainer {
            grantPermissionsDecoded0 = [ResourcePermission]()
            for structure0 in grantPermissionsContainer {
                if let structure0 = structure0 {
                    grantPermissionsDecoded0?.append(structure0)
                }
            }
        }
        grantPermissions = grantPermissionsDecoded0
        let revokePermissionsContainer = try containerValues.decodeIfPresent([ResourcePermission?].self, forKey: .revokePermissions)
        var revokePermissionsDecoded0:[ResourcePermission]? = nil
        if let revokePermissionsContainer = revokePermissionsContainer {
            revokePermissionsDecoded0 = [ResourcePermission]()
            for structure0 in revokePermissionsContainer {
                if let structure0 = structure0 {
                    revokePermissionsDecoded0?.append(structure0)
                }
            }
        }
        revokePermissions = revokePermissionsDecoded0
    }
}

extension UpdateThemePermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateThemePermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateThemePermissionsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateThemePermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateThemePermissionsOutputResponse(permissions: \(String(describing: permissions)), requestId: \(String(describing: requestId)), status: \(String(describing: status)), themeArn: \(String(describing: themeArn)), themeId: \(String(describing: themeId)))"}
}

extension UpdateThemePermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateThemePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.permissions = output.permissions
            self.requestId = output.requestId
            self.themeArn = output.themeArn
            self.themeId = output.themeId
        } else {
            self.permissions = nil
            self.requestId = nil
            self.themeArn = nil
            self.themeId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateThemePermissionsOutputResponse: Equatable {
    /// <p>The resulting list of resource permissions for the theme.</p>
    public let permissions: [ResourcePermission]?
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>The Amazon Resource Name (ARN) of the theme.</p>
    public let themeArn: String?
    /// <p>The ID for the theme.</p>
    public let themeId: String?

    public init (
        permissions: [ResourcePermission]? = nil,
        requestId: String? = nil,
        status: Int = 0,
        themeArn: String? = nil,
        themeId: String? = nil
    )
    {
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
        self.themeArn = themeArn
        self.themeId = themeId
    }
}

struct UpdateThemePermissionsOutputResponseBody: Equatable {
    public let themeId: String?
    public let themeArn: String?
    public let permissions: [ResourcePermission]?
    public let requestId: String?
    public let status: Int
}

extension UpdateThemePermissionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
        case themeArn = "ThemeArn"
        case themeId = "ThemeId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .themeId)
        themeId = themeIdDecoded
        let themeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .themeArn)
        themeArn = themeArnDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

public struct UpdateUserInputBodyMiddleware: Middleware {
    public let id: String = "UpdateUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserInput>
    public typealias MOutput = OperationOutput<UpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserOutputError>
}

extension UpdateUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserInput(awsAccountId: \(String(describing: awsAccountId)), customFederationProviderUrl: \(String(describing: customFederationProviderUrl)), customPermissionsName: \(String(describing: customPermissionsName)), email: \(String(describing: email)), externalLoginFederationProviderType: \(String(describing: externalLoginFederationProviderType)), externalLoginId: \(String(describing: externalLoginId)), namespace: \(String(describing: namespace)), role: \(String(describing: role)), unapplyCustomPermissions: \(String(describing: unapplyCustomPermissions)), userName: \(String(describing: userName)))"}
}

extension UpdateUserInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customFederationProviderUrl = "CustomFederationProviderUrl"
        case customPermissionsName = "CustomPermissionsName"
        case email = "Email"
        case externalLoginFederationProviderType = "ExternalLoginFederationProviderType"
        case externalLoginId = "ExternalLoginId"
        case role = "Role"
        case unapplyCustomPermissions = "UnapplyCustomPermissions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customFederationProviderUrl = customFederationProviderUrl {
            try encodeContainer.encode(customFederationProviderUrl, forKey: .customFederationProviderUrl)
        }
        if let customPermissionsName = customPermissionsName {
            try encodeContainer.encode(customPermissionsName, forKey: .customPermissionsName)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let externalLoginFederationProviderType = externalLoginFederationProviderType {
            try encodeContainer.encode(externalLoginFederationProviderType, forKey: .externalLoginFederationProviderType)
        }
        if let externalLoginId = externalLoginId {
            try encodeContainer.encode(externalLoginId, forKey: .externalLoginId)
        }
        if let role = role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
        if unapplyCustomPermissions != false {
            try encodeContainer.encode(unapplyCustomPermissions, forKey: .unapplyCustomPermissions)
        }
    }
}

public struct UpdateUserInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserInput>
    public typealias MOutput = OperationOutput<UpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserOutputError>
}

public struct UpdateUserInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserInput>
    public typealias MOutput = OperationOutput<UpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserOutputError>
}

public struct UpdateUserInput: Equatable {
    /// <p>The ID for the AWS account that the user is in. Currently, you use the ID for the AWS
    /// 			account that contains your Amazon QuickSight account.</p>
    public let awsAccountId: String?
    /// <p>The URL of the custom OpenID Connect (OIDC) provider that provides identity to let a user federate
    ///          into QuickSight with an associated AWS Identity and Access Management (IAM) role. This parameter should
    ///          only be used when <code>ExternalLoginFederationProviderType</code> parameter is set to <code>CUSTOM_OIDC</code>.</p>
    public let customFederationProviderUrl: String?
    /// <p>(Enterprise edition only) The name of the custom permissions profile that you want to
    ///             assign to this user. Customized permissions allows you to control a user's access by
    ///             restricting access the following operations:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Create and update data sources</p>
    ///             </li>
    ///             <li>
    ///                 <p>Create and update datasets</p>
    ///             </li>
    ///             <li>
    ///                 <p>Create and update email reports</p>
    ///             </li>
    ///             <li>
    ///                 <p>Subscribe to email reports</p>
    ///             </li>
    ///          </ul>
    ///         <p>A set of custom permissions includes any combination of these restrictions. Currently,
    ///             you need to create the profile names for custom permission sets by using the QuickSight
    ///             console. Then, you use the <code>RegisterUser</code> API operation to assign the named set of
    ///             permissions to a QuickSight user. </p>
    ///         <p>QuickSight custom permissions are applied through IAM policies. Therefore, they
    ///             override the permissions typically granted by assigning QuickSight users to one of the
    ///             default security cohorts in QuickSight (admin, author, reader).</p>
    ///         <p>This feature is available only to QuickSight Enterprise edition subscriptions that use
    ///             SAML 2.0-Based Federation for Single Sign-On (SSO).</p>
    public let customPermissionsName: String?
    /// <p>The email address of the user that you want to update.</p>
    public let email: String?
    /// <p>The type of supported external login provider that provides identity to let a user federate into QuickSight with an associated AWS Identity and Access Management (IAM) role. The type of supported external login provider can be one of the following.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>COGNITO</code>: Amazon Cognito. The provider URL is cognito-identity.amazonaws.com. When choosing the <code>COGNITO</code> provider type, don’t use the "CustomFederationProviderUrl" parameter which is only needed when the external provider is custom.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CUSTOM_OIDC</code>: Custom OpenID Connect (OIDC) provider. When choosing <code>CUSTOM_OIDC</code> type, use the <code>CustomFederationProviderUrl</code> parameter to provide the custom OIDC provider URL.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NONE</code>: This clears all the previously saved external login information for a user. Use <code>
    ///                      <a>DescribeUser</a>
    ///                   </code> API to check the external login information.</p>
    ///             </li>
    ///          </ul>
    public let externalLoginFederationProviderType: String?
    /// <p>The identity ID for a user in the external login provider.</p>
    public let externalLoginId: String?
    /// <p>The namespace. Currently, you should set this to <code>default</code>.</p>
    public let namespace: String?
    /// <p>The Amazon QuickSight role of the user. The role can be one of the
    /// 			following default security cohorts:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>
    ///                   <code>READER</code>: A user who has read-only access to dashboards.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>AUTHOR</code>: A user who can create data sources, datasets, analyses, and
    /// 					dashboards.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>ADMIN</code>: A user who is an author, who can also manage Amazon QuickSight
    /// 					settings.</p>
    /// 			         </li>
    ///          </ul>
    /// 	        <p>The name of the QuickSight role is invisible to the user except for the console
    /// 	        screens dealing with permissions.</p>
    public let role: UserRole?
    /// <p>A flag that you use to indicate that you want to remove all custom permissions
    ///             from this user. Using this parameter resets the user to the state
    ///             it was in before a custom permissions profile was applied. This parameter defaults to
    ///             NULL and it doesn't accept any other value.</p>
    public let unapplyCustomPermissions: Bool
    /// <p>The Amazon QuickSight user name that you want to update.</p>
    public let userName: String?

    public init (
        awsAccountId: String? = nil,
        customFederationProviderUrl: String? = nil,
        customPermissionsName: String? = nil,
        email: String? = nil,
        externalLoginFederationProviderType: String? = nil,
        externalLoginId: String? = nil,
        namespace: String? = nil,
        role: UserRole? = nil,
        unapplyCustomPermissions: Bool = false,
        userName: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.customFederationProviderUrl = customFederationProviderUrl
        self.customPermissionsName = customPermissionsName
        self.email = email
        self.externalLoginFederationProviderType = externalLoginFederationProviderType
        self.externalLoginId = externalLoginId
        self.namespace = namespace
        self.role = role
        self.unapplyCustomPermissions = unapplyCustomPermissions
        self.userName = userName
    }
}

struct UpdateUserInputBody: Equatable {
    public let email: String?
    public let role: UserRole?
    public let customPermissionsName: String?
    public let unapplyCustomPermissions: Bool
    public let externalLoginFederationProviderType: String?
    public let customFederationProviderUrl: String?
    public let externalLoginId: String?
}

extension UpdateUserInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customFederationProviderUrl = "CustomFederationProviderUrl"
        case customPermissionsName = "CustomPermissionsName"
        case email = "Email"
        case externalLoginFederationProviderType = "ExternalLoginFederationProviderType"
        case externalLoginId = "ExternalLoginId"
        case role = "Role"
        case unapplyCustomPermissions = "UnapplyCustomPermissions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
        let roleDecoded = try containerValues.decodeIfPresent(UserRole.self, forKey: .role)
        role = roleDecoded
        let customPermissionsNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customPermissionsName)
        customPermissionsName = customPermissionsNameDecoded
        let unapplyCustomPermissionsDecoded = try containerValues.decode(Bool.self, forKey: .unapplyCustomPermissions)
        unapplyCustomPermissions = unapplyCustomPermissionsDecoded
        let externalLoginFederationProviderTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalLoginFederationProviderType)
        externalLoginFederationProviderType = externalLoginFederationProviderTypeDecoded
        let customFederationProviderUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customFederationProviderUrl)
        customFederationProviderUrl = customFederationProviderUrlDecoded
        let externalLoginIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalLoginId)
        externalLoginId = externalLoginIdDecoded
    }
}

extension UpdateUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserOutputResponse(requestId: \(String(describing: requestId)), status: \(String(describing: status)), user: \(String(describing: user)))"}
}

extension UpdateUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateUserOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.requestId = output.requestId
            self.user = output.user
        } else {
            self.requestId = nil
            self.user = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateUserOutputResponse: Equatable {
    /// <p>The AWS request ID for this operation.</p>
    public let requestId: String?
    /// <p>The HTTP status of the request.</p>
    public let status: Int
    /// <p>The Amazon QuickSight user.</p>
    public let user: User?

    public init (
        requestId: String? = nil,
        status: Int = 0,
        user: User? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.user = user
    }
}

struct UpdateUserOutputResponseBody: Equatable {
    public let user: User?
    public let requestId: String?
    public let status: Int
}

extension UpdateUserOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case user = "User"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(User.self, forKey: .user)
        user = userDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension UploadSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case containsHeader = "ContainsHeader"
        case delimiter = "Delimiter"
        case format = "Format"
        case startFromRow = "StartFromRow"
        case textQualifier = "TextQualifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if containsHeader != false {
            try encodeContainer.encode(containsHeader, forKey: .containsHeader)
        }
        if let delimiter = delimiter {
            try encodeContainer.encode(delimiter, forKey: .delimiter)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if startFromRow != 0 {
            try encodeContainer.encode(startFromRow, forKey: .startFromRow)
        }
        if let textQualifier = textQualifier {
            try encodeContainer.encode(textQualifier.rawValue, forKey: .textQualifier)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(FileFormat.self, forKey: .format)
        format = formatDecoded
        let startFromRowDecoded = try containerValues.decode(Int.self, forKey: .startFromRow)
        startFromRow = startFromRowDecoded
        let containsHeaderDecoded = try containerValues.decode(Bool.self, forKey: .containsHeader)
        containsHeader = containsHeaderDecoded
        let textQualifierDecoded = try containerValues.decodeIfPresent(TextQualifier.self, forKey: .textQualifier)
        textQualifier = textQualifierDecoded
        let delimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
    }
}

extension UploadSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UploadSettings(containsHeader: \(String(describing: containsHeader)), delimiter: \(String(describing: delimiter)), format: \(String(describing: format)), startFromRow: \(String(describing: startFromRow)), textQualifier: \(String(describing: textQualifier)))"}
}

/// <p>Information about the format for a source file or files.</p>
public struct UploadSettings: Equatable {
    /// <p>Whether the file has a header row, or the files each have a header row.</p>
    public let containsHeader: Bool
    /// <p>The delimiter between values in the file.</p>
    public let delimiter: String?
    /// <p>File format.</p>
    public let format: FileFormat?
    /// <p>A row number to start reading data from.</p>
    public let startFromRow: Int
    /// <p>Text qualifier.</p>
    public let textQualifier: TextQualifier?

    public init (
        containsHeader: Bool = false,
        delimiter: String? = nil,
        format: FileFormat? = nil,
        startFromRow: Int = 0,
        textQualifier: TextQualifier? = nil
    )
    {
        self.containsHeader = containsHeader
        self.delimiter = delimiter
        self.format = format
        self.startFromRow = startFromRow
        self.textQualifier = textQualifier
    }
}

extension User: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case active = "Active"
        case arn = "Arn"
        case customPermissionsName = "CustomPermissionsName"
        case email = "Email"
        case externalLoginFederationProviderType = "ExternalLoginFederationProviderType"
        case externalLoginFederationProviderUrl = "ExternalLoginFederationProviderUrl"
        case externalLoginId = "ExternalLoginId"
        case identityType = "IdentityType"
        case principalId = "PrincipalId"
        case role = "Role"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if active != false {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let customPermissionsName = customPermissionsName {
            try encodeContainer.encode(customPermissionsName, forKey: .customPermissionsName)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let externalLoginFederationProviderType = externalLoginFederationProviderType {
            try encodeContainer.encode(externalLoginFederationProviderType, forKey: .externalLoginFederationProviderType)
        }
        if let externalLoginFederationProviderUrl = externalLoginFederationProviderUrl {
            try encodeContainer.encode(externalLoginFederationProviderUrl, forKey: .externalLoginFederationProviderUrl)
        }
        if let externalLoginId = externalLoginId {
            try encodeContainer.encode(externalLoginId, forKey: .externalLoginId)
        }
        if let identityType = identityType {
            try encodeContainer.encode(identityType.rawValue, forKey: .identityType)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let role = role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
        let roleDecoded = try containerValues.decodeIfPresent(UserRole.self, forKey: .role)
        role = roleDecoded
        let identityTypeDecoded = try containerValues.decodeIfPresent(IdentityType.self, forKey: .identityType)
        identityType = identityTypeDecoded
        let activeDecoded = try containerValues.decode(Bool.self, forKey: .active)
        active = activeDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let customPermissionsNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customPermissionsName)
        customPermissionsName = customPermissionsNameDecoded
        let externalLoginFederationProviderTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalLoginFederationProviderType)
        externalLoginFederationProviderType = externalLoginFederationProviderTypeDecoded
        let externalLoginFederationProviderUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalLoginFederationProviderUrl)
        externalLoginFederationProviderUrl = externalLoginFederationProviderUrlDecoded
        let externalLoginIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalLoginId)
        externalLoginId = externalLoginIdDecoded
    }
}

extension User: CustomDebugStringConvertible {
    public var debugDescription: String {
        "User(active: \(String(describing: active)), arn: \(String(describing: arn)), customPermissionsName: \(String(describing: customPermissionsName)), email: \(String(describing: email)), externalLoginFederationProviderType: \(String(describing: externalLoginFederationProviderType)), externalLoginFederationProviderUrl: \(String(describing: externalLoginFederationProviderUrl)), externalLoginId: \(String(describing: externalLoginId)), identityType: \(String(describing: identityType)), principalId: \(String(describing: principalId)), role: \(String(describing: role)), userName: \(String(describing: userName)))"}
}

/// <p>A registered user of Amazon QuickSight. </p>
public struct User: Equatable {
    /// <p>The active status of user. When you create an Amazon QuickSight user that’s not an IAM
    ///             user or an Active Directory user, that user is inactive until they sign in and provide a
    ///             password.</p>
    public let active: Bool
    /// <p>The Amazon Resource Name (ARN) for the user.</p>
    public let arn: String?
    /// <p>The custom permissions profile associated with this user.</p>
    public let customPermissionsName: String?
    /// <p>The user's email address.</p>
    public let email: String?
    /// <p>The type of supported external login provider that provides identity to let the user
    ///             federate into Amazon QuickSight with an associated IAM role. The type can be one of the following.</p>
    ///         <ul>
    ///             <li>
    ///                     <p>
    ///                   <code>COGNITO</code>: Amazon Cognito. The provider URL is cognito-identity.amazonaws.com.</p>
    ///                 </li>
    ///             <li>
    ///                     <p>
    ///                   <code>CUSTOM_OIDC</code>: Custom OpenID Connect (OIDC) provider.</p>
    ///                 </li>
    ///          </ul>
    public let externalLoginFederationProviderType: String?
    /// <p>The URL of the external login provider.</p>
    public let externalLoginFederationProviderUrl: String?
    /// <p>The identity ID for the user in the external login provider.</p>
    public let externalLoginId: String?
    /// <p>The type of identity authentication used by the user.</p>
    public let identityType: IdentityType?
    /// <p>The principal ID of the user.</p>
    public let principalId: String?
    /// <p>The Amazon QuickSight role for the user. The user role can be one of the
    ///             following:.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>READER</code>: A user who has read-only access to dashboards.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>AUTHOR</code>: A user who can create data sources, datasets, analyses,
    ///                     and dashboards.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>ADMIN</code>: A user who is an author, who can also manage Amazon
    ///                     QuickSight settings.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>RESTRICTED_READER</code>: This role isn't currently available for
    ///                     use.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>RESTRICTED_AUTHOR</code>: This role isn't currently available for
    ///                     use.</p>
    ///             </li>
    ///          </ul>
    public let role: UserRole?
    /// <p>The user's user name.</p>
    public let userName: String?

    public init (
        active: Bool = false,
        arn: String? = nil,
        customPermissionsName: String? = nil,
        email: String? = nil,
        externalLoginFederationProviderType: String? = nil,
        externalLoginFederationProviderUrl: String? = nil,
        externalLoginId: String? = nil,
        identityType: IdentityType? = nil,
        principalId: String? = nil,
        role: UserRole? = nil,
        userName: String? = nil
    )
    {
        self.active = active
        self.arn = arn
        self.customPermissionsName = customPermissionsName
        self.email = email
        self.externalLoginFederationProviderType = externalLoginFederationProviderType
        self.externalLoginFederationProviderUrl = externalLoginFederationProviderUrl
        self.externalLoginId = externalLoginId
        self.identityType = identityType
        self.principalId = principalId
        self.role = role
        self.userName = userName
    }
}

public enum UserRole {
    case admin
    case author
    case reader
    case restrictedAuthor
    case restrictedReader
    case sdkUnknown(String)
}

extension UserRole : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UserRole] {
        return [
            .admin,
            .author,
            .reader,
            .restrictedAuthor,
            .restrictedReader,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .admin: return "ADMIN"
        case .author: return "AUTHOR"
        case .reader: return "READER"
        case .restrictedAuthor: return "RESTRICTED_AUTHOR"
        case .restrictedReader: return "RESTRICTED_READER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UserRole(rawValue: rawValue) ?? UserRole.sdkUnknown(rawValue)
    }
}

extension VpcConnectionProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case vpcConnectionArn = "VpcConnectionArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vpcConnectionArn = vpcConnectionArn {
            try encodeContainer.encode(vpcConnectionArn, forKey: .vpcConnectionArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcConnectionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcConnectionArn)
        vpcConnectionArn = vpcConnectionArnDecoded
    }
}

extension VpcConnectionProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VpcConnectionProperties(vpcConnectionArn: \(String(describing: vpcConnectionArn)))"}
}

/// <p>VPC connection properties.</p>
public struct VpcConnectionProperties: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the VPC connection.</p>
    public let vpcConnectionArn: String?

    public init (
        vpcConnectionArn: String? = nil
    )
    {
        self.vpcConnectionArn = vpcConnectionArn
    }
}
