// Code generated by smithy-swift-codegen. DO NOT EDIT!



public enum IngestionErrorType {
    case accountCapacityLimitExceeded
    case connectionFailure
    case customerError
    case dataSetDeleted
    case dataSetNotSpice
    case dataSetSizeLimitExceeded
    case dataSourceAuthFailed
    case dataSourceConnectionFailed
    case dataSourceNotFound
    case dataToleranceException
    case failureToAssumeRole
    case failureToProcessJsonFile
    case iamRoleNotAvailable
    case ingestionCanceled
    case ingestionSuperseded
    case internalServiceError
    case invalidDataprepSyntax
    case invalidDataSourceConfig
    case invalidDateFormat
    case iotDataSetFileEmpty
    case iotFileNotFound
    case oauthTokenFailure
    case passwordAuthenticationFailure
    case permissionDenied
    case queryTimeout
    case rowSizeLimitExceeded
    case s3FileInaccessible
    case s3ManifestError
    case s3UploadedFileDeleted
    case sourceApiLimitExceededFailure
    case sourceResourceLimitExceeded
    case spiceTableNotFound
    case sqlException
    case sqlInvalidParameterValue
    case sqlNumericOverflow
    case sqlSchemaMismatchError
    case sqlTableNotFound
    case sslCertificateValidationFailure
    case unresolvableHost
    case unroutableHost
    case sdkUnknown(String)
}

extension IngestionErrorType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IngestionErrorType] {
        return [
            .accountCapacityLimitExceeded,
            .connectionFailure,
            .customerError,
            .dataSetDeleted,
            .dataSetNotSpice,
            .dataSetSizeLimitExceeded,
            .dataSourceAuthFailed,
            .dataSourceConnectionFailed,
            .dataSourceNotFound,
            .dataToleranceException,
            .failureToAssumeRole,
            .failureToProcessJsonFile,
            .iamRoleNotAvailable,
            .ingestionCanceled,
            .ingestionSuperseded,
            .internalServiceError,
            .invalidDataprepSyntax,
            .invalidDataSourceConfig,
            .invalidDateFormat,
            .iotDataSetFileEmpty,
            .iotFileNotFound,
            .oauthTokenFailure,
            .passwordAuthenticationFailure,
            .permissionDenied,
            .queryTimeout,
            .rowSizeLimitExceeded,
            .s3FileInaccessible,
            .s3ManifestError,
            .s3UploadedFileDeleted,
            .sourceApiLimitExceededFailure,
            .sourceResourceLimitExceeded,
            .spiceTableNotFound,
            .sqlException,
            .sqlInvalidParameterValue,
            .sqlNumericOverflow,
            .sqlSchemaMismatchError,
            .sqlTableNotFound,
            .sslCertificateValidationFailure,
            .unresolvableHost,
            .unroutableHost,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accountCapacityLimitExceeded: return "ACCOUNT_CAPACITY_LIMIT_EXCEEDED"
        case .connectionFailure: return "CONNECTION_FAILURE"
        case .customerError: return "CUSTOMER_ERROR"
        case .dataSetDeleted: return "DATA_SET_DELETED"
        case .dataSetNotSpice: return "DATA_SET_NOT_SPICE"
        case .dataSetSizeLimitExceeded: return "DATA_SET_SIZE_LIMIT_EXCEEDED"
        case .dataSourceAuthFailed: return "DATA_SOURCE_AUTH_FAILED"
        case .dataSourceConnectionFailed: return "DATA_SOURCE_CONNECTION_FAILED"
        case .dataSourceNotFound: return "DATA_SOURCE_NOT_FOUND"
        case .dataToleranceException: return "DATA_TOLERANCE_EXCEPTION"
        case .failureToAssumeRole: return "FAILURE_TO_ASSUME_ROLE"
        case .failureToProcessJsonFile: return "FAILURE_TO_PROCESS_JSON_FILE"
        case .iamRoleNotAvailable: return "IAM_ROLE_NOT_AVAILABLE"
        case .ingestionCanceled: return "INGESTION_CANCELED"
        case .ingestionSuperseded: return "INGESTION_SUPERSEDED"
        case .internalServiceError: return "INTERNAL_SERVICE_ERROR"
        case .invalidDataprepSyntax: return "INVALID_DATAPREP_SYNTAX"
        case .invalidDataSourceConfig: return "INVALID_DATA_SOURCE_CONFIG"
        case .invalidDateFormat: return "INVALID_DATE_FORMAT"
        case .iotDataSetFileEmpty: return "IOT_DATA_SET_FILE_EMPTY"
        case .iotFileNotFound: return "IOT_FILE_NOT_FOUND"
        case .oauthTokenFailure: return "OAUTH_TOKEN_FAILURE"
        case .passwordAuthenticationFailure: return "PASSWORD_AUTHENTICATION_FAILURE"
        case .permissionDenied: return "PERMISSION_DENIED"
        case .queryTimeout: return "QUERY_TIMEOUT"
        case .rowSizeLimitExceeded: return "ROW_SIZE_LIMIT_EXCEEDED"
        case .s3FileInaccessible: return "S3_FILE_INACCESSIBLE"
        case .s3ManifestError: return "S3_MANIFEST_ERROR"
        case .s3UploadedFileDeleted: return "S3_UPLOADED_FILE_DELETED"
        case .sourceApiLimitExceededFailure: return "SOURCE_API_LIMIT_EXCEEDED_FAILURE"
        case .sourceResourceLimitExceeded: return "SOURCE_RESOURCE_LIMIT_EXCEEDED"
        case .spiceTableNotFound: return "SPICE_TABLE_NOT_FOUND"
        case .sqlException: return "SQL_EXCEPTION"
        case .sqlInvalidParameterValue: return "SQL_INVALID_PARAMETER_VALUE"
        case .sqlNumericOverflow: return "SQL_NUMERIC_OVERFLOW"
        case .sqlSchemaMismatchError: return "SQL_SCHEMA_MISMATCH_ERROR"
        case .sqlTableNotFound: return "SQL_TABLE_NOT_FOUND"
        case .sslCertificateValidationFailure: return "SSL_CERTIFICATE_VALIDATION_FAILURE"
        case .unresolvableHost: return "UNRESOLVABLE_HOST"
        case .unroutableHost: return "UNROUTABLE_HOST"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IngestionErrorType(rawValue: rawValue) ?? IngestionErrorType.sdkUnknown(rawValue)
    }
}
