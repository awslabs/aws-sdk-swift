// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension Ingestion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case errorInfo = "ErrorInfo"
        case ingestionId = "IngestionId"
        case ingestionSizeInBytes = "IngestionSizeInBytes"
        case ingestionStatus = "IngestionStatus"
        case ingestionTimeInSeconds = "IngestionTimeInSeconds"
        case queueInfo = "QueueInfo"
        case requestSource = "RequestSource"
        case requestType = "RequestType"
        case rowInfo = "RowInfo"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let errorInfo = errorInfo {
            try encodeContainer.encode(errorInfo, forKey: .errorInfo)
        }
        if let ingestionId = ingestionId {
            try encodeContainer.encode(ingestionId, forKey: .ingestionId)
        }
        if ingestionSizeInBytes != 0 {
            try encodeContainer.encode(ingestionSizeInBytes, forKey: .ingestionSizeInBytes)
        }
        if let ingestionStatus = ingestionStatus {
            try encodeContainer.encode(ingestionStatus.rawValue, forKey: .ingestionStatus)
        }
        if ingestionTimeInSeconds != 0 {
            try encodeContainer.encode(ingestionTimeInSeconds, forKey: .ingestionTimeInSeconds)
        }
        if let queueInfo = queueInfo {
            try encodeContainer.encode(queueInfo, forKey: .queueInfo)
        }
        if let requestSource = requestSource {
            try encodeContainer.encode(requestSource.rawValue, forKey: .requestSource)
        }
        if let requestType = requestType {
            try encodeContainer.encode(requestType.rawValue, forKey: .requestType)
        }
        if let rowInfo = rowInfo {
            try encodeContainer.encode(rowInfo, forKey: .rowInfo)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let ingestionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ingestionId)
        ingestionId = ingestionIdDecoded
        let ingestionStatusDecoded = try containerValues.decodeIfPresent(IngestionStatus.self, forKey: .ingestionStatus)
        ingestionStatus = ingestionStatusDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(ErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let rowInfoDecoded = try containerValues.decodeIfPresent(RowInfo.self, forKey: .rowInfo)
        rowInfo = rowInfoDecoded
        let queueInfoDecoded = try containerValues.decodeIfPresent(QueueInfo.self, forKey: .queueInfo)
        queueInfo = queueInfoDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let ingestionTimeInSecondsDecoded = try containerValues.decode(Int.self, forKey: .ingestionTimeInSeconds)
        ingestionTimeInSeconds = ingestionTimeInSecondsDecoded
        let ingestionSizeInBytesDecoded = try containerValues.decode(Int.self, forKey: .ingestionSizeInBytes)
        ingestionSizeInBytes = ingestionSizeInBytesDecoded
        let requestSourceDecoded = try containerValues.decodeIfPresent(IngestionRequestSource.self, forKey: .requestSource)
        requestSource = requestSourceDecoded
        let requestTypeDecoded = try containerValues.decodeIfPresent(IngestionRequestType.self, forKey: .requestType)
        requestType = requestTypeDecoded
    }
}
