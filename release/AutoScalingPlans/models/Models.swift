// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ApplicationSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudFormationStackARN = "CloudFormationStackARN"
        case tagFilters = "TagFilters"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudFormationStackARN = cloudFormationStackARN {
            try encodeContainer.encode(cloudFormationStackARN, forKey: .cloudFormationStackARN)
        }
        if let tagFilters = tagFilters {
            var tagFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagFilters)
            for tagfilters0 in tagFilters {
                try tagFiltersContainer.encode(tagfilters0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFormationStackARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudFormationStackARN)
        cloudFormationStackARN = cloudFormationStackARNDecoded
        let tagFiltersContainer = try containerValues.decodeIfPresent([TagFilter?].self, forKey: .tagFilters)
        var tagFiltersDecoded0:[TagFilter]? = nil
        if let tagFiltersContainer = tagFiltersContainer {
            tagFiltersDecoded0 = [TagFilter]()
            for structure0 in tagFiltersContainer {
                if let structure0 = structure0 {
                    tagFiltersDecoded0?.append(structure0)
                }
            }
        }
        tagFilters = tagFiltersDecoded0
    }
}

extension ApplicationSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationSource(cloudFormationStackARN: \(String(describing: cloudFormationStackARN)), tagFilters: \(String(describing: tagFilters)))"}
}

/// <p>Represents an application source.</p>
public struct ApplicationSource: Equatable {
    /// <p>The Amazon Resource Name (ARN) of a AWS CloudFormation stack.</p>
    public let cloudFormationStackARN: String?
    /// <p>A set of tags (up to 50).</p>
    public let tagFilters: [TagFilter]?

    public init (
        cloudFormationStackARN: String? = nil,
        tagFilters: [TagFilter]? = nil
    )
    {
        self.cloudFormationStackARN = cloudFormationStackARN
        self.tagFilters = tagFilters
    }
}

extension ConcurrentUpdateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConcurrentUpdateException(message: \(String(describing: message)))"}
}

extension ConcurrentUpdateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConcurrentUpdateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Concurrent updates caused an exception, for example, if you request an update to a
///          scaling plan that already has a pending update.</p>
public struct ConcurrentUpdateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentUpdateExceptionBody: Equatable {
    public let message: String?
}

extension ConcurrentUpdateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateScalingPlanInputBodyMiddleware: Middleware {
    public let id: String = "CreateScalingPlanInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateScalingPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateScalingPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateScalingPlanInput>
    public typealias MOutput = OperationOutput<CreateScalingPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateScalingPlanOutputError>
}

extension CreateScalingPlanInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateScalingPlanInput(applicationSource: \(String(describing: applicationSource)), scalingInstructions: \(String(describing: scalingInstructions)), scalingPlanName: \(String(describing: scalingPlanName)))"}
}

extension CreateScalingPlanInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationSource = "ApplicationSource"
        case scalingInstructions = "ScalingInstructions"
        case scalingPlanName = "ScalingPlanName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationSource = applicationSource {
            try encodeContainer.encode(applicationSource, forKey: .applicationSource)
        }
        if let scalingInstructions = scalingInstructions {
            var scalingInstructionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scalingInstructions)
            for scalinginstructions0 in scalingInstructions {
                try scalingInstructionsContainer.encode(scalinginstructions0)
            }
        }
        if let scalingPlanName = scalingPlanName {
            try encodeContainer.encode(scalingPlanName, forKey: .scalingPlanName)
        }
    }
}

public struct CreateScalingPlanInputHeadersMiddleware: Middleware {
    public let id: String = "CreateScalingPlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateScalingPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateScalingPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateScalingPlanInput>
    public typealias MOutput = OperationOutput<CreateScalingPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateScalingPlanOutputError>
}

public struct CreateScalingPlanInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateScalingPlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateScalingPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateScalingPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateScalingPlanInput>
    public typealias MOutput = OperationOutput<CreateScalingPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateScalingPlanOutputError>
}

public struct CreateScalingPlanInput: Equatable {
    /// <p>A CloudFormation stack or set of tags. You can create one scaling plan per application
    ///          source.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/plans/APIReference/API_ApplicationSource.html">ApplicationSource</a> in the <i>AWS Auto Scaling API Reference</i>.</p>
    public let applicationSource: ApplicationSource?
    /// <p>The scaling instructions.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/plans/APIReference/API_ScalingInstruction.html">ScalingInstruction</a> in the <i>AWS Auto Scaling API Reference</i>.</p>
    public let scalingInstructions: [ScalingInstruction]?
    /// <p>The name of the scaling plan. Names cannot contain vertical bars, colons, or forward
    ///          slashes.</p>
    public let scalingPlanName: String?

    public init (
        applicationSource: ApplicationSource? = nil,
        scalingInstructions: [ScalingInstruction]? = nil,
        scalingPlanName: String? = nil
    )
    {
        self.applicationSource = applicationSource
        self.scalingInstructions = scalingInstructions
        self.scalingPlanName = scalingPlanName
    }
}

struct CreateScalingPlanInputBody: Equatable {
    public let scalingPlanName: String?
    public let applicationSource: ApplicationSource?
    public let scalingInstructions: [ScalingInstruction]?
}

extension CreateScalingPlanInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationSource = "ApplicationSource"
        case scalingInstructions = "ScalingInstructions"
        case scalingPlanName = "ScalingPlanName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scalingPlanNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scalingPlanName)
        scalingPlanName = scalingPlanNameDecoded
        let applicationSourceDecoded = try containerValues.decodeIfPresent(ApplicationSource.self, forKey: .applicationSource)
        applicationSource = applicationSourceDecoded
        let scalingInstructionsContainer = try containerValues.decodeIfPresent([ScalingInstruction?].self, forKey: .scalingInstructions)
        var scalingInstructionsDecoded0:[ScalingInstruction]? = nil
        if let scalingInstructionsContainer = scalingInstructionsContainer {
            scalingInstructionsDecoded0 = [ScalingInstruction]()
            for structure0 in scalingInstructionsContainer {
                if let structure0 = structure0 {
                    scalingInstructionsDecoded0?.append(structure0)
                }
            }
        }
        scalingInstructions = scalingInstructionsDecoded0
    }
}

extension CreateScalingPlanOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateScalingPlanOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentUpdateException" : self = .concurrentUpdateException(try ConcurrentUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateScalingPlanOutputError: Equatable {
    case concurrentUpdateException(ConcurrentUpdateException)
    case internalServiceException(InternalServiceException)
    case limitExceededException(LimitExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateScalingPlanOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateScalingPlanOutputResponse(scalingPlanVersion: \(String(describing: scalingPlanVersion)))"}
}

extension CreateScalingPlanOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateScalingPlanOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.scalingPlanVersion = output.scalingPlanVersion
        } else {
            self.scalingPlanVersion = nil
        }
    }
}

public struct CreateScalingPlanOutputResponse: Equatable {
    /// <p>The version number of the scaling plan. This value is always <code>1</code>. Currently,
    ///          you cannot have multiple scaling plan versions.</p>
    public let scalingPlanVersion: Int?

    public init (
        scalingPlanVersion: Int? = nil
    )
    {
        self.scalingPlanVersion = scalingPlanVersion
    }
}

struct CreateScalingPlanOutputResponseBody: Equatable {
    public let scalingPlanVersion: Int?
}

extension CreateScalingPlanOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case scalingPlanVersion = "ScalingPlanVersion"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scalingPlanVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .scalingPlanVersion)
        scalingPlanVersion = scalingPlanVersionDecoded
    }
}

extension CustomizedLoadMetricSpecification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dimensions = "Dimensions"
        case metricName = "MetricName"
        case namespace = "Namespace"
        case statistic = "Statistic"
        case unit = "Unit"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensions)
            for metricdimensions0 in dimensions {
                try dimensionsContainer.encode(metricdimensions0)
            }
        }
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let statistic = statistic {
            try encodeContainer.encode(statistic.rawValue, forKey: .statistic)
        }
        if let unit = unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let dimensionsContainer = try containerValues.decodeIfPresent([MetricDimension?].self, forKey: .dimensions)
        var dimensionsDecoded0:[MetricDimension]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [MetricDimension]()
            for structure0 in dimensionsContainer {
                if let structure0 = structure0 {
                    dimensionsDecoded0?.append(structure0)
                }
            }
        }
        dimensions = dimensionsDecoded0
        let statisticDecoded = try containerValues.decodeIfPresent(MetricStatistic.self, forKey: .statistic)
        statistic = statisticDecoded
        let unitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension CustomizedLoadMetricSpecification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomizedLoadMetricSpecification(dimensions: \(String(describing: dimensions)), metricName: \(String(describing: metricName)), namespace: \(String(describing: namespace)), statistic: \(String(describing: statistic)), unit: \(String(describing: unit)))"}
}

/// <p>Represents a CloudWatch metric of your choosing that can be used for predictive scaling. </p>
///          <p>For predictive scaling to work with a customized load metric specification, AWS Auto Scaling
///          needs access to the <code>Sum</code> and <code>Average</code> statistics that CloudWatch computes
///          from metric data.</p>
///          <p>When you choose a load metric, make sure that the required <code>Sum</code> and
///             <code>Average</code> statistics for your metric are available in CloudWatch and that they
///          provide relevant data for predictive scaling. The <code>Sum</code> statistic must represent
///          the total load on the resource, and the <code>Average</code> statistic must represent the
///          average load per capacity unit of the resource. For example, there is a metric that counts
///          the number of requests processed by your Auto Scaling group. If the <code>Sum</code> statistic
///          represents the total request count processed by the group, then the <code>Average</code>
///          statistic for the specified metric must represent the average request count processed by
///          each instance of the group. </p>
///          <p>If you publish your own metrics, you can aggregate the data points at a given interval
///          and then publish the aggregated data points to CloudWatch. Before AWS Auto Scaling generates the
///          forecast, it sums up all the metric data points that occurred within each hour to match the
///          granularity period that is used in the forecast (60 minutes).</p>
///          <p>For information about terminology, available metrics, or how to publish new metrics, see
///             <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html">Amazon CloudWatch
///             Concepts</a> in the <i>Amazon CloudWatch User Guide</i>. </p>
///          <p>After creating your scaling plan, you can use the AWS Auto Scaling console to visualize
///          forecasts for the specified metric. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/plans/userguide/gs-create-scaling-plan.html#gs-view-resource">View
///             Scaling Information for a Resource</a> in the
///          <i>AWS Auto Scaling User Guide</i>.</p>
public struct CustomizedLoadMetricSpecification: Equatable {
    /// <p>The dimensions of the metric.</p>
    ///          <p>Conditional: If you published your metric with dimensions, you must specify the same
    ///          dimensions in your customized load metric specification.</p>
    public let dimensions: [MetricDimension]?
    /// <p>The name of the metric.</p>
    public let metricName: String?
    /// <p>The namespace of the metric.</p>
    public let namespace: String?
    /// <p>The statistic of the metric. The only valid value is <code>Sum</code>.</p>
    public let statistic: MetricStatistic?
    /// <p>The unit of the metric.</p>
    public let unit: String?

    public init (
        dimensions: [MetricDimension]? = nil,
        metricName: String? = nil,
        namespace: String? = nil,
        statistic: MetricStatistic? = nil,
        unit: String? = nil
    )
    {
        self.dimensions = dimensions
        self.metricName = metricName
        self.namespace = namespace
        self.statistic = statistic
        self.unit = unit
    }
}

extension CustomizedScalingMetricSpecification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dimensions = "Dimensions"
        case metricName = "MetricName"
        case namespace = "Namespace"
        case statistic = "Statistic"
        case unit = "Unit"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensions)
            for metricdimensions0 in dimensions {
                try dimensionsContainer.encode(metricdimensions0)
            }
        }
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let statistic = statistic {
            try encodeContainer.encode(statistic.rawValue, forKey: .statistic)
        }
        if let unit = unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let dimensionsContainer = try containerValues.decodeIfPresent([MetricDimension?].self, forKey: .dimensions)
        var dimensionsDecoded0:[MetricDimension]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [MetricDimension]()
            for structure0 in dimensionsContainer {
                if let structure0 = structure0 {
                    dimensionsDecoded0?.append(structure0)
                }
            }
        }
        dimensions = dimensionsDecoded0
        let statisticDecoded = try containerValues.decodeIfPresent(MetricStatistic.self, forKey: .statistic)
        statistic = statisticDecoded
        let unitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension CustomizedScalingMetricSpecification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomizedScalingMetricSpecification(dimensions: \(String(describing: dimensions)), metricName: \(String(describing: metricName)), namespace: \(String(describing: namespace)), statistic: \(String(describing: statistic)), unit: \(String(describing: unit)))"}
}

/// <p>Represents a CloudWatch metric of your choosing that can be used for dynamic scaling as part
///          of a target tracking scaling policy. </p>
///          <p>To create your customized scaling metric specification:</p>
///          <ul>
///             <li>
///                <p>Add values for each required parameter from CloudWatch. You can use an existing metric,
///                or a new metric that you create. To use your own metric, you must first publish the
///                metric to CloudWatch. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/publishingMetrics.html">Publish Custom
///                   Metrics</a> in the <i>Amazon CloudWatch User Guide</i>.</p>
///             </li>
///             <li>
///                <p>Choose a metric that changes proportionally with capacity. The value of the metric
///                should increase or decrease in inverse proportion to the number of capacity units.
///                That is, the value of the metric should decrease when capacity increases. </p>
///             </li>
///          </ul>
///          <p>For information about terminology, available metrics, or how to publish new metrics, see
///             <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html">Amazon CloudWatch
///             Concepts</a> in the <i>Amazon CloudWatch User Guide</i>. </p>
public struct CustomizedScalingMetricSpecification: Equatable {
    /// <p>The dimensions of the metric.</p>
    ///          <p>Conditional: If you published your metric with dimensions, you must specify the same
    ///          dimensions in your customized scaling metric specification.</p>
    public let dimensions: [MetricDimension]?
    /// <p>The name of the metric.</p>
    public let metricName: String?
    /// <p>The namespace of the metric.</p>
    public let namespace: String?
    /// <p>The statistic of the metric.</p>
    public let statistic: MetricStatistic?
    /// <p>The unit of the metric. </p>
    public let unit: String?

    public init (
        dimensions: [MetricDimension]? = nil,
        metricName: String? = nil,
        namespace: String? = nil,
        statistic: MetricStatistic? = nil,
        unit: String? = nil
    )
    {
        self.dimensions = dimensions
        self.metricName = metricName
        self.namespace = namespace
        self.statistic = statistic
        self.unit = unit
    }
}

extension Datapoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case timestamp = "Timestamp"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension Datapoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Datapoint(timestamp: \(String(describing: timestamp)), value: \(String(describing: value)))"}
}

/// <p>Represents a single value in the forecast data used for predictive scaling.</p>
public struct Datapoint: Equatable {
    /// <p>The time stamp for the data point in UTC format.</p>
    public let timestamp: Date?
    /// <p>The value of the data point.</p>
    public let value: Double?

    public init (
        timestamp: Date? = nil,
        value: Double? = nil
    )
    {
        self.timestamp = timestamp
        self.value = value
    }
}

public struct DeleteScalingPlanInputBodyMiddleware: Middleware {
    public let id: String = "DeleteScalingPlanInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteScalingPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteScalingPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteScalingPlanInput>
    public typealias MOutput = OperationOutput<DeleteScalingPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteScalingPlanOutputError>
}

extension DeleteScalingPlanInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteScalingPlanInput(scalingPlanName: \(String(describing: scalingPlanName)), scalingPlanVersion: \(String(describing: scalingPlanVersion)))"}
}

extension DeleteScalingPlanInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case scalingPlanName = "ScalingPlanName"
        case scalingPlanVersion = "ScalingPlanVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scalingPlanName = scalingPlanName {
            try encodeContainer.encode(scalingPlanName, forKey: .scalingPlanName)
        }
        if let scalingPlanVersion = scalingPlanVersion {
            try encodeContainer.encode(scalingPlanVersion, forKey: .scalingPlanVersion)
        }
    }
}

public struct DeleteScalingPlanInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteScalingPlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteScalingPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteScalingPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteScalingPlanInput>
    public typealias MOutput = OperationOutput<DeleteScalingPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteScalingPlanOutputError>
}

public struct DeleteScalingPlanInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteScalingPlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteScalingPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteScalingPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteScalingPlanInput>
    public typealias MOutput = OperationOutput<DeleteScalingPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteScalingPlanOutputError>
}

public struct DeleteScalingPlanInput: Equatable {
    /// <p>The name of the scaling plan.</p>
    public let scalingPlanName: String?
    /// <p>The version number of the scaling plan. Currently, the only valid value is
    ///             <code>1</code>.</p>
    public let scalingPlanVersion: Int?

    public init (
        scalingPlanName: String? = nil,
        scalingPlanVersion: Int? = nil
    )
    {
        self.scalingPlanName = scalingPlanName
        self.scalingPlanVersion = scalingPlanVersion
    }
}

struct DeleteScalingPlanInputBody: Equatable {
    public let scalingPlanName: String?
    public let scalingPlanVersion: Int?
}

extension DeleteScalingPlanInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case scalingPlanName = "ScalingPlanName"
        case scalingPlanVersion = "ScalingPlanVersion"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scalingPlanNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scalingPlanName)
        scalingPlanName = scalingPlanNameDecoded
        let scalingPlanVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .scalingPlanVersion)
        scalingPlanVersion = scalingPlanVersionDecoded
    }
}

extension DeleteScalingPlanOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteScalingPlanOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentUpdateException" : self = .concurrentUpdateException(try ConcurrentUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ObjectNotFoundException" : self = .objectNotFoundException(try ObjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteScalingPlanOutputError: Equatable {
    case concurrentUpdateException(ConcurrentUpdateException)
    case internalServiceException(InternalServiceException)
    case objectNotFoundException(ObjectNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteScalingPlanOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteScalingPlanOutputResponse()"}
}

extension DeleteScalingPlanOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteScalingPlanOutputResponse: Equatable {

    public init() {}
}

struct DeleteScalingPlanOutputResponseBody: Equatable {
}

extension DeleteScalingPlanOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeScalingPlanResourcesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeScalingPlanResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeScalingPlanResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeScalingPlanResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeScalingPlanResourcesInput>
    public typealias MOutput = OperationOutput<DescribeScalingPlanResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeScalingPlanResourcesOutputError>
}

extension DescribeScalingPlanResourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeScalingPlanResourcesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), scalingPlanName: \(String(describing: scalingPlanName)), scalingPlanVersion: \(String(describing: scalingPlanVersion)))"}
}

extension DescribeScalingPlanResourcesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case scalingPlanName = "ScalingPlanName"
        case scalingPlanVersion = "ScalingPlanVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let scalingPlanName = scalingPlanName {
            try encodeContainer.encode(scalingPlanName, forKey: .scalingPlanName)
        }
        if let scalingPlanVersion = scalingPlanVersion {
            try encodeContainer.encode(scalingPlanVersion, forKey: .scalingPlanVersion)
        }
    }
}

public struct DescribeScalingPlanResourcesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeScalingPlanResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeScalingPlanResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeScalingPlanResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeScalingPlanResourcesInput>
    public typealias MOutput = OperationOutput<DescribeScalingPlanResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeScalingPlanResourcesOutputError>
}

public struct DescribeScalingPlanResourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeScalingPlanResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeScalingPlanResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeScalingPlanResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeScalingPlanResourcesInput>
    public typealias MOutput = OperationOutput<DescribeScalingPlanResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeScalingPlanResourcesOutputError>
}

public struct DescribeScalingPlanResourcesInput: Equatable {
    /// <p>The maximum number of scalable resources to return. The value must be between
    ///          1 and 50. The default value is 50.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results.</p>
    public let nextToken: String?
    /// <p>The name of the scaling plan.</p>
    public let scalingPlanName: String?
    /// <p>The version number of the scaling plan. Currently, the only valid value is
    ///             <code>1</code>.</p>
    public let scalingPlanVersion: Int?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        scalingPlanName: String? = nil,
        scalingPlanVersion: Int? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.scalingPlanName = scalingPlanName
        self.scalingPlanVersion = scalingPlanVersion
    }
}

struct DescribeScalingPlanResourcesInputBody: Equatable {
    public let scalingPlanName: String?
    public let scalingPlanVersion: Int?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeScalingPlanResourcesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case scalingPlanName = "ScalingPlanName"
        case scalingPlanVersion = "ScalingPlanVersion"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scalingPlanNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scalingPlanName)
        scalingPlanName = scalingPlanNameDecoded
        let scalingPlanVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .scalingPlanVersion)
        scalingPlanVersion = scalingPlanVersionDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeScalingPlanResourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeScalingPlanResourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentUpdateException" : self = .concurrentUpdateException(try ConcurrentUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeScalingPlanResourcesOutputError: Equatable {
    case concurrentUpdateException(ConcurrentUpdateException)
    case internalServiceException(InternalServiceException)
    case invalidNextTokenException(InvalidNextTokenException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeScalingPlanResourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeScalingPlanResourcesOutputResponse(nextToken: \(String(describing: nextToken)), scalingPlanResources: \(String(describing: scalingPlanResources)))"}
}

extension DescribeScalingPlanResourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeScalingPlanResourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.scalingPlanResources = output.scalingPlanResources
        } else {
            self.nextToken = nil
            self.scalingPlanResources = nil
        }
    }
}

public struct DescribeScalingPlanResourcesOutputResponse: Equatable {
    /// <p>The token required to get the next set of results. This value is <code>null</code> if
    ///          there are no more results to return.</p>
    public let nextToken: String?
    /// <p>Information about the scalable resources.</p>
    public let scalingPlanResources: [ScalingPlanResource]?

    public init (
        nextToken: String? = nil,
        scalingPlanResources: [ScalingPlanResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.scalingPlanResources = scalingPlanResources
    }
}

struct DescribeScalingPlanResourcesOutputResponseBody: Equatable {
    public let scalingPlanResources: [ScalingPlanResource]?
    public let nextToken: String?
}

extension DescribeScalingPlanResourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case scalingPlanResources = "ScalingPlanResources"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scalingPlanResourcesContainer = try containerValues.decodeIfPresent([ScalingPlanResource?].self, forKey: .scalingPlanResources)
        var scalingPlanResourcesDecoded0:[ScalingPlanResource]? = nil
        if let scalingPlanResourcesContainer = scalingPlanResourcesContainer {
            scalingPlanResourcesDecoded0 = [ScalingPlanResource]()
            for structure0 in scalingPlanResourcesContainer {
                if let structure0 = structure0 {
                    scalingPlanResourcesDecoded0?.append(structure0)
                }
            }
        }
        scalingPlanResources = scalingPlanResourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeScalingPlansInputBodyMiddleware: Middleware {
    public let id: String = "DescribeScalingPlansInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeScalingPlansInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeScalingPlansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeScalingPlansInput>
    public typealias MOutput = OperationOutput<DescribeScalingPlansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeScalingPlansOutputError>
}

extension DescribeScalingPlansInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeScalingPlansInput(applicationSources: \(String(describing: applicationSources)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), scalingPlanNames: \(String(describing: scalingPlanNames)), scalingPlanVersion: \(String(describing: scalingPlanVersion)))"}
}

extension DescribeScalingPlansInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationSources = "ApplicationSources"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case scalingPlanNames = "ScalingPlanNames"
        case scalingPlanVersion = "ScalingPlanVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationSources = applicationSources {
            var applicationSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationSources)
            for applicationsources0 in applicationSources {
                try applicationSourcesContainer.encode(applicationsources0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let scalingPlanNames = scalingPlanNames {
            var scalingPlanNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scalingPlanNames)
            for scalingplannames0 in scalingPlanNames {
                try scalingPlanNamesContainer.encode(scalingplannames0)
            }
        }
        if let scalingPlanVersion = scalingPlanVersion {
            try encodeContainer.encode(scalingPlanVersion, forKey: .scalingPlanVersion)
        }
    }
}

public struct DescribeScalingPlansInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeScalingPlansInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeScalingPlansInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeScalingPlansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeScalingPlansInput>
    public typealias MOutput = OperationOutput<DescribeScalingPlansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeScalingPlansOutputError>
}

public struct DescribeScalingPlansInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeScalingPlansInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeScalingPlansInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeScalingPlansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeScalingPlansInput>
    public typealias MOutput = OperationOutput<DescribeScalingPlansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeScalingPlansOutputError>
}

public struct DescribeScalingPlansInput: Equatable {
    /// <p>The sources for the applications (up to 10). If you specify scaling plan names, you
    ///          cannot specify application sources.</p>
    public let applicationSources: [ApplicationSource]?
    /// <p>The maximum number of scalable resources to return. This value can be between
    ///          1 and 50. The default value is 50.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results.</p>
    public let nextToken: String?
    /// <p>The names of the scaling plans (up to 10). If you specify application sources, you
    ///          cannot specify scaling plan names.</p>
    public let scalingPlanNames: [String]?
    /// <p>The version number of the scaling plan. Currently, the only valid value is
    ///             <code>1</code>.</p>
    ///          <note>
    ///             <p>If you specify a scaling plan version, you must also specify a scaling plan
    ///             name.</p>
    ///          </note>
    public let scalingPlanVersion: Int?

    public init (
        applicationSources: [ApplicationSource]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        scalingPlanNames: [String]? = nil,
        scalingPlanVersion: Int? = nil
    )
    {
        self.applicationSources = applicationSources
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.scalingPlanNames = scalingPlanNames
        self.scalingPlanVersion = scalingPlanVersion
    }
}

struct DescribeScalingPlansInputBody: Equatable {
    public let scalingPlanNames: [String]?
    public let scalingPlanVersion: Int?
    public let applicationSources: [ApplicationSource]?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeScalingPlansInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationSources = "ApplicationSources"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case scalingPlanNames = "ScalingPlanNames"
        case scalingPlanVersion = "ScalingPlanVersion"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scalingPlanNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .scalingPlanNames)
        var scalingPlanNamesDecoded0:[String]? = nil
        if let scalingPlanNamesContainer = scalingPlanNamesContainer {
            scalingPlanNamesDecoded0 = [String]()
            for string0 in scalingPlanNamesContainer {
                if let string0 = string0 {
                    scalingPlanNamesDecoded0?.append(string0)
                }
            }
        }
        scalingPlanNames = scalingPlanNamesDecoded0
        let scalingPlanVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .scalingPlanVersion)
        scalingPlanVersion = scalingPlanVersionDecoded
        let applicationSourcesContainer = try containerValues.decodeIfPresent([ApplicationSource?].self, forKey: .applicationSources)
        var applicationSourcesDecoded0:[ApplicationSource]? = nil
        if let applicationSourcesContainer = applicationSourcesContainer {
            applicationSourcesDecoded0 = [ApplicationSource]()
            for structure0 in applicationSourcesContainer {
                if let structure0 = structure0 {
                    applicationSourcesDecoded0?.append(structure0)
                }
            }
        }
        applicationSources = applicationSourcesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeScalingPlansOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeScalingPlansOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentUpdateException" : self = .concurrentUpdateException(try ConcurrentUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeScalingPlansOutputError: Equatable {
    case concurrentUpdateException(ConcurrentUpdateException)
    case internalServiceException(InternalServiceException)
    case invalidNextTokenException(InvalidNextTokenException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeScalingPlansOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeScalingPlansOutputResponse(nextToken: \(String(describing: nextToken)), scalingPlans: \(String(describing: scalingPlans)))"}
}

extension DescribeScalingPlansOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeScalingPlansOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.scalingPlans = output.scalingPlans
        } else {
            self.nextToken = nil
            self.scalingPlans = nil
        }
    }
}

public struct DescribeScalingPlansOutputResponse: Equatable {
    /// <p>The token required to get the next set of results. This value is <code>null</code> if
    ///          there are no more results to return.</p>
    public let nextToken: String?
    /// <p>Information about the scaling plans.</p>
    public let scalingPlans: [ScalingPlan]?

    public init (
        nextToken: String? = nil,
        scalingPlans: [ScalingPlan]? = nil
    )
    {
        self.nextToken = nextToken
        self.scalingPlans = scalingPlans
    }
}

struct DescribeScalingPlansOutputResponseBody: Equatable {
    public let scalingPlans: [ScalingPlan]?
    public let nextToken: String?
}

extension DescribeScalingPlansOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case scalingPlans = "ScalingPlans"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scalingPlansContainer = try containerValues.decodeIfPresent([ScalingPlan?].self, forKey: .scalingPlans)
        var scalingPlansDecoded0:[ScalingPlan]? = nil
        if let scalingPlansContainer = scalingPlansContainer {
            scalingPlansDecoded0 = [ScalingPlan]()
            for structure0 in scalingPlansContainer {
                if let structure0 = structure0 {
                    scalingPlansDecoded0?.append(structure0)
                }
            }
        }
        scalingPlans = scalingPlansDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public enum ForecastDataType {
    case capacityforecast
    case loadforecast
    case scheduledactionmaxcapacity
    case scheduledactionmincapacity
    case sdkUnknown(String)
}

extension ForecastDataType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ForecastDataType] {
        return [
            .capacityforecast,
            .loadforecast,
            .scheduledactionmaxcapacity,
            .scheduledactionmincapacity,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .capacityforecast: return "CapacityForecast"
        case .loadforecast: return "LoadForecast"
        case .scheduledactionmaxcapacity: return "ScheduledActionMaxCapacity"
        case .scheduledactionmincapacity: return "ScheduledActionMinCapacity"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ForecastDataType(rawValue: rawValue) ?? ForecastDataType.sdkUnknown(rawValue)
    }
}

public struct GetScalingPlanResourceForecastDataInputBodyMiddleware: Middleware {
    public let id: String = "GetScalingPlanResourceForecastDataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetScalingPlanResourceForecastDataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetScalingPlanResourceForecastDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetScalingPlanResourceForecastDataInput>
    public typealias MOutput = OperationOutput<GetScalingPlanResourceForecastDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetScalingPlanResourceForecastDataOutputError>
}

extension GetScalingPlanResourceForecastDataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetScalingPlanResourceForecastDataInput(endTime: \(String(describing: endTime)), forecastDataType: \(String(describing: forecastDataType)), resourceId: \(String(describing: resourceId)), scalableDimension: \(String(describing: scalableDimension)), scalingPlanName: \(String(describing: scalingPlanName)), scalingPlanVersion: \(String(describing: scalingPlanVersion)), serviceNamespace: \(String(describing: serviceNamespace)), startTime: \(String(describing: startTime)))"}
}

extension GetScalingPlanResourceForecastDataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case forecastDataType = "ForecastDataType"
        case resourceId = "ResourceId"
        case scalableDimension = "ScalableDimension"
        case scalingPlanName = "ScalingPlanName"
        case scalingPlanVersion = "ScalingPlanVersion"
        case serviceNamespace = "ServiceNamespace"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let forecastDataType = forecastDataType {
            try encodeContainer.encode(forecastDataType.rawValue, forKey: .forecastDataType)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let scalableDimension = scalableDimension {
            try encodeContainer.encode(scalableDimension.rawValue, forKey: .scalableDimension)
        }
        if let scalingPlanName = scalingPlanName {
            try encodeContainer.encode(scalingPlanName, forKey: .scalingPlanName)
        }
        if let scalingPlanVersion = scalingPlanVersion {
            try encodeContainer.encode(scalingPlanVersion, forKey: .scalingPlanVersion)
        }
        if let serviceNamespace = serviceNamespace {
            try encodeContainer.encode(serviceNamespace.rawValue, forKey: .serviceNamespace)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }
}

public struct GetScalingPlanResourceForecastDataInputHeadersMiddleware: Middleware {
    public let id: String = "GetScalingPlanResourceForecastDataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetScalingPlanResourceForecastDataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetScalingPlanResourceForecastDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetScalingPlanResourceForecastDataInput>
    public typealias MOutput = OperationOutput<GetScalingPlanResourceForecastDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetScalingPlanResourceForecastDataOutputError>
}

public struct GetScalingPlanResourceForecastDataInputQueryItemMiddleware: Middleware {
    public let id: String = "GetScalingPlanResourceForecastDataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetScalingPlanResourceForecastDataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetScalingPlanResourceForecastDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetScalingPlanResourceForecastDataInput>
    public typealias MOutput = OperationOutput<GetScalingPlanResourceForecastDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetScalingPlanResourceForecastDataOutputError>
}

public struct GetScalingPlanResourceForecastDataInput: Equatable {
    /// <p>The exclusive end time of the time range for the forecast data to get. The maximum time
    ///          duration between the start and end time is seven days. </p>
    ///          <p>Although this parameter can accept a date and time that is more than two days in the
    ///          future, the availability of forecast data has limits. AWS Auto Scaling only issues forecasts for
    ///          periods of two days in advance.</p>
    public let endTime: Date?
    /// <p>The type of forecast data to get.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>LoadForecast</code>: The load metric forecast. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CapacityForecast</code>: The capacity forecast. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ScheduledActionMinCapacity</code>: The minimum capacity for each scheduled
    ///                scaling action. This data is calculated as the larger of two values: the capacity
    ///                forecast or the minimum capacity in the scaling instruction.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ScheduledActionMaxCapacity</code>: The maximum capacity for each scheduled
    ///                scaling action. The calculation used is determined by the predictive scaling maximum
    ///                capacity behavior setting in the scaling instruction.</p>
    ///             </li>
    ///          </ul>
    public let forecastDataType: ForecastDataType?
    /// <p>The ID of the resource. This string consists of a prefix (<code>autoScalingGroup</code>)
    ///          followed by the name of a specified Auto Scaling group (<code>my-asg</code>). Example:
    ///             <code>autoScalingGroup/my-asg</code>. </p>
    public let resourceId: String?
    /// <p>The scalable dimension for the resource. The only valid value is
    ///             <code>autoscaling:autoScalingGroup:DesiredCapacity</code>. </p>
    public let scalableDimension: ScalableDimension?
    /// <p>The name of the scaling plan.</p>
    public let scalingPlanName: String?
    /// <p>The version number of the scaling plan. Currently, the only valid value is
    ///             <code>1</code>.</p>
    public let scalingPlanVersion: Int?
    /// <p>The namespace of the AWS service. The only valid value is <code>autoscaling</code>.
    ///       </p>
    public let serviceNamespace: ServiceNamespace?
    /// <p>The inclusive start time of the time range for the forecast data to get. The date and
    ///          time can be at most 56 days before the current date and time. </p>
    public let startTime: Date?

    public init (
        endTime: Date? = nil,
        forecastDataType: ForecastDataType? = nil,
        resourceId: String? = nil,
        scalableDimension: ScalableDimension? = nil,
        scalingPlanName: String? = nil,
        scalingPlanVersion: Int? = nil,
        serviceNamespace: ServiceNamespace? = nil,
        startTime: Date? = nil
    )
    {
        self.endTime = endTime
        self.forecastDataType = forecastDataType
        self.resourceId = resourceId
        self.scalableDimension = scalableDimension
        self.scalingPlanName = scalingPlanName
        self.scalingPlanVersion = scalingPlanVersion
        self.serviceNamespace = serviceNamespace
        self.startTime = startTime
    }
}

struct GetScalingPlanResourceForecastDataInputBody: Equatable {
    public let scalingPlanName: String?
    public let scalingPlanVersion: Int?
    public let serviceNamespace: ServiceNamespace?
    public let resourceId: String?
    public let scalableDimension: ScalableDimension?
    public let forecastDataType: ForecastDataType?
    public let startTime: Date?
    public let endTime: Date?
}

extension GetScalingPlanResourceForecastDataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case forecastDataType = "ForecastDataType"
        case resourceId = "ResourceId"
        case scalableDimension = "ScalableDimension"
        case scalingPlanName = "ScalingPlanName"
        case scalingPlanVersion = "ScalingPlanVersion"
        case serviceNamespace = "ServiceNamespace"
        case startTime = "StartTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scalingPlanNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scalingPlanName)
        scalingPlanName = scalingPlanNameDecoded
        let scalingPlanVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .scalingPlanVersion)
        scalingPlanVersion = scalingPlanVersionDecoded
        let serviceNamespaceDecoded = try containerValues.decodeIfPresent(ServiceNamespace.self, forKey: .serviceNamespace)
        serviceNamespace = serviceNamespaceDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let scalableDimensionDecoded = try containerValues.decodeIfPresent(ScalableDimension.self, forKey: .scalableDimension)
        scalableDimension = scalableDimensionDecoded
        let forecastDataTypeDecoded = try containerValues.decodeIfPresent(ForecastDataType.self, forKey: .forecastDataType)
        forecastDataType = forecastDataTypeDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension GetScalingPlanResourceForecastDataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetScalingPlanResourceForecastDataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetScalingPlanResourceForecastDataOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetScalingPlanResourceForecastDataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetScalingPlanResourceForecastDataOutputResponse(datapoints: \(String(describing: datapoints)))"}
}

extension GetScalingPlanResourceForecastDataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetScalingPlanResourceForecastDataOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datapoints = output.datapoints
        } else {
            self.datapoints = nil
        }
    }
}

public struct GetScalingPlanResourceForecastDataOutputResponse: Equatable {
    /// <p>The data points to return.</p>
    public let datapoints: [Datapoint]?

    public init (
        datapoints: [Datapoint]? = nil
    )
    {
        self.datapoints = datapoints
    }
}

struct GetScalingPlanResourceForecastDataOutputResponseBody: Equatable {
    public let datapoints: [Datapoint]?
}

extension GetScalingPlanResourceForecastDataOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datapoints = "Datapoints"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datapointsContainer = try containerValues.decodeIfPresent([Datapoint?].self, forKey: .datapoints)
        var datapointsDecoded0:[Datapoint]? = nil
        if let datapointsContainer = datapointsContainer {
            datapointsDecoded0 = [Datapoint]()
            for structure0 in datapointsContainer {
                if let structure0 = structure0 {
                    datapointsDecoded0?.append(structure0)
                }
            }
        }
        datapoints = datapointsDecoded0
    }
}

extension InternalServiceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServiceException(message: \(String(describing: message)))"}
}

extension InternalServiceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServiceExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service encountered an internal error.</p>
public struct InternalServiceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceExceptionBody: Equatable {
    public let message: String?
}

extension InternalServiceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidNextTokenException(message: \(String(describing: message)))"}
}

extension InvalidNextTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The token provided is not valid.</p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidNextTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your account exceeded a limit. This exception is thrown when a per-account resource
///          limit is exceeded.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum LoadMetricType {
    case albtargetgrouprequestcount
    case asgtotalcpuutilization
    case asgtotalnetworkin
    case asgtotalnetworkout
    case sdkUnknown(String)
}

extension LoadMetricType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LoadMetricType] {
        return [
            .albtargetgrouprequestcount,
            .asgtotalcpuutilization,
            .asgtotalnetworkin,
            .asgtotalnetworkout,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .albtargetgrouprequestcount: return "ALBTargetGroupRequestCount"
        case .asgtotalcpuutilization: return "ASGTotalCPUUtilization"
        case .asgtotalnetworkin: return "ASGTotalNetworkIn"
        case .asgtotalnetworkout: return "ASGTotalNetworkOut"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LoadMetricType(rawValue: rawValue) ?? LoadMetricType.sdkUnknown(rawValue)
    }
}

extension MetricDimension: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension MetricDimension: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MetricDimension(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>Represents a dimension for a customized metric.</p>
public struct MetricDimension: Equatable {
    /// <p>The name of the dimension.</p>
    public let name: String?
    /// <p>The value of the dimension.</p>
    public let value: String?

    public init (
        name: String? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

public enum MetricStatistic {
    case average
    case maximum
    case minimum
    case samplecount
    case sum
    case sdkUnknown(String)
}

extension MetricStatistic : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MetricStatistic] {
        return [
            .average,
            .maximum,
            .minimum,
            .samplecount,
            .sum,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .average: return "Average"
        case .maximum: return "Maximum"
        case .minimum: return "Minimum"
        case .samplecount: return "SampleCount"
        case .sum: return "Sum"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MetricStatistic(rawValue: rawValue) ?? MetricStatistic.sdkUnknown(rawValue)
    }
}

extension ObjectNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ObjectNotFoundException(message: \(String(describing: message)))"}
}

extension ObjectNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ObjectNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified object could not be found.</p>
public struct ObjectNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ObjectNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ObjectNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum PolicyType {
    case targettrackingscaling
    case sdkUnknown(String)
}

extension PolicyType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PolicyType] {
        return [
            .targettrackingscaling,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .targettrackingscaling: return "TargetTrackingScaling"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PolicyType(rawValue: rawValue) ?? PolicyType.sdkUnknown(rawValue)
    }
}

extension PredefinedLoadMetricSpecification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case predefinedLoadMetricType = "PredefinedLoadMetricType"
        case resourceLabel = "ResourceLabel"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predefinedLoadMetricType = predefinedLoadMetricType {
            try encodeContainer.encode(predefinedLoadMetricType.rawValue, forKey: .predefinedLoadMetricType)
        }
        if let resourceLabel = resourceLabel {
            try encodeContainer.encode(resourceLabel, forKey: .resourceLabel)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predefinedLoadMetricTypeDecoded = try containerValues.decodeIfPresent(LoadMetricType.self, forKey: .predefinedLoadMetricType)
        predefinedLoadMetricType = predefinedLoadMetricTypeDecoded
        let resourceLabelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceLabel)
        resourceLabel = resourceLabelDecoded
    }
}

extension PredefinedLoadMetricSpecification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PredefinedLoadMetricSpecification(predefinedLoadMetricType: \(String(describing: predefinedLoadMetricType)), resourceLabel: \(String(describing: resourceLabel)))"}
}

/// <p>Represents a predefined metric that can be used for predictive scaling.</p>
///          <p>After creating your scaling plan, you can use the AWS Auto Scaling console to visualize
///          forecasts for the specified metric. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/plans/userguide/gs-create-scaling-plan.html#gs-view-resource">View
///             Scaling Information for a Resource</a> in the
///          <i>AWS Auto Scaling User Guide</i>.</p>
public struct PredefinedLoadMetricSpecification: Equatable {
    /// <p>The metric type.</p>
    public let predefinedLoadMetricType: LoadMetricType?
    /// <p>Identifies the resource associated with the metric type. You can't specify a resource
    ///          label unless the metric type is <code>ALBTargetGroupRequestCount</code> and there is a
    ///          target group for an Application Load Balancer attached to the Auto Scaling group.</p>
    ///          <p>You create the resource label by appending the final portion of the load balancer ARN
    ///          and the final portion of the target group ARN into a single value, separated by a forward
    ///          slash (/). The format is
    ///          app/<load-balancer-name>/<load-balancer-id>/targetgroup/<target-group-name>/<target-group-id>,
    ///          where:</p>
    ///          <ul>
    ///             <li>
    ///                <p>app/<load-balancer-name>/<load-balancer-id> is the final portion of
    ///                the load balancer ARN</p>
    ///             </li>
    ///             <li>
    ///                <p>targetgroup/<target-group-name>/<target-group-id> is the final portion
    ///                of the target group ARN.</p>
    ///             </li>
    ///          </ul>
    ///          <p>This is an example:
    ///          app/EC2Co-EcsEl-1TKLTMITMM0EO/f37c06a68c1748aa/targetgroup/EC2Co-Defau-LDNM7Q3ZH1ZN/6d4ea56ca2d6a18d.</p>
    ///          <p>To find the ARN for an Application Load Balancer, use the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeLoadBalancers.html">DescribeLoadBalancers</a> API operation. To find the ARN for the target group, use
    ///          the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeTargetGroups.html">DescribeTargetGroups</a> API operation.</p>
    public let resourceLabel: String?

    public init (
        predefinedLoadMetricType: LoadMetricType? = nil,
        resourceLabel: String? = nil
    )
    {
        self.predefinedLoadMetricType = predefinedLoadMetricType
        self.resourceLabel = resourceLabel
    }
}

extension PredefinedScalingMetricSpecification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case predefinedScalingMetricType = "PredefinedScalingMetricType"
        case resourceLabel = "ResourceLabel"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predefinedScalingMetricType = predefinedScalingMetricType {
            try encodeContainer.encode(predefinedScalingMetricType.rawValue, forKey: .predefinedScalingMetricType)
        }
        if let resourceLabel = resourceLabel {
            try encodeContainer.encode(resourceLabel, forKey: .resourceLabel)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predefinedScalingMetricTypeDecoded = try containerValues.decodeIfPresent(ScalingMetricType.self, forKey: .predefinedScalingMetricType)
        predefinedScalingMetricType = predefinedScalingMetricTypeDecoded
        let resourceLabelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceLabel)
        resourceLabel = resourceLabelDecoded
    }
}

extension PredefinedScalingMetricSpecification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PredefinedScalingMetricSpecification(predefinedScalingMetricType: \(String(describing: predefinedScalingMetricType)), resourceLabel: \(String(describing: resourceLabel)))"}
}

/// <p>Represents a predefined metric that can be used for dynamic scaling as part of a target
///          tracking scaling policy.</p>
public struct PredefinedScalingMetricSpecification: Equatable {
    /// <p>The metric type. The <code>ALBRequestCountPerTarget</code> metric type applies only to
    ///          Auto Scaling groups, Spot Fleet requests, and ECS services.</p>
    public let predefinedScalingMetricType: ScalingMetricType?
    /// <p>Identifies the resource associated with the metric type. You can't specify a resource
    ///          label unless the metric type is <code>ALBRequestCountPerTarget</code> and there is a target
    ///          group for an Application Load Balancer attached to the Auto Scaling group, Spot Fleet request, or
    ///          ECS service.</p>
    ///          <p>You create the resource label by appending the final portion of the load balancer ARN
    ///          and the final portion of the target group ARN into a single value, separated by a forward
    ///          slash (/). The format is
    ///          app/<load-balancer-name>/<load-balancer-id>/targetgroup/<target-group-name>/<target-group-id>,
    ///          where:</p>
    ///          <ul>
    ///             <li>
    ///                <p>app/<load-balancer-name>/<load-balancer-id> is the final portion of
    ///                the load balancer ARN</p>
    ///             </li>
    ///             <li>
    ///                <p>targetgroup/<target-group-name>/<target-group-id> is the final portion
    ///                of the target group ARN.</p>
    ///             </li>
    ///          </ul>
    ///          <p>This is an example:
    ///          app/EC2Co-EcsEl-1TKLTMITMM0EO/f37c06a68c1748aa/targetgroup/EC2Co-Defau-LDNM7Q3ZH1ZN/6d4ea56ca2d6a18d.</p>
    ///          <p>To find the ARN for an Application Load Balancer, use the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeLoadBalancers.html">DescribeLoadBalancers</a> API operation. To find the ARN for the target group, use
    ///          the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeTargetGroups.html">DescribeTargetGroups</a> API operation.</p>
    public let resourceLabel: String?

    public init (
        predefinedScalingMetricType: ScalingMetricType? = nil,
        resourceLabel: String? = nil
    )
    {
        self.predefinedScalingMetricType = predefinedScalingMetricType
        self.resourceLabel = resourceLabel
    }
}

public enum PredictiveScalingMaxCapacityBehavior {
    case setforecastcapacitytomaxcapacity
    case setmaxcapacityaboveforecastcapacity
    case setmaxcapacitytoforecastcapacity
    case sdkUnknown(String)
}

extension PredictiveScalingMaxCapacityBehavior : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PredictiveScalingMaxCapacityBehavior] {
        return [
            .setforecastcapacitytomaxcapacity,
            .setmaxcapacityaboveforecastcapacity,
            .setmaxcapacitytoforecastcapacity,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .setforecastcapacitytomaxcapacity: return "SetForecastCapacityToMaxCapacity"
        case .setmaxcapacityaboveforecastcapacity: return "SetMaxCapacityAboveForecastCapacity"
        case .setmaxcapacitytoforecastcapacity: return "SetMaxCapacityToForecastCapacity"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PredictiveScalingMaxCapacityBehavior(rawValue: rawValue) ?? PredictiveScalingMaxCapacityBehavior.sdkUnknown(rawValue)
    }
}

public enum PredictiveScalingMode {
    case forecastandscale
    case forecastonly
    case sdkUnknown(String)
}

extension PredictiveScalingMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PredictiveScalingMode] {
        return [
            .forecastandscale,
            .forecastonly,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .forecastandscale: return "ForecastAndScale"
        case .forecastonly: return "ForecastOnly"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PredictiveScalingMode(rawValue: rawValue) ?? PredictiveScalingMode.sdkUnknown(rawValue)
    }
}

public enum ScalableDimension {
    case autoscalinggroupdesiredcapacity
    case dynamodbindexreadcapacityunits
    case dynamodbindexwritecapacityunits
    case dynamodbtablereadcapacityunits
    case dynamodbtablewritecapacityunits
    case ec2spotfleetrequesttargetcapacity
    case ecsservicedesiredcount
    case rdsclusterreadreplicacount
    case sdkUnknown(String)
}

extension ScalableDimension : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ScalableDimension] {
        return [
            .autoscalinggroupdesiredcapacity,
            .dynamodbindexreadcapacityunits,
            .dynamodbindexwritecapacityunits,
            .dynamodbtablereadcapacityunits,
            .dynamodbtablewritecapacityunits,
            .ec2spotfleetrequesttargetcapacity,
            .ecsservicedesiredcount,
            .rdsclusterreadreplicacount,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .autoscalinggroupdesiredcapacity: return "autoscaling:autoScalingGroup:DesiredCapacity"
        case .dynamodbindexreadcapacityunits: return "dynamodb:index:ReadCapacityUnits"
        case .dynamodbindexwritecapacityunits: return "dynamodb:index:WriteCapacityUnits"
        case .dynamodbtablereadcapacityunits: return "dynamodb:table:ReadCapacityUnits"
        case .dynamodbtablewritecapacityunits: return "dynamodb:table:WriteCapacityUnits"
        case .ec2spotfleetrequesttargetcapacity: return "ec2:spot-fleet-request:TargetCapacity"
        case .ecsservicedesiredcount: return "ecs:service:DesiredCount"
        case .rdsclusterreadreplicacount: return "rds:cluster:ReadReplicaCount"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ScalableDimension(rawValue: rawValue) ?? ScalableDimension.sdkUnknown(rawValue)
    }
}

extension ScalingInstruction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customizedLoadMetricSpecification = "CustomizedLoadMetricSpecification"
        case disableDynamicScaling = "DisableDynamicScaling"
        case maxCapacity = "MaxCapacity"
        case minCapacity = "MinCapacity"
        case predefinedLoadMetricSpecification = "PredefinedLoadMetricSpecification"
        case predictiveScalingMaxCapacityBehavior = "PredictiveScalingMaxCapacityBehavior"
        case predictiveScalingMaxCapacityBuffer = "PredictiveScalingMaxCapacityBuffer"
        case predictiveScalingMode = "PredictiveScalingMode"
        case resourceId = "ResourceId"
        case scalableDimension = "ScalableDimension"
        case scalingPolicyUpdateBehavior = "ScalingPolicyUpdateBehavior"
        case scheduledActionBufferTime = "ScheduledActionBufferTime"
        case serviceNamespace = "ServiceNamespace"
        case targetTrackingConfigurations = "TargetTrackingConfigurations"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customizedLoadMetricSpecification = customizedLoadMetricSpecification {
            try encodeContainer.encode(customizedLoadMetricSpecification, forKey: .customizedLoadMetricSpecification)
        }
        if let disableDynamicScaling = disableDynamicScaling {
            try encodeContainer.encode(disableDynamicScaling, forKey: .disableDynamicScaling)
        }
        if let maxCapacity = maxCapacity {
            try encodeContainer.encode(maxCapacity, forKey: .maxCapacity)
        }
        if let minCapacity = minCapacity {
            try encodeContainer.encode(minCapacity, forKey: .minCapacity)
        }
        if let predefinedLoadMetricSpecification = predefinedLoadMetricSpecification {
            try encodeContainer.encode(predefinedLoadMetricSpecification, forKey: .predefinedLoadMetricSpecification)
        }
        if let predictiveScalingMaxCapacityBehavior = predictiveScalingMaxCapacityBehavior {
            try encodeContainer.encode(predictiveScalingMaxCapacityBehavior.rawValue, forKey: .predictiveScalingMaxCapacityBehavior)
        }
        if let predictiveScalingMaxCapacityBuffer = predictiveScalingMaxCapacityBuffer {
            try encodeContainer.encode(predictiveScalingMaxCapacityBuffer, forKey: .predictiveScalingMaxCapacityBuffer)
        }
        if let predictiveScalingMode = predictiveScalingMode {
            try encodeContainer.encode(predictiveScalingMode.rawValue, forKey: .predictiveScalingMode)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let scalableDimension = scalableDimension {
            try encodeContainer.encode(scalableDimension.rawValue, forKey: .scalableDimension)
        }
        if let scalingPolicyUpdateBehavior = scalingPolicyUpdateBehavior {
            try encodeContainer.encode(scalingPolicyUpdateBehavior.rawValue, forKey: .scalingPolicyUpdateBehavior)
        }
        if let scheduledActionBufferTime = scheduledActionBufferTime {
            try encodeContainer.encode(scheduledActionBufferTime, forKey: .scheduledActionBufferTime)
        }
        if let serviceNamespace = serviceNamespace {
            try encodeContainer.encode(serviceNamespace.rawValue, forKey: .serviceNamespace)
        }
        if let targetTrackingConfigurations = targetTrackingConfigurations {
            var targetTrackingConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetTrackingConfigurations)
            for targettrackingconfigurations0 in targetTrackingConfigurations {
                try targetTrackingConfigurationsContainer.encode(targettrackingconfigurations0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNamespaceDecoded = try containerValues.decodeIfPresent(ServiceNamespace.self, forKey: .serviceNamespace)
        serviceNamespace = serviceNamespaceDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let scalableDimensionDecoded = try containerValues.decodeIfPresent(ScalableDimension.self, forKey: .scalableDimension)
        scalableDimension = scalableDimensionDecoded
        let minCapacityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minCapacity)
        minCapacity = minCapacityDecoded
        let maxCapacityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxCapacity)
        maxCapacity = maxCapacityDecoded
        let targetTrackingConfigurationsContainer = try containerValues.decodeIfPresent([TargetTrackingConfiguration?].self, forKey: .targetTrackingConfigurations)
        var targetTrackingConfigurationsDecoded0:[TargetTrackingConfiguration]? = nil
        if let targetTrackingConfigurationsContainer = targetTrackingConfigurationsContainer {
            targetTrackingConfigurationsDecoded0 = [TargetTrackingConfiguration]()
            for structure0 in targetTrackingConfigurationsContainer {
                if let structure0 = structure0 {
                    targetTrackingConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        targetTrackingConfigurations = targetTrackingConfigurationsDecoded0
        let predefinedLoadMetricSpecificationDecoded = try containerValues.decodeIfPresent(PredefinedLoadMetricSpecification.self, forKey: .predefinedLoadMetricSpecification)
        predefinedLoadMetricSpecification = predefinedLoadMetricSpecificationDecoded
        let customizedLoadMetricSpecificationDecoded = try containerValues.decodeIfPresent(CustomizedLoadMetricSpecification.self, forKey: .customizedLoadMetricSpecification)
        customizedLoadMetricSpecification = customizedLoadMetricSpecificationDecoded
        let scheduledActionBufferTimeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .scheduledActionBufferTime)
        scheduledActionBufferTime = scheduledActionBufferTimeDecoded
        let predictiveScalingMaxCapacityBehaviorDecoded = try containerValues.decodeIfPresent(PredictiveScalingMaxCapacityBehavior.self, forKey: .predictiveScalingMaxCapacityBehavior)
        predictiveScalingMaxCapacityBehavior = predictiveScalingMaxCapacityBehaviorDecoded
        let predictiveScalingMaxCapacityBufferDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .predictiveScalingMaxCapacityBuffer)
        predictiveScalingMaxCapacityBuffer = predictiveScalingMaxCapacityBufferDecoded
        let predictiveScalingModeDecoded = try containerValues.decodeIfPresent(PredictiveScalingMode.self, forKey: .predictiveScalingMode)
        predictiveScalingMode = predictiveScalingModeDecoded
        let scalingPolicyUpdateBehaviorDecoded = try containerValues.decodeIfPresent(ScalingPolicyUpdateBehavior.self, forKey: .scalingPolicyUpdateBehavior)
        scalingPolicyUpdateBehavior = scalingPolicyUpdateBehaviorDecoded
        let disableDynamicScalingDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .disableDynamicScaling)
        disableDynamicScaling = disableDynamicScalingDecoded
    }
}

extension ScalingInstruction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScalingInstruction(customizedLoadMetricSpecification: \(String(describing: customizedLoadMetricSpecification)), disableDynamicScaling: \(String(describing: disableDynamicScaling)), maxCapacity: \(String(describing: maxCapacity)), minCapacity: \(String(describing: minCapacity)), predefinedLoadMetricSpecification: \(String(describing: predefinedLoadMetricSpecification)), predictiveScalingMaxCapacityBehavior: \(String(describing: predictiveScalingMaxCapacityBehavior)), predictiveScalingMaxCapacityBuffer: \(String(describing: predictiveScalingMaxCapacityBuffer)), predictiveScalingMode: \(String(describing: predictiveScalingMode)), resourceId: \(String(describing: resourceId)), scalableDimension: \(String(describing: scalableDimension)), scalingPolicyUpdateBehavior: \(String(describing: scalingPolicyUpdateBehavior)), scheduledActionBufferTime: \(String(describing: scheduledActionBufferTime)), serviceNamespace: \(String(describing: serviceNamespace)), targetTrackingConfigurations: \(String(describing: targetTrackingConfigurations)))"}
}

/// <p>Describes a scaling instruction for a scalable resource in a scaling plan. Each scaling
///          instruction applies to one resource.</p>
///          <p>AWS Auto Scaling creates target tracking scaling policies based on the scaling instructions.
///          Target tracking scaling policies adjust the capacity of your scalable resource as required
///          to maintain resource utilization at the target value that you specified. </p>
///          <p>AWS Auto Scaling also configures predictive scaling for your Amazon EC2 Auto Scaling groups using a subset of
///          parameters, including the load metric, the scaling metric, the target value for the scaling
///          metric, the predictive scaling mode (forecast and scale or forecast only), and the desired
///          behavior when the forecast capacity exceeds the maximum capacity of the resource. With
///          predictive scaling, AWS Auto Scaling generates forecasts with traffic predictions for the two days
///          ahead and schedules scaling actions that proactively add and remove resource capacity to
///          match the forecast. </p>
///          <important>
///             <p>We recommend waiting a minimum of 24 hours after creating an Auto Scaling group to configure
///             predictive scaling. At minimum, there must be 24 hours of historical data to generate a
///             forecast. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/plans/userguide/gs-best-practices.html">Best Practices for
///                AWS Auto Scaling</a> in the <i>AWS Auto Scaling User Guide</i>.</p>
///          </important>
public struct ScalingInstruction: Equatable {
    /// <p>The customized load metric to use for predictive scaling. This parameter or a <b>PredefinedLoadMetricSpecification</b> is required when configuring
    ///          predictive scaling, and cannot be used otherwise. </p>
    public let customizedLoadMetricSpecification: CustomizedLoadMetricSpecification?
    /// <p>Controls whether dynamic scaling by AWS Auto Scaling is disabled. When dynamic scaling is
    ///          enabled, AWS Auto Scaling creates target tracking scaling policies based on the specified target
    ///          tracking configurations. </p>
    ///          <p>The default is enabled (<code>false</code>). </p>
    public let disableDynamicScaling: Bool?
    /// <p>The maximum capacity of the resource. The exception to this upper limit is if you
    ///          specify a non-default setting for <b>PredictiveScalingMaxCapacityBehavior</b>. </p>
    public let maxCapacity: Int?
    /// <p>The minimum capacity of the resource. </p>
    public let minCapacity: Int?
    /// <p>The predefined load metric to use for predictive scaling. This parameter or a <b>CustomizedLoadMetricSpecification</b> is required when configuring
    ///          predictive scaling, and cannot be used otherwise. </p>
    public let predefinedLoadMetricSpecification: PredefinedLoadMetricSpecification?
    /// <p>Defines the behavior that should be applied if the forecast capacity approaches or
    ///          exceeds the maximum capacity specified for the resource. The default value is
    ///             <code>SetForecastCapacityToMaxCapacity</code>.</p>
    ///          <p>The following are possible values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>SetForecastCapacityToMaxCapacity</code> - AWS Auto Scaling cannot scale resource
    ///                capacity higher than the maximum capacity. The maximum capacity is enforced as a hard
    ///                limit. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SetMaxCapacityToForecastCapacity</code> - AWS Auto Scaling may scale resource
    ///                capacity higher than the maximum capacity to equal but not exceed forecast
    ///                capacity.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SetMaxCapacityAboveForecastCapacity</code> - AWS Auto Scaling may scale resource
    ///                capacity higher than the maximum capacity by a specified buffer value. The intention
    ///                is to give the target tracking scaling policy extra capacity if unexpected traffic
    ///                occurs. </p>
    ///             </li>
    ///          </ul>
    ///          <p>Only valid when configuring predictive scaling.</p>
    public let predictiveScalingMaxCapacityBehavior: PredictiveScalingMaxCapacityBehavior?
    /// <p>The size of the capacity buffer to use when the forecast capacity is close to or exceeds
    ///          the maximum capacity. The value is specified as a percentage relative to the forecast
    ///          capacity. For example, if the buffer is 10, this means a 10 percent buffer, such that if
    ///          the forecast capacity is 50, and the maximum capacity is 40, then the effective maximum
    ///          capacity is 55.</p>
    ///          <p>Only valid when configuring predictive scaling. Required if the <b>PredictiveScalingMaxCapacityBehavior</b> is set to
    ///             <code>SetMaxCapacityAboveForecastCapacity</code>, and cannot be used otherwise.</p>
    ///          <p>The range is 1-100.</p>
    public let predictiveScalingMaxCapacityBuffer: Int?
    /// <p>The predictive scaling mode. The default value is <code>ForecastAndScale</code>.
    ///          Otherwise, AWS Auto Scaling forecasts capacity but does not create any scheduled scaling actions
    ///          based on the capacity forecast. </p>
    public let predictiveScalingMode: PredictiveScalingMode?
    /// <p>The ID of the resource. This string consists of the resource type and unique
    ///          identifier.</p>
    ///          <ul>
    ///             <li>
    ///                <p>Auto Scaling group - The resource type is <code>autoScalingGroup</code> and the unique identifier is the
    ///                name of the Auto Scaling group. Example: <code>autoScalingGroup/my-asg</code>.</p>
    ///            </li>
    ///             <li>
    ///                <p>ECS service - The resource type is <code>service</code> and the unique identifier is the cluster name
    ///                and service name. Example: <code>service/default/sample-webapp</code>.</p>
    ///            </li>
    ///             <li>
    ///                <p>Spot Fleet request - The resource type is <code>spot-fleet-request</code> and the unique identifier is the
    ///                Spot Fleet request ID. Example: <code>spot-fleet-request/sfr-73fbd2ce-aa30-494c-8788-1cee4EXAMPLE</code>.</p>
    ///            </li>
    ///             <li>
    ///                <p>DynamoDB table - The resource type is <code>table</code> and the unique identifier is the resource ID.
    ///                Example: <code>table/my-table</code>.</p>
    ///            </li>
    ///             <li>
    ///                <p>DynamoDB global secondary index - The resource type is <code>index</code> and the unique identifier is the resource ID.
    ///                Example: <code>table/my-table/index/my-table-index</code>.</p>
    ///            </li>
    ///             <li>
    ///                <p>Aurora DB cluster - The resource type is <code>cluster</code> and the unique identifier is the cluster name.
    ///                Example: <code>cluster:my-db-cluster</code>.</p>
    ///            </li>
    ///          </ul>
    public let resourceId: String?
    /// <p>The scalable dimension associated with the resource.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>autoscaling:autoScalingGroup:DesiredCapacity</code> - The desired capacity of an Auto Scaling group.</p>
    ///            </li>
    ///             <li>
    ///                <p>
    ///                   <code>ecs:service:DesiredCount</code> - The desired task count of an ECS service.</p>
    ///            </li>
    ///             <li>
    ///                <p>
    ///                   <code>ec2:spot-fleet-request:TargetCapacity</code> - The target capacity of a Spot Fleet request.</p>
    ///            </li>
    ///             <li>
    ///                <p>
    ///                   <code>dynamodb:table:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB table.</p>
    ///            </li>
    ///             <li>
    ///                <p>
    ///                   <code>dynamodb:table:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB table.</p>
    ///            </li>
    ///             <li>
    ///                <p>
    ///                   <code>dynamodb:index:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB global secondary index.</p>
    ///            </li>
    ///             <li>
    ///                <p>
    ///                   <code>dynamodb:index:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB global secondary index.</p>
    ///            </li>
    ///             <li>
    ///                <p>
    ///                   <code>rds:cluster:ReadReplicaCount</code> - The count of Aurora Replicas in an Aurora DB cluster. Available for Aurora MySQL-compatible edition and Aurora PostgreSQL-compatible edition.</p>
    ///            </li>
    ///          </ul>
    public let scalableDimension: ScalableDimension?
    /// <p>Controls whether a resource's externally created scaling policies are kept or replaced. </p>
    ///          <p>The default value is <code>KeepExternalPolicies</code>. If the parameter is set to
    ///             <code>ReplaceExternalPolicies</code>, any scaling policies that are external to AWS Auto Scaling
    ///          are deleted and new target tracking scaling policies created. </p>
    ///          <p>Only valid when configuring dynamic scaling. </p>
    ///          <p>Condition: The number of existing policies to be replaced must be less than or equal to
    ///          50. If there are more than 50 policies to be replaced, AWS Auto Scaling keeps all existing policies
    ///          and does not create new ones.</p>
    public let scalingPolicyUpdateBehavior: ScalingPolicyUpdateBehavior?
    /// <p>The amount of time, in seconds, to buffer the run time of scheduled scaling actions when
    ///          scaling out. For example, if the forecast says to add capacity at 10:00 AM, and the buffer
    ///          time is 5 minutes, then the run time of the corresponding scheduled scaling action will be
    ///          9:55 AM. The intention is to give resources time to be provisioned. For example, it can
    ///          take a few minutes to launch an EC2 instance. The actual amount of time required depends on
    ///          several factors, such as the size of the instance and whether there are startup scripts to
    ///          complete. </p>
    ///          <p>The value must be less than the forecast interval duration of 3600 seconds (60 minutes).
    ///          The default is 300 seconds. </p>
    ///          <p>Only valid when configuring predictive scaling. </p>
    public let scheduledActionBufferTime: Int?
    /// <p>The namespace of the AWS service.</p>
    public let serviceNamespace: ServiceNamespace?
    /// <p>The target tracking configurations (up to 10). Each of these structures must specify a
    ///          unique scaling metric and a target value for the metric. </p>
    public let targetTrackingConfigurations: [TargetTrackingConfiguration]?

    public init (
        customizedLoadMetricSpecification: CustomizedLoadMetricSpecification? = nil,
        disableDynamicScaling: Bool? = nil,
        maxCapacity: Int? = nil,
        minCapacity: Int? = nil,
        predefinedLoadMetricSpecification: PredefinedLoadMetricSpecification? = nil,
        predictiveScalingMaxCapacityBehavior: PredictiveScalingMaxCapacityBehavior? = nil,
        predictiveScalingMaxCapacityBuffer: Int? = nil,
        predictiveScalingMode: PredictiveScalingMode? = nil,
        resourceId: String? = nil,
        scalableDimension: ScalableDimension? = nil,
        scalingPolicyUpdateBehavior: ScalingPolicyUpdateBehavior? = nil,
        scheduledActionBufferTime: Int? = nil,
        serviceNamespace: ServiceNamespace? = nil,
        targetTrackingConfigurations: [TargetTrackingConfiguration]? = nil
    )
    {
        self.customizedLoadMetricSpecification = customizedLoadMetricSpecification
        self.disableDynamicScaling = disableDynamicScaling
        self.maxCapacity = maxCapacity
        self.minCapacity = minCapacity
        self.predefinedLoadMetricSpecification = predefinedLoadMetricSpecification
        self.predictiveScalingMaxCapacityBehavior = predictiveScalingMaxCapacityBehavior
        self.predictiveScalingMaxCapacityBuffer = predictiveScalingMaxCapacityBuffer
        self.predictiveScalingMode = predictiveScalingMode
        self.resourceId = resourceId
        self.scalableDimension = scalableDimension
        self.scalingPolicyUpdateBehavior = scalingPolicyUpdateBehavior
        self.scheduledActionBufferTime = scheduledActionBufferTime
        self.serviceNamespace = serviceNamespace
        self.targetTrackingConfigurations = targetTrackingConfigurations
    }
}

public enum ScalingMetricType {
    case albrequestcountpertarget
    case asgaveragecpuutilization
    case asgaveragenetworkin
    case asgaveragenetworkout
    case dynamodbreadcapacityutilization
    case dynamodbwritecapacityutilization
    case ec2spotfleetrequestaveragecpuutilization
    case ec2spotfleetrequestaveragenetworkin
    case ec2spotfleetrequestaveragenetworkout
    case ecsserviceaveragecpuutilization
    case ecsserviceaveragememoryutilization
    case rdsreaderaveragecpuutilization
    case rdsreaderaveragedatabaseconnections
    case sdkUnknown(String)
}

extension ScalingMetricType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ScalingMetricType] {
        return [
            .albrequestcountpertarget,
            .asgaveragecpuutilization,
            .asgaveragenetworkin,
            .asgaveragenetworkout,
            .dynamodbreadcapacityutilization,
            .dynamodbwritecapacityutilization,
            .ec2spotfleetrequestaveragecpuutilization,
            .ec2spotfleetrequestaveragenetworkin,
            .ec2spotfleetrequestaveragenetworkout,
            .ecsserviceaveragecpuutilization,
            .ecsserviceaveragememoryutilization,
            .rdsreaderaveragecpuutilization,
            .rdsreaderaveragedatabaseconnections,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .albrequestcountpertarget: return "ALBRequestCountPerTarget"
        case .asgaveragecpuutilization: return "ASGAverageCPUUtilization"
        case .asgaveragenetworkin: return "ASGAverageNetworkIn"
        case .asgaveragenetworkout: return "ASGAverageNetworkOut"
        case .dynamodbreadcapacityutilization: return "DynamoDBReadCapacityUtilization"
        case .dynamodbwritecapacityutilization: return "DynamoDBWriteCapacityUtilization"
        case .ec2spotfleetrequestaveragecpuutilization: return "EC2SpotFleetRequestAverageCPUUtilization"
        case .ec2spotfleetrequestaveragenetworkin: return "EC2SpotFleetRequestAverageNetworkIn"
        case .ec2spotfleetrequestaveragenetworkout: return "EC2SpotFleetRequestAverageNetworkOut"
        case .ecsserviceaveragecpuutilization: return "ECSServiceAverageCPUUtilization"
        case .ecsserviceaveragememoryutilization: return "ECSServiceAverageMemoryUtilization"
        case .rdsreaderaveragecpuutilization: return "RDSReaderAverageCPUUtilization"
        case .rdsreaderaveragedatabaseconnections: return "RDSReaderAverageDatabaseConnections"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ScalingMetricType(rawValue: rawValue) ?? ScalingMetricType.sdkUnknown(rawValue)
    }
}

extension ScalingPlan: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationSource = "ApplicationSource"
        case creationTime = "CreationTime"
        case scalingInstructions = "ScalingInstructions"
        case scalingPlanName = "ScalingPlanName"
        case scalingPlanVersion = "ScalingPlanVersion"
        case statusCode = "StatusCode"
        case statusMessage = "StatusMessage"
        case statusStartTime = "StatusStartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationSource = applicationSource {
            try encodeContainer.encode(applicationSource, forKey: .applicationSource)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let scalingInstructions = scalingInstructions {
            var scalingInstructionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scalingInstructions)
            for scalinginstructions0 in scalingInstructions {
                try scalingInstructionsContainer.encode(scalinginstructions0)
            }
        }
        if let scalingPlanName = scalingPlanName {
            try encodeContainer.encode(scalingPlanName, forKey: .scalingPlanName)
        }
        if let scalingPlanVersion = scalingPlanVersion {
            try encodeContainer.encode(scalingPlanVersion, forKey: .scalingPlanVersion)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let statusStartTime = statusStartTime {
            try encodeContainer.encode(statusStartTime.timeIntervalSince1970, forKey: .statusStartTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scalingPlanNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scalingPlanName)
        scalingPlanName = scalingPlanNameDecoded
        let scalingPlanVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .scalingPlanVersion)
        scalingPlanVersion = scalingPlanVersionDecoded
        let applicationSourceDecoded = try containerValues.decodeIfPresent(ApplicationSource.self, forKey: .applicationSource)
        applicationSource = applicationSourceDecoded
        let scalingInstructionsContainer = try containerValues.decodeIfPresent([ScalingInstruction?].self, forKey: .scalingInstructions)
        var scalingInstructionsDecoded0:[ScalingInstruction]? = nil
        if let scalingInstructionsContainer = scalingInstructionsContainer {
            scalingInstructionsDecoded0 = [ScalingInstruction]()
            for structure0 in scalingInstructionsContainer {
                if let structure0 = structure0 {
                    scalingInstructionsDecoded0?.append(structure0)
                }
            }
        }
        scalingInstructions = scalingInstructionsDecoded0
        let statusCodeDecoded = try containerValues.decodeIfPresent(ScalingPlanStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let statusStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .statusStartTime)
        statusStartTime = statusStartTimeDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension ScalingPlan: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScalingPlan(applicationSource: \(String(describing: applicationSource)), creationTime: \(String(describing: creationTime)), scalingInstructions: \(String(describing: scalingInstructions)), scalingPlanName: \(String(describing: scalingPlanName)), scalingPlanVersion: \(String(describing: scalingPlanVersion)), statusCode: \(String(describing: statusCode)), statusMessage: \(String(describing: statusMessage)), statusStartTime: \(String(describing: statusStartTime)))"}
}

/// <p>Represents a scaling plan.</p>
public struct ScalingPlan: Equatable {
    /// <p>A CloudFormation stack or a set of tags. You can create one scaling plan per application
    ///          source.</p>
    public let applicationSource: ApplicationSource?
    /// <p>The Unix time stamp when the scaling plan was created.</p>
    public let creationTime: Date?
    /// <p>The scaling instructions.</p>
    public let scalingInstructions: [ScalingInstruction]?
    /// <p>The name of the scaling plan.</p>
    public let scalingPlanName: String?
    /// <p>The version number of the scaling plan.</p>
    public let scalingPlanVersion: Int?
    /// <p>The status of the scaling plan.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Active</code> - The scaling plan is active.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ActiveWithProblems</code> - The scaling plan is active, but the scaling
    ///                configuration for one or more resources could not be applied.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CreationInProgress</code> - The scaling plan is being created.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CreationFailed</code> - The scaling plan could not be created.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DeletionInProgress</code> - The scaling plan is being deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DeletionFailed</code> - The scaling plan could not be deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UpdateInProgress</code> - The scaling plan is being updated.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UpdateFailed</code> - The scaling plan could not be updated.</p>
    ///             </li>
    ///          </ul>
    public let statusCode: ScalingPlanStatusCode?
    /// <p>A simple message about the current status of the scaling plan.</p>
    public let statusMessage: String?
    /// <p>The Unix time stamp when the scaling plan entered the current status.</p>
    public let statusStartTime: Date?

    public init (
        applicationSource: ApplicationSource? = nil,
        creationTime: Date? = nil,
        scalingInstructions: [ScalingInstruction]? = nil,
        scalingPlanName: String? = nil,
        scalingPlanVersion: Int? = nil,
        statusCode: ScalingPlanStatusCode? = nil,
        statusMessage: String? = nil,
        statusStartTime: Date? = nil
    )
    {
        self.applicationSource = applicationSource
        self.creationTime = creationTime
        self.scalingInstructions = scalingInstructions
        self.scalingPlanName = scalingPlanName
        self.scalingPlanVersion = scalingPlanVersion
        self.statusCode = statusCode
        self.statusMessage = statusMessage
        self.statusStartTime = statusStartTime
    }
}

extension ScalingPlanResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case scalableDimension = "ScalableDimension"
        case scalingPlanName = "ScalingPlanName"
        case scalingPlanVersion = "ScalingPlanVersion"
        case scalingPolicies = "ScalingPolicies"
        case scalingStatusCode = "ScalingStatusCode"
        case scalingStatusMessage = "ScalingStatusMessage"
        case serviceNamespace = "ServiceNamespace"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let scalableDimension = scalableDimension {
            try encodeContainer.encode(scalableDimension.rawValue, forKey: .scalableDimension)
        }
        if let scalingPlanName = scalingPlanName {
            try encodeContainer.encode(scalingPlanName, forKey: .scalingPlanName)
        }
        if let scalingPlanVersion = scalingPlanVersion {
            try encodeContainer.encode(scalingPlanVersion, forKey: .scalingPlanVersion)
        }
        if let scalingPolicies = scalingPolicies {
            var scalingPoliciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scalingPolicies)
            for scalingpolicies0 in scalingPolicies {
                try scalingPoliciesContainer.encode(scalingpolicies0)
            }
        }
        if let scalingStatusCode = scalingStatusCode {
            try encodeContainer.encode(scalingStatusCode.rawValue, forKey: .scalingStatusCode)
        }
        if let scalingStatusMessage = scalingStatusMessage {
            try encodeContainer.encode(scalingStatusMessage, forKey: .scalingStatusMessage)
        }
        if let serviceNamespace = serviceNamespace {
            try encodeContainer.encode(serviceNamespace.rawValue, forKey: .serviceNamespace)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scalingPlanNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scalingPlanName)
        scalingPlanName = scalingPlanNameDecoded
        let scalingPlanVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .scalingPlanVersion)
        scalingPlanVersion = scalingPlanVersionDecoded
        let serviceNamespaceDecoded = try containerValues.decodeIfPresent(ServiceNamespace.self, forKey: .serviceNamespace)
        serviceNamespace = serviceNamespaceDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let scalableDimensionDecoded = try containerValues.decodeIfPresent(ScalableDimension.self, forKey: .scalableDimension)
        scalableDimension = scalableDimensionDecoded
        let scalingPoliciesContainer = try containerValues.decodeIfPresent([ScalingPolicy?].self, forKey: .scalingPolicies)
        var scalingPoliciesDecoded0:[ScalingPolicy]? = nil
        if let scalingPoliciesContainer = scalingPoliciesContainer {
            scalingPoliciesDecoded0 = [ScalingPolicy]()
            for structure0 in scalingPoliciesContainer {
                if let structure0 = structure0 {
                    scalingPoliciesDecoded0?.append(structure0)
                }
            }
        }
        scalingPolicies = scalingPoliciesDecoded0
        let scalingStatusCodeDecoded = try containerValues.decodeIfPresent(ScalingStatusCode.self, forKey: .scalingStatusCode)
        scalingStatusCode = scalingStatusCodeDecoded
        let scalingStatusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scalingStatusMessage)
        scalingStatusMessage = scalingStatusMessageDecoded
    }
}

extension ScalingPlanResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScalingPlanResource(resourceId: \(String(describing: resourceId)), scalableDimension: \(String(describing: scalableDimension)), scalingPlanName: \(String(describing: scalingPlanName)), scalingPlanVersion: \(String(describing: scalingPlanVersion)), scalingPolicies: \(String(describing: scalingPolicies)), scalingStatusCode: \(String(describing: scalingStatusCode)), scalingStatusMessage: \(String(describing: scalingStatusMessage)), serviceNamespace: \(String(describing: serviceNamespace)))"}
}

/// <p>Represents a scalable resource.</p>
public struct ScalingPlanResource: Equatable {
    /// <p>The ID of the resource. This string consists of the resource type and unique
    ///          identifier.</p>
    ///          <ul>
    ///             <li>
    ///                <p>Auto Scaling group - The resource type is <code>autoScalingGroup</code> and the unique identifier is the
    ///                name of the Auto Scaling group. Example: <code>autoScalingGroup/my-asg</code>.</p>
    ///            </li>
    ///             <li>
    ///                <p>ECS service - The resource type is <code>service</code> and the unique identifier is the cluster name
    ///                and service name. Example: <code>service/default/sample-webapp</code>.</p>
    ///            </li>
    ///             <li>
    ///                <p>Spot Fleet request - The resource type is <code>spot-fleet-request</code> and the unique identifier is the
    ///                Spot Fleet request ID. Example: <code>spot-fleet-request/sfr-73fbd2ce-aa30-494c-8788-1cee4EXAMPLE</code>.</p>
    ///            </li>
    ///             <li>
    ///                <p>DynamoDB table - The resource type is <code>table</code> and the unique identifier is the resource ID.
    ///                Example: <code>table/my-table</code>.</p>
    ///            </li>
    ///             <li>
    ///                <p>DynamoDB global secondary index - The resource type is <code>index</code> and the unique identifier is the resource ID.
    ///                Example: <code>table/my-table/index/my-table-index</code>.</p>
    ///            </li>
    ///             <li>
    ///                <p>Aurora DB cluster - The resource type is <code>cluster</code> and the unique identifier is the cluster name.
    ///                Example: <code>cluster:my-db-cluster</code>.</p>
    ///            </li>
    ///          </ul>
    public let resourceId: String?
    /// <p>The scalable dimension for the resource.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>autoscaling:autoScalingGroup:DesiredCapacity</code> - The desired capacity of an Auto Scaling group.</p>
    ///            </li>
    ///             <li>
    ///                <p>
    ///                   <code>ecs:service:DesiredCount</code> - The desired task count of an ECS service.</p>
    ///            </li>
    ///             <li>
    ///                <p>
    ///                   <code>ec2:spot-fleet-request:TargetCapacity</code> - The target capacity of a Spot Fleet request.</p>
    ///            </li>
    ///             <li>
    ///                <p>
    ///                   <code>dynamodb:table:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB table.</p>
    ///            </li>
    ///             <li>
    ///                <p>
    ///                   <code>dynamodb:table:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB table.</p>
    ///            </li>
    ///             <li>
    ///                <p>
    ///                   <code>dynamodb:index:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB global secondary index.</p>
    ///            </li>
    ///             <li>
    ///                <p>
    ///                   <code>dynamodb:index:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB global secondary index.</p>
    ///            </li>
    ///             <li>
    ///                <p>
    ///                   <code>rds:cluster:ReadReplicaCount</code> - The count of Aurora Replicas in an Aurora DB cluster. Available for Aurora MySQL-compatible edition and Aurora PostgreSQL-compatible edition.</p>
    ///            </li>
    ///          </ul>
    public let scalableDimension: ScalableDimension?
    /// <p>The name of the scaling plan.</p>
    public let scalingPlanName: String?
    /// <p>The version number of the scaling plan.</p>
    public let scalingPlanVersion: Int?
    /// <p>The scaling policies.</p>
    public let scalingPolicies: [ScalingPolicy]?
    /// <p>The scaling status of the resource.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Active</code> - The scaling configuration is active.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Inactive</code> - The scaling configuration is not active because the
    ///                scaling plan is being created or the scaling configuration could not be applied.
    ///                Check the status message for more information.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PartiallyActive</code> - The scaling configuration is partially active
    ///                because the scaling plan is being created or deleted or the scaling configuration
    ///                could not be fully applied. Check the status message for more information.</p>
    ///             </li>
    ///          </ul>
    public let scalingStatusCode: ScalingStatusCode?
    /// <p>A simple message about the current scaling status of the resource.</p>
    public let scalingStatusMessage: String?
    /// <p>The namespace of the AWS service.</p>
    public let serviceNamespace: ServiceNamespace?

    public init (
        resourceId: String? = nil,
        scalableDimension: ScalableDimension? = nil,
        scalingPlanName: String? = nil,
        scalingPlanVersion: Int? = nil,
        scalingPolicies: [ScalingPolicy]? = nil,
        scalingStatusCode: ScalingStatusCode? = nil,
        scalingStatusMessage: String? = nil,
        serviceNamespace: ServiceNamespace? = nil
    )
    {
        self.resourceId = resourceId
        self.scalableDimension = scalableDimension
        self.scalingPlanName = scalingPlanName
        self.scalingPlanVersion = scalingPlanVersion
        self.scalingPolicies = scalingPolicies
        self.scalingStatusCode = scalingStatusCode
        self.scalingStatusMessage = scalingStatusMessage
        self.serviceNamespace = serviceNamespace
    }
}

public enum ScalingPlanStatusCode {
    case active
    case activewithproblems
    case creationfailed
    case creationinprogress
    case deletionfailed
    case deletioninprogress
    case updatefailed
    case updateinprogress
    case sdkUnknown(String)
}

extension ScalingPlanStatusCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ScalingPlanStatusCode] {
        return [
            .active,
            .activewithproblems,
            .creationfailed,
            .creationinprogress,
            .deletionfailed,
            .deletioninprogress,
            .updatefailed,
            .updateinprogress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "Active"
        case .activewithproblems: return "ActiveWithProblems"
        case .creationfailed: return "CreationFailed"
        case .creationinprogress: return "CreationInProgress"
        case .deletionfailed: return "DeletionFailed"
        case .deletioninprogress: return "DeletionInProgress"
        case .updatefailed: return "UpdateFailed"
        case .updateinprogress: return "UpdateInProgress"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ScalingPlanStatusCode(rawValue: rawValue) ?? ScalingPlanStatusCode.sdkUnknown(rawValue)
    }
}

extension ScalingPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policyName = "PolicyName"
        case policyType = "PolicyType"
        case targetTrackingConfiguration = "TargetTrackingConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyName = policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
        if let policyType = policyType {
            try encodeContainer.encode(policyType.rawValue, forKey: .policyType)
        }
        if let targetTrackingConfiguration = targetTrackingConfiguration {
            try encodeContainer.encode(targetTrackingConfiguration, forKey: .targetTrackingConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyTypeDecoded = try containerValues.decodeIfPresent(PolicyType.self, forKey: .policyType)
        policyType = policyTypeDecoded
        let targetTrackingConfigurationDecoded = try containerValues.decodeIfPresent(TargetTrackingConfiguration.self, forKey: .targetTrackingConfiguration)
        targetTrackingConfiguration = targetTrackingConfigurationDecoded
    }
}

extension ScalingPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScalingPolicy(policyName: \(String(describing: policyName)), policyType: \(String(describing: policyType)), targetTrackingConfiguration: \(String(describing: targetTrackingConfiguration)))"}
}

/// <p>Represents a scaling policy.</p>
public struct ScalingPolicy: Equatable {
    /// <p>The name of the scaling policy.</p>
    public let policyName: String?
    /// <p>The type of scaling policy.</p>
    public let policyType: PolicyType?
    /// <p>The target tracking scaling policy. Includes support for predefined or customized
    ///          metrics.</p>
    public let targetTrackingConfiguration: TargetTrackingConfiguration?

    public init (
        policyName: String? = nil,
        policyType: PolicyType? = nil,
        targetTrackingConfiguration: TargetTrackingConfiguration? = nil
    )
    {
        self.policyName = policyName
        self.policyType = policyType
        self.targetTrackingConfiguration = targetTrackingConfiguration
    }
}

public enum ScalingPolicyUpdateBehavior {
    case keepexternalpolicies
    case replaceexternalpolicies
    case sdkUnknown(String)
}

extension ScalingPolicyUpdateBehavior : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ScalingPolicyUpdateBehavior] {
        return [
            .keepexternalpolicies,
            .replaceexternalpolicies,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .keepexternalpolicies: return "KeepExternalPolicies"
        case .replaceexternalpolicies: return "ReplaceExternalPolicies"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ScalingPolicyUpdateBehavior(rawValue: rawValue) ?? ScalingPolicyUpdateBehavior.sdkUnknown(rawValue)
    }
}

public enum ScalingStatusCode {
    case active
    case inactive
    case partiallyactive
    case sdkUnknown(String)
}

extension ScalingStatusCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ScalingStatusCode] {
        return [
            .active,
            .inactive,
            .partiallyactive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "Active"
        case .inactive: return "Inactive"
        case .partiallyactive: return "PartiallyActive"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ScalingStatusCode(rawValue: rawValue) ?? ScalingStatusCode.sdkUnknown(rawValue)
    }
}

public enum ServiceNamespace {
    case autoscaling
    case dynamodb
    case ec2
    case ecs
    case rds
    case sdkUnknown(String)
}

extension ServiceNamespace : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ServiceNamespace] {
        return [
            .autoscaling,
            .dynamodb,
            .ec2,
            .ecs,
            .rds,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .autoscaling: return "autoscaling"
        case .dynamodb: return "dynamodb"
        case .ec2: return "ec2"
        case .ecs: return "ecs"
        case .rds: return "rds"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ServiceNamespace(rawValue: rawValue) ?? ServiceNamespace.sdkUnknown(rawValue)
    }
}

extension TagFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for tagvalues0 in values {
                try valuesContainer.encode(tagvalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension TagFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagFilter(key: \(String(describing: key)), values: \(String(describing: values)))"}
}

/// <p>Represents a tag.</p>
public struct TagFilter: Equatable {
    /// <p>The tag key.</p>
    public let key: String?
    /// <p>The tag values (0 to 20).</p>
    public let values: [String]?

    public init (
        key: String? = nil,
        values: [String]? = nil
    )
    {
        self.key = key
        self.values = values
    }
}

extension TargetTrackingConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customizedScalingMetricSpecification = "CustomizedScalingMetricSpecification"
        case disableScaleIn = "DisableScaleIn"
        case estimatedInstanceWarmup = "EstimatedInstanceWarmup"
        case predefinedScalingMetricSpecification = "PredefinedScalingMetricSpecification"
        case scaleInCooldown = "ScaleInCooldown"
        case scaleOutCooldown = "ScaleOutCooldown"
        case targetValue = "TargetValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customizedScalingMetricSpecification = customizedScalingMetricSpecification {
            try encodeContainer.encode(customizedScalingMetricSpecification, forKey: .customizedScalingMetricSpecification)
        }
        if let disableScaleIn = disableScaleIn {
            try encodeContainer.encode(disableScaleIn, forKey: .disableScaleIn)
        }
        if let estimatedInstanceWarmup = estimatedInstanceWarmup {
            try encodeContainer.encode(estimatedInstanceWarmup, forKey: .estimatedInstanceWarmup)
        }
        if let predefinedScalingMetricSpecification = predefinedScalingMetricSpecification {
            try encodeContainer.encode(predefinedScalingMetricSpecification, forKey: .predefinedScalingMetricSpecification)
        }
        if let scaleInCooldown = scaleInCooldown {
            try encodeContainer.encode(scaleInCooldown, forKey: .scaleInCooldown)
        }
        if let scaleOutCooldown = scaleOutCooldown {
            try encodeContainer.encode(scaleOutCooldown, forKey: .scaleOutCooldown)
        }
        if let targetValue = targetValue {
            try encodeContainer.encode(targetValue, forKey: .targetValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predefinedScalingMetricSpecificationDecoded = try containerValues.decodeIfPresent(PredefinedScalingMetricSpecification.self, forKey: .predefinedScalingMetricSpecification)
        predefinedScalingMetricSpecification = predefinedScalingMetricSpecificationDecoded
        let customizedScalingMetricSpecificationDecoded = try containerValues.decodeIfPresent(CustomizedScalingMetricSpecification.self, forKey: .customizedScalingMetricSpecification)
        customizedScalingMetricSpecification = customizedScalingMetricSpecificationDecoded
        let targetValueDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .targetValue)
        targetValue = targetValueDecoded
        let disableScaleInDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .disableScaleIn)
        disableScaleIn = disableScaleInDecoded
        let scaleOutCooldownDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .scaleOutCooldown)
        scaleOutCooldown = scaleOutCooldownDecoded
        let scaleInCooldownDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .scaleInCooldown)
        scaleInCooldown = scaleInCooldownDecoded
        let estimatedInstanceWarmupDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .estimatedInstanceWarmup)
        estimatedInstanceWarmup = estimatedInstanceWarmupDecoded
    }
}

extension TargetTrackingConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TargetTrackingConfiguration(customizedScalingMetricSpecification: \(String(describing: customizedScalingMetricSpecification)), disableScaleIn: \(String(describing: disableScaleIn)), estimatedInstanceWarmup: \(String(describing: estimatedInstanceWarmup)), predefinedScalingMetricSpecification: \(String(describing: predefinedScalingMetricSpecification)), scaleInCooldown: \(String(describing: scaleInCooldown)), scaleOutCooldown: \(String(describing: scaleOutCooldown)), targetValue: \(String(describing: targetValue)))"}
}

/// <p>Describes a target tracking configuration to use with AWS Auto Scaling. Used with <a>ScalingInstruction</a> and <a>ScalingPolicy</a>.</p>
public struct TargetTrackingConfiguration: Equatable {
    /// <p>A customized metric. You can specify either a predefined metric or a customized metric.
    ///       </p>
    public let customizedScalingMetricSpecification: CustomizedScalingMetricSpecification?
    /// <p>Indicates whether scale in by the target tracking scaling policy is disabled. If the
    ///          value is <code>true</code>, scale in is disabled and the target tracking scaling policy
    ///          doesn't remove capacity from the scalable resource. Otherwise, scale in is enabled and the
    ///          target tracking scaling policy can remove capacity from the scalable resource. </p>
    ///          <p>The default value is <code>false</code>.</p>
    public let disableScaleIn: Bool?
    /// <p>The estimated time, in seconds, until a newly launched instance can contribute to the
    ///          CloudWatch metrics. This value is used only if the resource is an Auto Scaling group.</p>
    public let estimatedInstanceWarmup: Int?
    /// <p>A predefined metric. You can specify either a predefined metric or a customized
    ///          metric.</p>
    public let predefinedScalingMetricSpecification: PredefinedScalingMetricSpecification?
    /// <p>The amount of time, in seconds, after a scale-in activity completes before another
    ///          scale-in activity can start. This property is not used if the scalable resource is an Auto Scaling
    ///          group.</p>
    ///          <p>With the <i>scale-in cooldown period</i>, the intention is to scale in
    ///          conservatively to protect your application’s availability, so scale-in activities are blocked
    ///          until the cooldown period has expired. However, if another alarm triggers a scale-out activity
    ///          during the scale-in cooldown period, Auto Scaling scales out the target immediately. In this case,
    ///          the scale-in cooldown period stops and doesn't complete.</p>
    public let scaleInCooldown: Int?
    /// <p>The amount of time, in seconds, to wait for a previous scale-out activity to take
    ///          effect. This property is not used if the scalable resource is an Auto Scaling
    ///          group.</p>
    ///          <p>With the <i>scale-out cooldown period</i>, the intention is to continuously
    ///          (but not excessively) scale out. After Auto Scaling successfully scales out using a target
    ///          tracking scaling policy, it starts to calculate the cooldown time. The scaling policy won't
    ///          increase the desired capacity again unless either a larger scale out is triggered or the
    ///          cooldown period ends.</p>
    public let scaleOutCooldown: Int?
    /// <p>The target value for the metric. Although this property accepts numbers of type Double,
    ///          it won't accept values that are either too small or too large. Values must be in the range
    ///          of -2^360 to 2^360.</p>
    public let targetValue: Double?

    public init (
        customizedScalingMetricSpecification: CustomizedScalingMetricSpecification? = nil,
        disableScaleIn: Bool? = nil,
        estimatedInstanceWarmup: Int? = nil,
        predefinedScalingMetricSpecification: PredefinedScalingMetricSpecification? = nil,
        scaleInCooldown: Int? = nil,
        scaleOutCooldown: Int? = nil,
        targetValue: Double? = nil
    )
    {
        self.customizedScalingMetricSpecification = customizedScalingMetricSpecification
        self.disableScaleIn = disableScaleIn
        self.estimatedInstanceWarmup = estimatedInstanceWarmup
        self.predefinedScalingMetricSpecification = predefinedScalingMetricSpecification
        self.scaleInCooldown = scaleInCooldown
        self.scaleOutCooldown = scaleOutCooldown
        self.targetValue = targetValue
    }
}

public struct UpdateScalingPlanInputBodyMiddleware: Middleware {
    public let id: String = "UpdateScalingPlanInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateScalingPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateScalingPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateScalingPlanInput>
    public typealias MOutput = OperationOutput<UpdateScalingPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateScalingPlanOutputError>
}

extension UpdateScalingPlanInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateScalingPlanInput(applicationSource: \(String(describing: applicationSource)), scalingInstructions: \(String(describing: scalingInstructions)), scalingPlanName: \(String(describing: scalingPlanName)), scalingPlanVersion: \(String(describing: scalingPlanVersion)))"}
}

extension UpdateScalingPlanInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationSource = "ApplicationSource"
        case scalingInstructions = "ScalingInstructions"
        case scalingPlanName = "ScalingPlanName"
        case scalingPlanVersion = "ScalingPlanVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationSource = applicationSource {
            try encodeContainer.encode(applicationSource, forKey: .applicationSource)
        }
        if let scalingInstructions = scalingInstructions {
            var scalingInstructionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scalingInstructions)
            for scalinginstructions0 in scalingInstructions {
                try scalingInstructionsContainer.encode(scalinginstructions0)
            }
        }
        if let scalingPlanName = scalingPlanName {
            try encodeContainer.encode(scalingPlanName, forKey: .scalingPlanName)
        }
        if let scalingPlanVersion = scalingPlanVersion {
            try encodeContainer.encode(scalingPlanVersion, forKey: .scalingPlanVersion)
        }
    }
}

public struct UpdateScalingPlanInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateScalingPlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateScalingPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateScalingPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateScalingPlanInput>
    public typealias MOutput = OperationOutput<UpdateScalingPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateScalingPlanOutputError>
}

public struct UpdateScalingPlanInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateScalingPlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateScalingPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateScalingPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateScalingPlanInput>
    public typealias MOutput = OperationOutput<UpdateScalingPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateScalingPlanOutputError>
}

public struct UpdateScalingPlanInput: Equatable {
    /// <p>A CloudFormation stack or set of tags.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/plans/APIReference/API_ApplicationSource.html">ApplicationSource</a> in the <i>AWS Auto Scaling API Reference</i>.</p>
    public let applicationSource: ApplicationSource?
    /// <p>The scaling instructions.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/plans/APIReference/API_ScalingInstruction.html">ScalingInstruction</a> in the <i>AWS Auto Scaling API Reference</i>.</p>
    public let scalingInstructions: [ScalingInstruction]?
    /// <p>The name of the scaling plan.</p>
    public let scalingPlanName: String?
    /// <p>The version number of the scaling plan. The only valid value is <code>1</code>.
    ///          Currently, you cannot have multiple scaling plan versions.</p>
    public let scalingPlanVersion: Int?

    public init (
        applicationSource: ApplicationSource? = nil,
        scalingInstructions: [ScalingInstruction]? = nil,
        scalingPlanName: String? = nil,
        scalingPlanVersion: Int? = nil
    )
    {
        self.applicationSource = applicationSource
        self.scalingInstructions = scalingInstructions
        self.scalingPlanName = scalingPlanName
        self.scalingPlanVersion = scalingPlanVersion
    }
}

struct UpdateScalingPlanInputBody: Equatable {
    public let scalingPlanName: String?
    public let scalingPlanVersion: Int?
    public let applicationSource: ApplicationSource?
    public let scalingInstructions: [ScalingInstruction]?
}

extension UpdateScalingPlanInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationSource = "ApplicationSource"
        case scalingInstructions = "ScalingInstructions"
        case scalingPlanName = "ScalingPlanName"
        case scalingPlanVersion = "ScalingPlanVersion"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scalingPlanNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scalingPlanName)
        scalingPlanName = scalingPlanNameDecoded
        let scalingPlanVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .scalingPlanVersion)
        scalingPlanVersion = scalingPlanVersionDecoded
        let applicationSourceDecoded = try containerValues.decodeIfPresent(ApplicationSource.self, forKey: .applicationSource)
        applicationSource = applicationSourceDecoded
        let scalingInstructionsContainer = try containerValues.decodeIfPresent([ScalingInstruction?].self, forKey: .scalingInstructions)
        var scalingInstructionsDecoded0:[ScalingInstruction]? = nil
        if let scalingInstructionsContainer = scalingInstructionsContainer {
            scalingInstructionsDecoded0 = [ScalingInstruction]()
            for structure0 in scalingInstructionsContainer {
                if let structure0 = structure0 {
                    scalingInstructionsDecoded0?.append(structure0)
                }
            }
        }
        scalingInstructions = scalingInstructionsDecoded0
    }
}

extension UpdateScalingPlanOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateScalingPlanOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentUpdateException" : self = .concurrentUpdateException(try ConcurrentUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ObjectNotFoundException" : self = .objectNotFoundException(try ObjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateScalingPlanOutputError: Equatable {
    case concurrentUpdateException(ConcurrentUpdateException)
    case internalServiceException(InternalServiceException)
    case objectNotFoundException(ObjectNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateScalingPlanOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateScalingPlanOutputResponse()"}
}

extension UpdateScalingPlanOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateScalingPlanOutputResponse: Equatable {

    public init() {}
}

struct UpdateScalingPlanOutputResponseBody: Equatable {
}

extension UpdateScalingPlanOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An exception was thrown for a validation issue. Review the parameters provided.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
