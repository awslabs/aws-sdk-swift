// Code generated by smithy-swift-codegen. DO NOT EDIT!



/// <p>Describes a target tracking configuration to use with AWS Auto Scaling. Used with <a>ScalingInstruction</a> and <a>ScalingPolicy</a>.</p>
public struct TargetTrackingConfiguration: Equatable {
    /// <p>A customized metric. You can specify either a predefined metric or a customized metric.
    ///       </p>
    public let customizedScalingMetricSpecification: CustomizedScalingMetricSpecification?
    /// <p>Indicates whether scale in by the target tracking scaling policy is disabled. If the
    ///          value is <code>true</code>, scale in is disabled and the target tracking scaling policy
    ///          doesn't remove capacity from the scalable resource. Otherwise, scale in is enabled and the
    ///          target tracking scaling policy can remove capacity from the scalable resource. </p>
    ///          <p>The default value is <code>false</code>.</p>
    public let disableScaleIn: Bool?
    /// <p>The estimated time, in seconds, until a newly launched instance can contribute to the
    ///          CloudWatch metrics. This value is used only if the resource is an Auto Scaling group.</p>
    public let estimatedInstanceWarmup: Int?
    /// <p>A predefined metric. You can specify either a predefined metric or a customized
    ///          metric.</p>
    public let predefinedScalingMetricSpecification: PredefinedScalingMetricSpecification?
    /// <p>The amount of time, in seconds, after a scale-in activity completes before another
    ///          scale-in activity can start. This property is not used if the scalable resource is an Auto Scaling
    ///          group.</p>
    ///          <p>With the <i>scale-in cooldown period</i>, the intention is to scale in
    ///          conservatively to protect your applicationâ€™s availability, so scale-in activities are blocked
    ///          until the cooldown period has expired. However, if another alarm triggers a scale-out activity
    ///          during the scale-in cooldown period, Auto Scaling scales out the target immediately. In this case,
    ///          the scale-in cooldown period stops and doesn't complete.</p>
    public let scaleInCooldown: Int?
    /// <p>The amount of time, in seconds, to wait for a previous scale-out activity to take
    ///          effect. This property is not used if the scalable resource is an Auto Scaling
    ///          group.</p>
    ///          <p>With the <i>scale-out cooldown period</i>, the intention is to continuously
    ///          (but not excessively) scale out. After Auto Scaling successfully scales out using a target
    ///          tracking scaling policy, it starts to calculate the cooldown time. The scaling policy won't
    ///          increase the desired capacity again unless either a larger scale out is triggered or the
    ///          cooldown period ends.</p>
    public let scaleOutCooldown: Int?
    /// <p>The target value for the metric. Although this property accepts numbers of type Double,
    ///          it won't accept values that are either too small or too large. Values must be in the range
    ///          of -2^360 to 2^360.</p>
    public let targetValue: Double?

    public init (
        customizedScalingMetricSpecification: CustomizedScalingMetricSpecification? = nil,
        disableScaleIn: Bool? = nil,
        estimatedInstanceWarmup: Int? = nil,
        predefinedScalingMetricSpecification: PredefinedScalingMetricSpecification? = nil,
        scaleInCooldown: Int? = nil,
        scaleOutCooldown: Int? = nil,
        targetValue: Double? = nil
    )
    {
        self.customizedScalingMetricSpecification = customizedScalingMetricSpecification
        self.disableScaleIn = disableScaleIn
        self.estimatedInstanceWarmup = estimatedInstanceWarmup
        self.predefinedScalingMetricSpecification = predefinedScalingMetricSpecification
        self.scaleInCooldown = scaleInCooldown
        self.scaleOutCooldown = scaleOutCooldown
        self.targetValue = targetValue
    }
}
