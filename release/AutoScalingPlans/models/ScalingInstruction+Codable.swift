// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension ScalingInstruction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customizedLoadMetricSpecification = "CustomizedLoadMetricSpecification"
        case disableDynamicScaling = "DisableDynamicScaling"
        case maxCapacity = "MaxCapacity"
        case minCapacity = "MinCapacity"
        case predefinedLoadMetricSpecification = "PredefinedLoadMetricSpecification"
        case predictiveScalingMaxCapacityBehavior = "PredictiveScalingMaxCapacityBehavior"
        case predictiveScalingMaxCapacityBuffer = "PredictiveScalingMaxCapacityBuffer"
        case predictiveScalingMode = "PredictiveScalingMode"
        case resourceId = "ResourceId"
        case scalableDimension = "ScalableDimension"
        case scalingPolicyUpdateBehavior = "ScalingPolicyUpdateBehavior"
        case scheduledActionBufferTime = "ScheduledActionBufferTime"
        case serviceNamespace = "ServiceNamespace"
        case targetTrackingConfigurations = "TargetTrackingConfigurations"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customizedLoadMetricSpecification = customizedLoadMetricSpecification {
            try encodeContainer.encode(customizedLoadMetricSpecification, forKey: .customizedLoadMetricSpecification)
        }
        if let disableDynamicScaling = disableDynamicScaling {
            try encodeContainer.encode(disableDynamicScaling, forKey: .disableDynamicScaling)
        }
        if let maxCapacity = maxCapacity {
            try encodeContainer.encode(maxCapacity, forKey: .maxCapacity)
        }
        if let minCapacity = minCapacity {
            try encodeContainer.encode(minCapacity, forKey: .minCapacity)
        }
        if let predefinedLoadMetricSpecification = predefinedLoadMetricSpecification {
            try encodeContainer.encode(predefinedLoadMetricSpecification, forKey: .predefinedLoadMetricSpecification)
        }
        if let predictiveScalingMaxCapacityBehavior = predictiveScalingMaxCapacityBehavior {
            try encodeContainer.encode(predictiveScalingMaxCapacityBehavior.rawValue, forKey: .predictiveScalingMaxCapacityBehavior)
        }
        if let predictiveScalingMaxCapacityBuffer = predictiveScalingMaxCapacityBuffer {
            try encodeContainer.encode(predictiveScalingMaxCapacityBuffer, forKey: .predictiveScalingMaxCapacityBuffer)
        }
        if let predictiveScalingMode = predictiveScalingMode {
            try encodeContainer.encode(predictiveScalingMode.rawValue, forKey: .predictiveScalingMode)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let scalableDimension = scalableDimension {
            try encodeContainer.encode(scalableDimension.rawValue, forKey: .scalableDimension)
        }
        if let scalingPolicyUpdateBehavior = scalingPolicyUpdateBehavior {
            try encodeContainer.encode(scalingPolicyUpdateBehavior.rawValue, forKey: .scalingPolicyUpdateBehavior)
        }
        if let scheduledActionBufferTime = scheduledActionBufferTime {
            try encodeContainer.encode(scheduledActionBufferTime, forKey: .scheduledActionBufferTime)
        }
        if let serviceNamespace = serviceNamespace {
            try encodeContainer.encode(serviceNamespace.rawValue, forKey: .serviceNamespace)
        }
        if let targetTrackingConfigurations = targetTrackingConfigurations {
            var targetTrackingConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetTrackingConfigurations)
            for targettrackingconfigurations0 in targetTrackingConfigurations {
                try targetTrackingConfigurationsContainer.encode(targettrackingconfigurations0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNamespaceDecoded = try containerValues.decodeIfPresent(ServiceNamespace.self, forKey: .serviceNamespace)
        serviceNamespace = serviceNamespaceDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let scalableDimensionDecoded = try containerValues.decodeIfPresent(ScalableDimension.self, forKey: .scalableDimension)
        scalableDimension = scalableDimensionDecoded
        let minCapacityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minCapacity)
        minCapacity = minCapacityDecoded
        let maxCapacityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxCapacity)
        maxCapacity = maxCapacityDecoded
        let targetTrackingConfigurationsContainer = try containerValues.decodeIfPresent([TargetTrackingConfiguration].self, forKey: .targetTrackingConfigurations)
        var targetTrackingConfigurationsDecoded0:[TargetTrackingConfiguration]? = nil
        if let targetTrackingConfigurationsContainer = targetTrackingConfigurationsContainer {
            targetTrackingConfigurationsDecoded0 = [TargetTrackingConfiguration]()
            for structure0 in targetTrackingConfigurationsContainer {
                targetTrackingConfigurationsDecoded0?.append(structure0)
            }
        }
        targetTrackingConfigurations = targetTrackingConfigurationsDecoded0
        let predefinedLoadMetricSpecificationDecoded = try containerValues.decodeIfPresent(PredefinedLoadMetricSpecification.self, forKey: .predefinedLoadMetricSpecification)
        predefinedLoadMetricSpecification = predefinedLoadMetricSpecificationDecoded
        let customizedLoadMetricSpecificationDecoded = try containerValues.decodeIfPresent(CustomizedLoadMetricSpecification.self, forKey: .customizedLoadMetricSpecification)
        customizedLoadMetricSpecification = customizedLoadMetricSpecificationDecoded
        let scheduledActionBufferTimeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .scheduledActionBufferTime)
        scheduledActionBufferTime = scheduledActionBufferTimeDecoded
        let predictiveScalingMaxCapacityBehaviorDecoded = try containerValues.decodeIfPresent(PredictiveScalingMaxCapacityBehavior.self, forKey: .predictiveScalingMaxCapacityBehavior)
        predictiveScalingMaxCapacityBehavior = predictiveScalingMaxCapacityBehaviorDecoded
        let predictiveScalingMaxCapacityBufferDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .predictiveScalingMaxCapacityBuffer)
        predictiveScalingMaxCapacityBuffer = predictiveScalingMaxCapacityBufferDecoded
        let predictiveScalingModeDecoded = try containerValues.decodeIfPresent(PredictiveScalingMode.self, forKey: .predictiveScalingMode)
        predictiveScalingMode = predictiveScalingModeDecoded
        let scalingPolicyUpdateBehaviorDecoded = try containerValues.decodeIfPresent(ScalingPolicyUpdateBehavior.self, forKey: .scalingPolicyUpdateBehavior)
        scalingPolicyUpdateBehavior = scalingPolicyUpdateBehaviorDecoded
        let disableDynamicScalingDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .disableDynamicScaling)
        disableDynamicScaling = disableDynamicScalingDecoded
    }
}
