// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension RoboMakerClientTypes {
    public enum Architecture: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case arm64
        case armhf
        case x8664
        case sdkUnknown(Swift.String)

        public static var allCases: [Architecture] {
            return [
                .arm64,
                .armhf,
                .x8664,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .arm64: return "ARM64"
            case .armhf: return "ARMHF"
            case .x8664: return "X86_64"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Architecture(rawValue: rawValue) ?? Architecture.sdkUnknown(rawValue)
        }
    }
}

extension BatchDeleteWorldsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case worlds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let worlds = worlds {
            var worldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .worlds)
            for arn0 in worlds {
                try worldsContainer.encode(arn0)
            }
        }
    }
}

extension BatchDeleteWorldsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/batchDeleteWorlds"
    }
}

public struct BatchDeleteWorldsInput: Swift.Equatable {
    /// A list of Amazon Resource Names (arns) that correspond to worlds to delete.
    /// This member is required.
    public var worlds: [Swift.String]?

    public init (
        worlds: [Swift.String]? = nil
    )
    {
        self.worlds = worlds
    }
}

struct BatchDeleteWorldsInputBody: Swift.Equatable {
    let worlds: [Swift.String]?
}

extension BatchDeleteWorldsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case worlds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let worldsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .worlds)
        var worldsDecoded0:[Swift.String]? = nil
        if let worldsContainer = worldsContainer {
            worldsDecoded0 = [Swift.String]()
            for string0 in worldsContainer {
                if let string0 = string0 {
                    worldsDecoded0?.append(string0)
                }
            }
        }
        worlds = worldsDecoded0
    }
}

extension BatchDeleteWorldsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDeleteWorldsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchDeleteWorldsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDeleteWorldsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchDeleteWorldsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedWorlds = output.unprocessedWorlds
        } else {
            self.unprocessedWorlds = nil
        }
    }
}

public struct BatchDeleteWorldsOutputResponse: Swift.Equatable {
    /// A list of unprocessed worlds associated with the call. These worlds were not deleted.
    public var unprocessedWorlds: [Swift.String]?

    public init (
        unprocessedWorlds: [Swift.String]? = nil
    )
    {
        self.unprocessedWorlds = unprocessedWorlds
    }
}

struct BatchDeleteWorldsOutputResponseBody: Swift.Equatable {
    let unprocessedWorlds: [Swift.String]?
}

extension BatchDeleteWorldsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedWorlds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedWorldsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .unprocessedWorlds)
        var unprocessedWorldsDecoded0:[Swift.String]? = nil
        if let unprocessedWorldsContainer = unprocessedWorldsContainer {
            unprocessedWorldsDecoded0 = [Swift.String]()
            for string0 in unprocessedWorldsContainer {
                if let string0 = string0 {
                    unprocessedWorldsDecoded0?.append(string0)
                }
            }
        }
        unprocessedWorlds = unprocessedWorldsDecoded0
    }
}

extension BatchDescribeSimulationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobs = jobs {
            var jobsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobs)
            for arn0 in jobs {
                try jobsContainer.encode(arn0)
            }
        }
    }
}

extension BatchDescribeSimulationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/batchDescribeSimulationJob"
    }
}

public struct BatchDescribeSimulationJobInput: Swift.Equatable {
    /// A list of Amazon Resource Names (ARNs) of simulation jobs to describe.
    /// This member is required.
    public var jobs: [Swift.String]?

    public init (
        jobs: [Swift.String]? = nil
    )
    {
        self.jobs = jobs
    }
}

struct BatchDescribeSimulationJobInputBody: Swift.Equatable {
    let jobs: [Swift.String]?
}

extension BatchDescribeSimulationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .jobs)
        var jobsDecoded0:[Swift.String]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [Swift.String]()
            for string0 in jobsContainer {
                if let string0 = string0 {
                    jobsDecoded0?.append(string0)
                }
            }
        }
        jobs = jobsDecoded0
    }
}

extension BatchDescribeSimulationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDescribeSimulationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchDescribeSimulationJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDescribeSimulationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchDescribeSimulationJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
            self.unprocessedJobs = output.unprocessedJobs
        } else {
            self.jobs = nil
            self.unprocessedJobs = nil
        }
    }
}

public struct BatchDescribeSimulationJobOutputResponse: Swift.Equatable {
    /// A list of simulation jobs.
    public var jobs: [RoboMakerClientTypes.SimulationJob]?
    /// A list of unprocessed simulation job Amazon Resource Names (ARNs).
    public var unprocessedJobs: [Swift.String]?

    public init (
        jobs: [RoboMakerClientTypes.SimulationJob]? = nil,
        unprocessedJobs: [Swift.String]? = nil
    )
    {
        self.jobs = jobs
        self.unprocessedJobs = unprocessedJobs
    }
}

struct BatchDescribeSimulationJobOutputResponseBody: Swift.Equatable {
    let jobs: [RoboMakerClientTypes.SimulationJob]?
    let unprocessedJobs: [Swift.String]?
}

extension BatchDescribeSimulationJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs
        case unprocessedJobs
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationJob?].self, forKey: .jobs)
        var jobsDecoded0:[RoboMakerClientTypes.SimulationJob]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [RoboMakerClientTypes.SimulationJob]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let unprocessedJobsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .unprocessedJobs)
        var unprocessedJobsDecoded0:[Swift.String]? = nil
        if let unprocessedJobsContainer = unprocessedJobsContainer {
            unprocessedJobsDecoded0 = [Swift.String]()
            for string0 in unprocessedJobsContainer {
                if let string0 = string0 {
                    unprocessedJobsDecoded0?.append(string0)
                }
            }
        }
        unprocessedJobs = unprocessedJobsDecoded0
    }
}

extension RoboMakerClientTypes.BatchPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxConcurrency
        case timeoutInSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxConcurrency = self.maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let timeoutInSeconds = self.timeoutInSeconds {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about the batch policy.
    public struct BatchPolicy: Swift.Equatable {
        /// The number of active simulation jobs create as part of the batch that can be in an active state at the same time. Active states include: Pending,Preparing, Running, Restarting, RunningFailed and Terminating. All other states are terminal states.
        public var maxConcurrency: Swift.Int?
        /// The amount of time, in seconds, to wait for the batch to complete. If a batch times out, and there are pending requests that were failing due to an internal failure (like InternalServiceError), they will be moved to the failed list and the batch status will be Failed. If the pending requests were failing for any other reason, the failed pending requests will be moved to the failed list and the batch status will be TimedOut.
        public var timeoutInSeconds: Swift.Int?

        public init (
            maxConcurrency: Swift.Int? = nil,
            timeoutInSeconds: Swift.Int? = nil
        )
        {
            self.maxConcurrency = maxConcurrency
            self.timeoutInSeconds = timeoutInSeconds
        }
    }

}

extension CancelDeploymentJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = self.job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

extension CancelDeploymentJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/cancelDeploymentJob"
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct CancelDeploymentJobInput: Swift.Equatable {
    /// The deployment job ARN to cancel.
    /// This member is required.
    public var job: Swift.String?

    public init (
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

struct CancelDeploymentJobInputBody: Swift.Equatable {
    let job: Swift.String?
}

extension CancelDeploymentJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .job)
        job = jobDecoded
    }
}

extension CancelDeploymentJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelDeploymentJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CancelDeploymentJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelDeploymentJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct CancelDeploymentJobOutputResponse: Swift.Equatable {

    public init () { }
}

extension CancelSimulationJobBatchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batch
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batch = self.batch {
            try encodeContainer.encode(batch, forKey: .batch)
        }
    }
}

extension CancelSimulationJobBatchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/cancelSimulationJobBatch"
    }
}

public struct CancelSimulationJobBatchInput: Swift.Equatable {
    /// The id of the batch to cancel.
    /// This member is required.
    public var batch: Swift.String?

    public init (
        batch: Swift.String? = nil
    )
    {
        self.batch = batch
    }
}

struct CancelSimulationJobBatchInputBody: Swift.Equatable {
    let batch: Swift.String?
}

extension CancelSimulationJobBatchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batch
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batch)
        batch = batchDecoded
    }
}

extension CancelSimulationJobBatchOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelSimulationJobBatchOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CancelSimulationJobBatchOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelSimulationJobBatchOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CancelSimulationJobBatchOutputResponse: Swift.Equatable {

    public init () { }
}

extension CancelSimulationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = self.job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

extension CancelSimulationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/cancelSimulationJob"
    }
}

public struct CancelSimulationJobInput: Swift.Equatable {
    /// The simulation job ARN to cancel.
    /// This member is required.
    public var job: Swift.String?

    public init (
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

struct CancelSimulationJobInputBody: Swift.Equatable {
    let job: Swift.String?
}

extension CancelSimulationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .job)
        job = jobDecoded
    }
}

extension CancelSimulationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelSimulationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CancelSimulationJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelSimulationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CancelSimulationJobOutputResponse: Swift.Equatable {

    public init () { }
}

extension CancelWorldExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = self.job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

extension CancelWorldExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/cancelWorldExportJob"
    }
}

public struct CancelWorldExportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the world export job to cancel.
    /// This member is required.
    public var job: Swift.String?

    public init (
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

struct CancelWorldExportJobInputBody: Swift.Equatable {
    let job: Swift.String?
}

extension CancelWorldExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .job)
        job = jobDecoded
    }
}

extension CancelWorldExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelWorldExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CancelWorldExportJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelWorldExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CancelWorldExportJobOutputResponse: Swift.Equatable {

    public init () { }
}

extension CancelWorldGenerationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = self.job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

extension CancelWorldGenerationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/cancelWorldGenerationJob"
    }
}

public struct CancelWorldGenerationJobInput: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the world generator job to cancel.
    /// This member is required.
    public var job: Swift.String?

    public init (
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

struct CancelWorldGenerationJobInputBody: Swift.Equatable {
    let job: Swift.String?
}

extension CancelWorldGenerationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .job)
        job = jobDecoded
    }
}

extension CancelWorldGenerationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelWorldGenerationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CancelWorldGenerationJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelWorldGenerationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CancelWorldGenerationJobOutputResponse: Swift.Equatable {

    public init () { }
}

extension RoboMakerClientTypes.Compute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computeType
        case gpuUnitLimit
        case simulationUnitLimit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computeType = self.computeType {
            try encodeContainer.encode(computeType.rawValue, forKey: .computeType)
        }
        if let gpuUnitLimit = self.gpuUnitLimit {
            try encodeContainer.encode(gpuUnitLimit, forKey: .gpuUnitLimit)
        }
        if let simulationUnitLimit = self.simulationUnitLimit {
            try encodeContainer.encode(simulationUnitLimit, forKey: .simulationUnitLimit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simulationUnitLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .simulationUnitLimit)
        simulationUnitLimit = simulationUnitLimitDecoded
        let computeTypeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.ComputeType.self, forKey: .computeType)
        computeType = computeTypeDecoded
        let gpuUnitLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gpuUnitLimit)
        gpuUnitLimit = gpuUnitLimitDecoded
    }
}

extension RoboMakerClientTypes {
    /// Compute information for the simulation job.
    public struct Compute: Swift.Equatable {
        /// Compute type information for the simulation job.
        public var computeType: RoboMakerClientTypes.ComputeType?
        /// Compute GPU unit limit for the simulation job. It is the same as the number of GPUs allocated to the SimulationJob.
        public var gpuUnitLimit: Swift.Int?
        /// The simulation unit limit. Your simulation is allocated CPU and memory proportional to the supplied simulation unit limit. A simulation unit is 1 vcpu and 2GB of memory. You are only billed for the SU utilization you consume up to the maximum value provided. The default is 15.
        public var simulationUnitLimit: Swift.Int?

        public init (
            computeType: RoboMakerClientTypes.ComputeType? = nil,
            gpuUnitLimit: Swift.Int? = nil,
            simulationUnitLimit: Swift.Int? = nil
        )
        {
            self.computeType = computeType
            self.gpuUnitLimit = gpuUnitLimit
            self.simulationUnitLimit = simulationUnitLimit
        }
    }

}

extension RoboMakerClientTypes.ComputeResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computeType
        case gpuUnitLimit
        case simulationUnitLimit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computeType = self.computeType {
            try encodeContainer.encode(computeType.rawValue, forKey: .computeType)
        }
        if let gpuUnitLimit = self.gpuUnitLimit {
            try encodeContainer.encode(gpuUnitLimit, forKey: .gpuUnitLimit)
        }
        if let simulationUnitLimit = self.simulationUnitLimit {
            try encodeContainer.encode(simulationUnitLimit, forKey: .simulationUnitLimit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simulationUnitLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .simulationUnitLimit)
        simulationUnitLimit = simulationUnitLimitDecoded
        let computeTypeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.ComputeType.self, forKey: .computeType)
        computeType = computeTypeDecoded
        let gpuUnitLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gpuUnitLimit)
        gpuUnitLimit = gpuUnitLimitDecoded
    }
}

extension RoboMakerClientTypes {
    /// Compute information for the simulation job
    public struct ComputeResponse: Swift.Equatable {
        /// Compute type response information for the simulation job.
        public var computeType: RoboMakerClientTypes.ComputeType?
        /// Compute GPU unit limit for the simulation job. It is the same as the number of GPUs allocated to the SimulationJob.
        public var gpuUnitLimit: Swift.Int?
        /// The simulation unit limit. Your simulation is allocated CPU and memory proportional to the supplied simulation unit limit. A simulation unit is 1 vcpu and 2GB of memory. You are only billed for the SU utilization you consume up to the maximum value provided. The default is 15.
        public var simulationUnitLimit: Swift.Int?

        public init (
            computeType: RoboMakerClientTypes.ComputeType? = nil,
            gpuUnitLimit: Swift.Int? = nil,
            simulationUnitLimit: Swift.Int? = nil
        )
        {
            self.computeType = computeType
            self.gpuUnitLimit = gpuUnitLimit
            self.simulationUnitLimit = simulationUnitLimit
        }
    }

}

extension RoboMakerClientTypes {
    public enum ComputeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cpu
        case gpuAndCpu
        case sdkUnknown(Swift.String)

        public static var allCases: [ComputeType] {
            return [
                .cpu,
                .gpuAndCpu,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cpu: return "CPU"
            case .gpuAndCpu: return "GPU_AND_CPU"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComputeType(rawValue: rawValue) ?? ComputeType.sdkUnknown(rawValue)
        }
    }
}

extension ConcurrentDeploymentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConcurrentDeploymentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The failure percentage threshold percentage was met.
public struct ConcurrentDeploymentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentDeploymentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConcurrentDeploymentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateDeploymentJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case deploymentApplicationConfigs
        case deploymentConfig
        case fleet
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let deploymentApplicationConfigs = deploymentApplicationConfigs {
            var deploymentApplicationConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deploymentApplicationConfigs)
            for deploymentapplicationconfig0 in deploymentApplicationConfigs {
                try deploymentApplicationConfigsContainer.encode(deploymentapplicationconfig0)
            }
        }
        if let deploymentConfig = self.deploymentConfig {
            try encodeContainer.encode(deploymentConfig, forKey: .deploymentConfig)
        }
        if let fleet = self.fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDeploymentJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createDeploymentJob"
    }
}

@available(*, deprecated, message: "AWS RoboMaker is unable to process this request as the support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct CreateDeploymentJobInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The deployment application configuration.
    /// This member is required.
    public var deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
    /// The requested deployment configuration.
    public var deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
    /// The Amazon Resource Name (ARN) of the fleet to deploy.
    /// This member is required.
    public var fleet: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the deployment job.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientRequestToken: Swift.String? = nil,
        deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]? = nil,
        deploymentConfig: RoboMakerClientTypes.DeploymentConfig? = nil,
        fleet: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.deploymentApplicationConfigs = deploymentApplicationConfigs
        self.deploymentConfig = deploymentConfig
        self.fleet = fleet
        self.tags = tags
    }
}

struct CreateDeploymentJobInputBody: Swift.Equatable {
    let deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
    let clientRequestToken: Swift.String?
    let fleet: Swift.String?
    let deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateDeploymentJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case deploymentApplicationConfigs
        case deploymentConfig
        case fleet
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentConfig.self, forKey: .deploymentConfig)
        deploymentConfig = deploymentConfigDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let deploymentApplicationConfigsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DeploymentApplicationConfig?].self, forKey: .deploymentApplicationConfigs)
        var deploymentApplicationConfigsDecoded0:[RoboMakerClientTypes.DeploymentApplicationConfig]? = nil
        if let deploymentApplicationConfigsContainer = deploymentApplicationConfigsContainer {
            deploymentApplicationConfigsDecoded0 = [RoboMakerClientTypes.DeploymentApplicationConfig]()
            for structure0 in deploymentApplicationConfigsContainer {
                if let structure0 = structure0 {
                    deploymentApplicationConfigsDecoded0?.append(structure0)
                }
            }
        }
        deploymentApplicationConfigs = deploymentApplicationConfigsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDeploymentJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeploymentJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentDeploymentException" : self = .concurrentDeploymentException(try ConcurrentDeploymentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDeploymentJobOutputError: Swift.Error, Swift.Equatable {
    case concurrentDeploymentException(ConcurrentDeploymentException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeploymentJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDeploymentJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.deploymentApplicationConfigs = output.deploymentApplicationConfigs
            self.deploymentConfig = output.deploymentConfig
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.fleet = output.fleet
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.createdAt = nil
            self.deploymentApplicationConfigs = nil
            self.deploymentConfig = nil
            self.failureCode = nil
            self.failureReason = nil
            self.fleet = nil
            self.status = nil
            self.tags = nil
        }
    }
}

@available(*, deprecated, message: "AWS RoboMaker is unable to process this request as the support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct CreateDeploymentJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deployment job.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the fleet was created.
    public var createdAt: ClientRuntime.Date?
    /// The deployment application configuration.
    public var deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
    /// The deployment configuration.
    public var deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
    /// The failure code of the simulation job if it failed: BadPermissionError AWS Greengrass requires a service-level role permission to access other services. The role must include the [AWSGreengrassResourceAccessRolePolicy] managed policy(https://console.aws.amazon.com/iam/home?#/policies/arn:aws:iam::aws:policy/service-role/AWSGreengrassResourceAccessRolePolicy$jsonEditor). ExtractingBundleFailure The robot application could not be extracted from the bundle. FailureThresholdBreached The percentage of robots that could not be updated exceeded the percentage set for the deployment. GreengrassDeploymentFailed The robot application could not be deployed to the robot. GreengrassGroupVersionDoesNotExist The AWS Greengrass group or version associated with a robot is missing. InternalServerError An internal error has occurred. Retry your request, but if the problem persists, contact us with details. MissingRobotApplicationArchitecture The robot application does not have a source that matches the architecture of the robot. MissingRobotDeploymentResource One or more of the resources specified for the robot application are missing. For example, does the robot application have the correct launch package and launch file? PostLaunchFileFailure The post-launch script failed. PreLaunchFileFailure The pre-launch script failed. ResourceNotFound One or more deployment resources are missing. For example, do robot application source bundles still exist? RobotDeploymentNoResponse There is no response from the robot. It might not be powered on or connected to the internet.
    public var failureCode: RoboMakerClientTypes.DeploymentJobErrorCode?
    /// The failure reason of the deployment job if it failed.
    public var failureReason: Swift.String?
    /// The target fleet for the deployment job.
    public var fleet: Swift.String?
    /// The status of the deployment job.
    public var status: RoboMakerClientTypes.DeploymentStatus?
    /// The list of all tags added to the deployment job.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]? = nil,
        deploymentConfig: RoboMakerClientTypes.DeploymentConfig? = nil,
        failureCode: RoboMakerClientTypes.DeploymentJobErrorCode? = nil,
        failureReason: Swift.String? = nil,
        fleet: Swift.String? = nil,
        status: RoboMakerClientTypes.DeploymentStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.deploymentApplicationConfigs = deploymentApplicationConfigs
        self.deploymentConfig = deploymentConfig
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.fleet = fleet
        self.status = status
        self.tags = tags
    }
}

struct CreateDeploymentJobOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let fleet: Swift.String?
    let status: RoboMakerClientTypes.DeploymentStatus?
    let deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
    let failureReason: Swift.String?
    let failureCode: RoboMakerClientTypes.DeploymentJobErrorCode?
    let createdAt: ClientRuntime.Date?
    let deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
    let tags: [Swift.String:Swift.String]?
}

extension CreateDeploymentJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case deploymentApplicationConfigs
        case deploymentConfig
        case failureCode
        case failureReason
        case fleet
        case status
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentStatus.self, forKey: .status)
        status = statusDecoded
        let deploymentApplicationConfigsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DeploymentApplicationConfig?].self, forKey: .deploymentApplicationConfigs)
        var deploymentApplicationConfigsDecoded0:[RoboMakerClientTypes.DeploymentApplicationConfig]? = nil
        if let deploymentApplicationConfigsContainer = deploymentApplicationConfigsContainer {
            deploymentApplicationConfigsDecoded0 = [RoboMakerClientTypes.DeploymentApplicationConfig]()
            for structure0 in deploymentApplicationConfigsContainer {
                if let structure0 = structure0 {
                    deploymentApplicationConfigsDecoded0?.append(structure0)
                }
            }
        }
        deploymentApplicationConfigs = deploymentApplicationConfigsDecoded0
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let deploymentConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentConfig.self, forKey: .deploymentConfig)
        deploymentConfig = deploymentConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createFleet"
    }
}

@available(*, deprecated, message: "AWS RoboMaker is unable to process this request as the support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct CreateFleetInput: Swift.Equatable {
    /// The name of the fleet.
    /// This member is required.
    public var name: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the fleet.
    public var tags: [Swift.String:Swift.String]?

    public init (
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.name = name
        self.tags = tags
    }
}

struct CreateFleetInputBody: Swift.Equatable {
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateFleetOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateFleetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.createdAt = nil
            self.name = nil
            self.tags = nil
        }
    }
}

@available(*, deprecated, message: "AWS RoboMaker is unable to process this request as the support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct CreateFleetOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the fleet was created.
    public var createdAt: ClientRuntime.Date?
    /// The name of the fleet.
    public var name: Swift.String?
    /// The list of all tags added to the fleet.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.name = name
        self.tags = tags
    }
}

struct CreateFleetOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let createdAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension CreateFleetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRobotApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environment
        case name
        case robotSoftwareSuite
        case sources
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environment = self.environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let robotSoftwareSuite = self.robotSoftwareSuite {
            try encodeContainer.encode(robotSoftwareSuite, forKey: .robotSoftwareSuite)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for sourceconfig0 in sources {
                try sourcesContainer.encode(sourceconfig0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateRobotApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createRobotApplication"
    }
}

public struct CreateRobotApplicationInput: Swift.Equatable {
    /// The object that contains that URI of the Docker image that you use for your robot application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The name of the robot application.
    /// This member is required.
    public var name: Swift.String?
    /// The robot software suite (ROS distribuition) used by the robot application.
    /// This member is required.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The sources of the robot application.
    public var sources: [RoboMakerClientTypes.SourceConfig]?
    /// A map that contains tag keys and tag values that are attached to the robot application.
    public var tags: [Swift.String:Swift.String]?

    public init (
        environment: RoboMakerClientTypes.Environment? = nil,
        name: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.SourceConfig]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.environment = environment
        self.name = name
        self.robotSoftwareSuite = robotSoftwareSuite
        self.sources = sources
        self.tags = tags
    }
}

struct CreateRobotApplicationInputBody: Swift.Equatable {
    let name: Swift.String?
    let sources: [RoboMakerClientTypes.SourceConfig]?
    let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    let tags: [Swift.String:Swift.String]?
    let environment: RoboMakerClientTypes.Environment?
}

extension CreateRobotApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environment
        case name
        case robotSoftwareSuite
        case sources
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SourceConfig?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.SourceConfig]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.SourceConfig]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

extension CreateRobotApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRobotApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateRobotApplicationOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRobotApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateRobotApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.environment = output.environment
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.sources = output.sources
            self.tags = output.tags
            self.version = output.version
        } else {
            self.arn = nil
            self.environment = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.sources = nil
            self.tags = nil
            self.version = nil
        }
    }
}

public struct CreateRobotApplicationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the robot application.
    public var arn: Swift.String?
    /// An object that contains the Docker image URI used to a create your robot application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The time, in milliseconds since the epoch, when the robot application was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the robot application.
    public var name: Swift.String?
    /// The revision id of the robot application.
    public var revisionId: Swift.String?
    /// The robot software suite (ROS distribution) used by the robot application.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The sources of the robot application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The list of all tags added to the robot application.
    public var tags: [Swift.String:Swift.String]?
    /// The version of the robot application.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.sources = sources
        self.tags = tags
        self.version = version
    }
}

struct CreateRobotApplicationOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let version: Swift.String?
    let sources: [RoboMakerClientTypes.Source]?
    let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    let lastUpdatedAt: ClientRuntime.Date?
    let revisionId: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let environment: RoboMakerClientTypes.Environment?
}

extension CreateRobotApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case environment
        case lastUpdatedAt
        case name
        case revisionId
        case robotSoftwareSuite
        case sources
        case tags
        case version
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Source?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

extension CreateRobotApplicationVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case currentRevisionId
        case imageDigest
        case s3Etags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = self.application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let currentRevisionId = self.currentRevisionId {
            try encodeContainer.encode(currentRevisionId, forKey: .currentRevisionId)
        }
        if let imageDigest = self.imageDigest {
            try encodeContainer.encode(imageDigest, forKey: .imageDigest)
        }
        if let s3Etags = s3Etags {
            var s3EtagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3Etags)
            for s3etag0 in s3Etags {
                try s3EtagsContainer.encode(s3etag0)
            }
        }
    }
}

extension CreateRobotApplicationVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createRobotApplicationVersion"
    }
}

public struct CreateRobotApplicationVersionInput: Swift.Equatable {
    /// The application information for the robot application.
    /// This member is required.
    public var application: Swift.String?
    /// The current revision id for the robot application. If you provide a value and it matches the latest revision ID, a new version will be created.
    public var currentRevisionId: Swift.String?
    /// A SHA256 identifier for the Docker image that you use for your robot application.
    public var imageDigest: Swift.String?
    /// The Amazon S3 identifier for the zip file bundle that you use for your robot application.
    public var s3Etags: [Swift.String]?

    public init (
        application: Swift.String? = nil,
        currentRevisionId: Swift.String? = nil,
        imageDigest: Swift.String? = nil,
        s3Etags: [Swift.String]? = nil
    )
    {
        self.application = application
        self.currentRevisionId = currentRevisionId
        self.imageDigest = imageDigest
        self.s3Etags = s3Etags
    }
}

struct CreateRobotApplicationVersionInputBody: Swift.Equatable {
    let application: Swift.String?
    let currentRevisionId: Swift.String?
    let s3Etags: [Swift.String]?
    let imageDigest: Swift.String?
}

extension CreateRobotApplicationVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case currentRevisionId
        case imageDigest
        case s3Etags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let currentRevisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentRevisionId)
        currentRevisionId = currentRevisionIdDecoded
        let s3EtagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .s3Etags)
        var s3EtagsDecoded0:[Swift.String]? = nil
        if let s3EtagsContainer = s3EtagsContainer {
            s3EtagsDecoded0 = [Swift.String]()
            for string0 in s3EtagsContainer {
                if let string0 = string0 {
                    s3EtagsDecoded0?.append(string0)
                }
            }
        }
        s3Etags = s3EtagsDecoded0
        let imageDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
    }
}

extension CreateRobotApplicationVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRobotApplicationVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateRobotApplicationVersionOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRobotApplicationVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateRobotApplicationVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.environment = output.environment
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.sources = output.sources
            self.version = output.version
        } else {
            self.arn = nil
            self.environment = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.sources = nil
            self.version = nil
        }
    }
}

public struct CreateRobotApplicationVersionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the robot application.
    public var arn: Swift.String?
    /// The object that contains the Docker image URI used to create your robot application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The time, in milliseconds since the epoch, when the robot application was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the robot application.
    public var name: Swift.String?
    /// The revision id of the robot application.
    public var revisionId: Swift.String?
    /// The robot software suite (ROS distribution) used by the robot application.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The sources of the robot application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The version of the robot application.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.sources = sources
        self.version = version
    }
}

struct CreateRobotApplicationVersionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let version: Swift.String?
    let sources: [RoboMakerClientTypes.Source]?
    let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    let lastUpdatedAt: ClientRuntime.Date?
    let revisionId: Swift.String?
    let environment: RoboMakerClientTypes.Environment?
}

extension CreateRobotApplicationVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case environment
        case lastUpdatedAt
        case name
        case revisionId
        case robotSoftwareSuite
        case sources
        case version
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Source?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

extension CreateRobotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case greengrassGroupId
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architecture = self.architecture {
            try encodeContainer.encode(architecture.rawValue, forKey: .architecture)
        }
        if let greengrassGroupId = self.greengrassGroupId {
            try encodeContainer.encode(greengrassGroupId, forKey: .greengrassGroupId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateRobotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createRobot"
    }
}

@available(*, deprecated, message: "AWS RoboMaker is unable to process this request as the support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct CreateRobotInput: Swift.Equatable {
    /// The target architecture of the robot.
    /// This member is required.
    public var architecture: RoboMakerClientTypes.Architecture?
    /// The Greengrass group id.
    /// This member is required.
    public var greengrassGroupId: Swift.String?
    /// The name for the robot.
    /// This member is required.
    public var name: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the robot.
    public var tags: [Swift.String:Swift.String]?

    public init (
        architecture: RoboMakerClientTypes.Architecture? = nil,
        greengrassGroupId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.architecture = architecture
        self.greengrassGroupId = greengrassGroupId
        self.name = name
        self.tags = tags
    }
}

struct CreateRobotInputBody: Swift.Equatable {
    let name: Swift.String?
    let architecture: RoboMakerClientTypes.Architecture?
    let greengrassGroupId: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateRobotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case greengrassGroupId
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
        let greengrassGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .greengrassGroupId)
        greengrassGroupId = greengrassGroupIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRobotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRobotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateRobotOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRobotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateRobotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.architecture = output.architecture
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.greengrassGroupId = output.greengrassGroupId
            self.name = output.name
            self.tags = output.tags
        } else {
            self.architecture = nil
            self.arn = nil
            self.createdAt = nil
            self.greengrassGroupId = nil
            self.name = nil
            self.tags = nil
        }
    }
}

@available(*, deprecated, message: "AWS RoboMaker is unable to process this request as the support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct CreateRobotOutputResponse: Swift.Equatable {
    /// The target architecture of the robot.
    public var architecture: RoboMakerClientTypes.Architecture?
    /// The Amazon Resource Name (ARN) of the robot.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the robot was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the Greengrass group associated with the robot.
    public var greengrassGroupId: Swift.String?
    /// The name of the robot.
    public var name: Swift.String?
    /// The list of all tags added to the robot.
    public var tags: [Swift.String:Swift.String]?

    public init (
        architecture: RoboMakerClientTypes.Architecture? = nil,
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        greengrassGroupId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.architecture = architecture
        self.arn = arn
        self.createdAt = createdAt
        self.greengrassGroupId = greengrassGroupId
        self.name = name
        self.tags = tags
    }
}

struct CreateRobotOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let createdAt: ClientRuntime.Date?
    let greengrassGroupId: Swift.String?
    let architecture: RoboMakerClientTypes.Architecture?
    let tags: [Swift.String:Swift.String]?
}

extension CreateRobotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case arn
        case createdAt
        case greengrassGroupId
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let greengrassGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .greengrassGroupId)
        greengrassGroupId = greengrassGroupIdDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSimulationApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environment
        case name
        case renderingEngine
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environment = self.environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let renderingEngine = self.renderingEngine {
            try encodeContainer.encode(renderingEngine, forKey: .renderingEngine)
        }
        if let robotSoftwareSuite = self.robotSoftwareSuite {
            try encodeContainer.encode(robotSoftwareSuite, forKey: .robotSoftwareSuite)
        }
        if let simulationSoftwareSuite = self.simulationSoftwareSuite {
            try encodeContainer.encode(simulationSoftwareSuite, forKey: .simulationSoftwareSuite)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for sourceconfig0 in sources {
                try sourcesContainer.encode(sourceconfig0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateSimulationApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createSimulationApplication"
    }
}

public struct CreateSimulationApplicationInput: Swift.Equatable {
    /// The object that contains the Docker image URI used to create your simulation application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The name of the simulation application.
    /// This member is required.
    public var name: Swift.String?
    /// The rendering engine for the simulation application.
    public var renderingEngine: RoboMakerClientTypes.RenderingEngine?
    /// The robot software suite (ROS distribution) used by the simulation application.
    /// This member is required.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The simulation software suite used by the simulation application.
    /// This member is required.
    public var simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    /// The sources of the simulation application.
    public var sources: [RoboMakerClientTypes.SourceConfig]?
    /// A map that contains tag keys and tag values that are attached to the simulation application.
    public var tags: [Swift.String:Swift.String]?

    public init (
        environment: RoboMakerClientTypes.Environment? = nil,
        name: Swift.String? = nil,
        renderingEngine: RoboMakerClientTypes.RenderingEngine? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.SourceConfig]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.environment = environment
        self.name = name
        self.renderingEngine = renderingEngine
        self.robotSoftwareSuite = robotSoftwareSuite
        self.simulationSoftwareSuite = simulationSoftwareSuite
        self.sources = sources
        self.tags = tags
    }
}

struct CreateSimulationApplicationInputBody: Swift.Equatable {
    let name: Swift.String?
    let sources: [RoboMakerClientTypes.SourceConfig]?
    let simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    let renderingEngine: RoboMakerClientTypes.RenderingEngine?
    let tags: [Swift.String:Swift.String]?
    let environment: RoboMakerClientTypes.Environment?
}

extension CreateSimulationApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environment
        case name
        case renderingEngine
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SourceConfig?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.SourceConfig]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.SourceConfig]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let simulationSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationSoftwareSuite.self, forKey: .simulationSoftwareSuite)
        simulationSoftwareSuite = simulationSoftwareSuiteDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let renderingEngineDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RenderingEngine.self, forKey: .renderingEngine)
        renderingEngine = renderingEngineDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

extension CreateSimulationApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSimulationApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSimulationApplicationOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSimulationApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSimulationApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.environment = output.environment
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.renderingEngine = output.renderingEngine
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.simulationSoftwareSuite = output.simulationSoftwareSuite
            self.sources = output.sources
            self.tags = output.tags
            self.version = output.version
        } else {
            self.arn = nil
            self.environment = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.renderingEngine = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.simulationSoftwareSuite = nil
            self.sources = nil
            self.tags = nil
            self.version = nil
        }
    }
}

public struct CreateSimulationApplicationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the simulation application.
    public var arn: Swift.String?
    /// The object that contains the Docker image URI that you used to create your simulation application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The time, in milliseconds since the epoch, when the simulation application was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the simulation application.
    public var name: Swift.String?
    /// The rendering engine for the simulation application.
    public var renderingEngine: RoboMakerClientTypes.RenderingEngine?
    /// The revision id of the simulation application.
    public var revisionId: Swift.String?
    /// Information about the robot software suite (ROS distribution).
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The simulation software suite used by the simulation application.
    public var simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    /// The sources of the simulation application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The list of all tags added to the simulation application.
    public var tags: [Swift.String:Swift.String]?
    /// The version of the simulation application.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        renderingEngine: RoboMakerClientTypes.RenderingEngine? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.renderingEngine = renderingEngine
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.simulationSoftwareSuite = simulationSoftwareSuite
        self.sources = sources
        self.tags = tags
        self.version = version
    }
}

struct CreateSimulationApplicationOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let version: Swift.String?
    let sources: [RoboMakerClientTypes.Source]?
    let simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    let renderingEngine: RoboMakerClientTypes.RenderingEngine?
    let lastUpdatedAt: ClientRuntime.Date?
    let revisionId: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let environment: RoboMakerClientTypes.Environment?
}

extension CreateSimulationApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case environment
        case lastUpdatedAt
        case name
        case renderingEngine
        case revisionId
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
        case tags
        case version
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Source?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let simulationSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationSoftwareSuite.self, forKey: .simulationSoftwareSuite)
        simulationSoftwareSuite = simulationSoftwareSuiteDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let renderingEngineDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RenderingEngine.self, forKey: .renderingEngine)
        renderingEngine = renderingEngineDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

extension CreateSimulationApplicationVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case currentRevisionId
        case imageDigest
        case s3Etags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = self.application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let currentRevisionId = self.currentRevisionId {
            try encodeContainer.encode(currentRevisionId, forKey: .currentRevisionId)
        }
        if let imageDigest = self.imageDigest {
            try encodeContainer.encode(imageDigest, forKey: .imageDigest)
        }
        if let s3Etags = s3Etags {
            var s3EtagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3Etags)
            for s3etag0 in s3Etags {
                try s3EtagsContainer.encode(s3etag0)
            }
        }
    }
}

extension CreateSimulationApplicationVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createSimulationApplicationVersion"
    }
}

public struct CreateSimulationApplicationVersionInput: Swift.Equatable {
    /// The application information for the simulation application.
    /// This member is required.
    public var application: Swift.String?
    /// The current revision id for the simulation application. If you provide a value and it matches the latest revision ID, a new version will be created.
    public var currentRevisionId: Swift.String?
    /// The SHA256 digest used to identify the Docker image URI used to created the simulation application.
    public var imageDigest: Swift.String?
    /// The Amazon S3 eTag identifier for the zip file bundle that you use to create the simulation application.
    public var s3Etags: [Swift.String]?

    public init (
        application: Swift.String? = nil,
        currentRevisionId: Swift.String? = nil,
        imageDigest: Swift.String? = nil,
        s3Etags: [Swift.String]? = nil
    )
    {
        self.application = application
        self.currentRevisionId = currentRevisionId
        self.imageDigest = imageDigest
        self.s3Etags = s3Etags
    }
}

struct CreateSimulationApplicationVersionInputBody: Swift.Equatable {
    let application: Swift.String?
    let currentRevisionId: Swift.String?
    let s3Etags: [Swift.String]?
    let imageDigest: Swift.String?
}

extension CreateSimulationApplicationVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case currentRevisionId
        case imageDigest
        case s3Etags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let currentRevisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentRevisionId)
        currentRevisionId = currentRevisionIdDecoded
        let s3EtagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .s3Etags)
        var s3EtagsDecoded0:[Swift.String]? = nil
        if let s3EtagsContainer = s3EtagsContainer {
            s3EtagsDecoded0 = [Swift.String]()
            for string0 in s3EtagsContainer {
                if let string0 = string0 {
                    s3EtagsDecoded0?.append(string0)
                }
            }
        }
        s3Etags = s3EtagsDecoded0
        let imageDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
    }
}

extension CreateSimulationApplicationVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSimulationApplicationVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSimulationApplicationVersionOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSimulationApplicationVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSimulationApplicationVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.environment = output.environment
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.renderingEngine = output.renderingEngine
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.simulationSoftwareSuite = output.simulationSoftwareSuite
            self.sources = output.sources
            self.version = output.version
        } else {
            self.arn = nil
            self.environment = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.renderingEngine = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.simulationSoftwareSuite = nil
            self.sources = nil
            self.version = nil
        }
    }
}

public struct CreateSimulationApplicationVersionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the simulation application.
    public var arn: Swift.String?
    /// The object that contains the Docker image URI used to create the simulation application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The time, in milliseconds since the epoch, when the simulation application was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the simulation application.
    public var name: Swift.String?
    /// The rendering engine for the simulation application.
    public var renderingEngine: RoboMakerClientTypes.RenderingEngine?
    /// The revision ID of the simulation application.
    public var revisionId: Swift.String?
    /// Information about the robot software suite (ROS distribution).
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The simulation software suite used by the simulation application.
    public var simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    /// The sources of the simulation application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The version of the simulation application.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        renderingEngine: RoboMakerClientTypes.RenderingEngine? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.renderingEngine = renderingEngine
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.simulationSoftwareSuite = simulationSoftwareSuite
        self.sources = sources
        self.version = version
    }
}

struct CreateSimulationApplicationVersionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let version: Swift.String?
    let sources: [RoboMakerClientTypes.Source]?
    let simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    let renderingEngine: RoboMakerClientTypes.RenderingEngine?
    let lastUpdatedAt: ClientRuntime.Date?
    let revisionId: Swift.String?
    let environment: RoboMakerClientTypes.Environment?
}

extension CreateSimulationApplicationVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case environment
        case lastUpdatedAt
        case name
        case renderingEngine
        case revisionId
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
        case version
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Source?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let simulationSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationSoftwareSuite.self, forKey: .simulationSoftwareSuite)
        simulationSoftwareSuite = simulationSoftwareSuiteDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let renderingEngineDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RenderingEngine.self, forKey: .renderingEngine)
        renderingEngine = renderingEngineDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

extension CreateSimulationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case compute
        case dataSources
        case failureBehavior
        case iamRole
        case loggingConfig
        case maxJobDurationInSeconds
        case outputLocation
        case robotApplications
        case simulationApplications
        case tags
        case vpcConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let compute = self.compute {
            try encodeContainer.encode(compute, forKey: .compute)
        }
        if let dataSources = dataSources {
            var dataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSources)
            for datasourceconfig0 in dataSources {
                try dataSourcesContainer.encode(datasourceconfig0)
            }
        }
        if let failureBehavior = self.failureBehavior {
            try encodeContainer.encode(failureBehavior.rawValue, forKey: .failureBehavior)
        }
        if let iamRole = self.iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if let loggingConfig = self.loggingConfig {
            try encodeContainer.encode(loggingConfig, forKey: .loggingConfig)
        }
        if maxJobDurationInSeconds != 0 {
            try encodeContainer.encode(maxJobDurationInSeconds, forKey: .maxJobDurationInSeconds)
        }
        if let outputLocation = self.outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let robotApplications = robotApplications {
            var robotApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .robotApplications)
            for robotapplicationconfig0 in robotApplications {
                try robotApplicationsContainer.encode(robotapplicationconfig0)
            }
        }
        if let simulationApplications = simulationApplications {
            var simulationApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .simulationApplications)
            for simulationapplicationconfig0 in simulationApplications {
                try simulationApplicationsContainer.encode(simulationapplicationconfig0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

extension CreateSimulationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createSimulationJob"
    }
}

public struct CreateSimulationJobInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// Compute information for the simulation job.
    public var compute: RoboMakerClientTypes.Compute?
    /// Specify data sources to mount read-only files from S3 into your simulation. These files are available under /opt/robomaker/datasources/data_source_name. There is a limit of 100 files and a combined size of 25GB for all DataSourceConfig objects.
    public var dataSources: [RoboMakerClientTypes.DataSourceConfig]?
    /// The failure behavior the simulation job. Continue Leaves the instance running for its maximum timeout duration after a 4XX error code. Fail Stop the simulation job and terminate the instance.
    public var failureBehavior: RoboMakerClientTypes.FailureBehavior?
    /// The IAM role name that allows the simulation instance to call the AWS APIs that are specified in its associated policies on your behalf. This is how credentials are passed in to your simulation job.
    /// This member is required.
    public var iamRole: Swift.String?
    /// The logging configuration.
    public var loggingConfig: RoboMakerClientTypes.LoggingConfig?
    /// The maximum simulation job duration in seconds (up to 14 days or 1,209,600 seconds. When maxJobDurationInSeconds is reached, the simulation job will status will transition to Completed.
    /// This member is required.
    public var maxJobDurationInSeconds: Swift.Int
    /// Location for output files generated by the simulation job.
    public var outputLocation: RoboMakerClientTypes.OutputLocation?
    /// The robot application to use in the simulation job.
    public var robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]?
    /// The simulation application to use in the simulation job.
    public var simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]?
    /// A map that contains tag keys and tag values that are attached to the simulation job.
    public var tags: [Swift.String:Swift.String]?
    /// If your simulation job accesses resources in a VPC, you provide this parameter identifying the list of security group IDs and subnet IDs. These must belong to the same VPC. You must provide at least one security group and one subnet ID.
    public var vpcConfig: RoboMakerClientTypes.VPCConfig?

    public init (
        clientRequestToken: Swift.String? = nil,
        compute: RoboMakerClientTypes.Compute? = nil,
        dataSources: [RoboMakerClientTypes.DataSourceConfig]? = nil,
        failureBehavior: RoboMakerClientTypes.FailureBehavior? = nil,
        iamRole: Swift.String? = nil,
        loggingConfig: RoboMakerClientTypes.LoggingConfig? = nil,
        maxJobDurationInSeconds: Swift.Int = 0,
        outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
        robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]? = nil,
        simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcConfig: RoboMakerClientTypes.VPCConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.compute = compute
        self.dataSources = dataSources
        self.failureBehavior = failureBehavior
        self.iamRole = iamRole
        self.loggingConfig = loggingConfig
        self.maxJobDurationInSeconds = maxJobDurationInSeconds
        self.outputLocation = outputLocation
        self.robotApplications = robotApplications
        self.simulationApplications = simulationApplications
        self.tags = tags
        self.vpcConfig = vpcConfig
    }
}

struct CreateSimulationJobInputBody: Swift.Equatable {
    let clientRequestToken: Swift.String?
    let outputLocation: RoboMakerClientTypes.OutputLocation?
    let loggingConfig: RoboMakerClientTypes.LoggingConfig?
    let maxJobDurationInSeconds: Swift.Int
    let iamRole: Swift.String?
    let failureBehavior: RoboMakerClientTypes.FailureBehavior?
    let robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]?
    let simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]?
    let dataSources: [RoboMakerClientTypes.DataSourceConfig]?
    let tags: [Swift.String:Swift.String]?
    let vpcConfig: RoboMakerClientTypes.VPCConfig?
    let compute: RoboMakerClientTypes.Compute?
}

extension CreateSimulationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case compute
        case dataSources
        case failureBehavior
        case iamRole
        case loggingConfig
        case maxJobDurationInSeconds
        case outputLocation
        case robotApplications
        case simulationApplications
        case tags
        case vpcConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let loggingConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.LoggingConfig.self, forKey: .loggingConfig)
        loggingConfig = loggingConfigDecoded
        let maxJobDurationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxJobDurationInSeconds) ?? 0
        maxJobDurationInSeconds = maxJobDurationInSecondsDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let failureBehaviorDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.FailureBehavior.self, forKey: .failureBehavior)
        failureBehavior = failureBehaviorDecoded
        let robotApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.RobotApplicationConfig?].self, forKey: .robotApplications)
        var robotApplicationsDecoded0:[RoboMakerClientTypes.RobotApplicationConfig]? = nil
        if let robotApplicationsContainer = robotApplicationsContainer {
            robotApplicationsDecoded0 = [RoboMakerClientTypes.RobotApplicationConfig]()
            for structure0 in robotApplicationsContainer {
                if let structure0 = structure0 {
                    robotApplicationsDecoded0?.append(structure0)
                }
            }
        }
        robotApplications = robotApplicationsDecoded0
        let simulationApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationApplicationConfig?].self, forKey: .simulationApplications)
        var simulationApplicationsDecoded0:[RoboMakerClientTypes.SimulationApplicationConfig]? = nil
        if let simulationApplicationsContainer = simulationApplicationsContainer {
            simulationApplicationsDecoded0 = [RoboMakerClientTypes.SimulationApplicationConfig]()
            for structure0 in simulationApplicationsContainer {
                if let structure0 = structure0 {
                    simulationApplicationsDecoded0?.append(structure0)
                }
            }
        }
        simulationApplications = simulationApplicationsDecoded0
        let dataSourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DataSourceConfig?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[RoboMakerClientTypes.DataSourceConfig]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [RoboMakerClientTypes.DataSourceConfig]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let vpcConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.VPCConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let computeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Compute.self, forKey: .compute)
        compute = computeDecoded
    }
}

extension CreateSimulationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSimulationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSimulationJobOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSimulationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSimulationJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.compute = output.compute
            self.dataSources = output.dataSources
            self.failureBehavior = output.failureBehavior
            self.failureCode = output.failureCode
            self.iamRole = output.iamRole
            self.lastStartedAt = output.lastStartedAt
            self.lastUpdatedAt = output.lastUpdatedAt
            self.loggingConfig = output.loggingConfig
            self.maxJobDurationInSeconds = output.maxJobDurationInSeconds
            self.outputLocation = output.outputLocation
            self.robotApplications = output.robotApplications
            self.simulationApplications = output.simulationApplications
            self.simulationTimeMillis = output.simulationTimeMillis
            self.status = output.status
            self.tags = output.tags
            self.vpcConfig = output.vpcConfig
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.compute = nil
            self.dataSources = nil
            self.failureBehavior = nil
            self.failureCode = nil
            self.iamRole = nil
            self.lastStartedAt = nil
            self.lastUpdatedAt = nil
            self.loggingConfig = nil
            self.maxJobDurationInSeconds = 0
            self.outputLocation = nil
            self.robotApplications = nil
            self.simulationApplications = nil
            self.simulationTimeMillis = 0
            self.status = nil
            self.tags = nil
            self.vpcConfig = nil
        }
    }
}

public struct CreateSimulationJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the simulation job.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// Compute information for the simulation job.
    public var compute: RoboMakerClientTypes.ComputeResponse?
    /// The data sources for the simulation job.
    public var dataSources: [RoboMakerClientTypes.DataSource]?
    /// the failure behavior for the simulation job.
    public var failureBehavior: RoboMakerClientTypes.FailureBehavior?
    /// The failure code of the simulation job if it failed: InternalServiceError Internal service error. RobotApplicationCrash Robot application exited abnormally. SimulationApplicationCrash Simulation application exited abnormally. BadPermissionsRobotApplication Robot application bundle could not be downloaded. BadPermissionsSimulationApplication Simulation application bundle could not be downloaded. BadPermissionsS3Output Unable to publish outputs to customer-provided S3 bucket. BadPermissionsCloudwatchLogs Unable to publish logs to customer-provided CloudWatch Logs resource. SubnetIpLimitExceeded Subnet IP limit exceeded. ENILimitExceeded ENI limit exceeded. BadPermissionsUserCredentials Unable to use the Role provided. InvalidBundleRobotApplication Robot bundle cannot be extracted (invalid format, bundling error, or other issue). InvalidBundleSimulationApplication Simulation bundle cannot be extracted (invalid format, bundling error, or other issue). RobotApplicationVersionMismatchedEtag Etag for RobotApplication does not match value during version creation. SimulationApplicationVersionMismatchedEtag Etag for SimulationApplication does not match value during version creation.
    public var failureCode: RoboMakerClientTypes.SimulationJobErrorCode?
    /// The IAM role that allows the simulation job to call the AWS APIs that are specified in its associated policies on your behalf.
    public var iamRole: Swift.String?
    /// The time, in milliseconds since the epoch, when the simulation job was last started.
    public var lastStartedAt: ClientRuntime.Date?
    /// The time, in milliseconds since the epoch, when the simulation job was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The logging configuration.
    public var loggingConfig: RoboMakerClientTypes.LoggingConfig?
    /// The maximum simulation job duration in seconds.
    public var maxJobDurationInSeconds: Swift.Int
    /// Simulation job output files location.
    public var outputLocation: RoboMakerClientTypes.OutputLocation?
    /// The robot application used by the simulation job.
    public var robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]?
    /// The simulation application used by the simulation job.
    public var simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]?
    /// The simulation job execution duration in milliseconds.
    public var simulationTimeMillis: Swift.Int
    /// The status of the simulation job.
    public var status: RoboMakerClientTypes.SimulationJobStatus?
    /// The list of all tags added to the simulation job.
    public var tags: [Swift.String:Swift.String]?
    /// Information about the vpc configuration.
    public var vpcConfig: RoboMakerClientTypes.VPCConfigResponse?

    public init (
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        compute: RoboMakerClientTypes.ComputeResponse? = nil,
        dataSources: [RoboMakerClientTypes.DataSource]? = nil,
        failureBehavior: RoboMakerClientTypes.FailureBehavior? = nil,
        failureCode: RoboMakerClientTypes.SimulationJobErrorCode? = nil,
        iamRole: Swift.String? = nil,
        lastStartedAt: ClientRuntime.Date? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        loggingConfig: RoboMakerClientTypes.LoggingConfig? = nil,
        maxJobDurationInSeconds: Swift.Int = 0,
        outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
        robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]? = nil,
        simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]? = nil,
        simulationTimeMillis: Swift.Int = 0,
        status: RoboMakerClientTypes.SimulationJobStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcConfig: RoboMakerClientTypes.VPCConfigResponse? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.compute = compute
        self.dataSources = dataSources
        self.failureBehavior = failureBehavior
        self.failureCode = failureCode
        self.iamRole = iamRole
        self.lastStartedAt = lastStartedAt
        self.lastUpdatedAt = lastUpdatedAt
        self.loggingConfig = loggingConfig
        self.maxJobDurationInSeconds = maxJobDurationInSeconds
        self.outputLocation = outputLocation
        self.robotApplications = robotApplications
        self.simulationApplications = simulationApplications
        self.simulationTimeMillis = simulationTimeMillis
        self.status = status
        self.tags = tags
        self.vpcConfig = vpcConfig
    }
}

struct CreateSimulationJobOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let status: RoboMakerClientTypes.SimulationJobStatus?
    let lastStartedAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let failureBehavior: RoboMakerClientTypes.FailureBehavior?
    let failureCode: RoboMakerClientTypes.SimulationJobErrorCode?
    let clientRequestToken: Swift.String?
    let outputLocation: RoboMakerClientTypes.OutputLocation?
    let loggingConfig: RoboMakerClientTypes.LoggingConfig?
    let maxJobDurationInSeconds: Swift.Int
    let simulationTimeMillis: Swift.Int
    let iamRole: Swift.String?
    let robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]?
    let simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]?
    let dataSources: [RoboMakerClientTypes.DataSource]?
    let tags: [Swift.String:Swift.String]?
    let vpcConfig: RoboMakerClientTypes.VPCConfigResponse?
    let compute: RoboMakerClientTypes.ComputeResponse?
}

extension CreateSimulationJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case compute
        case dataSources
        case failureBehavior
        case failureCode
        case iamRole
        case lastStartedAt
        case lastUpdatedAt
        case loggingConfig
        case maxJobDurationInSeconds
        case outputLocation
        case robotApplications
        case simulationApplications
        case simulationTimeMillis
        case status
        case tags
        case vpcConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobStatus.self, forKey: .status)
        status = statusDecoded
        let lastStartedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastStartedAt)
        lastStartedAt = lastStartedAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let failureBehaviorDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.FailureBehavior.self, forKey: .failureBehavior)
        failureBehavior = failureBehaviorDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let loggingConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.LoggingConfig.self, forKey: .loggingConfig)
        loggingConfig = loggingConfigDecoded
        let maxJobDurationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxJobDurationInSeconds) ?? 0
        maxJobDurationInSeconds = maxJobDurationInSecondsDecoded
        let simulationTimeMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .simulationTimeMillis) ?? 0
        simulationTimeMillis = simulationTimeMillisDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let robotApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.RobotApplicationConfig?].self, forKey: .robotApplications)
        var robotApplicationsDecoded0:[RoboMakerClientTypes.RobotApplicationConfig]? = nil
        if let robotApplicationsContainer = robotApplicationsContainer {
            robotApplicationsDecoded0 = [RoboMakerClientTypes.RobotApplicationConfig]()
            for structure0 in robotApplicationsContainer {
                if let structure0 = structure0 {
                    robotApplicationsDecoded0?.append(structure0)
                }
            }
        }
        robotApplications = robotApplicationsDecoded0
        let simulationApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationApplicationConfig?].self, forKey: .simulationApplications)
        var simulationApplicationsDecoded0:[RoboMakerClientTypes.SimulationApplicationConfig]? = nil
        if let simulationApplicationsContainer = simulationApplicationsContainer {
            simulationApplicationsDecoded0 = [RoboMakerClientTypes.SimulationApplicationConfig]()
            for structure0 in simulationApplicationsContainer {
                if let structure0 = structure0 {
                    simulationApplicationsDecoded0?.append(structure0)
                }
            }
        }
        simulationApplications = simulationApplicationsDecoded0
        let dataSourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[RoboMakerClientTypes.DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [RoboMakerClientTypes.DataSource]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let vpcConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.VPCConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let computeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.ComputeResponse.self, forKey: .compute)
        compute = computeDecoded
    }
}

extension CreateWorldExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case iamRole
        case outputLocation
        case tags
        case worlds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let iamRole = self.iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if let outputLocation = self.outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let worlds = worlds {
            var worldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .worlds)
            for arn0 in worlds {
                try worldsContainer.encode(arn0)
            }
        }
    }
}

extension CreateWorldExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createWorldExportJob"
    }
}

public struct CreateWorldExportJobInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// The IAM role that the world export process uses to access the Amazon S3 bucket and put the export.
    /// This member is required.
    public var iamRole: Swift.String?
    /// The output location.
    /// This member is required.
    public var outputLocation: RoboMakerClientTypes.OutputLocation?
    /// A map that contains tag keys and tag values that are attached to the world export job.
    public var tags: [Swift.String:Swift.String]?
    /// A list of Amazon Resource Names (arns) that correspond to worlds to export.
    /// This member is required.
    public var worlds: [Swift.String]?

    public init (
        clientRequestToken: Swift.String? = nil,
        iamRole: Swift.String? = nil,
        outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        worlds: [Swift.String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.iamRole = iamRole
        self.outputLocation = outputLocation
        self.tags = tags
        self.worlds = worlds
    }
}

struct CreateWorldExportJobInputBody: Swift.Equatable {
    let clientRequestToken: Swift.String?
    let worlds: [Swift.String]?
    let outputLocation: RoboMakerClientTypes.OutputLocation?
    let iamRole: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateWorldExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case iamRole
        case outputLocation
        case tags
        case worlds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let worldsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .worlds)
        var worldsDecoded0:[Swift.String]? = nil
        if let worldsContainer = worldsContainer {
            worldsDecoded0 = [Swift.String]()
            for string0 in worldsContainer {
                if let string0 = string0 {
                    worldsDecoded0?.append(string0)
                }
            }
        }
        worlds = worldsDecoded0
        let outputLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorldExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorldExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateWorldExportJobOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorldExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateWorldExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.failureCode = output.failureCode
            self.iamRole = output.iamRole
            self.outputLocation = output.outputLocation
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.failureCode = nil
            self.iamRole = nil
            self.outputLocation = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct CreateWorldExportJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the world export job.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the world export job was created.
    public var createdAt: ClientRuntime.Date?
    /// The failure code of the world export job if it failed: InternalServiceError Internal service error. LimitExceeded The requested resource exceeds the maximum number allowed, or the number of concurrent stream requests exceeds the maximum number allowed. ResourceNotFound The specified resource could not be found. RequestThrottled The request was throttled. InvalidInput An input parameter in the request is not valid. AllWorldGenerationFailed All of the worlds in the world generation job failed. This can happen if your worldCount is greater than 50 or less than 1. For more information about troubleshooting WorldForge, see [Troubleshooting Simulation WorldForge](https://docs.aws.amazon.com/robomaker/latest/dg/troubleshooting-worldforge.html).
    public var failureCode: RoboMakerClientTypes.WorldExportJobErrorCode?
    /// The IAM role that the world export process uses to access the Amazon S3 bucket and put the export.
    public var iamRole: Swift.String?
    /// The output location.
    public var outputLocation: RoboMakerClientTypes.OutputLocation?
    /// The status of the world export job. Pending The world export job request is pending. Running The world export job is running. Completed The world export job completed. Failed The world export job failed. See failureCode for more information. Canceled The world export job was cancelled. Canceling The world export job is being cancelled.
    public var status: RoboMakerClientTypes.WorldExportJobStatus?
    /// A map that contains tag keys and tag values that are attached to the world export job.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        failureCode: RoboMakerClientTypes.WorldExportJobErrorCode? = nil,
        iamRole: Swift.String? = nil,
        outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
        status: RoboMakerClientTypes.WorldExportJobStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.failureCode = failureCode
        self.iamRole = iamRole
        self.outputLocation = outputLocation
        self.status = status
        self.tags = tags
    }
}

struct CreateWorldExportJobOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let status: RoboMakerClientTypes.WorldExportJobStatus?
    let createdAt: ClientRuntime.Date?
    let failureCode: RoboMakerClientTypes.WorldExportJobErrorCode?
    let clientRequestToken: Swift.String?
    let outputLocation: RoboMakerClientTypes.OutputLocation?
    let iamRole: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateWorldExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case createdAt
        case failureCode
        case iamRole
        case outputLocation
        case status
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldExportJobStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldExportJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorldGenerationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case tags
        case template
        case worldCount
        case worldTags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let template = self.template {
            try encodeContainer.encode(template, forKey: .template)
        }
        if let worldCount = self.worldCount {
            try encodeContainer.encode(worldCount, forKey: .worldCount)
        }
        if let worldTags = worldTags {
            var worldTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .worldTags)
            for (dictKey0, tagMap0) in worldTags {
                try worldTagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateWorldGenerationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createWorldGenerationJob"
    }
}

public struct CreateWorldGenerationJobInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the world generator job.
    public var tags: [Swift.String:Swift.String]?
    /// The Amazon Resource Name (arn) of the world template describing the worlds you want to create.
    /// This member is required.
    public var template: Swift.String?
    /// Information about the world count.
    /// This member is required.
    public var worldCount: RoboMakerClientTypes.WorldCount?
    /// A map that contains tag keys and tag values that are attached to the generated worlds.
    public var worldTags: [Swift.String:Swift.String]?

    public init (
        clientRequestToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        template: Swift.String? = nil,
        worldCount: RoboMakerClientTypes.WorldCount? = nil,
        worldTags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.tags = tags
        self.template = template
        self.worldCount = worldCount
        self.worldTags = worldTags
    }
}

struct CreateWorldGenerationJobInputBody: Swift.Equatable {
    let clientRequestToken: Swift.String?
    let template: Swift.String?
    let worldCount: RoboMakerClientTypes.WorldCount?
    let tags: [Swift.String:Swift.String]?
    let worldTags: [Swift.String:Swift.String]?
}

extension CreateWorldGenerationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case tags
        case template
        case worldCount
        case worldTags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
        let worldCountDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldCount.self, forKey: .worldCount)
        worldCount = worldCountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let worldTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .worldTags)
        var worldTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let worldTagsContainer = worldTagsContainer {
            worldTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in worldTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    worldTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        worldTags = worldTagsDecoded0
    }
}

extension CreateWorldGenerationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorldGenerationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateWorldGenerationJobOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorldGenerationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateWorldGenerationJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.failureCode = output.failureCode
            self.status = output.status
            self.tags = output.tags
            self.template = output.template
            self.worldCount = output.worldCount
            self.worldTags = output.worldTags
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.failureCode = nil
            self.status = nil
            self.tags = nil
            self.template = nil
            self.worldCount = nil
            self.worldTags = nil
        }
    }
}

public struct CreateWorldGenerationJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the world generator job.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the world generator job was created.
    public var createdAt: ClientRuntime.Date?
    /// The failure code of the world generator job if it failed: InternalServiceError Internal service error. LimitExceeded The requested resource exceeds the maximum number allowed, or the number of concurrent stream requests exceeds the maximum number allowed. ResourceNotFound The specified resource could not be found. RequestThrottled The request was throttled. InvalidInput An input parameter in the request is not valid.
    public var failureCode: RoboMakerClientTypes.WorldGenerationJobErrorCode?
    /// The status of the world generator job. Pending The world generator job request is pending. Running The world generator job is running. Completed The world generator job completed. Failed The world generator job failed. See failureCode for more information. PartialFailed Some worlds did not generate. Canceled The world generator job was cancelled. Canceling The world generator job is being cancelled.
    public var status: RoboMakerClientTypes.WorldGenerationJobStatus?
    /// A map that contains tag keys and tag values that are attached to the world generator job.
    public var tags: [Swift.String:Swift.String]?
    /// The Amazon Resource Name (arn) of the world template.
    public var template: Swift.String?
    /// Information about the world count.
    public var worldCount: RoboMakerClientTypes.WorldCount?
    /// A map that contains tag keys and tag values that are attached to the generated worlds.
    public var worldTags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        failureCode: RoboMakerClientTypes.WorldGenerationJobErrorCode? = nil,
        status: RoboMakerClientTypes.WorldGenerationJobStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        template: Swift.String? = nil,
        worldCount: RoboMakerClientTypes.WorldCount? = nil,
        worldTags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.failureCode = failureCode
        self.status = status
        self.tags = tags
        self.template = template
        self.worldCount = worldCount
        self.worldTags = worldTags
    }
}

struct CreateWorldGenerationJobOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let status: RoboMakerClientTypes.WorldGenerationJobStatus?
    let createdAt: ClientRuntime.Date?
    let failureCode: RoboMakerClientTypes.WorldGenerationJobErrorCode?
    let clientRequestToken: Swift.String?
    let template: Swift.String?
    let worldCount: RoboMakerClientTypes.WorldCount?
    let tags: [Swift.String:Swift.String]?
    let worldTags: [Swift.String:Swift.String]?
}

extension CreateWorldGenerationJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case createdAt
        case failureCode
        case status
        case tags
        case template
        case worldCount
        case worldTags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldGenerationJobStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldGenerationJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
        let worldCountDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldCount.self, forKey: .worldCount)
        worldCount = worldCountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let worldTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .worldTags)
        var worldTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let worldTagsContainer = worldTagsContainer {
            worldTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in worldTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    worldTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        worldTags = worldTagsDecoded0
    }
}

extension CreateWorldTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case name
        case tags
        case templateBody
        case templateLocation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let templateBody = self.templateBody {
            try encodeContainer.encode(templateBody, forKey: .templateBody)
        }
        if let templateLocation = self.templateLocation {
            try encodeContainer.encode(templateLocation, forKey: .templateLocation)
        }
    }
}

extension CreateWorldTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createWorldTemplate"
    }
}

public struct CreateWorldTemplateInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// The name of the world template.
    public var name: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the world template.
    public var tags: [Swift.String:Swift.String]?
    /// The world template body.
    public var templateBody: Swift.String?
    /// The location of the world template.
    public var templateLocation: RoboMakerClientTypes.TemplateLocation?

    public init (
        clientRequestToken: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        templateBody: Swift.String? = nil,
        templateLocation: RoboMakerClientTypes.TemplateLocation? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.name = name
        self.tags = tags
        self.templateBody = templateBody
        self.templateLocation = templateLocation
    }
}

struct CreateWorldTemplateInputBody: Swift.Equatable {
    let clientRequestToken: Swift.String?
    let name: Swift.String?
    let templateBody: Swift.String?
    let templateLocation: RoboMakerClientTypes.TemplateLocation?
    let tags: [Swift.String:Swift.String]?
}

extension CreateWorldTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case name
        case tags
        case templateBody
        case templateLocation
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let templateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let templateLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.TemplateLocation.self, forKey: .templateLocation)
        templateLocation = templateLocationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorldTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorldTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateWorldTemplateOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorldTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateWorldTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct CreateWorldTemplateOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the world template.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the world template was created.
    public var createdAt: ClientRuntime.Date?
    /// The name of the world template.
    public var name: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the world template.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.name = name
        self.tags = tags
    }
}

struct CreateWorldTemplateOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let clientRequestToken: Swift.String?
    let createdAt: ClientRuntime.Date?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateWorldTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case createdAt
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension RoboMakerClientTypes.DataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination
        case name
        case s3Bucket
        case s3Keys
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Keys = s3Keys {
            var s3KeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3Keys)
            for s3keyoutput0 in s3Keys {
                try s3KeysContainer.encode(s3keyoutput0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeysContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.S3KeyOutput?].self, forKey: .s3Keys)
        var s3KeysDecoded0:[RoboMakerClientTypes.S3KeyOutput]? = nil
        if let s3KeysContainer = s3KeysContainer {
            s3KeysDecoded0 = [RoboMakerClientTypes.S3KeyOutput]()
            for structure0 in s3KeysContainer {
                if let structure0 = structure0 {
                    s3KeysDecoded0?.append(structure0)
                }
            }
        }
        s3Keys = s3KeysDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DataSourceType.self, forKey: .type)
        type = typeDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a data source.
    public struct DataSource: Swift.Equatable {
        /// The location where your files are mounted in the container image. If you've specified the type of the data source as an Archive, you must provide an Amazon S3 object key to your archive. The object key must point to either a .zip or .tar.gz file. If you've specified the type of the data source as a Prefix, you provide the Amazon S3 prefix that points to the files that you are using for your data source. If you've specified the type of the data source as a File, you provide the Amazon S3 path to the file that you're using as your data source.
        public var destination: Swift.String?
        /// The name of the data source.
        public var name: Swift.String?
        /// The S3 bucket where the data files are located.
        public var s3Bucket: Swift.String?
        /// The list of S3 keys identifying the data source files.
        public var s3Keys: [RoboMakerClientTypes.S3KeyOutput]?
        /// The data type for the data source that you're using for your container image or simulation job. You can use this field to specify whether your data source is an Archive, an Amazon S3 prefix, or a file. If you don't specify a field, the default value is File.
        public var type: RoboMakerClientTypes.DataSourceType?

        public init (
            destination: Swift.String? = nil,
            name: Swift.String? = nil,
            s3Bucket: Swift.String? = nil,
            s3Keys: [RoboMakerClientTypes.S3KeyOutput]? = nil,
            type: RoboMakerClientTypes.DataSourceType? = nil
        )
        {
            self.destination = destination
            self.name = name
            self.s3Bucket = s3Bucket
            self.s3Keys = s3Keys
            self.type = type
        }
    }

}

extension RoboMakerClientTypes.DataSourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination
        case name
        case s3Bucket
        case s3Keys
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Keys = s3Keys {
            var s3KeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3Keys)
            for s3keyorprefix0 in s3Keys {
                try s3KeysContainer.encode(s3keyorprefix0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .s3Keys)
        var s3KeysDecoded0:[Swift.String]? = nil
        if let s3KeysContainer = s3KeysContainer {
            s3KeysDecoded0 = [Swift.String]()
            for string0 in s3KeysContainer {
                if let string0 = string0 {
                    s3KeysDecoded0?.append(string0)
                }
            }
        }
        s3Keys = s3KeysDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DataSourceType.self, forKey: .type)
        type = typeDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a data source.
    public struct DataSourceConfig: Swift.Equatable {
        /// The location where your files are mounted in the container image. If you've specified the type of the data source as an Archive, you must provide an Amazon S3 object key to your archive. The object key must point to either a .zip or .tar.gz file. If you've specified the type of the data source as a Prefix, you provide the Amazon S3 prefix that points to the files that you are using for your data source. If you've specified the type of the data source as a File, you provide the Amazon S3 path to the file that you're using as your data source.
        public var destination: Swift.String?
        /// The name of the data source.
        /// This member is required.
        public var name: Swift.String?
        /// The S3 bucket where the data files are located.
        /// This member is required.
        public var s3Bucket: Swift.String?
        /// The list of S3 keys identifying the data source files.
        /// This member is required.
        public var s3Keys: [Swift.String]?
        /// The data type for the data source that you're using for your container image or simulation job. You can use this field to specify whether your data source is an Archive, an Amazon S3 prefix, or a file. If you don't specify a field, the default value is File.
        public var type: RoboMakerClientTypes.DataSourceType?

        public init (
            destination: Swift.String? = nil,
            name: Swift.String? = nil,
            s3Bucket: Swift.String? = nil,
            s3Keys: [Swift.String]? = nil,
            type: RoboMakerClientTypes.DataSourceType? = nil
        )
        {
            self.destination = destination
            self.name = name
            self.s3Bucket = s3Bucket
            self.s3Keys = s3Keys
            self.type = type
        }
    }

}

extension RoboMakerClientTypes {
    public enum DataSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case archive
        case file
        case `prefix`
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceType] {
            return [
                .archive,
                .file,
                .prefix,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .archive: return "Archive"
            case .file: return "File"
            case .prefix: return "Prefix"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSourceType(rawValue: rawValue) ?? DataSourceType.sdkUnknown(rawValue)
        }
    }
}

extension DeleteFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleet = self.fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
    }
}

extension DeleteFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteFleet"
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DeleteFleetInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var fleet: Swift.String?

    public init (
        fleet: Swift.String? = nil
    )
    {
        self.fleet = fleet
    }
}

struct DeleteFleetInputBody: Swift.Equatable {
    let fleet: Swift.String?
}

extension DeleteFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
    }
}

extension DeleteFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteFleetOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DeleteFleetOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteRobotApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = self.application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let applicationVersion = self.applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
    }
}

extension DeleteRobotApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteRobotApplication"
    }
}

public struct DeleteRobotApplicationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the the robot application.
    /// This member is required.
    public var application: Swift.String?
    /// The version of the robot application to delete.
    public var applicationVersion: Swift.String?

    public init (
        application: Swift.String? = nil,
        applicationVersion: Swift.String? = nil
    )
    {
        self.application = application
        self.applicationVersion = applicationVersion
    }
}

struct DeleteRobotApplicationInputBody: Swift.Equatable {
    let application: Swift.String?
    let applicationVersion: Swift.String?
}

extension DeleteRobotApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
    }
}

extension DeleteRobotApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRobotApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteRobotApplicationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRobotApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRobotApplicationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteRobotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case robot
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let robot = self.robot {
            try encodeContainer.encode(robot, forKey: .robot)
        }
    }
}

extension DeleteRobotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteRobot"
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DeleteRobotInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the robot.
    /// This member is required.
    public var robot: Swift.String?

    public init (
        robot: Swift.String? = nil
    )
    {
        self.robot = robot
    }
}

struct DeleteRobotInputBody: Swift.Equatable {
    let robot: Swift.String?
}

extension DeleteRobotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case robot
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let robotDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .robot)
        robot = robotDecoded
    }
}

extension DeleteRobotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRobotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteRobotOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRobotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DeleteRobotOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteSimulationApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = self.application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let applicationVersion = self.applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
    }
}

extension DeleteSimulationApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteSimulationApplication"
    }
}

public struct DeleteSimulationApplicationInput: Swift.Equatable {
    /// The application information for the simulation application to delete.
    /// This member is required.
    public var application: Swift.String?
    /// The version of the simulation application to delete.
    public var applicationVersion: Swift.String?

    public init (
        application: Swift.String? = nil,
        applicationVersion: Swift.String? = nil
    )
    {
        self.application = application
        self.applicationVersion = applicationVersion
    }
}

struct DeleteSimulationApplicationInputBody: Swift.Equatable {
    let application: Swift.String?
    let applicationVersion: Swift.String?
}

extension DeleteSimulationApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
    }
}

extension DeleteSimulationApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSimulationApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSimulationApplicationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSimulationApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSimulationApplicationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteWorldTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case template
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let template = self.template {
            try encodeContainer.encode(template, forKey: .template)
        }
    }
}

extension DeleteWorldTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteWorldTemplate"
    }
}

public struct DeleteWorldTemplateInput: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the world template you want to delete.
    /// This member is required.
    public var template: Swift.String?

    public init (
        template: Swift.String? = nil
    )
    {
        self.template = template
    }
}

struct DeleteWorldTemplateInputBody: Swift.Equatable {
    let template: Swift.String?
}

extension DeleteWorldTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case template
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
    }
}

extension DeleteWorldTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorldTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteWorldTemplateOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorldTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWorldTemplateOutputResponse: Swift.Equatable {

    public init () { }
}

extension RoboMakerClientTypes.DeploymentApplicationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
        case launchConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = self.application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let applicationVersion = self.applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
        if let launchConfig = self.launchConfig {
            try encodeContainer.encode(launchConfig, forKey: .launchConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
        let launchConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentLaunchConfig.self, forKey: .launchConfig)
        launchConfig = launchConfigDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a deployment application configuration.
    public struct DeploymentApplicationConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the robot application.
        /// This member is required.
        public var application: Swift.String?
        /// The version of the application.
        /// This member is required.
        public var applicationVersion: Swift.String?
        /// The launch configuration.
        /// This member is required.
        public var launchConfig: RoboMakerClientTypes.DeploymentLaunchConfig?

        public init (
            application: Swift.String? = nil,
            applicationVersion: Swift.String? = nil,
            launchConfig: RoboMakerClientTypes.DeploymentLaunchConfig? = nil
        )
        {
            self.application = application
            self.applicationVersion = applicationVersion
            self.launchConfig = launchConfig
        }
    }

}

extension RoboMakerClientTypes.DeploymentConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case concurrentDeploymentPercentage
        case downloadConditionFile
        case failureThresholdPercentage
        case robotDeploymentTimeoutInSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let concurrentDeploymentPercentage = self.concurrentDeploymentPercentage {
            try encodeContainer.encode(concurrentDeploymentPercentage, forKey: .concurrentDeploymentPercentage)
        }
        if let downloadConditionFile = self.downloadConditionFile {
            try encodeContainer.encode(downloadConditionFile, forKey: .downloadConditionFile)
        }
        if let failureThresholdPercentage = self.failureThresholdPercentage {
            try encodeContainer.encode(failureThresholdPercentage, forKey: .failureThresholdPercentage)
        }
        if let robotDeploymentTimeoutInSeconds = self.robotDeploymentTimeoutInSeconds {
            try encodeContainer.encode(robotDeploymentTimeoutInSeconds, forKey: .robotDeploymentTimeoutInSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let concurrentDeploymentPercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .concurrentDeploymentPercentage)
        concurrentDeploymentPercentage = concurrentDeploymentPercentageDecoded
        let failureThresholdPercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failureThresholdPercentage)
        failureThresholdPercentage = failureThresholdPercentageDecoded
        let robotDeploymentTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .robotDeploymentTimeoutInSeconds)
        robotDeploymentTimeoutInSeconds = robotDeploymentTimeoutInSecondsDecoded
        let downloadConditionFileDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.S3Object.self, forKey: .downloadConditionFile)
        downloadConditionFile = downloadConditionFileDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a deployment configuration.
    public struct DeploymentConfig: Swift.Equatable {
        /// The percentage of robots receiving the deployment at the same time.
        public var concurrentDeploymentPercentage: Swift.Int?
        /// The download condition file.
        public var downloadConditionFile: RoboMakerClientTypes.S3Object?
        /// The percentage of deployments that need to fail before stopping deployment.
        public var failureThresholdPercentage: Swift.Int?
        /// The amount of time, in seconds, to wait for deployment to a single robot to complete. Choose a time between 1 minute and 7 days. The default is 5 hours.
        public var robotDeploymentTimeoutInSeconds: Swift.Int?

        public init (
            concurrentDeploymentPercentage: Swift.Int? = nil,
            downloadConditionFile: RoboMakerClientTypes.S3Object? = nil,
            failureThresholdPercentage: Swift.Int? = nil,
            robotDeploymentTimeoutInSeconds: Swift.Int? = nil
        )
        {
            self.concurrentDeploymentPercentage = concurrentDeploymentPercentage
            self.downloadConditionFile = downloadConditionFile
            self.failureThresholdPercentage = failureThresholdPercentage
            self.robotDeploymentTimeoutInSeconds = robotDeploymentTimeoutInSeconds
        }
    }

}

extension RoboMakerClientTypes.DeploymentJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case deploymentApplicationConfigs
        case deploymentConfig
        case failureCode
        case failureReason
        case fleet
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let deploymentApplicationConfigs = deploymentApplicationConfigs {
            var deploymentApplicationConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deploymentApplicationConfigs)
            for deploymentapplicationconfig0 in deploymentApplicationConfigs {
                try deploymentApplicationConfigsContainer.encode(deploymentapplicationconfig0)
            }
        }
        if let deploymentConfig = self.deploymentConfig {
            try encodeContainer.encode(deploymentConfig, forKey: .deploymentConfig)
        }
        if let failureCode = self.failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let fleet = self.fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentStatus.self, forKey: .status)
        status = statusDecoded
        let deploymentApplicationConfigsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DeploymentApplicationConfig?].self, forKey: .deploymentApplicationConfigs)
        var deploymentApplicationConfigsDecoded0:[RoboMakerClientTypes.DeploymentApplicationConfig]? = nil
        if let deploymentApplicationConfigsContainer = deploymentApplicationConfigsContainer {
            deploymentApplicationConfigsDecoded0 = [RoboMakerClientTypes.DeploymentApplicationConfig]()
            for structure0 in deploymentApplicationConfigsContainer {
                if let structure0 = structure0 {
                    deploymentApplicationConfigsDecoded0?.append(structure0)
                }
            }
        }
        deploymentApplicationConfigs = deploymentApplicationConfigsDecoded0
        let deploymentConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentConfig.self, forKey: .deploymentConfig)
        deploymentConfig = deploymentConfigDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a deployment job.
    public struct DeploymentJob: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the deployment job.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the deployment job was created.
        public var createdAt: ClientRuntime.Date?
        /// The deployment application configuration.
        public var deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
        /// The deployment configuration.
        public var deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
        /// The deployment job failure code.
        public var failureCode: RoboMakerClientTypes.DeploymentJobErrorCode?
        /// A short description of the reason why the deployment job failed.
        public var failureReason: Swift.String?
        /// The Amazon Resource Name (ARN) of the fleet.
        public var fleet: Swift.String?
        /// The status of the deployment job.
        public var status: RoboMakerClientTypes.DeploymentStatus?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]? = nil,
            deploymentConfig: RoboMakerClientTypes.DeploymentConfig? = nil,
            failureCode: RoboMakerClientTypes.DeploymentJobErrorCode? = nil,
            failureReason: Swift.String? = nil,
            fleet: Swift.String? = nil,
            status: RoboMakerClientTypes.DeploymentStatus? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.deploymentApplicationConfigs = deploymentApplicationConfigs
            self.deploymentConfig = deploymentConfig
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.fleet = fleet
            self.status = status
        }
    }

}

extension RoboMakerClientTypes {
    public enum DeploymentJobErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case badlambdaassociated
        case badpermissionerror
        case deploymentfleetdoesnotexist
        case downloadconditionfailed
        case environmentsetuperror
        case etagmismatch
        case extractingbundlefailure
        case failurethresholdbreached
        case fleetdeploymenttimeout
        case greengrassdeploymentfailed
        case greengrassgroupversiondoesnotexist
        case internalservererror
        case invalidgreengrassgroup
        case lambdadeleted
        case missingrobotapplicationarchitecture
        case missingrobotarchitecture
        case missingrobotdeploymentresource
        case postlaunchfilefailure
        case prelaunchfilefailure
        case resourcenotfound
        case robotagentconnectiontimeout
        case robotapplicationdoesnotexist
        case robotdeploymentaborted
        case robotdeploymentnoresponse
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentJobErrorCode] {
            return [
                .badlambdaassociated,
                .badpermissionerror,
                .deploymentfleetdoesnotexist,
                .downloadconditionfailed,
                .environmentsetuperror,
                .etagmismatch,
                .extractingbundlefailure,
                .failurethresholdbreached,
                .fleetdeploymenttimeout,
                .greengrassdeploymentfailed,
                .greengrassgroupversiondoesnotexist,
                .internalservererror,
                .invalidgreengrassgroup,
                .lambdadeleted,
                .missingrobotapplicationarchitecture,
                .missingrobotarchitecture,
                .missingrobotdeploymentresource,
                .postlaunchfilefailure,
                .prelaunchfilefailure,
                .resourcenotfound,
                .robotagentconnectiontimeout,
                .robotapplicationdoesnotexist,
                .robotdeploymentaborted,
                .robotdeploymentnoresponse,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .badlambdaassociated: return "BadLambdaAssociated"
            case .badpermissionerror: return "BadPermissionError"
            case .deploymentfleetdoesnotexist: return "DeploymentFleetDoesNotExist"
            case .downloadconditionfailed: return "DownloadConditionFailed"
            case .environmentsetuperror: return "EnvironmentSetupError"
            case .etagmismatch: return "EtagMismatch"
            case .extractingbundlefailure: return "ExtractingBundleFailure"
            case .failurethresholdbreached: return "FailureThresholdBreached"
            case .fleetdeploymenttimeout: return "FleetDeploymentTimeout"
            case .greengrassdeploymentfailed: return "GreengrassDeploymentFailed"
            case .greengrassgroupversiondoesnotexist: return "GreengrassGroupVersionDoesNotExist"
            case .internalservererror: return "InternalServerError"
            case .invalidgreengrassgroup: return "InvalidGreengrassGroup"
            case .lambdadeleted: return "LambdaDeleted"
            case .missingrobotapplicationarchitecture: return "MissingRobotApplicationArchitecture"
            case .missingrobotarchitecture: return "MissingRobotArchitecture"
            case .missingrobotdeploymentresource: return "MissingRobotDeploymentResource"
            case .postlaunchfilefailure: return "PostLaunchFileFailure"
            case .prelaunchfilefailure: return "PreLaunchFileFailure"
            case .resourcenotfound: return "ResourceNotFound"
            case .robotagentconnectiontimeout: return "RobotAgentConnectionTimeout"
            case .robotapplicationdoesnotexist: return "RobotApplicationDoesNotExist"
            case .robotdeploymentaborted: return "RobotDeploymentAborted"
            case .robotdeploymentnoresponse: return "RobotDeploymentNoResponse"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentJobErrorCode(rawValue: rawValue) ?? DeploymentJobErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.DeploymentLaunchConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentVariables
        case launchFile
        case packageName
        case postLaunchFile
        case preLaunchFile
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .environmentVariables)
            for (dictKey0, environmentVariableMap0) in environmentVariables {
                try environmentVariablesContainer.encode(environmentVariableMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let launchFile = self.launchFile {
            try encodeContainer.encode(launchFile, forKey: .launchFile)
        }
        if let packageName = self.packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let postLaunchFile = self.postLaunchFile {
            try encodeContainer.encode(postLaunchFile, forKey: .postLaunchFile)
        }
        if let preLaunchFile = self.preLaunchFile {
            try encodeContainer.encode(preLaunchFile, forKey: .preLaunchFile)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let preLaunchFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preLaunchFile)
        preLaunchFile = preLaunchFileDecoded
        let launchFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchFile)
        launchFile = launchFileDecoded
        let postLaunchFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postLaunchFile)
        postLaunchFile = postLaunchFileDecoded
        let environmentVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .environmentVariables)
        var environmentVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let environmentVariablesContainer = environmentVariablesContainer {
            environmentVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, environmentvariablevalue0) in environmentVariablesContainer {
                if let environmentvariablevalue0 = environmentvariablevalue0 {
                    environmentVariablesDecoded0?[key0] = environmentvariablevalue0
                }
            }
        }
        environmentVariables = environmentVariablesDecoded0
    }
}

extension RoboMakerClientTypes {
    /// Configuration information for a deployment launch.
    public struct DeploymentLaunchConfig: Swift.Equatable {
        /// An array of key/value pairs specifying environment variables for the robot application
        public var environmentVariables: [Swift.String:Swift.String]?
        /// The launch file name.
        /// This member is required.
        public var launchFile: Swift.String?
        /// The package name.
        /// This member is required.
        public var packageName: Swift.String?
        /// The deployment post-launch file. This file will be executed after the launch file.
        public var postLaunchFile: Swift.String?
        /// The deployment pre-launch file. This file will be executed prior to the launch file.
        public var preLaunchFile: Swift.String?

        public init (
            environmentVariables: [Swift.String:Swift.String]? = nil,
            launchFile: Swift.String? = nil,
            packageName: Swift.String? = nil,
            postLaunchFile: Swift.String? = nil,
            preLaunchFile: Swift.String? = nil
        )
        {
            self.environmentVariables = environmentVariables
            self.launchFile = launchFile
            self.packageName = packageName
            self.postLaunchFile = postLaunchFile
            self.preLaunchFile = preLaunchFile
        }
    }

}

extension RoboMakerClientTypes {
    public enum DeploymentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case failed
        case inprogress
        case pending
        case preparing
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentStatus] {
            return [
                .canceled,
                .failed,
                .inprogress,
                .pending,
                .preparing,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "Canceled"
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .pending: return "Pending"
            case .preparing: return "Preparing"
            case .succeeded: return "Succeeded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentStatus(rawValue: rawValue) ?? DeploymentStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeregisterRobotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet
        case robot
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleet = self.fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
        if let robot = self.robot {
            try encodeContainer.encode(robot, forKey: .robot)
        }
    }
}

extension DeregisterRobotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deregisterRobot"
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DeregisterRobotInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var fleet: Swift.String?
    /// The Amazon Resource Name (ARN) of the robot.
    /// This member is required.
    public var robot: Swift.String?

    public init (
        fleet: Swift.String? = nil,
        robot: Swift.String? = nil
    )
    {
        self.fleet = fleet
        self.robot = robot
    }
}

struct DeregisterRobotInputBody: Swift.Equatable {
    let fleet: Swift.String?
    let robot: Swift.String?
}

extension DeregisterRobotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet
        case robot
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let robotDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .robot)
        robot = robotDecoded
    }
}

extension DeregisterRobotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterRobotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeregisterRobotOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterRobotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeregisterRobotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fleet = output.fleet
            self.robot = output.robot
        } else {
            self.fleet = nil
            self.robot = nil
        }
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DeregisterRobotOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    public var fleet: Swift.String?
    /// The Amazon Resource Name (ARN) of the robot.
    public var robot: Swift.String?

    public init (
        fleet: Swift.String? = nil,
        robot: Swift.String? = nil
    )
    {
        self.fleet = fleet
        self.robot = robot
    }
}

struct DeregisterRobotOutputResponseBody: Swift.Equatable {
    let fleet: Swift.String?
    let robot: Swift.String?
}

extension DeregisterRobotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet
        case robot
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let robotDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .robot)
        robot = robotDecoded
    }
}

extension DescribeDeploymentJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = self.job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

extension DescribeDeploymentJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeDeploymentJob"
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DescribeDeploymentJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deployment job.
    /// This member is required.
    public var job: Swift.String?

    public init (
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

struct DescribeDeploymentJobInputBody: Swift.Equatable {
    let job: Swift.String?
}

extension DescribeDeploymentJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .job)
        job = jobDecoded
    }
}

extension DescribeDeploymentJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDeploymentJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDeploymentJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDeploymentJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDeploymentJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.deploymentApplicationConfigs = output.deploymentApplicationConfigs
            self.deploymentConfig = output.deploymentConfig
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.fleet = output.fleet
            self.robotDeploymentSummary = output.robotDeploymentSummary
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.createdAt = nil
            self.deploymentApplicationConfigs = nil
            self.deploymentConfig = nil
            self.failureCode = nil
            self.failureReason = nil
            self.fleet = nil
            self.robotDeploymentSummary = nil
            self.status = nil
            self.tags = nil
        }
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DescribeDeploymentJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deployment job.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the deployment job was created.
    public var createdAt: ClientRuntime.Date?
    /// The deployment application configuration.
    public var deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
    /// The deployment configuration.
    public var deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
    /// The deployment job failure code.
    public var failureCode: RoboMakerClientTypes.DeploymentJobErrorCode?
    /// A short description of the reason why the deployment job failed.
    public var failureReason: Swift.String?
    /// The Amazon Resource Name (ARN) of the fleet.
    public var fleet: Swift.String?
    /// A list of robot deployment summaries.
    public var robotDeploymentSummary: [RoboMakerClientTypes.RobotDeployment]?
    /// The status of the deployment job.
    public var status: RoboMakerClientTypes.DeploymentStatus?
    /// The list of all tags added to the specified deployment job.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]? = nil,
        deploymentConfig: RoboMakerClientTypes.DeploymentConfig? = nil,
        failureCode: RoboMakerClientTypes.DeploymentJobErrorCode? = nil,
        failureReason: Swift.String? = nil,
        fleet: Swift.String? = nil,
        robotDeploymentSummary: [RoboMakerClientTypes.RobotDeployment]? = nil,
        status: RoboMakerClientTypes.DeploymentStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.deploymentApplicationConfigs = deploymentApplicationConfigs
        self.deploymentConfig = deploymentConfig
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.fleet = fleet
        self.robotDeploymentSummary = robotDeploymentSummary
        self.status = status
        self.tags = tags
    }
}

struct DescribeDeploymentJobOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let fleet: Swift.String?
    let status: RoboMakerClientTypes.DeploymentStatus?
    let deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
    let deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
    let failureReason: Swift.String?
    let failureCode: RoboMakerClientTypes.DeploymentJobErrorCode?
    let createdAt: ClientRuntime.Date?
    let robotDeploymentSummary: [RoboMakerClientTypes.RobotDeployment]?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeDeploymentJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case deploymentApplicationConfigs
        case deploymentConfig
        case failureCode
        case failureReason
        case fleet
        case robotDeploymentSummary
        case status
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentStatus.self, forKey: .status)
        status = statusDecoded
        let deploymentConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentConfig.self, forKey: .deploymentConfig)
        deploymentConfig = deploymentConfigDecoded
        let deploymentApplicationConfigsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DeploymentApplicationConfig?].self, forKey: .deploymentApplicationConfigs)
        var deploymentApplicationConfigsDecoded0:[RoboMakerClientTypes.DeploymentApplicationConfig]? = nil
        if let deploymentApplicationConfigsContainer = deploymentApplicationConfigsContainer {
            deploymentApplicationConfigsDecoded0 = [RoboMakerClientTypes.DeploymentApplicationConfig]()
            for structure0 in deploymentApplicationConfigsContainer {
                if let structure0 = structure0 {
                    deploymentApplicationConfigsDecoded0?.append(structure0)
                }
            }
        }
        deploymentApplicationConfigs = deploymentApplicationConfigsDecoded0
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let robotDeploymentSummaryContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.RobotDeployment?].self, forKey: .robotDeploymentSummary)
        var robotDeploymentSummaryDecoded0:[RoboMakerClientTypes.RobotDeployment]? = nil
        if let robotDeploymentSummaryContainer = robotDeploymentSummaryContainer {
            robotDeploymentSummaryDecoded0 = [RoboMakerClientTypes.RobotDeployment]()
            for structure0 in robotDeploymentSummaryContainer {
                if let structure0 = structure0 {
                    robotDeploymentSummaryDecoded0?.append(structure0)
                }
            }
        }
        robotDeploymentSummary = robotDeploymentSummaryDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribeFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleet = self.fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
    }
}

extension DescribeFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeFleet"
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DescribeFleetInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var fleet: Swift.String?

    public init (
        fleet: Swift.String? = nil
    )
    {
        self.fleet = fleet
    }
}

struct DescribeFleetInputBody: Swift.Equatable {
    let fleet: Swift.String?
}

extension DescribeFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
    }
}

extension DescribeFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeFleetOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeFleetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.lastDeploymentJob = output.lastDeploymentJob
            self.lastDeploymentStatus = output.lastDeploymentStatus
            self.lastDeploymentTime = output.lastDeploymentTime
            self.name = output.name
            self.robots = output.robots
            self.tags = output.tags
        } else {
            self.arn = nil
            self.createdAt = nil
            self.lastDeploymentJob = nil
            self.lastDeploymentStatus = nil
            self.lastDeploymentTime = nil
            self.name = nil
            self.robots = nil
            self.tags = nil
        }
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DescribeFleetOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the fleet was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the last deployment job.
    public var lastDeploymentJob: Swift.String?
    /// The status of the last deployment.
    public var lastDeploymentStatus: RoboMakerClientTypes.DeploymentStatus?
    /// The time of the last deployment.
    public var lastDeploymentTime: ClientRuntime.Date?
    /// The name of the fleet.
    public var name: Swift.String?
    /// A list of robots.
    public var robots: [RoboMakerClientTypes.Robot]?
    /// The list of all tags added to the specified fleet.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        lastDeploymentJob: Swift.String? = nil,
        lastDeploymentStatus: RoboMakerClientTypes.DeploymentStatus? = nil,
        lastDeploymentTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        robots: [RoboMakerClientTypes.Robot]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.lastDeploymentJob = lastDeploymentJob
        self.lastDeploymentStatus = lastDeploymentStatus
        self.lastDeploymentTime = lastDeploymentTime
        self.name = name
        self.robots = robots
        self.tags = tags
    }
}

struct DescribeFleetOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let robots: [RoboMakerClientTypes.Robot]?
    let createdAt: ClientRuntime.Date?
    let lastDeploymentStatus: RoboMakerClientTypes.DeploymentStatus?
    let lastDeploymentJob: Swift.String?
    let lastDeploymentTime: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeFleetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case lastDeploymentJob
        case lastDeploymentStatus
        case lastDeploymentTime
        case name
        case robots
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let robotsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Robot?].self, forKey: .robots)
        var robotsDecoded0:[RoboMakerClientTypes.Robot]? = nil
        if let robotsContainer = robotsContainer {
            robotsDecoded0 = [RoboMakerClientTypes.Robot]()
            for structure0 in robotsContainer {
                if let structure0 = structure0 {
                    robotsDecoded0?.append(structure0)
                }
            }
        }
        robots = robotsDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastDeploymentStatusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentStatus.self, forKey: .lastDeploymentStatus)
        lastDeploymentStatus = lastDeploymentStatusDecoded
        let lastDeploymentJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastDeploymentJob)
        lastDeploymentJob = lastDeploymentJobDecoded
        let lastDeploymentTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastDeploymentTime)
        lastDeploymentTime = lastDeploymentTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribeRobotApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = self.application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let applicationVersion = self.applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
    }
}

extension DescribeRobotApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeRobotApplication"
    }
}

public struct DescribeRobotApplicationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the robot application.
    /// This member is required.
    public var application: Swift.String?
    /// The version of the robot application to describe.
    public var applicationVersion: Swift.String?

    public init (
        application: Swift.String? = nil,
        applicationVersion: Swift.String? = nil
    )
    {
        self.application = application
        self.applicationVersion = applicationVersion
    }
}

struct DescribeRobotApplicationInputBody: Swift.Equatable {
    let application: Swift.String?
    let applicationVersion: Swift.String?
}

extension DescribeRobotApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
    }
}

extension DescribeRobotApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRobotApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeRobotApplicationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRobotApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeRobotApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.environment = output.environment
            self.imageDigest = output.imageDigest
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.sources = output.sources
            self.tags = output.tags
            self.version = output.version
        } else {
            self.arn = nil
            self.environment = nil
            self.imageDigest = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.sources = nil
            self.tags = nil
            self.version = nil
        }
    }
}

public struct DescribeRobotApplicationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the robot application.
    public var arn: Swift.String?
    /// The object that contains the Docker image URI used to create the robot application.
    public var environment: RoboMakerClientTypes.Environment?
    /// A SHA256 identifier for the Docker image that you use for your robot application.
    public var imageDigest: Swift.String?
    /// The time, in milliseconds since the epoch, when the robot application was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the robot application.
    public var name: Swift.String?
    /// The revision id of the robot application.
    public var revisionId: Swift.String?
    /// The robot software suite (ROS distribution) used by the robot application.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The sources of the robot application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The list of all tags added to the specified robot application.
    public var tags: [Swift.String:Swift.String]?
    /// The version of the robot application.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        imageDigest: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.imageDigest = imageDigest
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.sources = sources
        self.tags = tags
        self.version = version
    }
}

struct DescribeRobotApplicationOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let version: Swift.String?
    let sources: [RoboMakerClientTypes.Source]?
    let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    let revisionId: Swift.String?
    let lastUpdatedAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
    let environment: RoboMakerClientTypes.Environment?
    let imageDigest: Swift.String?
}

extension DescribeRobotApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case environment
        case imageDigest
        case lastUpdatedAt
        case name
        case revisionId
        case robotSoftwareSuite
        case sources
        case tags
        case version
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Source?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
        let imageDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
    }
}

extension DescribeRobotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case robot
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let robot = self.robot {
            try encodeContainer.encode(robot, forKey: .robot)
        }
    }
}

extension DescribeRobotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeRobot"
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DescribeRobotInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the robot to be described.
    /// This member is required.
    public var robot: Swift.String?

    public init (
        robot: Swift.String? = nil
    )
    {
        self.robot = robot
    }
}

struct DescribeRobotInputBody: Swift.Equatable {
    let robot: Swift.String?
}

extension DescribeRobotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case robot
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let robotDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .robot)
        robot = robotDecoded
    }
}

extension DescribeRobotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRobotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeRobotOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRobotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeRobotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.architecture = output.architecture
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.fleetArn = output.fleetArn
            self.greengrassGroupId = output.greengrassGroupId
            self.lastDeploymentJob = output.lastDeploymentJob
            self.lastDeploymentTime = output.lastDeploymentTime
            self.name = output.name
            self.status = output.status
            self.tags = output.tags
        } else {
            self.architecture = nil
            self.arn = nil
            self.createdAt = nil
            self.fleetArn = nil
            self.greengrassGroupId = nil
            self.lastDeploymentJob = nil
            self.lastDeploymentTime = nil
            self.name = nil
            self.status = nil
            self.tags = nil
        }
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DescribeRobotOutputResponse: Swift.Equatable {
    /// The target architecture of the robot application.
    public var architecture: RoboMakerClientTypes.Architecture?
    /// The Amazon Resource Name (ARN) of the robot.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the robot was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the fleet.
    public var fleetArn: Swift.String?
    /// The Greengrass group id.
    public var greengrassGroupId: Swift.String?
    /// The Amazon Resource Name (ARN) of the last deployment job.
    public var lastDeploymentJob: Swift.String?
    /// The time of the last deployment job.
    public var lastDeploymentTime: ClientRuntime.Date?
    /// The name of the robot.
    public var name: Swift.String?
    /// The status of the fleet.
    public var status: RoboMakerClientTypes.RobotStatus?
    /// The list of all tags added to the specified robot.
    public var tags: [Swift.String:Swift.String]?

    public init (
        architecture: RoboMakerClientTypes.Architecture? = nil,
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        fleetArn: Swift.String? = nil,
        greengrassGroupId: Swift.String? = nil,
        lastDeploymentJob: Swift.String? = nil,
        lastDeploymentTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        status: RoboMakerClientTypes.RobotStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.architecture = architecture
        self.arn = arn
        self.createdAt = createdAt
        self.fleetArn = fleetArn
        self.greengrassGroupId = greengrassGroupId
        self.lastDeploymentJob = lastDeploymentJob
        self.lastDeploymentTime = lastDeploymentTime
        self.name = name
        self.status = status
        self.tags = tags
    }
}

struct DescribeRobotOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let fleetArn: Swift.String?
    let status: RoboMakerClientTypes.RobotStatus?
    let greengrassGroupId: Swift.String?
    let createdAt: ClientRuntime.Date?
    let architecture: RoboMakerClientTypes.Architecture?
    let lastDeploymentJob: Swift.String?
    let lastDeploymentTime: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeRobotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case arn
        case createdAt
        case fleetArn
        case greengrassGroupId
        case lastDeploymentJob
        case lastDeploymentTime
        case name
        case status
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotStatus.self, forKey: .status)
        status = statusDecoded
        let greengrassGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .greengrassGroupId)
        greengrassGroupId = greengrassGroupIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
        let lastDeploymentJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastDeploymentJob)
        lastDeploymentJob = lastDeploymentJobDecoded
        let lastDeploymentTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastDeploymentTime)
        lastDeploymentTime = lastDeploymentTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribeSimulationApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = self.application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let applicationVersion = self.applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
    }
}

extension DescribeSimulationApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeSimulationApplication"
    }
}

public struct DescribeSimulationApplicationInput: Swift.Equatable {
    /// The application information for the simulation application.
    /// This member is required.
    public var application: Swift.String?
    /// The version of the simulation application to describe.
    public var applicationVersion: Swift.String?

    public init (
        application: Swift.String? = nil,
        applicationVersion: Swift.String? = nil
    )
    {
        self.application = application
        self.applicationVersion = applicationVersion
    }
}

struct DescribeSimulationApplicationInputBody: Swift.Equatable {
    let application: Swift.String?
    let applicationVersion: Swift.String?
}

extension DescribeSimulationApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
    }
}

extension DescribeSimulationApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSimulationApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeSimulationApplicationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSimulationApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeSimulationApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.environment = output.environment
            self.imageDigest = output.imageDigest
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.renderingEngine = output.renderingEngine
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.simulationSoftwareSuite = output.simulationSoftwareSuite
            self.sources = output.sources
            self.tags = output.tags
            self.version = output.version
        } else {
            self.arn = nil
            self.environment = nil
            self.imageDigest = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.renderingEngine = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.simulationSoftwareSuite = nil
            self.sources = nil
            self.tags = nil
            self.version = nil
        }
    }
}

public struct DescribeSimulationApplicationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the robot simulation application.
    public var arn: Swift.String?
    /// The object that contains the Docker image URI used to create the simulation application.
    public var environment: RoboMakerClientTypes.Environment?
    /// A SHA256 identifier for the Docker image that you use for your simulation application.
    public var imageDigest: Swift.String?
    /// The time, in milliseconds since the epoch, when the simulation application was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the simulation application.
    public var name: Swift.String?
    /// The rendering engine for the simulation application.
    public var renderingEngine: RoboMakerClientTypes.RenderingEngine?
    /// The revision id of the simulation application.
    public var revisionId: Swift.String?
    /// Information about the robot software suite (ROS distribution).
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The simulation software suite used by the simulation application.
    public var simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    /// The sources of the simulation application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The list of all tags added to the specified simulation application.
    public var tags: [Swift.String:Swift.String]?
    /// The version of the simulation application.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        imageDigest: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        renderingEngine: RoboMakerClientTypes.RenderingEngine? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.imageDigest = imageDigest
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.renderingEngine = renderingEngine
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.simulationSoftwareSuite = simulationSoftwareSuite
        self.sources = sources
        self.tags = tags
        self.version = version
    }
}

struct DescribeSimulationApplicationOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let version: Swift.String?
    let sources: [RoboMakerClientTypes.Source]?
    let simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    let renderingEngine: RoboMakerClientTypes.RenderingEngine?
    let revisionId: Swift.String?
    let lastUpdatedAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
    let environment: RoboMakerClientTypes.Environment?
    let imageDigest: Swift.String?
}

extension DescribeSimulationApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case environment
        case imageDigest
        case lastUpdatedAt
        case name
        case renderingEngine
        case revisionId
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
        case tags
        case version
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Source?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let simulationSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationSoftwareSuite.self, forKey: .simulationSoftwareSuite)
        simulationSoftwareSuite = simulationSoftwareSuiteDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let renderingEngineDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RenderingEngine.self, forKey: .renderingEngine)
        renderingEngine = renderingEngineDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
        let imageDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
    }
}

extension DescribeSimulationJobBatchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batch
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batch = self.batch {
            try encodeContainer.encode(batch, forKey: .batch)
        }
    }
}

extension DescribeSimulationJobBatchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeSimulationJobBatch"
    }
}

public struct DescribeSimulationJobBatchInput: Swift.Equatable {
    /// The id of the batch to describe.
    /// This member is required.
    public var batch: Swift.String?

    public init (
        batch: Swift.String? = nil
    )
    {
        self.batch = batch
    }
}

struct DescribeSimulationJobBatchInputBody: Swift.Equatable {
    let batch: Swift.String?
}

extension DescribeSimulationJobBatchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batch
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batch)
        batch = batchDecoded
    }
}

extension DescribeSimulationJobBatchOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSimulationJobBatchOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeSimulationJobBatchOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSimulationJobBatchOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeSimulationJobBatchOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.batchPolicy = output.batchPolicy
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.createdRequests = output.createdRequests
            self.failedRequests = output.failedRequests
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.lastUpdatedAt = output.lastUpdatedAt
            self.pendingRequests = output.pendingRequests
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.batchPolicy = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.createdRequests = nil
            self.failedRequests = nil
            self.failureCode = nil
            self.failureReason = nil
            self.lastUpdatedAt = nil
            self.pendingRequests = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct DescribeSimulationJobBatchOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the batch.
    public var arn: Swift.String?
    /// The batch policy.
    public var batchPolicy: RoboMakerClientTypes.BatchPolicy?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the simulation job batch was created.
    public var createdAt: ClientRuntime.Date?
    /// A list of created simulation job summaries.
    public var createdRequests: [RoboMakerClientTypes.SimulationJobSummary]?
    /// A list of failed create simulation job requests. The request failed to be created into a simulation job. Failed requests do not have a simulation job ID.
    public var failedRequests: [RoboMakerClientTypes.FailedCreateSimulationJobRequest]?
    /// The failure code of the simulation job batch.
    public var failureCode: RoboMakerClientTypes.SimulationJobBatchErrorCode?
    /// The reason the simulation job batch failed.
    public var failureReason: Swift.String?
    /// The time, in milliseconds since the epoch, when the simulation job batch was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// A list of pending simulation job requests. These requests have not yet been created into simulation jobs.
    public var pendingRequests: [RoboMakerClientTypes.SimulationJobRequest]?
    /// The status of the batch. Pending The simulation job batch request is pending. InProgress The simulation job batch is in progress. Failed The simulation job batch failed. One or more simulation job requests could not be completed due to an internal failure (like InternalServiceError). See failureCode and failureReason for more information. Completed The simulation batch job completed. A batch is complete when (1) there are no pending simulation job requests in the batch and none of the failed simulation job requests are due to InternalServiceError and (2) when all created simulation jobs have reached a terminal state (for example, Completed or Failed). Canceled The simulation batch job was cancelled. Canceling The simulation batch job is being cancelled. Completing The simulation batch job is completing. TimingOut The simulation job batch is timing out. If a batch timing out, and there are pending requests that were failing due to an internal failure (like InternalServiceError), the batch status will be Failed. If there are no such failing request, the batch status will be TimedOut. TimedOut The simulation batch job timed out.
    public var status: RoboMakerClientTypes.SimulationJobBatchStatus?
    /// A map that contains tag keys and tag values that are attached to the simulation job batch.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        batchPolicy: RoboMakerClientTypes.BatchPolicy? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdRequests: [RoboMakerClientTypes.SimulationJobSummary]? = nil,
        failedRequests: [RoboMakerClientTypes.FailedCreateSimulationJobRequest]? = nil,
        failureCode: RoboMakerClientTypes.SimulationJobBatchErrorCode? = nil,
        failureReason: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        pendingRequests: [RoboMakerClientTypes.SimulationJobRequest]? = nil,
        status: RoboMakerClientTypes.SimulationJobBatchStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.batchPolicy = batchPolicy
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.createdRequests = createdRequests
        self.failedRequests = failedRequests
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.lastUpdatedAt = lastUpdatedAt
        self.pendingRequests = pendingRequests
        self.status = status
        self.tags = tags
    }
}

struct DescribeSimulationJobBatchOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let status: RoboMakerClientTypes.SimulationJobBatchStatus?
    let lastUpdatedAt: ClientRuntime.Date?
    let createdAt: ClientRuntime.Date?
    let clientRequestToken: Swift.String?
    let batchPolicy: RoboMakerClientTypes.BatchPolicy?
    let failureCode: RoboMakerClientTypes.SimulationJobBatchErrorCode?
    let failureReason: Swift.String?
    let failedRequests: [RoboMakerClientTypes.FailedCreateSimulationJobRequest]?
    let pendingRequests: [RoboMakerClientTypes.SimulationJobRequest]?
    let createdRequests: [RoboMakerClientTypes.SimulationJobSummary]?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeSimulationJobBatchOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case batchPolicy
        case clientRequestToken
        case createdAt
        case createdRequests
        case failedRequests
        case failureCode
        case failureReason
        case lastUpdatedAt
        case pendingRequests
        case status
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobBatchStatus.self, forKey: .status)
        status = statusDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let batchPolicyDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.BatchPolicy.self, forKey: .batchPolicy)
        batchPolicy = batchPolicyDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobBatchErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failedRequestsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.FailedCreateSimulationJobRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[RoboMakerClientTypes.FailedCreateSimulationJobRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [RoboMakerClientTypes.FailedCreateSimulationJobRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
        let pendingRequestsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationJobRequest?].self, forKey: .pendingRequests)
        var pendingRequestsDecoded0:[RoboMakerClientTypes.SimulationJobRequest]? = nil
        if let pendingRequestsContainer = pendingRequestsContainer {
            pendingRequestsDecoded0 = [RoboMakerClientTypes.SimulationJobRequest]()
            for structure0 in pendingRequestsContainer {
                if let structure0 = structure0 {
                    pendingRequestsDecoded0?.append(structure0)
                }
            }
        }
        pendingRequests = pendingRequestsDecoded0
        let createdRequestsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationJobSummary?].self, forKey: .createdRequests)
        var createdRequestsDecoded0:[RoboMakerClientTypes.SimulationJobSummary]? = nil
        if let createdRequestsContainer = createdRequestsContainer {
            createdRequestsDecoded0 = [RoboMakerClientTypes.SimulationJobSummary]()
            for structure0 in createdRequestsContainer {
                if let structure0 = structure0 {
                    createdRequestsDecoded0?.append(structure0)
                }
            }
        }
        createdRequests = createdRequestsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribeSimulationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = self.job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

extension DescribeSimulationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeSimulationJob"
    }
}

public struct DescribeSimulationJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the simulation job to be described.
    /// This member is required.
    public var job: Swift.String?

    public init (
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

struct DescribeSimulationJobInputBody: Swift.Equatable {
    let job: Swift.String?
}

extension DescribeSimulationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .job)
        job = jobDecoded
    }
}

extension DescribeSimulationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSimulationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeSimulationJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSimulationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeSimulationJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.compute = output.compute
            self.dataSources = output.dataSources
            self.failureBehavior = output.failureBehavior
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.iamRole = output.iamRole
            self.lastStartedAt = output.lastStartedAt
            self.lastUpdatedAt = output.lastUpdatedAt
            self.loggingConfig = output.loggingConfig
            self.maxJobDurationInSeconds = output.maxJobDurationInSeconds
            self.name = output.name
            self.networkInterface = output.networkInterface
            self.outputLocation = output.outputLocation
            self.robotApplications = output.robotApplications
            self.simulationApplications = output.simulationApplications
            self.simulationTimeMillis = output.simulationTimeMillis
            self.status = output.status
            self.tags = output.tags
            self.vpcConfig = output.vpcConfig
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.compute = nil
            self.dataSources = nil
            self.failureBehavior = nil
            self.failureCode = nil
            self.failureReason = nil
            self.iamRole = nil
            self.lastStartedAt = nil
            self.lastUpdatedAt = nil
            self.loggingConfig = nil
            self.maxJobDurationInSeconds = 0
            self.name = nil
            self.networkInterface = nil
            self.outputLocation = nil
            self.robotApplications = nil
            self.simulationApplications = nil
            self.simulationTimeMillis = 0
            self.status = nil
            self.tags = nil
            self.vpcConfig = nil
        }
    }
}

public struct DescribeSimulationJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the simulation job.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// Compute information for the simulation job.
    public var compute: RoboMakerClientTypes.ComputeResponse?
    /// The data sources for the simulation job.
    public var dataSources: [RoboMakerClientTypes.DataSource]?
    /// The failure behavior for the simulation job.
    public var failureBehavior: RoboMakerClientTypes.FailureBehavior?
    /// The failure code of the simulation job if it failed: InternalServiceError Internal service error. RobotApplicationCrash Robot application exited abnormally. SimulationApplicationCrash Simulation application exited abnormally. BadPermissionsRobotApplication Robot application bundle could not be downloaded. BadPermissionsSimulationApplication Simulation application bundle could not be downloaded. BadPermissionsS3Output Unable to publish outputs to customer-provided S3 bucket. BadPermissionsCloudwatchLogs Unable to publish logs to customer-provided CloudWatch Logs resource. SubnetIpLimitExceeded Subnet IP limit exceeded. ENILimitExceeded ENI limit exceeded. BadPermissionsUserCredentials Unable to use the Role provided. InvalidBundleRobotApplication Robot bundle cannot be extracted (invalid format, bundling error, or other issue). InvalidBundleSimulationApplication Simulation bundle cannot be extracted (invalid format, bundling error, or other issue). RobotApplicationVersionMismatchedEtag Etag for RobotApplication does not match value during version creation. SimulationApplicationVersionMismatchedEtag Etag for SimulationApplication does not match value during version creation.
    public var failureCode: RoboMakerClientTypes.SimulationJobErrorCode?
    /// Details about why the simulation job failed. For more information about troubleshooting, see [Troubleshooting](https://docs.aws.amazon.com/robomaker/latest/dg/troubleshooting.html).
    public var failureReason: Swift.String?
    /// The IAM role that allows the simulation instance to call the AWS APIs that are specified in its associated policies on your behalf.
    public var iamRole: Swift.String?
    /// The time, in milliseconds since the epoch, when the simulation job was last started.
    public var lastStartedAt: ClientRuntime.Date?
    /// The time, in milliseconds since the epoch, when the simulation job was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The logging configuration.
    public var loggingConfig: RoboMakerClientTypes.LoggingConfig?
    /// The maximum job duration in seconds. The value must be 8 days (691,200 seconds) or less.
    public var maxJobDurationInSeconds: Swift.Int
    /// The name of the simulation job.
    public var name: Swift.String?
    /// The network interface information for the simulation job.
    public var networkInterface: RoboMakerClientTypes.NetworkInterface?
    /// Location for output files generated by the simulation job.
    public var outputLocation: RoboMakerClientTypes.OutputLocation?
    /// A list of robot applications.
    public var robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]?
    /// A list of simulation applications.
    public var simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]?
    /// The simulation job execution duration in milliseconds.
    public var simulationTimeMillis: Swift.Int
    /// The status of the simulation job.
    public var status: RoboMakerClientTypes.SimulationJobStatus?
    /// The list of all tags added to the specified simulation job.
    public var tags: [Swift.String:Swift.String]?
    /// The VPC configuration.
    public var vpcConfig: RoboMakerClientTypes.VPCConfigResponse?

    public init (
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        compute: RoboMakerClientTypes.ComputeResponse? = nil,
        dataSources: [RoboMakerClientTypes.DataSource]? = nil,
        failureBehavior: RoboMakerClientTypes.FailureBehavior? = nil,
        failureCode: RoboMakerClientTypes.SimulationJobErrorCode? = nil,
        failureReason: Swift.String? = nil,
        iamRole: Swift.String? = nil,
        lastStartedAt: ClientRuntime.Date? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        loggingConfig: RoboMakerClientTypes.LoggingConfig? = nil,
        maxJobDurationInSeconds: Swift.Int = 0,
        name: Swift.String? = nil,
        networkInterface: RoboMakerClientTypes.NetworkInterface? = nil,
        outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
        robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]? = nil,
        simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]? = nil,
        simulationTimeMillis: Swift.Int = 0,
        status: RoboMakerClientTypes.SimulationJobStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcConfig: RoboMakerClientTypes.VPCConfigResponse? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.compute = compute
        self.dataSources = dataSources
        self.failureBehavior = failureBehavior
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.iamRole = iamRole
        self.lastStartedAt = lastStartedAt
        self.lastUpdatedAt = lastUpdatedAt
        self.loggingConfig = loggingConfig
        self.maxJobDurationInSeconds = maxJobDurationInSeconds
        self.name = name
        self.networkInterface = networkInterface
        self.outputLocation = outputLocation
        self.robotApplications = robotApplications
        self.simulationApplications = simulationApplications
        self.simulationTimeMillis = simulationTimeMillis
        self.status = status
        self.tags = tags
        self.vpcConfig = vpcConfig
    }
}

struct DescribeSimulationJobOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let status: RoboMakerClientTypes.SimulationJobStatus?
    let lastStartedAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let failureBehavior: RoboMakerClientTypes.FailureBehavior?
    let failureCode: RoboMakerClientTypes.SimulationJobErrorCode?
    let failureReason: Swift.String?
    let clientRequestToken: Swift.String?
    let outputLocation: RoboMakerClientTypes.OutputLocation?
    let loggingConfig: RoboMakerClientTypes.LoggingConfig?
    let maxJobDurationInSeconds: Swift.Int
    let simulationTimeMillis: Swift.Int
    let iamRole: Swift.String?
    let robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]?
    let simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]?
    let dataSources: [RoboMakerClientTypes.DataSource]?
    let tags: [Swift.String:Swift.String]?
    let vpcConfig: RoboMakerClientTypes.VPCConfigResponse?
    let networkInterface: RoboMakerClientTypes.NetworkInterface?
    let compute: RoboMakerClientTypes.ComputeResponse?
}

extension DescribeSimulationJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case compute
        case dataSources
        case failureBehavior
        case failureCode
        case failureReason
        case iamRole
        case lastStartedAt
        case lastUpdatedAt
        case loggingConfig
        case maxJobDurationInSeconds
        case name
        case networkInterface
        case outputLocation
        case robotApplications
        case simulationApplications
        case simulationTimeMillis
        case status
        case tags
        case vpcConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobStatus.self, forKey: .status)
        status = statusDecoded
        let lastStartedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastStartedAt)
        lastStartedAt = lastStartedAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let failureBehaviorDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.FailureBehavior.self, forKey: .failureBehavior)
        failureBehavior = failureBehaviorDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let loggingConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.LoggingConfig.self, forKey: .loggingConfig)
        loggingConfig = loggingConfigDecoded
        let maxJobDurationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxJobDurationInSeconds) ?? 0
        maxJobDurationInSeconds = maxJobDurationInSecondsDecoded
        let simulationTimeMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .simulationTimeMillis) ?? 0
        simulationTimeMillis = simulationTimeMillisDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let robotApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.RobotApplicationConfig?].self, forKey: .robotApplications)
        var robotApplicationsDecoded0:[RoboMakerClientTypes.RobotApplicationConfig]? = nil
        if let robotApplicationsContainer = robotApplicationsContainer {
            robotApplicationsDecoded0 = [RoboMakerClientTypes.RobotApplicationConfig]()
            for structure0 in robotApplicationsContainer {
                if let structure0 = structure0 {
                    robotApplicationsDecoded0?.append(structure0)
                }
            }
        }
        robotApplications = robotApplicationsDecoded0
        let simulationApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationApplicationConfig?].self, forKey: .simulationApplications)
        var simulationApplicationsDecoded0:[RoboMakerClientTypes.SimulationApplicationConfig]? = nil
        if let simulationApplicationsContainer = simulationApplicationsContainer {
            simulationApplicationsDecoded0 = [RoboMakerClientTypes.SimulationApplicationConfig]()
            for structure0 in simulationApplicationsContainer {
                if let structure0 = structure0 {
                    simulationApplicationsDecoded0?.append(structure0)
                }
            }
        }
        simulationApplications = simulationApplicationsDecoded0
        let dataSourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[RoboMakerClientTypes.DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [RoboMakerClientTypes.DataSource]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let vpcConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.VPCConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let networkInterfaceDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.NetworkInterface.self, forKey: .networkInterface)
        networkInterface = networkInterfaceDecoded
        let computeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.ComputeResponse.self, forKey: .compute)
        compute = computeDecoded
    }
}

extension DescribeWorldExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = self.job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

extension DescribeWorldExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeWorldExportJob"
    }
}

public struct DescribeWorldExportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the world export job to describe.
    /// This member is required.
    public var job: Swift.String?

    public init (
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

struct DescribeWorldExportJobInputBody: Swift.Equatable {
    let job: Swift.String?
}

extension DescribeWorldExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .job)
        job = jobDecoded
    }
}

extension DescribeWorldExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorldExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeWorldExportJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorldExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeWorldExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.iamRole = output.iamRole
            self.outputLocation = output.outputLocation
            self.status = output.status
            self.tags = output.tags
            self.worlds = output.worlds
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.failureCode = nil
            self.failureReason = nil
            self.iamRole = nil
            self.outputLocation = nil
            self.status = nil
            self.tags = nil
            self.worlds = nil
        }
    }
}

public struct DescribeWorldExportJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the world export job.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the world export job was created.
    public var createdAt: ClientRuntime.Date?
    /// The failure code of the world export job if it failed: InternalServiceError Internal service error. LimitExceeded The requested resource exceeds the maximum number allowed, or the number of concurrent stream requests exceeds the maximum number allowed. ResourceNotFound The specified resource could not be found. RequestThrottled The request was throttled. InvalidInput An input parameter in the request is not valid.
    public var failureCode: RoboMakerClientTypes.WorldExportJobErrorCode?
    /// The reason why the world export job failed.
    public var failureReason: Swift.String?
    /// The IAM role that the world export process uses to access the Amazon S3 bucket and put the export.
    public var iamRole: Swift.String?
    /// The output location.
    public var outputLocation: RoboMakerClientTypes.OutputLocation?
    /// The status of the world export job. Pending The world export job request is pending. Running The world export job is running. Completed The world export job completed. Failed The world export job failed. See failureCode and failureReason for more information. Canceled The world export job was cancelled. Canceling The world export job is being cancelled.
    public var status: RoboMakerClientTypes.WorldExportJobStatus?
    /// A map that contains tag keys and tag values that are attached to the world export job.
    public var tags: [Swift.String:Swift.String]?
    /// A list of Amazon Resource Names (arns) that correspond to worlds to be exported.
    public var worlds: [Swift.String]?

    public init (
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        failureCode: RoboMakerClientTypes.WorldExportJobErrorCode? = nil,
        failureReason: Swift.String? = nil,
        iamRole: Swift.String? = nil,
        outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
        status: RoboMakerClientTypes.WorldExportJobStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        worlds: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.iamRole = iamRole
        self.outputLocation = outputLocation
        self.status = status
        self.tags = tags
        self.worlds = worlds
    }
}

struct DescribeWorldExportJobOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let status: RoboMakerClientTypes.WorldExportJobStatus?
    let createdAt: ClientRuntime.Date?
    let failureCode: RoboMakerClientTypes.WorldExportJobErrorCode?
    let failureReason: Swift.String?
    let clientRequestToken: Swift.String?
    let worlds: [Swift.String]?
    let outputLocation: RoboMakerClientTypes.OutputLocation?
    let iamRole: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeWorldExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case createdAt
        case failureCode
        case failureReason
        case iamRole
        case outputLocation
        case status
        case tags
        case worlds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldExportJobStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldExportJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let worldsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .worlds)
        var worldsDecoded0:[Swift.String]? = nil
        if let worldsContainer = worldsContainer {
            worldsDecoded0 = [Swift.String]()
            for string0 in worldsContainer {
                if let string0 = string0 {
                    worldsDecoded0?.append(string0)
                }
            }
        }
        worlds = worldsDecoded0
        let outputLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribeWorldGenerationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = self.job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

extension DescribeWorldGenerationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeWorldGenerationJob"
    }
}

public struct DescribeWorldGenerationJobInput: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the world generation job to describe.
    /// This member is required.
    public var job: Swift.String?

    public init (
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

struct DescribeWorldGenerationJobInputBody: Swift.Equatable {
    let job: Swift.String?
}

extension DescribeWorldGenerationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .job)
        job = jobDecoded
    }
}

extension DescribeWorldGenerationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorldGenerationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeWorldGenerationJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorldGenerationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeWorldGenerationJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.finishedWorldsSummary = output.finishedWorldsSummary
            self.status = output.status
            self.tags = output.tags
            self.template = output.template
            self.worldCount = output.worldCount
            self.worldTags = output.worldTags
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.failureCode = nil
            self.failureReason = nil
            self.finishedWorldsSummary = nil
            self.status = nil
            self.tags = nil
            self.template = nil
            self.worldCount = nil
            self.worldTags = nil
        }
    }
}

public struct DescribeWorldGenerationJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the world generation job.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the world generation job was created.
    public var createdAt: ClientRuntime.Date?
    /// The failure code of the world generation job if it failed: InternalServiceError Internal service error. LimitExceeded The requested resource exceeds the maximum number allowed, or the number of concurrent stream requests exceeds the maximum number allowed. ResourceNotFound The specified resource could not be found. RequestThrottled The request was throttled. InvalidInput An input parameter in the request is not valid.
    public var failureCode: RoboMakerClientTypes.WorldGenerationJobErrorCode?
    /// The reason why the world generation job failed.
    public var failureReason: Swift.String?
    /// Summary information about finished worlds.
    public var finishedWorldsSummary: RoboMakerClientTypes.FinishedWorldsSummary?
    /// The status of the world generation job: Pending The world generation job request is pending. Running The world generation job is running. Completed The world generation job completed. Failed The world generation job failed. See failureCode for more information. PartialFailed Some worlds did not generate. Canceled The world generation job was cancelled. Canceling The world generation job is being cancelled.
    public var status: RoboMakerClientTypes.WorldGenerationJobStatus?
    /// A map that contains tag keys and tag values that are attached to the world generation job.
    public var tags: [Swift.String:Swift.String]?
    /// The Amazon Resource Name (arn) of the world template.
    public var template: Swift.String?
    /// Information about the world count.
    public var worldCount: RoboMakerClientTypes.WorldCount?
    /// A map that contains tag keys and tag values that are attached to the generated worlds.
    public var worldTags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        failureCode: RoboMakerClientTypes.WorldGenerationJobErrorCode? = nil,
        failureReason: Swift.String? = nil,
        finishedWorldsSummary: RoboMakerClientTypes.FinishedWorldsSummary? = nil,
        status: RoboMakerClientTypes.WorldGenerationJobStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        template: Swift.String? = nil,
        worldCount: RoboMakerClientTypes.WorldCount? = nil,
        worldTags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.finishedWorldsSummary = finishedWorldsSummary
        self.status = status
        self.tags = tags
        self.template = template
        self.worldCount = worldCount
        self.worldTags = worldTags
    }
}

struct DescribeWorldGenerationJobOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let status: RoboMakerClientTypes.WorldGenerationJobStatus?
    let createdAt: ClientRuntime.Date?
    let failureCode: RoboMakerClientTypes.WorldGenerationJobErrorCode?
    let failureReason: Swift.String?
    let clientRequestToken: Swift.String?
    let template: Swift.String?
    let worldCount: RoboMakerClientTypes.WorldCount?
    let finishedWorldsSummary: RoboMakerClientTypes.FinishedWorldsSummary?
    let tags: [Swift.String:Swift.String]?
    let worldTags: [Swift.String:Swift.String]?
}

extension DescribeWorldGenerationJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case createdAt
        case failureCode
        case failureReason
        case finishedWorldsSummary
        case status
        case tags
        case template
        case worldCount
        case worldTags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldGenerationJobStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldGenerationJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
        let worldCountDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldCount.self, forKey: .worldCount)
        worldCount = worldCountDecoded
        let finishedWorldsSummaryDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.FinishedWorldsSummary.self, forKey: .finishedWorldsSummary)
        finishedWorldsSummary = finishedWorldsSummaryDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let worldTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .worldTags)
        var worldTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let worldTagsContainer = worldTagsContainer {
            worldTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in worldTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    worldTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        worldTags = worldTagsDecoded0
    }
}

extension DescribeWorldInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case world
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let world = self.world {
            try encodeContainer.encode(world, forKey: .world)
        }
    }
}

extension DescribeWorldInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeWorld"
    }
}

public struct DescribeWorldInput: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the world you want to describe.
    /// This member is required.
    public var world: Swift.String?

    public init (
        world: Swift.String? = nil
    )
    {
        self.world = world
    }
}

struct DescribeWorldInputBody: Swift.Equatable {
    let world: Swift.String?
}

extension DescribeWorldInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case world
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let worldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .world)
        world = worldDecoded
    }
}

extension DescribeWorldOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorldOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeWorldOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorldOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeWorldOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.generationJob = output.generationJob
            self.tags = output.tags
            self.template = output.template
            self.worldDescriptionBody = output.worldDescriptionBody
        } else {
            self.arn = nil
            self.createdAt = nil
            self.generationJob = nil
            self.tags = nil
            self.template = nil
            self.worldDescriptionBody = nil
        }
    }
}

public struct DescribeWorldOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the world.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the world was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon Resource Name (arn) of the world generation job that generated the world.
    public var generationJob: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the world.
    public var tags: [Swift.String:Swift.String]?
    /// The world template.
    public var template: Swift.String?
    /// Returns the JSON formatted string that describes the contents of your world.
    public var worldDescriptionBody: Swift.String?

    public init (
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        generationJob: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        template: Swift.String? = nil,
        worldDescriptionBody: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.generationJob = generationJob
        self.tags = tags
        self.template = template
        self.worldDescriptionBody = worldDescriptionBody
    }
}

struct DescribeWorldOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let generationJob: Swift.String?
    let template: Swift.String?
    let createdAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
    let worldDescriptionBody: Swift.String?
}

extension DescribeWorldOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case generationJob
        case tags
        case template
        case worldDescriptionBody
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let generationJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generationJob)
        generationJob = generationJobDecoded
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let worldDescriptionBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .worldDescriptionBody)
        worldDescriptionBody = worldDescriptionBodyDecoded
    }
}

extension DescribeWorldTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case template
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let template = self.template {
            try encodeContainer.encode(template, forKey: .template)
        }
    }
}

extension DescribeWorldTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeWorldTemplate"
    }
}

public struct DescribeWorldTemplateInput: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the world template you want to describe.
    /// This member is required.
    public var template: Swift.String?

    public init (
        template: Swift.String? = nil
    )
    {
        self.template = template
    }
}

struct DescribeWorldTemplateInputBody: Swift.Equatable {
    let template: Swift.String?
}

extension DescribeWorldTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case template
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
    }
}

extension DescribeWorldTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorldTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeWorldTemplateOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorldTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeWorldTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.tags = output.tags
            self.version = output.version
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.tags = nil
            self.version = nil
        }
    }
}

public struct DescribeWorldTemplateOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the world template.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the world template was created.
    public var createdAt: ClientRuntime.Date?
    /// The time, in milliseconds since the epoch, when the world template was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the world template.
    public var name: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the world template.
    public var tags: [Swift.String:Swift.String]?
    /// The version of the world template that you're using.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.tags = tags
        self.version = version
    }
}

struct DescribeWorldTemplateOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let clientRequestToken: Swift.String?
    let name: Swift.String?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
    let version: Swift.String?
}

extension DescribeWorldTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case createdAt
        case lastUpdatedAt
        case name
        case tags
        case version
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension RoboMakerClientTypes.Environment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
    }
}

extension RoboMakerClientTypes {
    /// The object that contains the Docker image URI for either your robot or simulation applications.
    public struct Environment: Swift.Equatable {
        /// The Docker image URI for either your robot or simulation applications.
        public var uri: Swift.String?

        public init (
            uri: Swift.String? = nil
        )
        {
            self.uri = uri
        }
    }

}

extension RoboMakerClientTypes {
    public enum ExitBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fail
        case restart
        case sdkUnknown(Swift.String)

        public static var allCases: [ExitBehavior] {
            return [
                .fail,
                .restart,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fail: return "FAIL"
            case .restart: return "RESTART"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExitBehavior(rawValue: rawValue) ?? ExitBehavior.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.FailedCreateSimulationJobRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedAt
        case failureCode
        case failureReason
        case request
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failedAt = self.failedAt {
            try encodeContainer.encodeTimestamp(failedAt, format: .epochSeconds, forKey: .failedAt)
        }
        if let failureCode = self.failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let request = self.request {
            try encodeContainer.encode(request, forKey: .request)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobRequest.self, forKey: .request)
        request = requestDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .failedAt)
        failedAt = failedAtDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a failed create simulation job request.
    public struct FailedCreateSimulationJobRequest: Swift.Equatable {
        /// The time, in milliseconds since the epoch, when the simulation job batch failed.
        public var failedAt: ClientRuntime.Date?
        /// The failure code.
        public var failureCode: RoboMakerClientTypes.SimulationJobErrorCode?
        /// The failure reason of the simulation job request.
        public var failureReason: Swift.String?
        /// The simulation job request.
        public var request: RoboMakerClientTypes.SimulationJobRequest?

        public init (
            failedAt: ClientRuntime.Date? = nil,
            failureCode: RoboMakerClientTypes.SimulationJobErrorCode? = nil,
            failureReason: Swift.String? = nil,
            request: RoboMakerClientTypes.SimulationJobRequest? = nil
        )
        {
            self.failedAt = failedAt
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.request = request
        }
    }

}

extension RoboMakerClientTypes {
    public enum FailureBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `continue`
        case fail
        case sdkUnknown(Swift.String)

        public static var allCases: [FailureBehavior] {
            return [
                .continue,
                .fail,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .continue: return "Continue"
            case .fail: return "Fail"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FailureBehavior(rawValue: rawValue) ?? FailureBehavior.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.FailureSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failures
        case totalFailureCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failures = failures {
            var failuresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .failures)
            for worldfailure0 in failures {
                try failuresContainer.encode(worldfailure0)
            }
        }
        if totalFailureCount != 0 {
            try encodeContainer.encode(totalFailureCount, forKey: .totalFailureCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalFailureCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalFailureCount) ?? 0
        totalFailureCount = totalFailureCountDecoded
        let failuresContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.WorldFailure?].self, forKey: .failures)
        var failuresDecoded0:[RoboMakerClientTypes.WorldFailure]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [RoboMakerClientTypes.WorldFailure]()
            for structure0 in failuresContainer {
                if let structure0 = structure0 {
                    failuresDecoded0?.append(structure0)
                }
            }
        }
        failures = failuresDecoded0
    }
}

extension RoboMakerClientTypes {
    /// Information about worlds that failed.
    public struct FailureSummary: Swift.Equatable {
        /// The worlds that failed.
        public var failures: [RoboMakerClientTypes.WorldFailure]?
        /// The total number of failures.
        public var totalFailureCount: Swift.Int

        public init (
            failures: [RoboMakerClientTypes.WorldFailure]? = nil,
            totalFailureCount: Swift.Int = 0
        )
        {
            self.failures = failures
            self.totalFailureCount = totalFailureCount
        }
    }

}

extension RoboMakerClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for name0 in values {
                try valuesContainer.encode(name0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension RoboMakerClientTypes {
    /// Information about a filter.
    public struct Filter: Swift.Equatable {
        /// The name of the filter.
        public var name: Swift.String?
        /// A list of values.
        public var values: [Swift.String]?

        public init (
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension RoboMakerClientTypes.FinishedWorldsSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureSummary
        case finishedCount
        case succeededWorlds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureSummary = self.failureSummary {
            try encodeContainer.encode(failureSummary, forKey: .failureSummary)
        }
        if finishedCount != 0 {
            try encodeContainer.encode(finishedCount, forKey: .finishedCount)
        }
        if let succeededWorlds = succeededWorlds {
            var succeededWorldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .succeededWorlds)
            for arn0 in succeededWorlds {
                try succeededWorldsContainer.encode(arn0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let finishedCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .finishedCount) ?? 0
        finishedCount = finishedCountDecoded
        let succeededWorldsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .succeededWorlds)
        var succeededWorldsDecoded0:[Swift.String]? = nil
        if let succeededWorldsContainer = succeededWorldsContainer {
            succeededWorldsDecoded0 = [Swift.String]()
            for string0 in succeededWorldsContainer {
                if let string0 = string0 {
                    succeededWorldsDecoded0?.append(string0)
                }
            }
        }
        succeededWorlds = succeededWorldsDecoded0
        let failureSummaryDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.FailureSummary.self, forKey: .failureSummary)
        failureSummary = failureSummaryDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about worlds that finished.
    public struct FinishedWorldsSummary: Swift.Equatable {
        /// Information about worlds that failed.
        public var failureSummary: RoboMakerClientTypes.FailureSummary?
        /// The total number of finished worlds.
        public var finishedCount: Swift.Int
        /// A list of worlds that succeeded.
        public var succeededWorlds: [Swift.String]?

        public init (
            failureSummary: RoboMakerClientTypes.FailureSummary? = nil,
            finishedCount: Swift.Int = 0,
            succeededWorlds: [Swift.String]? = nil
        )
        {
            self.failureSummary = failureSummary
            self.finishedCount = finishedCount
            self.succeededWorlds = succeededWorlds
        }
    }

}

extension RoboMakerClientTypes.Fleet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case lastDeploymentJob
        case lastDeploymentStatus
        case lastDeploymentTime
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let lastDeploymentJob = self.lastDeploymentJob {
            try encodeContainer.encode(lastDeploymentJob, forKey: .lastDeploymentJob)
        }
        if let lastDeploymentStatus = self.lastDeploymentStatus {
            try encodeContainer.encode(lastDeploymentStatus.rawValue, forKey: .lastDeploymentStatus)
        }
        if let lastDeploymentTime = self.lastDeploymentTime {
            try encodeContainer.encodeTimestamp(lastDeploymentTime, format: .epochSeconds, forKey: .lastDeploymentTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastDeploymentStatusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentStatus.self, forKey: .lastDeploymentStatus)
        lastDeploymentStatus = lastDeploymentStatusDecoded
        let lastDeploymentJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastDeploymentJob)
        lastDeploymentJob = lastDeploymentJobDecoded
        let lastDeploymentTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastDeploymentTime)
        lastDeploymentTime = lastDeploymentTimeDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a fleet.
    public struct Fleet: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the fleet.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the fleet was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the last deployment job.
        public var lastDeploymentJob: Swift.String?
        /// The status of the last fleet deployment.
        public var lastDeploymentStatus: RoboMakerClientTypes.DeploymentStatus?
        /// The time of the last deployment.
        public var lastDeploymentTime: ClientRuntime.Date?
        /// The name of the fleet.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            lastDeploymentJob: Swift.String? = nil,
            lastDeploymentStatus: RoboMakerClientTypes.DeploymentStatus? = nil,
            lastDeploymentTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.lastDeploymentJob = lastDeploymentJob
            self.lastDeploymentStatus = lastDeploymentStatus
            self.lastDeploymentTime = lastDeploymentTime
            self.name = name
        }
    }

}

extension GetWorldTemplateBodyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generationJob
        case template
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let generationJob = self.generationJob {
            try encodeContainer.encode(generationJob, forKey: .generationJob)
        }
        if let template = self.template {
            try encodeContainer.encode(template, forKey: .template)
        }
    }
}

extension GetWorldTemplateBodyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getWorldTemplateBody"
    }
}

public struct GetWorldTemplateBodyInput: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the world generator job.
    public var generationJob: Swift.String?
    /// The Amazon Resource Name (arn) of the world template.
    public var template: Swift.String?

    public init (
        generationJob: Swift.String? = nil,
        template: Swift.String? = nil
    )
    {
        self.generationJob = generationJob
        self.template = template
    }
}

struct GetWorldTemplateBodyInputBody: Swift.Equatable {
    let template: Swift.String?
    let generationJob: Swift.String?
}

extension GetWorldTemplateBodyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generationJob
        case template
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
        let generationJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generationJob)
        generationJob = generationJobDecoded
    }
}

extension GetWorldTemplateBodyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWorldTemplateBodyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetWorldTemplateBodyOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWorldTemplateBodyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetWorldTemplateBodyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.templateBody = output.templateBody
        } else {
            self.templateBody = nil
        }
    }
}

public struct GetWorldTemplateBodyOutputResponse: Swift.Equatable {
    /// The world template body.
    public var templateBody: Swift.String?

    public init (
        templateBody: Swift.String? = nil
    )
    {
        self.templateBody = templateBody
    }
}

struct GetWorldTemplateBodyOutputResponseBody: Swift.Equatable {
    let templateBody: Swift.String?
}

extension GetWorldTemplateBodyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateBody
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
    }
}

extension IdempotentParameterMismatchException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: IdempotentParameterMismatchExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request uses the same client token as a previous, but non-identical request. Do not reuse a client token with different requests, unless the requests are identical.
public struct IdempotentParameterMismatchException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IdempotentParameterMismatchExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension IdempotentParameterMismatchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// AWS RoboMaker experienced a service issue. Try your call again.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A parameter specified in a request is not valid, is unsupported, or cannot be used. The returned message provides an explanation of the error value.
public struct InvalidParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RoboMakerClientTypes.LaunchConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case command
        case environmentVariables
        case launchFile
        case packageName
        case portForwardingConfig
        case streamUI
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let command = command {
            var commandContainer = encodeContainer.nestedUnkeyedContainer(forKey: .command)
            for nonemptystring0 in command {
                try commandContainer.encode(nonemptystring0)
            }
        }
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .environmentVariables)
            for (dictKey0, environmentVariableMap0) in environmentVariables {
                try environmentVariablesContainer.encode(environmentVariableMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let launchFile = self.launchFile {
            try encodeContainer.encode(launchFile, forKey: .launchFile)
        }
        if let packageName = self.packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let portForwardingConfig = self.portForwardingConfig {
            try encodeContainer.encode(portForwardingConfig, forKey: .portForwardingConfig)
        }
        if streamUI != false {
            try encodeContainer.encode(streamUI, forKey: .streamUI)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let launchFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchFile)
        launchFile = launchFileDecoded
        let environmentVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .environmentVariables)
        var environmentVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let environmentVariablesContainer = environmentVariablesContainer {
            environmentVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, environmentvariablevalue0) in environmentVariablesContainer {
                if let environmentvariablevalue0 = environmentvariablevalue0 {
                    environmentVariablesDecoded0?[key0] = environmentvariablevalue0
                }
            }
        }
        environmentVariables = environmentVariablesDecoded0
        let portForwardingConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.PortForwardingConfig.self, forKey: .portForwardingConfig)
        portForwardingConfig = portForwardingConfigDecoded
        let streamUIDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .streamUI) ?? false
        streamUI = streamUIDecoded
        let commandContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .command)
        var commandDecoded0:[Swift.String]? = nil
        if let commandContainer = commandContainer {
            commandDecoded0 = [Swift.String]()
            for string0 in commandContainer {
                if let string0 = string0 {
                    commandDecoded0?.append(string0)
                }
            }
        }
        command = commandDecoded0
    }
}

extension RoboMakerClientTypes {
    /// Information about a launch configuration.
    public struct LaunchConfig: Swift.Equatable {
        /// If you've specified General as the value for your RobotSoftwareSuite, you can use this field to specify a list of commands for your container image. If you've specified SimulationRuntime as the value for your SimulationSoftwareSuite, you can use this field to specify a list of commands for your container image.
        public var command: [Swift.String]?
        /// The environment variables for the application launch.
        public var environmentVariables: [Swift.String:Swift.String]?
        /// The launch file name.
        public var launchFile: Swift.String?
        /// The package name.
        public var packageName: Swift.String?
        /// The port forwarding configuration.
        public var portForwardingConfig: RoboMakerClientTypes.PortForwardingConfig?
        /// Boolean indicating whether a streaming session will be configured for the application. If True, AWS RoboMaker will configure a connection so you can interact with your application as it is running in the simulation. You must configure and launch the component. It must have a graphical user interface.
        public var streamUI: Swift.Bool

        public init (
            command: [Swift.String]? = nil,
            environmentVariables: [Swift.String:Swift.String]? = nil,
            launchFile: Swift.String? = nil,
            packageName: Swift.String? = nil,
            portForwardingConfig: RoboMakerClientTypes.PortForwardingConfig? = nil,
            streamUI: Swift.Bool = false
        )
        {
            self.command = command
            self.environmentVariables = environmentVariables
            self.launchFile = launchFile
            self.packageName = packageName
            self.portForwardingConfig = portForwardingConfig
            self.streamUI = streamUI
        }
    }

}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested resource exceeds the maximum number allowed, or the number of concurrent stream requests exceeds the maximum number allowed.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListDeploymentJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDeploymentJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listDeploymentJobs"
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct ListDeploymentJobsInput: Swift.Equatable {
    /// Optional filters to limit results. The filter names status and fleetName are supported. When filtering, you must use the complete value of the filtered item. You can use up to three filters, but they must be for the same named item. For example, if you are looking for items with the status InProgress or the status Pending.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListDeploymentJobs only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListDeploymentJobs request with the returned nextToken value. This value can be between 1 and 200. If this parameter is not used, then ListDeploymentJobs returns up to 200 results and a nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListDeploymentJobs again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init (
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeploymentJobsInputBody: Swift.Equatable {
    let filters: [RoboMakerClientTypes.Filter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDeploymentJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[RoboMakerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [RoboMakerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDeploymentJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeploymentJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDeploymentJobsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeploymentJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDeploymentJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deploymentJobs = output.deploymentJobs
            self.nextToken = output.nextToken
        } else {
            self.deploymentJobs = nil
            self.nextToken = nil
        }
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct ListDeploymentJobsOutputResponse: Swift.Equatable {
    /// A list of deployment jobs that meet the criteria of the request.
    public var deploymentJobs: [RoboMakerClientTypes.DeploymentJob]?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListDeploymentJobs again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init (
        deploymentJobs: [RoboMakerClientTypes.DeploymentJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deploymentJobs = deploymentJobs
        self.nextToken = nextToken
    }
}

struct ListDeploymentJobsOutputResponseBody: Swift.Equatable {
    let deploymentJobs: [RoboMakerClientTypes.DeploymentJob]?
    let nextToken: Swift.String?
}

extension ListDeploymentJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentJobs
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentJobsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DeploymentJob?].self, forKey: .deploymentJobs)
        var deploymentJobsDecoded0:[RoboMakerClientTypes.DeploymentJob]? = nil
        if let deploymentJobsContainer = deploymentJobsContainer {
            deploymentJobsDecoded0 = [RoboMakerClientTypes.DeploymentJob]()
            for structure0 in deploymentJobsContainer {
                if let structure0 = structure0 {
                    deploymentJobsDecoded0?.append(structure0)
                }
            }
        }
        deploymentJobs = deploymentJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFleetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListFleetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listFleets"
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct ListFleetsInput: Swift.Equatable {
    /// Optional filters to limit results. The filter name name is supported. When filtering, you must use the complete value of the filtered item. You can use up to three filters.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListFleets only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListFleets request with the returned nextToken value. This value can be between 1 and 200. If this parameter is not used, then ListFleets returns up to 200 results and a nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListFleets again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null. This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.
    public var nextToken: Swift.String?

    public init (
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFleetsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [RoboMakerClientTypes.Filter]?
}

extension ListFleetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[RoboMakerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [RoboMakerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListFleetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFleetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListFleetsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFleetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListFleetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fleetDetails = output.fleetDetails
            self.nextToken = output.nextToken
        } else {
            self.fleetDetails = nil
            self.nextToken = nil
        }
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct ListFleetsOutputResponse: Swift.Equatable {
    /// A list of fleet details meeting the request criteria.
    public var fleetDetails: [RoboMakerClientTypes.Fleet]?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListFleets again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init (
        fleetDetails: [RoboMakerClientTypes.Fleet]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetDetails = fleetDetails
        self.nextToken = nextToken
    }
}

struct ListFleetsOutputResponseBody: Swift.Equatable {
    let fleetDetails: [RoboMakerClientTypes.Fleet]?
    let nextToken: Swift.String?
}

extension ListFleetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetDetails
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDetailsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Fleet?].self, forKey: .fleetDetails)
        var fleetDetailsDecoded0:[RoboMakerClientTypes.Fleet]? = nil
        if let fleetDetailsContainer = fleetDetailsContainer {
            fleetDetailsDecoded0 = [RoboMakerClientTypes.Fleet]()
            for structure0 in fleetDetailsContainer {
                if let structure0 = structure0 {
                    fleetDetailsDecoded0?.append(structure0)
                }
            }
        }
        fleetDetails = fleetDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRobotApplicationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case versionQualifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let versionQualifier = self.versionQualifier {
            try encodeContainer.encode(versionQualifier, forKey: .versionQualifier)
        }
    }
}

extension ListRobotApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listRobotApplications"
    }
}

public struct ListRobotApplicationsInput: Swift.Equatable {
    /// Optional filters to limit results. The filter name name is supported. When filtering, you must use the complete value of the filtered item. You can use up to three filters.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListRobotApplications only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListRobotApplications request with the returned nextToken value. This value can be between 1 and 100. If this parameter is not used, then ListRobotApplications returns up to 100 results and a nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListRobotApplications again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// The version qualifier of the robot application.
    public var versionQualifier: Swift.String?

    public init (
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        versionQualifier: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.versionQualifier = versionQualifier
    }
}

struct ListRobotApplicationsInputBody: Swift.Equatable {
    let versionQualifier: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [RoboMakerClientTypes.Filter]?
}

extension ListRobotApplicationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case versionQualifier
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionQualifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionQualifier)
        versionQualifier = versionQualifierDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[RoboMakerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [RoboMakerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListRobotApplicationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRobotApplicationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRobotApplicationsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRobotApplicationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRobotApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.robotApplicationSummaries = output.robotApplicationSummaries
        } else {
            self.nextToken = nil
            self.robotApplicationSummaries = nil
        }
    }
}

public struct ListRobotApplicationsOutputResponse: Swift.Equatable {
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListRobotApplications again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// A list of robot application summaries that meet the criteria of the request.
    public var robotApplicationSummaries: [RoboMakerClientTypes.RobotApplicationSummary]?

    public init (
        nextToken: Swift.String? = nil,
        robotApplicationSummaries: [RoboMakerClientTypes.RobotApplicationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.robotApplicationSummaries = robotApplicationSummaries
    }
}

struct ListRobotApplicationsOutputResponseBody: Swift.Equatable {
    let robotApplicationSummaries: [RoboMakerClientTypes.RobotApplicationSummary]?
    let nextToken: Swift.String?
}

extension ListRobotApplicationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case robotApplicationSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let robotApplicationSummariesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.RobotApplicationSummary?].self, forKey: .robotApplicationSummaries)
        var robotApplicationSummariesDecoded0:[RoboMakerClientTypes.RobotApplicationSummary]? = nil
        if let robotApplicationSummariesContainer = robotApplicationSummariesContainer {
            robotApplicationSummariesDecoded0 = [RoboMakerClientTypes.RobotApplicationSummary]()
            for structure0 in robotApplicationSummariesContainer {
                if let structure0 = structure0 {
                    robotApplicationSummariesDecoded0?.append(structure0)
                }
            }
        }
        robotApplicationSummaries = robotApplicationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRobotsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListRobotsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listRobots"
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct ListRobotsInput: Swift.Equatable {
    /// Optional filters to limit results. The filter names status and fleetName are supported. When filtering, you must use the complete value of the filtered item. You can use up to three filters, but they must be for the same named item. For example, if you are looking for items with the status Registered or the status Available.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListRobots only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListRobots request with the returned nextToken value. This value can be between 1 and 200. If this parameter is not used, then ListRobots returns up to 200 results and a nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListRobots again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init (
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRobotsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [RoboMakerClientTypes.Filter]?
}

extension ListRobotsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[RoboMakerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [RoboMakerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListRobotsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRobotsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRobotsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRobotsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRobotsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.robots = output.robots
        } else {
            self.nextToken = nil
            self.robots = nil
        }
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct ListRobotsOutputResponse: Swift.Equatable {
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListRobots again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// A list of robots that meet the criteria of the request.
    public var robots: [RoboMakerClientTypes.Robot]?

    public init (
        nextToken: Swift.String? = nil,
        robots: [RoboMakerClientTypes.Robot]? = nil
    )
    {
        self.nextToken = nextToken
        self.robots = robots
    }
}

struct ListRobotsOutputResponseBody: Swift.Equatable {
    let robots: [RoboMakerClientTypes.Robot]?
    let nextToken: Swift.String?
}

extension ListRobotsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case robots
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let robotsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Robot?].self, forKey: .robots)
        var robotsDecoded0:[RoboMakerClientTypes.Robot]? = nil
        if let robotsContainer = robotsContainer {
            robotsDecoded0 = [RoboMakerClientTypes.Robot]()
            for structure0 in robotsContainer {
                if let structure0 = structure0 {
                    robotsDecoded0?.append(structure0)
                }
            }
        }
        robots = robotsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSimulationApplicationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case versionQualifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let versionQualifier = self.versionQualifier {
            try encodeContainer.encode(versionQualifier, forKey: .versionQualifier)
        }
    }
}

extension ListSimulationApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listSimulationApplications"
    }
}

public struct ListSimulationApplicationsInput: Swift.Equatable {
    /// Optional list of filters to limit results. The filter name name is supported. When filtering, you must use the complete value of the filtered item. You can use up to three filters.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListSimulationApplications only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListSimulationApplications request with the returned nextToken value. This value can be between 1 and 100. If this parameter is not used, then ListSimulationApplications returns up to 100 results and a nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListSimulationApplications again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// The version qualifier of the simulation application.
    public var versionQualifier: Swift.String?

    public init (
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        versionQualifier: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.versionQualifier = versionQualifier
    }
}

struct ListSimulationApplicationsInputBody: Swift.Equatable {
    let versionQualifier: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [RoboMakerClientTypes.Filter]?
}

extension ListSimulationApplicationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case versionQualifier
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionQualifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionQualifier)
        versionQualifier = versionQualifierDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[RoboMakerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [RoboMakerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListSimulationApplicationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSimulationApplicationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSimulationApplicationsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSimulationApplicationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSimulationApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.simulationApplicationSummaries = output.simulationApplicationSummaries
        } else {
            self.nextToken = nil
            self.simulationApplicationSummaries = nil
        }
    }
}

public struct ListSimulationApplicationsOutputResponse: Swift.Equatable {
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListSimulationApplications again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// A list of simulation application summaries that meet the criteria of the request.
    public var simulationApplicationSummaries: [RoboMakerClientTypes.SimulationApplicationSummary]?

    public init (
        nextToken: Swift.String? = nil,
        simulationApplicationSummaries: [RoboMakerClientTypes.SimulationApplicationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.simulationApplicationSummaries = simulationApplicationSummaries
    }
}

struct ListSimulationApplicationsOutputResponseBody: Swift.Equatable {
    let simulationApplicationSummaries: [RoboMakerClientTypes.SimulationApplicationSummary]?
    let nextToken: Swift.String?
}

extension ListSimulationApplicationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case simulationApplicationSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simulationApplicationSummariesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationApplicationSummary?].self, forKey: .simulationApplicationSummaries)
        var simulationApplicationSummariesDecoded0:[RoboMakerClientTypes.SimulationApplicationSummary]? = nil
        if let simulationApplicationSummariesContainer = simulationApplicationSummariesContainer {
            simulationApplicationSummariesDecoded0 = [RoboMakerClientTypes.SimulationApplicationSummary]()
            for structure0 in simulationApplicationSummariesContainer {
                if let structure0 = structure0 {
                    simulationApplicationSummariesDecoded0?.append(structure0)
                }
            }
        }
        simulationApplicationSummaries = simulationApplicationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSimulationJobBatchesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSimulationJobBatchesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listSimulationJobBatches"
    }
}

public struct ListSimulationJobBatchesInput: Swift.Equatable {
    /// Optional filters to limit results.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListSimulationJobBatches only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListSimulationJobBatches request with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListSimulationJobBatches again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init (
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSimulationJobBatchesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [RoboMakerClientTypes.Filter]?
}

extension ListSimulationJobBatchesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[RoboMakerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [RoboMakerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListSimulationJobBatchesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSimulationJobBatchesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSimulationJobBatchesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSimulationJobBatchesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSimulationJobBatchesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.simulationJobBatchSummaries = output.simulationJobBatchSummaries
        } else {
            self.nextToken = nil
            self.simulationJobBatchSummaries = nil
        }
    }
}

public struct ListSimulationJobBatchesOutputResponse: Swift.Equatable {
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListSimulationJobBatches again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// A list of simulation job batch summaries.
    public var simulationJobBatchSummaries: [RoboMakerClientTypes.SimulationJobBatchSummary]?

    public init (
        nextToken: Swift.String? = nil,
        simulationJobBatchSummaries: [RoboMakerClientTypes.SimulationJobBatchSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.simulationJobBatchSummaries = simulationJobBatchSummaries
    }
}

struct ListSimulationJobBatchesOutputResponseBody: Swift.Equatable {
    let simulationJobBatchSummaries: [RoboMakerClientTypes.SimulationJobBatchSummary]?
    let nextToken: Swift.String?
}

extension ListSimulationJobBatchesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case simulationJobBatchSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simulationJobBatchSummariesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationJobBatchSummary?].self, forKey: .simulationJobBatchSummaries)
        var simulationJobBatchSummariesDecoded0:[RoboMakerClientTypes.SimulationJobBatchSummary]? = nil
        if let simulationJobBatchSummariesContainer = simulationJobBatchSummariesContainer {
            simulationJobBatchSummariesDecoded0 = [RoboMakerClientTypes.SimulationJobBatchSummary]()
            for structure0 in simulationJobBatchSummariesContainer {
                if let structure0 = structure0 {
                    simulationJobBatchSummariesDecoded0?.append(structure0)
                }
            }
        }
        simulationJobBatchSummaries = simulationJobBatchSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSimulationJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSimulationJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listSimulationJobs"
    }
}

public struct ListSimulationJobsInput: Swift.Equatable {
    /// Optional filters to limit results. The filter names status and simulationApplicationName and robotApplicationName are supported. When filtering, you must use the complete value of the filtered item. You can use up to three filters, but they must be for the same named item. For example, if you are looking for items with the status Preparing or the status Running.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListSimulationJobs only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListSimulationJobs request with the returned nextToken value. This value can be between 1 and 1000. If this parameter is not used, then ListSimulationJobs returns up to 1000 results and a nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListSimulationJobs again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init (
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSimulationJobsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [RoboMakerClientTypes.Filter]?
}

extension ListSimulationJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[RoboMakerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [RoboMakerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListSimulationJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSimulationJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSimulationJobsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSimulationJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSimulationJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.simulationJobSummaries = output.simulationJobSummaries
        } else {
            self.nextToken = nil
            self.simulationJobSummaries = nil
        }
    }
}

public struct ListSimulationJobsOutputResponse: Swift.Equatable {
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListSimulationJobs again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// A list of simulation job summaries that meet the criteria of the request.
    /// This member is required.
    public var simulationJobSummaries: [RoboMakerClientTypes.SimulationJobSummary]?

    public init (
        nextToken: Swift.String? = nil,
        simulationJobSummaries: [RoboMakerClientTypes.SimulationJobSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.simulationJobSummaries = simulationJobSummaries
    }
}

struct ListSimulationJobsOutputResponseBody: Swift.Equatable {
    let simulationJobSummaries: [RoboMakerClientTypes.SimulationJobSummary]?
    let nextToken: Swift.String?
}

extension ListSimulationJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case simulationJobSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simulationJobSummariesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationJobSummary?].self, forKey: .simulationJobSummaries)
        var simulationJobSummariesDecoded0:[RoboMakerClientTypes.SimulationJobSummary]? = nil
        if let simulationJobSummariesContainer = simulationJobSummariesContainer {
            simulationJobSummariesDecoded0 = [RoboMakerClientTypes.SimulationJobSummary]()
            for structure0 in simulationJobSummariesContainer {
                if let structure0 = structure0 {
                    simulationJobSummariesDecoded0?.append(structure0)
                }
            }
        }
        simulationJobSummaries = simulationJobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The AWS RoboMaker Amazon Resource Name (ARN) with tags to be listed.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The list of all tags added to the specified resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListWorldExportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWorldExportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listWorldExportJobs"
    }
}

public struct ListWorldExportJobsInput: Swift.Equatable {
    /// Optional filters to limit results. You can use generationJobId and templateId.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListWorldExportJobs only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListWorldExportJobs request with the returned nextToken value. This value can be between 1 and 100. If this parameter is not used, then ListWorldExportJobs returns up to 100 results and a nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorldExportJobs again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init (
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorldExportJobsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [RoboMakerClientTypes.Filter]?
}

extension ListWorldExportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[RoboMakerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [RoboMakerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListWorldExportJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorldExportJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListWorldExportJobsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorldExportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListWorldExportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.worldExportJobSummaries = output.worldExportJobSummaries
        } else {
            self.nextToken = nil
            self.worldExportJobSummaries = nil
        }
    }
}

public struct ListWorldExportJobsOutputResponse: Swift.Equatable {
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorldExportJobsRequest again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// Summary information for world export jobs.
    /// This member is required.
    public var worldExportJobSummaries: [RoboMakerClientTypes.WorldExportJobSummary]?

    public init (
        nextToken: Swift.String? = nil,
        worldExportJobSummaries: [RoboMakerClientTypes.WorldExportJobSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.worldExportJobSummaries = worldExportJobSummaries
    }
}

struct ListWorldExportJobsOutputResponseBody: Swift.Equatable {
    let worldExportJobSummaries: [RoboMakerClientTypes.WorldExportJobSummary]?
    let nextToken: Swift.String?
}

extension ListWorldExportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case worldExportJobSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let worldExportJobSummariesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.WorldExportJobSummary?].self, forKey: .worldExportJobSummaries)
        var worldExportJobSummariesDecoded0:[RoboMakerClientTypes.WorldExportJobSummary]? = nil
        if let worldExportJobSummariesContainer = worldExportJobSummariesContainer {
            worldExportJobSummariesDecoded0 = [RoboMakerClientTypes.WorldExportJobSummary]()
            for structure0 in worldExportJobSummariesContainer {
                if let structure0 = structure0 {
                    worldExportJobSummariesDecoded0?.append(structure0)
                }
            }
        }
        worldExportJobSummaries = worldExportJobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListWorldGenerationJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWorldGenerationJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listWorldGenerationJobs"
    }
}

public struct ListWorldGenerationJobsInput: Swift.Equatable {
    /// Optional filters to limit results. You can use status and templateId.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListWorldGeneratorJobs only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListWorldGeneratorJobs request with the returned nextToken value. This value can be between 1 and 100. If this parameter is not used, then ListWorldGeneratorJobs returns up to 100 results and a nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorldGenerationJobsRequest again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init (
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorldGenerationJobsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [RoboMakerClientTypes.Filter]?
}

extension ListWorldGenerationJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[RoboMakerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [RoboMakerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListWorldGenerationJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorldGenerationJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListWorldGenerationJobsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorldGenerationJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListWorldGenerationJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.worldGenerationJobSummaries = output.worldGenerationJobSummaries
        } else {
            self.nextToken = nil
            self.worldGenerationJobSummaries = nil
        }
    }
}

public struct ListWorldGenerationJobsOutputResponse: Swift.Equatable {
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorldGeneratorJobsRequest again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// Summary information for world generator jobs.
    /// This member is required.
    public var worldGenerationJobSummaries: [RoboMakerClientTypes.WorldGenerationJobSummary]?

    public init (
        nextToken: Swift.String? = nil,
        worldGenerationJobSummaries: [RoboMakerClientTypes.WorldGenerationJobSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.worldGenerationJobSummaries = worldGenerationJobSummaries
    }
}

struct ListWorldGenerationJobsOutputResponseBody: Swift.Equatable {
    let worldGenerationJobSummaries: [RoboMakerClientTypes.WorldGenerationJobSummary]?
    let nextToken: Swift.String?
}

extension ListWorldGenerationJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case worldGenerationJobSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let worldGenerationJobSummariesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.WorldGenerationJobSummary?].self, forKey: .worldGenerationJobSummaries)
        var worldGenerationJobSummariesDecoded0:[RoboMakerClientTypes.WorldGenerationJobSummary]? = nil
        if let worldGenerationJobSummariesContainer = worldGenerationJobSummariesContainer {
            worldGenerationJobSummariesDecoded0 = [RoboMakerClientTypes.WorldGenerationJobSummary]()
            for structure0 in worldGenerationJobSummariesContainer {
                if let structure0 = structure0 {
                    worldGenerationJobSummariesDecoded0?.append(structure0)
                }
            }
        }
        worldGenerationJobSummaries = worldGenerationJobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListWorldTemplatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWorldTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listWorldTemplates"
    }
}

public struct ListWorldTemplatesInput: Swift.Equatable {
    /// When this parameter is used, ListWorldTemplates only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListWorldTemplates request with the returned nextToken value. This value can be between 1 and 100. If this parameter is not used, then ListWorldTemplates returns up to 100 results and a nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorldTemplates again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorldTemplatesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListWorldTemplatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListWorldTemplatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorldTemplatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListWorldTemplatesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorldTemplatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListWorldTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.templateSummaries = output.templateSummaries
        } else {
            self.nextToken = nil
            self.templateSummaries = nil
        }
    }
}

public struct ListWorldTemplatesOutputResponse: Swift.Equatable {
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorldTemplates again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// Summary information for templates.
    public var templateSummaries: [RoboMakerClientTypes.TemplateSummary]?

    public init (
        nextToken: Swift.String? = nil,
        templateSummaries: [RoboMakerClientTypes.TemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.templateSummaries = templateSummaries
    }
}

struct ListWorldTemplatesOutputResponseBody: Swift.Equatable {
    let templateSummaries: [RoboMakerClientTypes.TemplateSummary]?
    let nextToken: Swift.String?
}

extension ListWorldTemplatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case templateSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateSummariesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.TemplateSummary?].self, forKey: .templateSummaries)
        var templateSummariesDecoded0:[RoboMakerClientTypes.TemplateSummary]? = nil
        if let templateSummariesContainer = templateSummariesContainer {
            templateSummariesDecoded0 = [RoboMakerClientTypes.TemplateSummary]()
            for structure0 in templateSummariesContainer {
                if let structure0 = structure0 {
                    templateSummariesDecoded0?.append(structure0)
                }
            }
        }
        templateSummaries = templateSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListWorldsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWorldsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listWorlds"
    }
}

public struct ListWorldsInput: Swift.Equatable {
    /// Optional filters to limit results. You can use status.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListWorlds only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListWorlds request with the returned nextToken value. This value can be between 1 and 100. If this parameter is not used, then ListWorlds returns up to 100 results and a nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorlds again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init (
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorldsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [RoboMakerClientTypes.Filter]?
}

extension ListWorldsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[RoboMakerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [RoboMakerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListWorldsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorldsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListWorldsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorldsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListWorldsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.worldSummaries = output.worldSummaries
        } else {
            self.nextToken = nil
            self.worldSummaries = nil
        }
    }
}

public struct ListWorldsOutputResponse: Swift.Equatable {
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorlds again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// Summary information for worlds.
    public var worldSummaries: [RoboMakerClientTypes.WorldSummary]?

    public init (
        nextToken: Swift.String? = nil,
        worldSummaries: [RoboMakerClientTypes.WorldSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.worldSummaries = worldSummaries
    }
}

struct ListWorldsOutputResponseBody: Swift.Equatable {
    let worldSummaries: [RoboMakerClientTypes.WorldSummary]?
    let nextToken: Swift.String?
}

extension ListWorldsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case worldSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let worldSummariesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.WorldSummary?].self, forKey: .worldSummaries)
        var worldSummariesDecoded0:[RoboMakerClientTypes.WorldSummary]? = nil
        if let worldSummariesContainer = worldSummariesContainer {
            worldSummariesDecoded0 = [RoboMakerClientTypes.WorldSummary]()
            for structure0 in worldSummariesContainer {
                if let structure0 = structure0 {
                    worldSummariesDecoded0?.append(structure0)
                }
            }
        }
        worldSummaries = worldSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension RoboMakerClientTypes.LoggingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordAllRosTopics
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recordAllRosTopics = self.recordAllRosTopics {
            try encodeContainer.encode(recordAllRosTopics, forKey: .recordAllRosTopics)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordAllRosTopicsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .recordAllRosTopics)
        recordAllRosTopics = recordAllRosTopicsDecoded
    }
}

extension RoboMakerClientTypes {
    /// The logging configuration.
    public struct LoggingConfig: Swift.Equatable {
        /// A boolean indicating whether to record all ROS topics. This API is no longer supported and will throw an error if used.
        @available(*, deprecated, message: "AWS RoboMaker is ending support for ROS software suite. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/software-support-policy.html.")
        public var recordAllRosTopics: Swift.Bool?

        public init (
            recordAllRosTopics: Swift.Bool? = nil
        )
        {
            self.recordAllRosTopics = recordAllRosTopics
        }
    }

}

extension RoboMakerClientTypes.NetworkInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkInterfaceId
        case privateIpAddress
        case publicIpAddress
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkInterfaceId = self.networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if let privateIpAddress = self.privateIpAddress {
            try encodeContainer.encode(privateIpAddress, forKey: .privateIpAddress)
        }
        if let publicIpAddress = self.publicIpAddress {
            try encodeContainer.encode(publicIpAddress, forKey: .publicIpAddress)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
        let publicIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicIpAddress)
        publicIpAddress = publicIpAddressDecoded
    }
}

extension RoboMakerClientTypes {
    /// Describes a network interface.
    public struct NetworkInterface: Swift.Equatable {
        /// The ID of the network interface.
        public var networkInterfaceId: Swift.String?
        /// The IPv4 address of the network interface within the subnet.
        public var privateIpAddress: Swift.String?
        /// The IPv4 public address of the network interface.
        public var publicIpAddress: Swift.String?

        public init (
            networkInterfaceId: Swift.String? = nil,
            privateIpAddress: Swift.String? = nil,
            publicIpAddress: Swift.String? = nil
        )
        {
            self.networkInterfaceId = networkInterfaceId
            self.privateIpAddress = privateIpAddress
            self.publicIpAddress = publicIpAddress
        }
    }

}

extension RoboMakerClientTypes.OutputLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket
        case s3Prefix
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Prefix = self.s3Prefix {
            try encodeContainer.encode(s3Prefix, forKey: .s3Prefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
    }
}

extension RoboMakerClientTypes {
    /// The output location.
    public struct OutputLocation: Swift.Equatable {
        /// The S3 bucket for output.
        public var s3Bucket: Swift.String?
        /// The S3 folder in the s3Bucket where output files will be placed.
        public var s3Prefix: Swift.String?

        public init (
            s3Bucket: Swift.String? = nil,
            s3Prefix: Swift.String? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3Prefix = s3Prefix
        }
    }

}

extension RoboMakerClientTypes.PortForwardingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portMappings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let portMappings = portMappings {
            var portMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portMappings)
            for portmapping0 in portMappings {
                try portMappingsContainer.encode(portmapping0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portMappingsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.PortMapping?].self, forKey: .portMappings)
        var portMappingsDecoded0:[RoboMakerClientTypes.PortMapping]? = nil
        if let portMappingsContainer = portMappingsContainer {
            portMappingsDecoded0 = [RoboMakerClientTypes.PortMapping]()
            for structure0 in portMappingsContainer {
                if let structure0 = structure0 {
                    portMappingsDecoded0?.append(structure0)
                }
            }
        }
        portMappings = portMappingsDecoded0
    }
}

extension RoboMakerClientTypes {
    /// Configuration information for port forwarding.
    public struct PortForwardingConfig: Swift.Equatable {
        /// The port mappings for the configuration.
        public var portMappings: [RoboMakerClientTypes.PortMapping]?

        public init (
            portMappings: [RoboMakerClientTypes.PortMapping]? = nil
        )
        {
            self.portMappings = portMappings
        }
    }

}

extension RoboMakerClientTypes.PortMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationPort
        case enableOnPublicIp
        case jobPort
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if applicationPort != 0 {
            try encodeContainer.encode(applicationPort, forKey: .applicationPort)
        }
        if enableOnPublicIp != false {
            try encodeContainer.encode(enableOnPublicIp, forKey: .enableOnPublicIp)
        }
        if jobPort != 0 {
            try encodeContainer.encode(jobPort, forKey: .jobPort)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .jobPort) ?? 0
        jobPort = jobPortDecoded
        let applicationPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationPort) ?? 0
        applicationPort = applicationPortDecoded
        let enableOnPublicIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableOnPublicIp) ?? false
        enableOnPublicIp = enableOnPublicIpDecoded
    }
}

extension RoboMakerClientTypes {
    /// An object representing a port mapping.
    public struct PortMapping: Swift.Equatable {
        /// The port number on the application.
        /// This member is required.
        public var applicationPort: Swift.Int
        /// A Boolean indicating whether to enable this port mapping on public IP.
        public var enableOnPublicIp: Swift.Bool
        /// The port number on the simulation job instance to use as a remote connection point.
        /// This member is required.
        public var jobPort: Swift.Int

        public init (
            applicationPort: Swift.Int = 0,
            enableOnPublicIp: Swift.Bool = false,
            jobPort: Swift.Int = 0
        )
        {
            self.applicationPort = applicationPort
            self.enableOnPublicIp = enableOnPublicIp
            self.jobPort = jobPort
        }
    }

}

extension RoboMakerClientTypes.ProgressDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentProgress
        case estimatedTimeRemainingSeconds
        case percentDone
        case targetResource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentProgress = self.currentProgress {
            try encodeContainer.encode(currentProgress.rawValue, forKey: .currentProgress)
        }
        if let estimatedTimeRemainingSeconds = self.estimatedTimeRemainingSeconds {
            try encodeContainer.encode(estimatedTimeRemainingSeconds, forKey: .estimatedTimeRemainingSeconds)
        }
        if let percentDone = self.percentDone {
            try encodeContainer.encode(percentDone, forKey: .percentDone)
        }
        if let targetResource = self.targetResource {
            try encodeContainer.encode(targetResource, forKey: .targetResource)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentProgressDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotDeploymentStep.self, forKey: .currentProgress)
        currentProgress = currentProgressDecoded
        let percentDoneDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .percentDone)
        percentDone = percentDoneDecoded
        let estimatedTimeRemainingSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeRemainingSeconds)
        estimatedTimeRemainingSeconds = estimatedTimeRemainingSecondsDecoded
        let targetResourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetResource)
        targetResource = targetResourceDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about the progress of a deployment job.
    public struct ProgressDetail: Swift.Equatable {
        /// The current progress status. Validating Validating the deployment. DownloadingExtracting Downloading and extracting the bundle on the robot. ExecutingPreLaunch Executing pre-launch script(s) if provided. Launching Launching the robot application. ExecutingPostLaunch Executing post-launch script(s) if provided. Finished Deployment is complete.
        public var currentProgress: RoboMakerClientTypes.RobotDeploymentStep?
        /// Estimated amount of time in seconds remaining in the step. This currently only applies to the Downloading/Extracting step of the deployment. It is empty for other steps.
        public var estimatedTimeRemainingSeconds: Swift.Int?
        /// Precentage of the step that is done. This currently only applies to the Downloading/Extracting step of the deployment. It is empty for other steps.
        public var percentDone: Swift.Float?
        /// The Amazon Resource Name (ARN) of the deployment job.
        public var targetResource: Swift.String?

        public init (
            currentProgress: RoboMakerClientTypes.RobotDeploymentStep? = nil,
            estimatedTimeRemainingSeconds: Swift.Int? = nil,
            percentDone: Swift.Float? = nil,
            targetResource: Swift.String? = nil
        )
        {
            self.currentProgress = currentProgress
            self.estimatedTimeRemainingSeconds = estimatedTimeRemainingSeconds
            self.percentDone = percentDone
            self.targetResource = targetResource
        }
    }

}

extension RegisterRobotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet
        case robot
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleet = self.fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
        if let robot = self.robot {
            try encodeContainer.encode(robot, forKey: .robot)
        }
    }
}

extension RegisterRobotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/registerRobot"
    }
}

@available(*, deprecated, message: "AWS RoboMaker is unable to process this request as the support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct RegisterRobotInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var fleet: Swift.String?
    /// The Amazon Resource Name (ARN) of the robot.
    /// This member is required.
    public var robot: Swift.String?

    public init (
        fleet: Swift.String? = nil,
        robot: Swift.String? = nil
    )
    {
        self.fleet = fleet
        self.robot = robot
    }
}

struct RegisterRobotInputBody: Swift.Equatable {
    let fleet: Swift.String?
    let robot: Swift.String?
}

extension RegisterRobotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet
        case robot
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let robotDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .robot)
        robot = robotDecoded
    }
}

extension RegisterRobotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterRobotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RegisterRobotOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterRobotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RegisterRobotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fleet = output.fleet
            self.robot = output.robot
        } else {
            self.fleet = nil
            self.robot = nil
        }
    }
}

@available(*, deprecated, message: "AWS RoboMaker is unable to process this request as the support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct RegisterRobotOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet that the robot will join.
    public var fleet: Swift.String?
    /// Information about the robot registration.
    public var robot: Swift.String?

    public init (
        fleet: Swift.String? = nil,
        robot: Swift.String? = nil
    )
    {
        self.fleet = fleet
        self.robot = robot
    }
}

struct RegisterRobotOutputResponseBody: Swift.Equatable {
    let fleet: Swift.String?
    let robot: Swift.String?
}

extension RegisterRobotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet
        case robot
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let robotDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .robot)
        robot = robotDecoded
    }
}

extension RoboMakerClientTypes.RenderingEngine: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RenderingEngineType.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a rendering engine.
    public struct RenderingEngine: Swift.Equatable {
        /// The name of the rendering engine.
        public var name: RoboMakerClientTypes.RenderingEngineType?
        /// The version of the rendering engine.
        public var version: Swift.String?

        public init (
            name: RoboMakerClientTypes.RenderingEngineType? = nil,
            version: Swift.String? = nil
        )
        {
            self.name = name
            self.version = version
        }
    }

}

extension RoboMakerClientTypes {
    public enum RenderingEngineType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ogre
        case sdkUnknown(Swift.String)

        public static var allCases: [RenderingEngineType] {
            return [
                .ogre,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ogre: return "OGRE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RenderingEngineType(rawValue: rawValue) ?? RenderingEngineType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource already exists.
public struct ResourceAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource does not exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RestartSimulationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = self.job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

extension RestartSimulationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/restartSimulationJob"
    }
}

public struct RestartSimulationJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the simulation job.
    /// This member is required.
    public var job: Swift.String?

    public init (
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

struct RestartSimulationJobInputBody: Swift.Equatable {
    let job: Swift.String?
}

extension RestartSimulationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .job)
        job = jobDecoded
    }
}

extension RestartSimulationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RestartSimulationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RestartSimulationJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestartSimulationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RestartSimulationJobOutputResponse: Swift.Equatable {

    public init () { }
}

extension RoboMakerClientTypes.Robot: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case arn
        case createdAt
        case fleetArn
        case greenGrassGroupId
        case lastDeploymentJob
        case lastDeploymentTime
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architecture = self.architecture {
            try encodeContainer.encode(architecture.rawValue, forKey: .architecture)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let greenGrassGroupId = self.greenGrassGroupId {
            try encodeContainer.encode(greenGrassGroupId, forKey: .greenGrassGroupId)
        }
        if let lastDeploymentJob = self.lastDeploymentJob {
            try encodeContainer.encode(lastDeploymentJob, forKey: .lastDeploymentJob)
        }
        if let lastDeploymentTime = self.lastDeploymentTime {
            try encodeContainer.encodeTimestamp(lastDeploymentTime, format: .epochSeconds, forKey: .lastDeploymentTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotStatus.self, forKey: .status)
        status = statusDecoded
        let greenGrassGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .greenGrassGroupId)
        greenGrassGroupId = greenGrassGroupIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
        let lastDeploymentJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastDeploymentJob)
        lastDeploymentJob = lastDeploymentJobDecoded
        let lastDeploymentTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastDeploymentTime)
        lastDeploymentTime = lastDeploymentTimeDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a robot.
    public struct Robot: Swift.Equatable {
        /// The architecture of the robot.
        public var architecture: RoboMakerClientTypes.Architecture?
        /// The Amazon Resource Name (ARN) of the robot.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the robot was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the fleet.
        public var fleetArn: Swift.String?
        /// The Greengrass group associated with the robot.
        public var greenGrassGroupId: Swift.String?
        /// The Amazon Resource Name (ARN) of the last deployment job.
        public var lastDeploymentJob: Swift.String?
        /// The time of the last deployment.
        public var lastDeploymentTime: ClientRuntime.Date?
        /// The name of the robot.
        public var name: Swift.String?
        /// The status of the robot.
        public var status: RoboMakerClientTypes.RobotStatus?

        public init (
            architecture: RoboMakerClientTypes.Architecture? = nil,
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            fleetArn: Swift.String? = nil,
            greenGrassGroupId: Swift.String? = nil,
            lastDeploymentJob: Swift.String? = nil,
            lastDeploymentTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: RoboMakerClientTypes.RobotStatus? = nil
        )
        {
            self.architecture = architecture
            self.arn = arn
            self.createdAt = createdAt
            self.fleetArn = fleetArn
            self.greenGrassGroupId = greenGrassGroupId
            self.lastDeploymentJob = lastDeploymentJob
            self.lastDeploymentTime = lastDeploymentTime
            self.name = name
            self.status = status
        }
    }

}

extension RoboMakerClientTypes.RobotApplicationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
        case launchConfig
        case tools
        case uploadConfigurations
        case useDefaultTools
        case useDefaultUploadConfigurations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = self.application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let applicationVersion = self.applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
        if let launchConfig = self.launchConfig {
            try encodeContainer.encode(launchConfig, forKey: .launchConfig)
        }
        if let tools = tools {
            var toolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tools)
            for tool0 in tools {
                try toolsContainer.encode(tool0)
            }
        }
        if let uploadConfigurations = uploadConfigurations {
            var uploadConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .uploadConfigurations)
            for uploadconfiguration0 in uploadConfigurations {
                try uploadConfigurationsContainer.encode(uploadconfiguration0)
            }
        }
        if let useDefaultTools = self.useDefaultTools {
            try encodeContainer.encode(useDefaultTools, forKey: .useDefaultTools)
        }
        if let useDefaultUploadConfigurations = self.useDefaultUploadConfigurations {
            try encodeContainer.encode(useDefaultUploadConfigurations, forKey: .useDefaultUploadConfigurations)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
        let launchConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.LaunchConfig.self, forKey: .launchConfig)
        launchConfig = launchConfigDecoded
        let uploadConfigurationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.UploadConfiguration?].self, forKey: .uploadConfigurations)
        var uploadConfigurationsDecoded0:[RoboMakerClientTypes.UploadConfiguration]? = nil
        if let uploadConfigurationsContainer = uploadConfigurationsContainer {
            uploadConfigurationsDecoded0 = [RoboMakerClientTypes.UploadConfiguration]()
            for structure0 in uploadConfigurationsContainer {
                if let structure0 = structure0 {
                    uploadConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        uploadConfigurations = uploadConfigurationsDecoded0
        let useDefaultUploadConfigurationsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDefaultUploadConfigurations)
        useDefaultUploadConfigurations = useDefaultUploadConfigurationsDecoded
        let toolsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Tool?].self, forKey: .tools)
        var toolsDecoded0:[RoboMakerClientTypes.Tool]? = nil
        if let toolsContainer = toolsContainer {
            toolsDecoded0 = [RoboMakerClientTypes.Tool]()
            for structure0 in toolsContainer {
                if let structure0 = structure0 {
                    toolsDecoded0?.append(structure0)
                }
            }
        }
        tools = toolsDecoded0
        let useDefaultToolsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDefaultTools)
        useDefaultTools = useDefaultToolsDecoded
    }
}

extension RoboMakerClientTypes {
    /// Application configuration information for a robot.
    public struct RobotApplicationConfig: Swift.Equatable {
        /// The application information for the robot application.
        /// This member is required.
        public var application: Swift.String?
        /// The version of the robot application.
        public var applicationVersion: Swift.String?
        /// The launch configuration for the robot application.
        /// This member is required.
        public var launchConfig: RoboMakerClientTypes.LaunchConfig?
        /// Information about tools configured for the robot application.
        public var tools: [RoboMakerClientTypes.Tool]?
        /// The upload configurations for the robot application.
        public var uploadConfigurations: [RoboMakerClientTypes.UploadConfiguration]?
        /// A Boolean indicating whether to use default robot application tools. The default tools are rviz, rqt, terminal and rosbag record. The default is False. This API is no longer supported and will throw an error if used.
        @available(*, deprecated, message: "AWS RoboMaker is ending support for ROS software suite. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/software-support-policy.html.")
        public var useDefaultTools: Swift.Bool?
        /// A Boolean indicating whether to use default upload configurations. By default, .ros and .gazebo files are uploaded when the application terminates and all ROS topics will be recorded. If you set this value, you must specify an outputLocation. This API is no longer supported and will throw an error if used.
        @available(*, deprecated, message: "AWS RoboMaker is ending support for ROS software suite. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/software-support-policy.html.")
        public var useDefaultUploadConfigurations: Swift.Bool?

        public init (
            application: Swift.String? = nil,
            applicationVersion: Swift.String? = nil,
            launchConfig: RoboMakerClientTypes.LaunchConfig? = nil,
            tools: [RoboMakerClientTypes.Tool]? = nil,
            uploadConfigurations: [RoboMakerClientTypes.UploadConfiguration]? = nil,
            useDefaultTools: Swift.Bool? = nil,
            useDefaultUploadConfigurations: Swift.Bool? = nil
        )
        {
            self.application = application
            self.applicationVersion = applicationVersion
            self.launchConfig = launchConfig
            self.tools = tools
            self.uploadConfigurations = uploadConfigurations
            self.useDefaultTools = useDefaultTools
            self.useDefaultUploadConfigurations = useDefaultUploadConfigurations
        }
    }

}

extension RoboMakerClientTypes.RobotApplicationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case lastUpdatedAt
        case name
        case robotSoftwareSuite
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let robotSoftwareSuite = self.robotSoftwareSuite {
            try encodeContainer.encode(robotSoftwareSuite, forKey: .robotSoftwareSuite)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
    }
}

extension RoboMakerClientTypes {
    /// Summary information for a robot application.
    public struct RobotApplicationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the robot.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the robot application was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the robot application.
        public var name: Swift.String?
        /// Information about a robot software suite (ROS distribution).
        public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
        /// The version of the robot application.
        public var version: Swift.String?

        public init (
            arn: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.robotSoftwareSuite = robotSoftwareSuite
            self.version = version
        }
    }

}

extension RoboMakerClientTypes.RobotDeployment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case deploymentFinishTime
        case deploymentStartTime
        case failureCode
        case failureReason
        case progressDetail
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let deploymentFinishTime = self.deploymentFinishTime {
            try encodeContainer.encodeTimestamp(deploymentFinishTime, format: .epochSeconds, forKey: .deploymentFinishTime)
        }
        if let deploymentStartTime = self.deploymentStartTime {
            try encodeContainer.encodeTimestamp(deploymentStartTime, format: .epochSeconds, forKey: .deploymentStartTime)
        }
        if let failureCode = self.failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let progressDetail = self.progressDetail {
            try encodeContainer.encode(progressDetail, forKey: .progressDetail)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let deploymentStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deploymentStartTime)
        deploymentStartTime = deploymentStartTimeDecoded
        let deploymentFinishTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deploymentFinishTime)
        deploymentFinishTime = deploymentFinishTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotStatus.self, forKey: .status)
        status = statusDecoded
        let progressDetailDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.ProgressDetail.self, forKey: .progressDetail)
        progressDetail = progressDetailDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a robot deployment.
    public struct RobotDeployment: Swift.Equatable {
        /// The robot deployment Amazon Resource Name (ARN).
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the deployment finished.
        public var deploymentFinishTime: ClientRuntime.Date?
        /// The time, in milliseconds since the epoch, when the deployment was started.
        public var deploymentStartTime: ClientRuntime.Date?
        /// The robot deployment failure code.
        public var failureCode: RoboMakerClientTypes.DeploymentJobErrorCode?
        /// A short description of the reason why the robot deployment failed.
        public var failureReason: Swift.String?
        /// Information about how the deployment is progressing.
        public var progressDetail: RoboMakerClientTypes.ProgressDetail?
        /// The status of the robot deployment.
        public var status: RoboMakerClientTypes.RobotStatus?

        public init (
            arn: Swift.String? = nil,
            deploymentFinishTime: ClientRuntime.Date? = nil,
            deploymentStartTime: ClientRuntime.Date? = nil,
            failureCode: RoboMakerClientTypes.DeploymentJobErrorCode? = nil,
            failureReason: Swift.String? = nil,
            progressDetail: RoboMakerClientTypes.ProgressDetail? = nil,
            status: RoboMakerClientTypes.RobotStatus? = nil
        )
        {
            self.arn = arn
            self.deploymentFinishTime = deploymentFinishTime
            self.deploymentStartTime = deploymentStartTime
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.progressDetail = progressDetail
            self.status = status
        }
    }

}

extension RoboMakerClientTypes {
    public enum RobotDeploymentStep: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case downloadingextractingstep
        case executingdownloadcondition
        case finishedstep
        case launchingstep
        case postlaunchstep
        case prelaunchstep
        case validatingstep
        case sdkUnknown(Swift.String)

        public static var allCases: [RobotDeploymentStep] {
            return [
                .downloadingextractingstep,
                .executingdownloadcondition,
                .finishedstep,
                .launchingstep,
                .postlaunchstep,
                .prelaunchstep,
                .validatingstep,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .downloadingextractingstep: return "DownloadingExtracting"
            case .executingdownloadcondition: return "ExecutingDownloadCondition"
            case .finishedstep: return "Finished"
            case .launchingstep: return "Launching"
            case .postlaunchstep: return "ExecutingPostLaunch"
            case .prelaunchstep: return "ExecutingPreLaunch"
            case .validatingstep: return "Validating"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RobotDeploymentStep(rawValue: rawValue) ?? RobotDeploymentStep.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.RobotSoftwareSuite: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let version = self.version {
            try encodeContainer.encode(version.rawValue, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuiteType.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuiteVersionType.self, forKey: .version)
        version = versionDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a robot software suite (ROS distribution).
    public struct RobotSoftwareSuite: Swift.Equatable {
        /// The name of the robot software suite (ROS distribution).
        public var name: RoboMakerClientTypes.RobotSoftwareSuiteType?
        /// The version of the robot software suite (ROS distribution).
        public var version: RoboMakerClientTypes.RobotSoftwareSuiteVersionType?

        public init (
            name: RoboMakerClientTypes.RobotSoftwareSuiteType? = nil,
            version: RoboMakerClientTypes.RobotSoftwareSuiteVersionType? = nil
        )
        {
            self.name = name
            self.version = version
        }
    }

}

extension RoboMakerClientTypes {
    public enum RobotSoftwareSuiteType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case general
        case ros
        case ros2
        case sdkUnknown(Swift.String)

        public static var allCases: [RobotSoftwareSuiteType] {
            return [
                .general,
                .ros,
                .ros2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .general: return "General"
            case .ros: return "ROS"
            case .ros2: return "ROS2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RobotSoftwareSuiteType(rawValue: rawValue) ?? RobotSoftwareSuiteType.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes {
    public enum RobotSoftwareSuiteVersionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dashing
        case foxy
        case kinetic
        case melodic
        case sdkUnknown(Swift.String)

        public static var allCases: [RobotSoftwareSuiteVersionType] {
            return [
                .dashing,
                .foxy,
                .kinetic,
                .melodic,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dashing: return "Dashing"
            case .foxy: return "Foxy"
            case .kinetic: return "Kinetic"
            case .melodic: return "Melodic"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RobotSoftwareSuiteVersionType(rawValue: rawValue) ?? RobotSoftwareSuiteVersionType.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes {
    public enum RobotStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deploying
        case failed
        case insync
        case noresponse
        case pendingnewdeployment
        case registered
        case sdkUnknown(Swift.String)

        public static var allCases: [RobotStatus] {
            return [
                .available,
                .deploying,
                .failed,
                .insync,
                .noresponse,
                .pendingnewdeployment,
                .registered,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "Available"
            case .deploying: return "Deploying"
            case .failed: return "Failed"
            case .insync: return "InSync"
            case .noresponse: return "NoResponse"
            case .pendingnewdeployment: return "PendingNewDeployment"
            case .registered: return "Registered"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RobotStatus(rawValue: rawValue) ?? RobotStatus.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.S3KeyOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case etag
        case s3Key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let etag = self.etag {
            try encodeContainer.encode(etag, forKey: .etag)
        }
        if let s3Key = self.s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let etagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .etag)
        etag = etagDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about S3 keys.
    public struct S3KeyOutput: Swift.Equatable {
        /// The etag for the object.
        public var etag: Swift.String?
        /// The S3 key.
        public var s3Key: Swift.String?

        public init (
            etag: Swift.String? = nil,
            s3Key: Swift.String? = nil
        )
        {
            self.etag = etag
            self.s3Key = s3Key
        }
    }

}

extension RoboMakerClientTypes.S3Object: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case etag
        case key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let etag = self.etag {
            try encodeContainer.encode(etag, forKey: .etag)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let etagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .etag)
        etag = etagDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about an S3 object.
    public struct S3Object: Swift.Equatable {
        /// The bucket containing the object.
        /// This member is required.
        public var bucket: Swift.String?
        /// The etag of the object.
        public var etag: Swift.String?
        /// The key of the object.
        /// This member is required.
        public var key: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            etag: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.etag = etag
            self.key = key
        }
    }

}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request has failed due to a temporary failure of the server.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RoboMakerClientTypes.SimulationApplicationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
        case launchConfig
        case tools
        case uploadConfigurations
        case useDefaultTools
        case useDefaultUploadConfigurations
        case worldConfigs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = self.application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let applicationVersion = self.applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
        if let launchConfig = self.launchConfig {
            try encodeContainer.encode(launchConfig, forKey: .launchConfig)
        }
        if let tools = tools {
            var toolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tools)
            for tool0 in tools {
                try toolsContainer.encode(tool0)
            }
        }
        if let uploadConfigurations = uploadConfigurations {
            var uploadConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .uploadConfigurations)
            for uploadconfiguration0 in uploadConfigurations {
                try uploadConfigurationsContainer.encode(uploadconfiguration0)
            }
        }
        if let useDefaultTools = self.useDefaultTools {
            try encodeContainer.encode(useDefaultTools, forKey: .useDefaultTools)
        }
        if let useDefaultUploadConfigurations = self.useDefaultUploadConfigurations {
            try encodeContainer.encode(useDefaultUploadConfigurations, forKey: .useDefaultUploadConfigurations)
        }
        if let worldConfigs = worldConfigs {
            var worldConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .worldConfigs)
            for worldconfig0 in worldConfigs {
                try worldConfigsContainer.encode(worldconfig0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
        let launchConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.LaunchConfig.self, forKey: .launchConfig)
        launchConfig = launchConfigDecoded
        let uploadConfigurationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.UploadConfiguration?].self, forKey: .uploadConfigurations)
        var uploadConfigurationsDecoded0:[RoboMakerClientTypes.UploadConfiguration]? = nil
        if let uploadConfigurationsContainer = uploadConfigurationsContainer {
            uploadConfigurationsDecoded0 = [RoboMakerClientTypes.UploadConfiguration]()
            for structure0 in uploadConfigurationsContainer {
                if let structure0 = structure0 {
                    uploadConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        uploadConfigurations = uploadConfigurationsDecoded0
        let worldConfigsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.WorldConfig?].self, forKey: .worldConfigs)
        var worldConfigsDecoded0:[RoboMakerClientTypes.WorldConfig]? = nil
        if let worldConfigsContainer = worldConfigsContainer {
            worldConfigsDecoded0 = [RoboMakerClientTypes.WorldConfig]()
            for structure0 in worldConfigsContainer {
                if let structure0 = structure0 {
                    worldConfigsDecoded0?.append(structure0)
                }
            }
        }
        worldConfigs = worldConfigsDecoded0
        let useDefaultUploadConfigurationsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDefaultUploadConfigurations)
        useDefaultUploadConfigurations = useDefaultUploadConfigurationsDecoded
        let toolsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Tool?].self, forKey: .tools)
        var toolsDecoded0:[RoboMakerClientTypes.Tool]? = nil
        if let toolsContainer = toolsContainer {
            toolsDecoded0 = [RoboMakerClientTypes.Tool]()
            for structure0 in toolsContainer {
                if let structure0 = structure0 {
                    toolsDecoded0?.append(structure0)
                }
            }
        }
        tools = toolsDecoded0
        let useDefaultToolsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDefaultTools)
        useDefaultTools = useDefaultToolsDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a simulation application configuration.
    public struct SimulationApplicationConfig: Swift.Equatable {
        /// The application information for the simulation application.
        /// This member is required.
        public var application: Swift.String?
        /// The version of the simulation application.
        public var applicationVersion: Swift.String?
        /// The launch configuration for the simulation application.
        /// This member is required.
        public var launchConfig: RoboMakerClientTypes.LaunchConfig?
        /// Information about tools configured for the simulation application.
        public var tools: [RoboMakerClientTypes.Tool]?
        /// Information about upload configurations for the simulation application.
        public var uploadConfigurations: [RoboMakerClientTypes.UploadConfiguration]?
        /// A Boolean indicating whether to use default simulation application tools. The default tools are rviz, rqt, terminal and rosbag record. The default is False. This API is no longer supported and will throw an error if used.
        @available(*, deprecated, message: "AWS RoboMaker is ending support for ROS software suite. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/software-support-policy.html.")
        public var useDefaultTools: Swift.Bool?
        /// A Boolean indicating whether to use default upload configurations. By default, .ros and .gazebo files are uploaded when the application terminates and all ROS topics will be recorded. If you set this value, you must specify an outputLocation. This API is no longer supported and will throw an error if used.
        @available(*, deprecated, message: "AWS RoboMaker is ending support for ROS software suite. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/software-support-policy.html.")
        public var useDefaultUploadConfigurations: Swift.Bool?
        /// A list of world configurations.
        public var worldConfigs: [RoboMakerClientTypes.WorldConfig]?

        public init (
            application: Swift.String? = nil,
            applicationVersion: Swift.String? = nil,
            launchConfig: RoboMakerClientTypes.LaunchConfig? = nil,
            tools: [RoboMakerClientTypes.Tool]? = nil,
            uploadConfigurations: [RoboMakerClientTypes.UploadConfiguration]? = nil,
            useDefaultTools: Swift.Bool? = nil,
            useDefaultUploadConfigurations: Swift.Bool? = nil,
            worldConfigs: [RoboMakerClientTypes.WorldConfig]? = nil
        )
        {
            self.application = application
            self.applicationVersion = applicationVersion
            self.launchConfig = launchConfig
            self.tools = tools
            self.uploadConfigurations = uploadConfigurations
            self.useDefaultTools = useDefaultTools
            self.useDefaultUploadConfigurations = useDefaultUploadConfigurations
            self.worldConfigs = worldConfigs
        }
    }

}

extension RoboMakerClientTypes.SimulationApplicationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case lastUpdatedAt
        case name
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let robotSoftwareSuite = self.robotSoftwareSuite {
            try encodeContainer.encode(robotSoftwareSuite, forKey: .robotSoftwareSuite)
        }
        if let simulationSoftwareSuite = self.simulationSoftwareSuite {
            try encodeContainer.encode(simulationSoftwareSuite, forKey: .simulationSoftwareSuite)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let simulationSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationSoftwareSuite.self, forKey: .simulationSoftwareSuite)
        simulationSoftwareSuite = simulationSoftwareSuiteDecoded
    }
}

extension RoboMakerClientTypes {
    /// Summary information for a simulation application.
    public struct SimulationApplicationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the simulation application.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the simulation application was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the simulation application.
        public var name: Swift.String?
        /// Information about a robot software suite (ROS distribution).
        public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
        /// Information about a simulation software suite.
        public var simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
        /// The version of the simulation application.
        public var version: Swift.String?

        public init (
            arn: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
            simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.robotSoftwareSuite = robotSoftwareSuite
            self.simulationSoftwareSuite = simulationSoftwareSuite
            self.version = version
        }
    }

}

extension RoboMakerClientTypes.SimulationJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case compute
        case dataSources
        case failureBehavior
        case failureCode
        case failureReason
        case iamRole
        case lastStartedAt
        case lastUpdatedAt
        case loggingConfig
        case maxJobDurationInSeconds
        case name
        case networkInterface
        case outputLocation
        case robotApplications
        case simulationApplications
        case simulationTimeMillis
        case status
        case tags
        case vpcConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let compute = self.compute {
            try encodeContainer.encode(compute, forKey: .compute)
        }
        if let dataSources = dataSources {
            var dataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSources)
            for datasource0 in dataSources {
                try dataSourcesContainer.encode(datasource0)
            }
        }
        if let failureBehavior = self.failureBehavior {
            try encodeContainer.encode(failureBehavior.rawValue, forKey: .failureBehavior)
        }
        if let failureCode = self.failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let iamRole = self.iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if let lastStartedAt = self.lastStartedAt {
            try encodeContainer.encodeTimestamp(lastStartedAt, format: .epochSeconds, forKey: .lastStartedAt)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let loggingConfig = self.loggingConfig {
            try encodeContainer.encode(loggingConfig, forKey: .loggingConfig)
        }
        if maxJobDurationInSeconds != 0 {
            try encodeContainer.encode(maxJobDurationInSeconds, forKey: .maxJobDurationInSeconds)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkInterface = self.networkInterface {
            try encodeContainer.encode(networkInterface, forKey: .networkInterface)
        }
        if let outputLocation = self.outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let robotApplications = robotApplications {
            var robotApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .robotApplications)
            for robotapplicationconfig0 in robotApplications {
                try robotApplicationsContainer.encode(robotapplicationconfig0)
            }
        }
        if let simulationApplications = simulationApplications {
            var simulationApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .simulationApplications)
            for simulationapplicationconfig0 in simulationApplications {
                try simulationApplicationsContainer.encode(simulationapplicationconfig0)
            }
        }
        if simulationTimeMillis != 0 {
            try encodeContainer.encode(simulationTimeMillis, forKey: .simulationTimeMillis)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobStatus.self, forKey: .status)
        status = statusDecoded
        let lastStartedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastStartedAt)
        lastStartedAt = lastStartedAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let failureBehaviorDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.FailureBehavior.self, forKey: .failureBehavior)
        failureBehavior = failureBehaviorDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let loggingConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.LoggingConfig.self, forKey: .loggingConfig)
        loggingConfig = loggingConfigDecoded
        let maxJobDurationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxJobDurationInSeconds) ?? 0
        maxJobDurationInSeconds = maxJobDurationInSecondsDecoded
        let simulationTimeMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .simulationTimeMillis) ?? 0
        simulationTimeMillis = simulationTimeMillisDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let robotApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.RobotApplicationConfig?].self, forKey: .robotApplications)
        var robotApplicationsDecoded0:[RoboMakerClientTypes.RobotApplicationConfig]? = nil
        if let robotApplicationsContainer = robotApplicationsContainer {
            robotApplicationsDecoded0 = [RoboMakerClientTypes.RobotApplicationConfig]()
            for structure0 in robotApplicationsContainer {
                if let structure0 = structure0 {
                    robotApplicationsDecoded0?.append(structure0)
                }
            }
        }
        robotApplications = robotApplicationsDecoded0
        let simulationApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationApplicationConfig?].self, forKey: .simulationApplications)
        var simulationApplicationsDecoded0:[RoboMakerClientTypes.SimulationApplicationConfig]? = nil
        if let simulationApplicationsContainer = simulationApplicationsContainer {
            simulationApplicationsDecoded0 = [RoboMakerClientTypes.SimulationApplicationConfig]()
            for structure0 in simulationApplicationsContainer {
                if let structure0 = structure0 {
                    simulationApplicationsDecoded0?.append(structure0)
                }
            }
        }
        simulationApplications = simulationApplicationsDecoded0
        let dataSourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[RoboMakerClientTypes.DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [RoboMakerClientTypes.DataSource]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let vpcConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.VPCConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let networkInterfaceDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.NetworkInterface.self, forKey: .networkInterface)
        networkInterface = networkInterfaceDecoded
        let computeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.ComputeResponse.self, forKey: .compute)
        compute = computeDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a simulation job.
    public struct SimulationJob: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the simulation job.
        public var arn: Swift.String?
        /// A unique identifier for this SimulationJob request.
        public var clientRequestToken: Swift.String?
        /// Compute information for the simulation job
        public var compute: RoboMakerClientTypes.ComputeResponse?
        /// The data sources for the simulation job.
        public var dataSources: [RoboMakerClientTypes.DataSource]?
        /// The failure behavior the simulation job. Continue Leaves the host running for its maximum timeout duration after a 4XX error code. Fail Stop the simulation job and terminate the instance.
        public var failureBehavior: RoboMakerClientTypes.FailureBehavior?
        /// The failure code of the simulation job if it failed.
        public var failureCode: RoboMakerClientTypes.SimulationJobErrorCode?
        /// The reason why the simulation job failed.
        public var failureReason: Swift.String?
        /// The IAM role that allows the simulation instance to call the AWS APIs that are specified in its associated policies on your behalf. This is how credentials are passed in to your simulation job.
        public var iamRole: Swift.String?
        /// The time, in milliseconds since the epoch, when the simulation job was last started.
        public var lastStartedAt: ClientRuntime.Date?
        /// The time, in milliseconds since the epoch, when the simulation job was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The logging configuration.
        public var loggingConfig: RoboMakerClientTypes.LoggingConfig?
        /// The maximum simulation job duration in seconds. The value must be 8 days (691,200 seconds) or less.
        public var maxJobDurationInSeconds: Swift.Int
        /// The name of the simulation job.
        public var name: Swift.String?
        /// Information about a network interface.
        public var networkInterface: RoboMakerClientTypes.NetworkInterface?
        /// Location for output files generated by the simulation job.
        public var outputLocation: RoboMakerClientTypes.OutputLocation?
        /// A list of robot applications.
        public var robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]?
        /// A list of simulation applications.
        public var simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]?
        /// The simulation job execution duration in milliseconds.
        public var simulationTimeMillis: Swift.Int
        /// Status of the simulation job.
        public var status: RoboMakerClientTypes.SimulationJobStatus?
        /// A map that contains tag keys and tag values that are attached to the simulation job.
        public var tags: [Swift.String:Swift.String]?
        /// VPC configuration information.
        public var vpcConfig: RoboMakerClientTypes.VPCConfigResponse?

        public init (
            arn: Swift.String? = nil,
            clientRequestToken: Swift.String? = nil,
            compute: RoboMakerClientTypes.ComputeResponse? = nil,
            dataSources: [RoboMakerClientTypes.DataSource]? = nil,
            failureBehavior: RoboMakerClientTypes.FailureBehavior? = nil,
            failureCode: RoboMakerClientTypes.SimulationJobErrorCode? = nil,
            failureReason: Swift.String? = nil,
            iamRole: Swift.String? = nil,
            lastStartedAt: ClientRuntime.Date? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            loggingConfig: RoboMakerClientTypes.LoggingConfig? = nil,
            maxJobDurationInSeconds: Swift.Int = 0,
            name: Swift.String? = nil,
            networkInterface: RoboMakerClientTypes.NetworkInterface? = nil,
            outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
            robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]? = nil,
            simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]? = nil,
            simulationTimeMillis: Swift.Int = 0,
            status: RoboMakerClientTypes.SimulationJobStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            vpcConfig: RoboMakerClientTypes.VPCConfigResponse? = nil
        )
        {
            self.arn = arn
            self.clientRequestToken = clientRequestToken
            self.compute = compute
            self.dataSources = dataSources
            self.failureBehavior = failureBehavior
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.iamRole = iamRole
            self.lastStartedAt = lastStartedAt
            self.lastUpdatedAt = lastUpdatedAt
            self.loggingConfig = loggingConfig
            self.maxJobDurationInSeconds = maxJobDurationInSeconds
            self.name = name
            self.networkInterface = networkInterface
            self.outputLocation = outputLocation
            self.robotApplications = robotApplications
            self.simulationApplications = simulationApplications
            self.simulationTimeMillis = simulationTimeMillis
            self.status = status
            self.tags = tags
            self.vpcConfig = vpcConfig
        }
    }

}

extension RoboMakerClientTypes {
    public enum SimulationJobBatchErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalserviceerror
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationJobBatchErrorCode] {
            return [
                .internalserviceerror,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalserviceerror: return "InternalServiceError"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SimulationJobBatchErrorCode(rawValue: rawValue) ?? SimulationJobBatchErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes {
    public enum SimulationJobBatchStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case canceling
        case completed
        case completing
        case failed
        case inprogress
        case pending
        case timedout
        case timingout
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationJobBatchStatus] {
            return [
                .canceled,
                .canceling,
                .completed,
                .completing,
                .failed,
                .inprogress,
                .pending,
                .timedout,
                .timingout,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "Canceled"
            case .canceling: return "Canceling"
            case .completed: return "Completed"
            case .completing: return "Completing"
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .pending: return "Pending"
            case .timedout: return "TimedOut"
            case .timingout: return "TimingOut"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SimulationJobBatchStatus(rawValue: rawValue) ?? SimulationJobBatchStatus.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.SimulationJobBatchSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case createdRequestCount
        case failedRequestCount
        case lastUpdatedAt
        case pendingRequestCount
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if createdRequestCount != 0 {
            try encodeContainer.encode(createdRequestCount, forKey: .createdRequestCount)
        }
        if failedRequestCount != 0 {
            try encodeContainer.encode(failedRequestCount, forKey: .failedRequestCount)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if pendingRequestCount != 0 {
            try encodeContainer.encode(pendingRequestCount, forKey: .pendingRequestCount)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobBatchStatus.self, forKey: .status)
        status = statusDecoded
        let failedRequestCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failedRequestCount) ?? 0
        failedRequestCount = failedRequestCountDecoded
        let pendingRequestCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pendingRequestCount) ?? 0
        pendingRequestCount = pendingRequestCountDecoded
        let createdRequestCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createdRequestCount) ?? 0
        createdRequestCount = createdRequestCountDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a simulation job batch.
    public struct SimulationJobBatchSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the batch.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the simulation job batch was created.
        public var createdAt: ClientRuntime.Date?
        /// The number of created simulation job requests.
        public var createdRequestCount: Swift.Int
        /// The number of failed simulation job requests.
        public var failedRequestCount: Swift.Int
        /// The time, in milliseconds since the epoch, when the simulation job batch was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The number of pending simulation job requests.
        public var pendingRequestCount: Swift.Int
        /// The status of the simulation job batch. Pending The simulation job batch request is pending. InProgress The simulation job batch is in progress. Failed The simulation job batch failed. One or more simulation job requests could not be completed due to an internal failure (like InternalServiceError). See failureCode and failureReason for more information. Completed The simulation batch job completed. A batch is complete when (1) there are no pending simulation job requests in the batch and none of the failed simulation job requests are due to InternalServiceError and (2) when all created simulation jobs have reached a terminal state (for example, Completed or Failed). Canceled The simulation batch job was cancelled. Canceling The simulation batch job is being cancelled. Completing The simulation batch job is completing. TimingOut The simulation job batch is timing out. If a batch timing out, and there are pending requests that were failing due to an internal failure (like InternalServiceError), the batch status will be Failed. If there are no such failing request, the batch status will be TimedOut. TimedOut The simulation batch job timed out.
        public var status: RoboMakerClientTypes.SimulationJobBatchStatus?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdRequestCount: Swift.Int = 0,
            failedRequestCount: Swift.Int = 0,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            pendingRequestCount: Swift.Int = 0,
            status: RoboMakerClientTypes.SimulationJobBatchStatus? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.createdRequestCount = createdRequestCount
            self.failedRequestCount = failedRequestCount
            self.lastUpdatedAt = lastUpdatedAt
            self.pendingRequestCount = pendingRequestCount
            self.status = status
        }
    }

}

extension RoboMakerClientTypes {
    public enum SimulationJobErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case badpermissionscloudwatchlogs
        case badpermissionsrobotapplication
        case badpermissionss3object
        case badpermissionss3output
        case badpermissionssimulationapplication
        case badpermissionsusercredentials
        case batchcanceled
        case batchtimedout
        case enilimitexceeded
        case internalserviceerror
        case invalidbundlerobotapplication
        case invalidbundlesimulationapplication
        case invalidinput
        case invalids3resource
        case limitexceeded
        case mismatchedetag
        case requestthrottled
        case resourcenotfound
        case robotapplicationcrash
        case robotapplicationhealthcheckfailure
        case robotapplicationversionmismatchedetag
        case simulationapplicationcrash
        case simulationapplicationhealthcheckfailure
        case simulationapplicationversionmismatchedetag
        case subnetiplimitexceeded
        case throttlingerror
        case uploadcontentmismatcherror
        case wrongregionrobotapplication
        case wrongregions3bucket
        case wrongregions3output
        case wrongregionsimulationapplication
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationJobErrorCode] {
            return [
                .badpermissionscloudwatchlogs,
                .badpermissionsrobotapplication,
                .badpermissionss3object,
                .badpermissionss3output,
                .badpermissionssimulationapplication,
                .badpermissionsusercredentials,
                .batchcanceled,
                .batchtimedout,
                .enilimitexceeded,
                .internalserviceerror,
                .invalidbundlerobotapplication,
                .invalidbundlesimulationapplication,
                .invalidinput,
                .invalids3resource,
                .limitexceeded,
                .mismatchedetag,
                .requestthrottled,
                .resourcenotfound,
                .robotapplicationcrash,
                .robotapplicationhealthcheckfailure,
                .robotapplicationversionmismatchedetag,
                .simulationapplicationcrash,
                .simulationapplicationhealthcheckfailure,
                .simulationapplicationversionmismatchedetag,
                .subnetiplimitexceeded,
                .throttlingerror,
                .uploadcontentmismatcherror,
                .wrongregionrobotapplication,
                .wrongregions3bucket,
                .wrongregions3output,
                .wrongregionsimulationapplication,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .badpermissionscloudwatchlogs: return "BadPermissionsCloudwatchLogs"
            case .badpermissionsrobotapplication: return "BadPermissionsRobotApplication"
            case .badpermissionss3object: return "BadPermissionsS3Object"
            case .badpermissionss3output: return "BadPermissionsS3Output"
            case .badpermissionssimulationapplication: return "BadPermissionsSimulationApplication"
            case .badpermissionsusercredentials: return "BadPermissionsUserCredentials"
            case .batchcanceled: return "BatchCanceled"
            case .batchtimedout: return "BatchTimedOut"
            case .enilimitexceeded: return "ENILimitExceeded"
            case .internalserviceerror: return "InternalServiceError"
            case .invalidbundlerobotapplication: return "InvalidBundleRobotApplication"
            case .invalidbundlesimulationapplication: return "InvalidBundleSimulationApplication"
            case .invalidinput: return "InvalidInput"
            case .invalids3resource: return "InvalidS3Resource"
            case .limitexceeded: return "LimitExceeded"
            case .mismatchedetag: return "MismatchedEtag"
            case .requestthrottled: return "RequestThrottled"
            case .resourcenotfound: return "ResourceNotFound"
            case .robotapplicationcrash: return "RobotApplicationCrash"
            case .robotapplicationhealthcheckfailure: return "RobotApplicationHealthCheckFailure"
            case .robotapplicationversionmismatchedetag: return "RobotApplicationVersionMismatchedEtag"
            case .simulationapplicationcrash: return "SimulationApplicationCrash"
            case .simulationapplicationhealthcheckfailure: return "SimulationApplicationHealthCheckFailure"
            case .simulationapplicationversionmismatchedetag: return "SimulationApplicationVersionMismatchedEtag"
            case .subnetiplimitexceeded: return "SubnetIpLimitExceeded"
            case .throttlingerror: return "ThrottlingError"
            case .uploadcontentmismatcherror: return "UploadContentMismatchError"
            case .wrongregionrobotapplication: return "WrongRegionRobotApplication"
            case .wrongregions3bucket: return "WrongRegionS3Bucket"
            case .wrongregions3output: return "WrongRegionS3Output"
            case .wrongregionsimulationapplication: return "WrongRegionSimulationApplication"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SimulationJobErrorCode(rawValue: rawValue) ?? SimulationJobErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.SimulationJobRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compute
        case dataSources
        case failureBehavior
        case iamRole
        case loggingConfig
        case maxJobDurationInSeconds
        case outputLocation
        case robotApplications
        case simulationApplications
        case tags
        case useDefaultApplications
        case vpcConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compute = self.compute {
            try encodeContainer.encode(compute, forKey: .compute)
        }
        if let dataSources = dataSources {
            var dataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSources)
            for datasourceconfig0 in dataSources {
                try dataSourcesContainer.encode(datasourceconfig0)
            }
        }
        if let failureBehavior = self.failureBehavior {
            try encodeContainer.encode(failureBehavior.rawValue, forKey: .failureBehavior)
        }
        if let iamRole = self.iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if let loggingConfig = self.loggingConfig {
            try encodeContainer.encode(loggingConfig, forKey: .loggingConfig)
        }
        if maxJobDurationInSeconds != 0 {
            try encodeContainer.encode(maxJobDurationInSeconds, forKey: .maxJobDurationInSeconds)
        }
        if let outputLocation = self.outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let robotApplications = robotApplications {
            var robotApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .robotApplications)
            for robotapplicationconfig0 in robotApplications {
                try robotApplicationsContainer.encode(robotapplicationconfig0)
            }
        }
        if let simulationApplications = simulationApplications {
            var simulationApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .simulationApplications)
            for simulationapplicationconfig0 in simulationApplications {
                try simulationApplicationsContainer.encode(simulationapplicationconfig0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let useDefaultApplications = self.useDefaultApplications {
            try encodeContainer.encode(useDefaultApplications, forKey: .useDefaultApplications)
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let loggingConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.LoggingConfig.self, forKey: .loggingConfig)
        loggingConfig = loggingConfigDecoded
        let maxJobDurationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxJobDurationInSeconds) ?? 0
        maxJobDurationInSeconds = maxJobDurationInSecondsDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let failureBehaviorDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.FailureBehavior.self, forKey: .failureBehavior)
        failureBehavior = failureBehaviorDecoded
        let useDefaultApplicationsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDefaultApplications)
        useDefaultApplications = useDefaultApplicationsDecoded
        let robotApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.RobotApplicationConfig?].self, forKey: .robotApplications)
        var robotApplicationsDecoded0:[RoboMakerClientTypes.RobotApplicationConfig]? = nil
        if let robotApplicationsContainer = robotApplicationsContainer {
            robotApplicationsDecoded0 = [RoboMakerClientTypes.RobotApplicationConfig]()
            for structure0 in robotApplicationsContainer {
                if let structure0 = structure0 {
                    robotApplicationsDecoded0?.append(structure0)
                }
            }
        }
        robotApplications = robotApplicationsDecoded0
        let simulationApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationApplicationConfig?].self, forKey: .simulationApplications)
        var simulationApplicationsDecoded0:[RoboMakerClientTypes.SimulationApplicationConfig]? = nil
        if let simulationApplicationsContainer = simulationApplicationsContainer {
            simulationApplicationsDecoded0 = [RoboMakerClientTypes.SimulationApplicationConfig]()
            for structure0 in simulationApplicationsContainer {
                if let structure0 = structure0 {
                    simulationApplicationsDecoded0?.append(structure0)
                }
            }
        }
        simulationApplications = simulationApplicationsDecoded0
        let dataSourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DataSourceConfig?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[RoboMakerClientTypes.DataSourceConfig]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [RoboMakerClientTypes.DataSourceConfig]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let vpcConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.VPCConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let computeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Compute.self, forKey: .compute)
        compute = computeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension RoboMakerClientTypes {
    /// Information about a simulation job request.
    public struct SimulationJobRequest: Swift.Equatable {
        /// Compute information for the simulation job
        public var compute: RoboMakerClientTypes.Compute?
        /// Specify data sources to mount read-only files from S3 into your simulation. These files are available under /opt/robomaker/datasources/data_source_name. There is a limit of 100 files and a combined size of 25GB for all DataSourceConfig objects.
        public var dataSources: [RoboMakerClientTypes.DataSourceConfig]?
        /// The failure behavior the simulation job. Continue Leaves the host running for its maximum timeout duration after a 4XX error code. Fail Stop the simulation job and terminate the instance.
        public var failureBehavior: RoboMakerClientTypes.FailureBehavior?
        /// The IAM role name that allows the simulation instance to call the AWS APIs that are specified in its associated policies on your behalf. This is how credentials are passed in to your simulation job.
        public var iamRole: Swift.String?
        /// The logging configuration.
        public var loggingConfig: RoboMakerClientTypes.LoggingConfig?
        /// The maximum simulation job duration in seconds. The value must be 8 days (691,200 seconds) or less.
        /// This member is required.
        public var maxJobDurationInSeconds: Swift.Int
        /// The output location.
        public var outputLocation: RoboMakerClientTypes.OutputLocation?
        /// The robot applications to use in the simulation job.
        public var robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]?
        /// The simulation applications to use in the simulation job.
        public var simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]?
        /// A map that contains tag keys and tag values that are attached to the simulation job request.
        public var tags: [Swift.String:Swift.String]?
        /// A Boolean indicating whether to use default applications in the simulation job. Default applications include Gazebo, rqt, rviz and terminal access.
        public var useDefaultApplications: Swift.Bool?
        /// If your simulation job accesses resources in a VPC, you provide this parameter identifying the list of security group IDs and subnet IDs. These must belong to the same VPC. You must provide at least one security group and two subnet IDs.
        public var vpcConfig: RoboMakerClientTypes.VPCConfig?

        public init (
            compute: RoboMakerClientTypes.Compute? = nil,
            dataSources: [RoboMakerClientTypes.DataSourceConfig]? = nil,
            failureBehavior: RoboMakerClientTypes.FailureBehavior? = nil,
            iamRole: Swift.String? = nil,
            loggingConfig: RoboMakerClientTypes.LoggingConfig? = nil,
            maxJobDurationInSeconds: Swift.Int = 0,
            outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
            robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]? = nil,
            simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            useDefaultApplications: Swift.Bool? = nil,
            vpcConfig: RoboMakerClientTypes.VPCConfig? = nil
        )
        {
            self.compute = compute
            self.dataSources = dataSources
            self.failureBehavior = failureBehavior
            self.iamRole = iamRole
            self.loggingConfig = loggingConfig
            self.maxJobDurationInSeconds = maxJobDurationInSeconds
            self.outputLocation = outputLocation
            self.robotApplications = robotApplications
            self.simulationApplications = simulationApplications
            self.tags = tags
            self.useDefaultApplications = useDefaultApplications
            self.vpcConfig = vpcConfig
        }
    }

}

extension RoboMakerClientTypes {
    public enum SimulationJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case completed
        case failed
        case pending
        case preparing
        case restarting
        case running
        case runningfailed
        case terminated
        case terminating
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationJobStatus] {
            return [
                .canceled,
                .completed,
                .failed,
                .pending,
                .preparing,
                .restarting,
                .running,
                .runningfailed,
                .terminated,
                .terminating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "Canceled"
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .pending: return "Pending"
            case .preparing: return "Preparing"
            case .restarting: return "Restarting"
            case .running: return "Running"
            case .runningfailed: return "RunningFailed"
            case .terminated: return "Terminated"
            case .terminating: return "Terminating"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SimulationJobStatus(rawValue: rawValue) ?? SimulationJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.SimulationJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case computeType
        case dataSourceNames
        case lastUpdatedAt
        case name
        case robotApplicationNames
        case simulationApplicationNames
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let computeType = self.computeType {
            try encodeContainer.encode(computeType.rawValue, forKey: .computeType)
        }
        if let dataSourceNames = dataSourceNames {
            var dataSourceNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSourceNames)
            for name0 in dataSourceNames {
                try dataSourceNamesContainer.encode(name0)
            }
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let robotApplicationNames = robotApplicationNames {
            var robotApplicationNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .robotApplicationNames)
            for name0 in robotApplicationNames {
                try robotApplicationNamesContainer.encode(name0)
            }
        }
        if let simulationApplicationNames = simulationApplicationNames {
            var simulationApplicationNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .simulationApplicationNames)
            for name0 in simulationApplicationNames {
                try simulationApplicationNamesContainer.encode(name0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobStatus.self, forKey: .status)
        status = statusDecoded
        let simulationApplicationNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .simulationApplicationNames)
        var simulationApplicationNamesDecoded0:[Swift.String]? = nil
        if let simulationApplicationNamesContainer = simulationApplicationNamesContainer {
            simulationApplicationNamesDecoded0 = [Swift.String]()
            for string0 in simulationApplicationNamesContainer {
                if let string0 = string0 {
                    simulationApplicationNamesDecoded0?.append(string0)
                }
            }
        }
        simulationApplicationNames = simulationApplicationNamesDecoded0
        let robotApplicationNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .robotApplicationNames)
        var robotApplicationNamesDecoded0:[Swift.String]? = nil
        if let robotApplicationNamesContainer = robotApplicationNamesContainer {
            robotApplicationNamesDecoded0 = [Swift.String]()
            for string0 in robotApplicationNamesContainer {
                if let string0 = string0 {
                    robotApplicationNamesDecoded0?.append(string0)
                }
            }
        }
        robotApplicationNames = robotApplicationNamesDecoded0
        let dataSourceNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dataSourceNames)
        var dataSourceNamesDecoded0:[Swift.String]? = nil
        if let dataSourceNamesContainer = dataSourceNamesContainer {
            dataSourceNamesDecoded0 = [Swift.String]()
            for string0 in dataSourceNamesContainer {
                if let string0 = string0 {
                    dataSourceNamesDecoded0?.append(string0)
                }
            }
        }
        dataSourceNames = dataSourceNamesDecoded0
        let computeTypeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.ComputeType.self, forKey: .computeType)
        computeType = computeTypeDecoded
    }
}

extension RoboMakerClientTypes {
    /// Summary information for a simulation job.
    public struct SimulationJobSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the simulation job.
        public var arn: Swift.String?
        /// The compute type for the simulation job summary.
        public var computeType: RoboMakerClientTypes.ComputeType?
        /// The names of the data sources.
        public var dataSourceNames: [Swift.String]?
        /// The time, in milliseconds since the epoch, when the simulation job was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the simulation job.
        public var name: Swift.String?
        /// A list of simulation job robot application names.
        public var robotApplicationNames: [Swift.String]?
        /// A list of simulation job simulation application names.
        public var simulationApplicationNames: [Swift.String]?
        /// The status of the simulation job.
        public var status: RoboMakerClientTypes.SimulationJobStatus?

        public init (
            arn: Swift.String? = nil,
            computeType: RoboMakerClientTypes.ComputeType? = nil,
            dataSourceNames: [Swift.String]? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            robotApplicationNames: [Swift.String]? = nil,
            simulationApplicationNames: [Swift.String]? = nil,
            status: RoboMakerClientTypes.SimulationJobStatus? = nil
        )
        {
            self.arn = arn
            self.computeType = computeType
            self.dataSourceNames = dataSourceNames
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.robotApplicationNames = robotApplicationNames
            self.simulationApplicationNames = simulationApplicationNames
            self.status = status
        }
    }

}

extension RoboMakerClientTypes.SimulationSoftwareSuite: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationSoftwareSuiteType.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a simulation software suite.
    public struct SimulationSoftwareSuite: Swift.Equatable {
        /// The name of the simulation software suite.
        public var name: RoboMakerClientTypes.SimulationSoftwareSuiteType?
        /// The version of the simulation software suite.
        public var version: Swift.String?

        public init (
            name: RoboMakerClientTypes.SimulationSoftwareSuiteType? = nil,
            version: Swift.String? = nil
        )
        {
            self.name = name
            self.version = version
        }
    }

}

extension RoboMakerClientTypes {
    public enum SimulationSoftwareSuiteType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gazebo
        case rosbagplay
        case simulationruntime
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationSoftwareSuiteType] {
            return [
                .gazebo,
                .rosbagplay,
                .simulationruntime,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gazebo: return "Gazebo"
            case .rosbagplay: return "RosbagPlay"
            case .simulationruntime: return "SimulationRuntime"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SimulationSoftwareSuiteType(rawValue: rawValue) ?? SimulationSoftwareSuiteType.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.Source: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case etag
        case s3Bucket
        case s3Key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architecture = self.architecture {
            try encodeContainer.encode(architecture.rawValue, forKey: .architecture)
        }
        if let etag = self.etag {
            try encodeContainer.encode(etag, forKey: .etag)
        }
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = self.s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let etagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .etag)
        etag = etagDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a source.
    public struct Source: Swift.Equatable {
        /// The taget processor architecture for the application.
        public var architecture: RoboMakerClientTypes.Architecture?
        /// A hash of the object specified by s3Bucket and s3Key.
        public var etag: Swift.String?
        /// The s3 bucket name.
        public var s3Bucket: Swift.String?
        /// The s3 object key.
        public var s3Key: Swift.String?

        public init (
            architecture: RoboMakerClientTypes.Architecture? = nil,
            etag: Swift.String? = nil,
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil
        )
        {
            self.architecture = architecture
            self.etag = etag
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }
    }

}

extension RoboMakerClientTypes.SourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case s3Bucket
        case s3Key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architecture = self.architecture {
            try encodeContainer.encode(architecture.rawValue, forKey: .architecture)
        }
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = self.s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a source configuration.
    public struct SourceConfig: Swift.Equatable {
        /// The target processor architecture for the application.
        public var architecture: RoboMakerClientTypes.Architecture?
        /// The Amazon S3 bucket name.
        public var s3Bucket: Swift.String?
        /// The s3 object key.
        public var s3Key: Swift.String?

        public init (
            architecture: RoboMakerClientTypes.Architecture? = nil,
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil
        )
        {
            self.architecture = architecture
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }
    }

}

extension StartSimulationJobBatchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchPolicy
        case clientRequestToken
        case createSimulationJobRequests
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchPolicy = self.batchPolicy {
            try encodeContainer.encode(batchPolicy, forKey: .batchPolicy)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let createSimulationJobRequests = createSimulationJobRequests {
            var createSimulationJobRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .createSimulationJobRequests)
            for simulationjobrequest0 in createSimulationJobRequests {
                try createSimulationJobRequestsContainer.encode(simulationjobrequest0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartSimulationJobBatchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/startSimulationJobBatch"
    }
}

public struct StartSimulationJobBatchInput: Swift.Equatable {
    /// The batch policy.
    public var batchPolicy: RoboMakerClientTypes.BatchPolicy?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// A list of simulation job requests to create in the batch.
    /// This member is required.
    public var createSimulationJobRequests: [RoboMakerClientTypes.SimulationJobRequest]?
    /// A map that contains tag keys and tag values that are attached to the deployment job batch.
    public var tags: [Swift.String:Swift.String]?

    public init (
        batchPolicy: RoboMakerClientTypes.BatchPolicy? = nil,
        clientRequestToken: Swift.String? = nil,
        createSimulationJobRequests: [RoboMakerClientTypes.SimulationJobRequest]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.batchPolicy = batchPolicy
        self.clientRequestToken = clientRequestToken
        self.createSimulationJobRequests = createSimulationJobRequests
        self.tags = tags
    }
}

struct StartSimulationJobBatchInputBody: Swift.Equatable {
    let clientRequestToken: Swift.String?
    let batchPolicy: RoboMakerClientTypes.BatchPolicy?
    let createSimulationJobRequests: [RoboMakerClientTypes.SimulationJobRequest]?
    let tags: [Swift.String:Swift.String]?
}

extension StartSimulationJobBatchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchPolicy
        case clientRequestToken
        case createSimulationJobRequests
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let batchPolicyDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.BatchPolicy.self, forKey: .batchPolicy)
        batchPolicy = batchPolicyDecoded
        let createSimulationJobRequestsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationJobRequest?].self, forKey: .createSimulationJobRequests)
        var createSimulationJobRequestsDecoded0:[RoboMakerClientTypes.SimulationJobRequest]? = nil
        if let createSimulationJobRequestsContainer = createSimulationJobRequestsContainer {
            createSimulationJobRequestsDecoded0 = [RoboMakerClientTypes.SimulationJobRequest]()
            for structure0 in createSimulationJobRequestsContainer {
                if let structure0 = structure0 {
                    createSimulationJobRequestsDecoded0?.append(structure0)
                }
            }
        }
        createSimulationJobRequests = createSimulationJobRequestsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartSimulationJobBatchOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartSimulationJobBatchOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartSimulationJobBatchOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartSimulationJobBatchOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartSimulationJobBatchOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.batchPolicy = output.batchPolicy
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.createdRequests = output.createdRequests
            self.failedRequests = output.failedRequests
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.pendingRequests = output.pendingRequests
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.batchPolicy = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.createdRequests = nil
            self.failedRequests = nil
            self.failureCode = nil
            self.failureReason = nil
            self.pendingRequests = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct StartSimulationJobBatchOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the batch.
    public var arn: Swift.String?
    /// The batch policy.
    public var batchPolicy: RoboMakerClientTypes.BatchPolicy?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the simulation job batch was created.
    public var createdAt: ClientRuntime.Date?
    /// A list of created simulation job request summaries.
    public var createdRequests: [RoboMakerClientTypes.SimulationJobSummary]?
    /// A list of failed simulation job requests. The request failed to be created into a simulation job. Failed requests do not have a simulation job ID.
    public var failedRequests: [RoboMakerClientTypes.FailedCreateSimulationJobRequest]?
    /// The failure code if the simulation job batch failed.
    public var failureCode: RoboMakerClientTypes.SimulationJobBatchErrorCode?
    /// The reason the simulation job batch failed.
    public var failureReason: Swift.String?
    /// A list of pending simulation job requests. These requests have not yet been created into simulation jobs.
    public var pendingRequests: [RoboMakerClientTypes.SimulationJobRequest]?
    /// The status of the simulation job batch. Pending The simulation job batch request is pending. InProgress The simulation job batch is in progress. Failed The simulation job batch failed. One or more simulation job requests could not be completed due to an internal failure (like InternalServiceError). See failureCode and failureReason for more information. Completed The simulation batch job completed. A batch is complete when (1) there are no pending simulation job requests in the batch and none of the failed simulation job requests are due to InternalServiceError and (2) when all created simulation jobs have reached a terminal state (for example, Completed or Failed). Canceled The simulation batch job was cancelled. Canceling The simulation batch job is being cancelled. Completing The simulation batch job is completing. TimingOut The simulation job batch is timing out. If a batch timing out, and there are pending requests that were failing due to an internal failure (like InternalServiceError), the batch status will be Failed. If there are no such failing request, the batch status will be TimedOut. TimedOut The simulation batch job timed out.
    public var status: RoboMakerClientTypes.SimulationJobBatchStatus?
    /// A map that contains tag keys and tag values that are attached to the deployment job batch.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        batchPolicy: RoboMakerClientTypes.BatchPolicy? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdRequests: [RoboMakerClientTypes.SimulationJobSummary]? = nil,
        failedRequests: [RoboMakerClientTypes.FailedCreateSimulationJobRequest]? = nil,
        failureCode: RoboMakerClientTypes.SimulationJobBatchErrorCode? = nil,
        failureReason: Swift.String? = nil,
        pendingRequests: [RoboMakerClientTypes.SimulationJobRequest]? = nil,
        status: RoboMakerClientTypes.SimulationJobBatchStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.batchPolicy = batchPolicy
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.createdRequests = createdRequests
        self.failedRequests = failedRequests
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.pendingRequests = pendingRequests
        self.status = status
        self.tags = tags
    }
}

struct StartSimulationJobBatchOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let status: RoboMakerClientTypes.SimulationJobBatchStatus?
    let createdAt: ClientRuntime.Date?
    let clientRequestToken: Swift.String?
    let batchPolicy: RoboMakerClientTypes.BatchPolicy?
    let failureCode: RoboMakerClientTypes.SimulationJobBatchErrorCode?
    let failureReason: Swift.String?
    let failedRequests: [RoboMakerClientTypes.FailedCreateSimulationJobRequest]?
    let pendingRequests: [RoboMakerClientTypes.SimulationJobRequest]?
    let createdRequests: [RoboMakerClientTypes.SimulationJobSummary]?
    let tags: [Swift.String:Swift.String]?
}

extension StartSimulationJobBatchOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case batchPolicy
        case clientRequestToken
        case createdAt
        case createdRequests
        case failedRequests
        case failureCode
        case failureReason
        case pendingRequests
        case status
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobBatchStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let batchPolicyDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.BatchPolicy.self, forKey: .batchPolicy)
        batchPolicy = batchPolicyDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobBatchErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failedRequestsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.FailedCreateSimulationJobRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[RoboMakerClientTypes.FailedCreateSimulationJobRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [RoboMakerClientTypes.FailedCreateSimulationJobRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
        let pendingRequestsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationJobRequest?].self, forKey: .pendingRequests)
        var pendingRequestsDecoded0:[RoboMakerClientTypes.SimulationJobRequest]? = nil
        if let pendingRequestsContainer = pendingRequestsContainer {
            pendingRequestsDecoded0 = [RoboMakerClientTypes.SimulationJobRequest]()
            for structure0 in pendingRequestsContainer {
                if let structure0 = structure0 {
                    pendingRequestsDecoded0?.append(structure0)
                }
            }
        }
        pendingRequests = pendingRequestsDecoded0
        let createdRequestsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationJobSummary?].self, forKey: .createdRequests)
        var createdRequestsDecoded0:[RoboMakerClientTypes.SimulationJobSummary]? = nil
        if let createdRequestsContainer = createdRequestsContainer {
            createdRequestsDecoded0 = [RoboMakerClientTypes.SimulationJobSummary]()
            for structure0 in createdRequestsContainer {
                if let structure0 = structure0 {
                    createdRequestsDecoded0?.append(structure0)
                }
            }
        }
        createdRequests = createdRequestsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SyncDeploymentJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case fleet
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let fleet = self.fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
    }
}

extension SyncDeploymentJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/syncDeploymentJob"
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct SyncDeploymentJobInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The target fleet for the synchronization.
    /// This member is required.
    public var fleet: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        fleet: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.fleet = fleet
    }
}

struct SyncDeploymentJobInputBody: Swift.Equatable {
    let clientRequestToken: Swift.String?
    let fleet: Swift.String?
}

extension SyncDeploymentJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case fleet
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
    }
}

extension SyncDeploymentJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SyncDeploymentJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentDeploymentException" : self = .concurrentDeploymentException(try ConcurrentDeploymentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SyncDeploymentJobOutputError: Swift.Error, Swift.Equatable {
    case concurrentDeploymentException(ConcurrentDeploymentException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SyncDeploymentJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SyncDeploymentJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.deploymentApplicationConfigs = output.deploymentApplicationConfigs
            self.deploymentConfig = output.deploymentConfig
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.fleet = output.fleet
            self.status = output.status
        } else {
            self.arn = nil
            self.createdAt = nil
            self.deploymentApplicationConfigs = nil
            self.deploymentConfig = nil
            self.failureCode = nil
            self.failureReason = nil
            self.fleet = nil
            self.status = nil
        }
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct SyncDeploymentJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the synchronization request.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the fleet was created.
    public var createdAt: ClientRuntime.Date?
    /// Information about the deployment application configurations.
    public var deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
    /// Information about the deployment configuration.
    public var deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
    /// The failure code if the job fails: InternalServiceError Internal service error. RobotApplicationCrash Robot application exited abnormally. SimulationApplicationCrash Simulation application exited abnormally. BadPermissionsRobotApplication Robot application bundle could not be downloaded. BadPermissionsSimulationApplication Simulation application bundle could not be downloaded. BadPermissionsS3Output Unable to publish outputs to customer-provided S3 bucket. BadPermissionsCloudwatchLogs Unable to publish logs to customer-provided CloudWatch Logs resource. SubnetIpLimitExceeded Subnet IP limit exceeded. ENILimitExceeded ENI limit exceeded. BadPermissionsUserCredentials Unable to use the Role provided. InvalidBundleRobotApplication Robot bundle cannot be extracted (invalid format, bundling error, or other issue). InvalidBundleSimulationApplication Simulation bundle cannot be extracted (invalid format, bundling error, or other issue). RobotApplicationVersionMismatchedEtag Etag for RobotApplication does not match value during version creation. SimulationApplicationVersionMismatchedEtag Etag for SimulationApplication does not match value during version creation.
    public var failureCode: RoboMakerClientTypes.DeploymentJobErrorCode?
    /// The failure reason if the job fails.
    public var failureReason: Swift.String?
    /// The Amazon Resource Name (ARN) of the fleet.
    public var fleet: Swift.String?
    /// The status of the synchronization job.
    public var status: RoboMakerClientTypes.DeploymentStatus?

    public init (
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]? = nil,
        deploymentConfig: RoboMakerClientTypes.DeploymentConfig? = nil,
        failureCode: RoboMakerClientTypes.DeploymentJobErrorCode? = nil,
        failureReason: Swift.String? = nil,
        fleet: Swift.String? = nil,
        status: RoboMakerClientTypes.DeploymentStatus? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.deploymentApplicationConfigs = deploymentApplicationConfigs
        self.deploymentConfig = deploymentConfig
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.fleet = fleet
        self.status = status
    }
}

struct SyncDeploymentJobOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let fleet: Swift.String?
    let status: RoboMakerClientTypes.DeploymentStatus?
    let deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
    let deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
    let failureReason: Swift.String?
    let failureCode: RoboMakerClientTypes.DeploymentJobErrorCode?
    let createdAt: ClientRuntime.Date?
}

extension SyncDeploymentJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case deploymentApplicationConfigs
        case deploymentConfig
        case failureCode
        case failureReason
        case fleet
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentStatus.self, forKey: .status)
        status = statusDecoded
        let deploymentConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentConfig.self, forKey: .deploymentConfig)
        deploymentConfig = deploymentConfigDecoded
        let deploymentApplicationConfigsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DeploymentApplicationConfig?].self, forKey: .deploymentApplicationConfigs)
        var deploymentApplicationConfigsDecoded0:[RoboMakerClientTypes.DeploymentApplicationConfig]? = nil
        if let deploymentApplicationConfigsContainer = deploymentApplicationConfigsContainer {
            deploymentApplicationConfigsDecoded0 = [RoboMakerClientTypes.DeploymentApplicationConfig]()
            for structure0 in deploymentApplicationConfigsContainer {
                if let structure0 = structure0 {
                    deploymentApplicationConfigsDecoded0?.append(structure0)
                }
            }
        }
        deploymentApplicationConfigs = deploymentApplicationConfigsDecoded0
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the AWS RoboMaker resource you are tagging.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension RoboMakerClientTypes.TemplateLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket
        case s3Key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = self.s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a template location.
    public struct TemplateLocation: Swift.Equatable {
        /// The Amazon S3 bucket name.
        /// This member is required.
        public var s3Bucket: Swift.String?
        /// The list of S3 keys identifying the data source files.
        /// This member is required.
        public var s3Key: Swift.String?

        public init (
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }
    }

}

extension RoboMakerClientTypes.TemplateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case lastUpdatedAt
        case name
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension RoboMakerClientTypes {
    /// Summary information for a template.
    public struct TemplateSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the template.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the template was created.
        public var createdAt: ClientRuntime.Date?
        /// The time, in milliseconds since the epoch, when the template was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the template.
        public var name: Swift.String?
        /// The version of the template that you're using.
        public var version: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.version = version
        }
    }

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// AWS RoboMaker is temporarily unable to process the request. Try your call again.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RoboMakerClientTypes.Tool: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case command
        case exitBehavior
        case name
        case streamOutputToCloudWatch
        case streamUI
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let command = self.command {
            try encodeContainer.encode(command, forKey: .command)
        }
        if let exitBehavior = self.exitBehavior {
            try encodeContainer.encode(exitBehavior.rawValue, forKey: .exitBehavior)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let streamOutputToCloudWatch = self.streamOutputToCloudWatch {
            try encodeContainer.encode(streamOutputToCloudWatch, forKey: .streamOutputToCloudWatch)
        }
        if let streamUI = self.streamUI {
            try encodeContainer.encode(streamUI, forKey: .streamUI)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamUIDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .streamUI)
        streamUI = streamUIDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let commandDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .command)
        command = commandDecoded
        let streamOutputToCloudWatchDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .streamOutputToCloudWatch)
        streamOutputToCloudWatch = streamOutputToCloudWatchDecoded
        let exitBehaviorDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.ExitBehavior.self, forKey: .exitBehavior)
        exitBehavior = exitBehaviorDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a tool. Tools are used in a simulation job.
    public struct Tool: Swift.Equatable {
        /// Command-line arguments for the tool. It must include the tool executable name.
        /// This member is required.
        public var command: Swift.String?
        /// Exit behavior determines what happens when your tool quits running. RESTART will cause your tool to be restarted. FAIL will cause your job to exit. The default is RESTART.
        public var exitBehavior: RoboMakerClientTypes.ExitBehavior?
        /// The name of the tool.
        /// This member is required.
        public var name: Swift.String?
        /// Boolean indicating whether logs will be recorded in CloudWatch for the tool. The default is False.
        public var streamOutputToCloudWatch: Swift.Bool?
        /// Boolean indicating whether a streaming session will be configured for the tool. If True, AWS RoboMaker will configure a connection so you can interact with the tool as it is running in the simulation. It must have a graphical user interface. The default is False.
        public var streamUI: Swift.Bool?

        public init (
            command: Swift.String? = nil,
            exitBehavior: RoboMakerClientTypes.ExitBehavior? = nil,
            name: Swift.String? = nil,
            streamOutputToCloudWatch: Swift.Bool? = nil,
            streamUI: Swift.Bool? = nil
        )
        {
            self.command = command
            self.exitBehavior = exitBehavior
            self.name = name
            self.streamOutputToCloudWatch = streamOutputToCloudWatch
            self.streamUI = streamUI
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the AWS RoboMaker resource you are removing tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A map that contains tag keys and tag values that will be unattached from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateRobotApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case currentRevisionId
        case environment
        case robotSoftwareSuite
        case sources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = self.application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let currentRevisionId = self.currentRevisionId {
            try encodeContainer.encode(currentRevisionId, forKey: .currentRevisionId)
        }
        if let environment = self.environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let robotSoftwareSuite = self.robotSoftwareSuite {
            try encodeContainer.encode(robotSoftwareSuite, forKey: .robotSoftwareSuite)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for sourceconfig0 in sources {
                try sourcesContainer.encode(sourceconfig0)
            }
        }
    }
}

extension UpdateRobotApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateRobotApplication"
    }
}

public struct UpdateRobotApplicationInput: Swift.Equatable {
    /// The application information for the robot application.
    /// This member is required.
    public var application: Swift.String?
    /// The revision id for the robot application.
    public var currentRevisionId: Swift.String?
    /// The object that contains the Docker image URI for your robot application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The robot software suite (ROS distribution) used by the robot application.
    /// This member is required.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The sources of the robot application.
    public var sources: [RoboMakerClientTypes.SourceConfig]?

    public init (
        application: Swift.String? = nil,
        currentRevisionId: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.SourceConfig]? = nil
    )
    {
        self.application = application
        self.currentRevisionId = currentRevisionId
        self.environment = environment
        self.robotSoftwareSuite = robotSoftwareSuite
        self.sources = sources
    }
}

struct UpdateRobotApplicationInputBody: Swift.Equatable {
    let application: Swift.String?
    let sources: [RoboMakerClientTypes.SourceConfig]?
    let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    let currentRevisionId: Swift.String?
    let environment: RoboMakerClientTypes.Environment?
}

extension UpdateRobotApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case currentRevisionId
        case environment
        case robotSoftwareSuite
        case sources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SourceConfig?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.SourceConfig]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.SourceConfig]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let currentRevisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentRevisionId)
        currentRevisionId = currentRevisionIdDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

extension UpdateRobotApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRobotApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateRobotApplicationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRobotApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateRobotApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.environment = output.environment
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.sources = output.sources
            self.version = output.version
        } else {
            self.arn = nil
            self.environment = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.sources = nil
            self.version = nil
        }
    }
}

public struct UpdateRobotApplicationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated robot application.
    public var arn: Swift.String?
    /// The object that contains the Docker image URI for your robot application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The time, in milliseconds since the epoch, when the robot application was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the robot application.
    public var name: Swift.String?
    /// The revision id of the robot application.
    public var revisionId: Swift.String?
    /// The robot software suite (ROS distribution) used by the robot application.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The sources of the robot application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The version of the robot application.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.sources = sources
        self.version = version
    }
}

struct UpdateRobotApplicationOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let version: Swift.String?
    let sources: [RoboMakerClientTypes.Source]?
    let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    let lastUpdatedAt: ClientRuntime.Date?
    let revisionId: Swift.String?
    let environment: RoboMakerClientTypes.Environment?
}

extension UpdateRobotApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case environment
        case lastUpdatedAt
        case name
        case revisionId
        case robotSoftwareSuite
        case sources
        case version
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Source?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

extension UpdateSimulationApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case currentRevisionId
        case environment
        case renderingEngine
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = self.application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let currentRevisionId = self.currentRevisionId {
            try encodeContainer.encode(currentRevisionId, forKey: .currentRevisionId)
        }
        if let environment = self.environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let renderingEngine = self.renderingEngine {
            try encodeContainer.encode(renderingEngine, forKey: .renderingEngine)
        }
        if let robotSoftwareSuite = self.robotSoftwareSuite {
            try encodeContainer.encode(robotSoftwareSuite, forKey: .robotSoftwareSuite)
        }
        if let simulationSoftwareSuite = self.simulationSoftwareSuite {
            try encodeContainer.encode(simulationSoftwareSuite, forKey: .simulationSoftwareSuite)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for sourceconfig0 in sources {
                try sourcesContainer.encode(sourceconfig0)
            }
        }
    }
}

extension UpdateSimulationApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateSimulationApplication"
    }
}

public struct UpdateSimulationApplicationInput: Swift.Equatable {
    /// The application information for the simulation application.
    /// This member is required.
    public var application: Swift.String?
    /// The revision id for the robot application.
    public var currentRevisionId: Swift.String?
    /// The object that contains the Docker image URI for your simulation application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The rendering engine for the simulation application.
    public var renderingEngine: RoboMakerClientTypes.RenderingEngine?
    /// Information about the robot software suite (ROS distribution).
    /// This member is required.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The simulation software suite used by the simulation application.
    /// This member is required.
    public var simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    /// The sources of the simulation application.
    public var sources: [RoboMakerClientTypes.SourceConfig]?

    public init (
        application: Swift.String? = nil,
        currentRevisionId: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        renderingEngine: RoboMakerClientTypes.RenderingEngine? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.SourceConfig]? = nil
    )
    {
        self.application = application
        self.currentRevisionId = currentRevisionId
        self.environment = environment
        self.renderingEngine = renderingEngine
        self.robotSoftwareSuite = robotSoftwareSuite
        self.simulationSoftwareSuite = simulationSoftwareSuite
        self.sources = sources
    }
}

struct UpdateSimulationApplicationInputBody: Swift.Equatable {
    let application: Swift.String?
    let sources: [RoboMakerClientTypes.SourceConfig]?
    let simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    let renderingEngine: RoboMakerClientTypes.RenderingEngine?
    let currentRevisionId: Swift.String?
    let environment: RoboMakerClientTypes.Environment?
}

extension UpdateSimulationApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case currentRevisionId
        case environment
        case renderingEngine
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SourceConfig?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.SourceConfig]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.SourceConfig]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let simulationSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationSoftwareSuite.self, forKey: .simulationSoftwareSuite)
        simulationSoftwareSuite = simulationSoftwareSuiteDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let renderingEngineDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RenderingEngine.self, forKey: .renderingEngine)
        renderingEngine = renderingEngineDecoded
        let currentRevisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentRevisionId)
        currentRevisionId = currentRevisionIdDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

extension UpdateSimulationApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSimulationApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSimulationApplicationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSimulationApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateSimulationApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.environment = output.environment
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.renderingEngine = output.renderingEngine
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.simulationSoftwareSuite = output.simulationSoftwareSuite
            self.sources = output.sources
            self.version = output.version
        } else {
            self.arn = nil
            self.environment = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.renderingEngine = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.simulationSoftwareSuite = nil
            self.sources = nil
            self.version = nil
        }
    }
}

public struct UpdateSimulationApplicationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated simulation application.
    public var arn: Swift.String?
    /// The object that contains the Docker image URI used for your simulation application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The time, in milliseconds since the epoch, when the simulation application was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the simulation application.
    public var name: Swift.String?
    /// The rendering engine for the simulation application.
    public var renderingEngine: RoboMakerClientTypes.RenderingEngine?
    /// The revision id of the simulation application.
    public var revisionId: Swift.String?
    /// Information about the robot software suite (ROS distribution).
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The simulation software suite used by the simulation application.
    public var simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    /// The sources of the simulation application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The version of the robot application.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        renderingEngine: RoboMakerClientTypes.RenderingEngine? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.renderingEngine = renderingEngine
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.simulationSoftwareSuite = simulationSoftwareSuite
        self.sources = sources
        self.version = version
    }
}

struct UpdateSimulationApplicationOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let version: Swift.String?
    let sources: [RoboMakerClientTypes.Source]?
    let simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    let renderingEngine: RoboMakerClientTypes.RenderingEngine?
    let lastUpdatedAt: ClientRuntime.Date?
    let revisionId: Swift.String?
    let environment: RoboMakerClientTypes.Environment?
}

extension UpdateSimulationApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case environment
        case lastUpdatedAt
        case name
        case renderingEngine
        case revisionId
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
        case version
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Source?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let simulationSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationSoftwareSuite.self, forKey: .simulationSoftwareSuite)
        simulationSoftwareSuite = simulationSoftwareSuiteDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let renderingEngineDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RenderingEngine.self, forKey: .renderingEngine)
        renderingEngine = renderingEngineDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

extension UpdateWorldTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case template
        case templateBody
        case templateLocation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let template = self.template {
            try encodeContainer.encode(template, forKey: .template)
        }
        if let templateBody = self.templateBody {
            try encodeContainer.encode(templateBody, forKey: .templateBody)
        }
        if let templateLocation = self.templateLocation {
            try encodeContainer.encode(templateLocation, forKey: .templateLocation)
        }
    }
}

extension UpdateWorldTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateWorldTemplate"
    }
}

public struct UpdateWorldTemplateInput: Swift.Equatable {
    /// The name of the template.
    public var name: Swift.String?
    /// The Amazon Resource Name (arn) of the world template to update.
    /// This member is required.
    public var template: Swift.String?
    /// The world template body.
    public var templateBody: Swift.String?
    /// The location of the world template.
    public var templateLocation: RoboMakerClientTypes.TemplateLocation?

    public init (
        name: Swift.String? = nil,
        template: Swift.String? = nil,
        templateBody: Swift.String? = nil,
        templateLocation: RoboMakerClientTypes.TemplateLocation? = nil
    )
    {
        self.name = name
        self.template = template
        self.templateBody = templateBody
        self.templateLocation = templateLocation
    }
}

struct UpdateWorldTemplateInputBody: Swift.Equatable {
    let template: Swift.String?
    let name: Swift.String?
    let templateBody: Swift.String?
    let templateLocation: RoboMakerClientTypes.TemplateLocation?
}

extension UpdateWorldTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case template
        case templateBody
        case templateLocation
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let templateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let templateLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.TemplateLocation.self, forKey: .templateLocation)
        templateLocation = templateLocationDecoded
    }
}

extension UpdateWorldTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWorldTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateWorldTemplateOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWorldTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateWorldTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
        } else {
            self.arn = nil
            self.createdAt = nil
            self.lastUpdatedAt = nil
            self.name = nil
        }
    }
}

public struct UpdateWorldTemplateOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the world template.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the world template was created.
    public var createdAt: ClientRuntime.Date?
    /// The time, in milliseconds since the epoch, when the world template was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the world template.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
    }
}

struct UpdateWorldTemplateOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
}

extension UpdateWorldTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case lastUpdatedAt
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension RoboMakerClientTypes {
    public enum UploadBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case uploadOnTerminate
        case uploadRollingAutoRemove
        case sdkUnknown(Swift.String)

        public static var allCases: [UploadBehavior] {
            return [
                .uploadOnTerminate,
                .uploadRollingAutoRemove,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .uploadOnTerminate: return "UPLOAD_ON_TERMINATE"
            case .uploadRollingAutoRemove: return "UPLOAD_ROLLING_AUTO_REMOVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UploadBehavior(rawValue: rawValue) ?? UploadBehavior.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.UploadConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case path
        case uploadBehavior
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let uploadBehavior = self.uploadBehavior {
            try encodeContainer.encode(uploadBehavior.rawValue, forKey: .uploadBehavior)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let uploadBehaviorDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.UploadBehavior.self, forKey: .uploadBehavior)
        uploadBehavior = uploadBehaviorDecoded
    }
}

extension RoboMakerClientTypes {
    /// Provides upload configuration information. Files are uploaded from the simulation job to a location you specify.
    public struct UploadConfiguration: Swift.Equatable {
        /// A prefix that specifies where files will be uploaded in Amazon S3. It is appended to the simulation output location to determine the final path. For example, if your simulation output location is s3://my-bucket and your upload configuration name is robot-test, your files will be uploaded to s3://my-bucket///robot-test.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the path of the file(s) to upload. Standard Unix glob matching rules are accepted, with the addition of ** as a super asterisk. For example, specifying /var/log/**.log causes all .log files in the /var/log directory tree to be collected. For more examples, see [Glob Library](https://github.com/gobwas/glob).
        /// This member is required.
        public var path: Swift.String?
        /// Specifies when to upload the files: UPLOAD_ON_TERMINATE Matching files are uploaded once the simulation enters the TERMINATING state. Matching files are not uploaded until all of your code (including tools) have stopped. If there is a problem uploading a file, the upload is retried. If problems persist, no further upload attempts will be made. UPLOAD_ROLLING_AUTO_REMOVE Matching files are uploaded as they are created. They are deleted after they are uploaded. The specified path is checked every 5 seconds. A final check is made when all of your code (including tools) have stopped.
        /// This member is required.
        public var uploadBehavior: RoboMakerClientTypes.UploadBehavior?

        public init (
            name: Swift.String? = nil,
            path: Swift.String? = nil,
            uploadBehavior: RoboMakerClientTypes.UploadBehavior? = nil
        )
        {
            self.name = name
            self.path = path
            self.uploadBehavior = uploadBehavior
        }
    }

}

extension RoboMakerClientTypes.VPCConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignPublicIp
        case securityGroups
        case subnets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if assignPublicIp != false {
            try encodeContainer.encode(assignPublicIp, forKey: .assignPublicIp)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for nonemptystring0 in securityGroups {
                try securityGroupsContainer.encode(nonemptystring0)
            }
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for nonemptystring0 in subnets {
                try subnetsContainer.encode(nonemptystring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnets)
        var subnetsDecoded0:[Swift.String]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [Swift.String]()
            for string0 in subnetsContainer {
                if let string0 = string0 {
                    subnetsDecoded0?.append(string0)
                }
            }
        }
        subnets = subnetsDecoded0
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let assignPublicIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .assignPublicIp) ?? false
        assignPublicIp = assignPublicIpDecoded
    }
}

extension RoboMakerClientTypes {
    /// If your simulation job accesses resources in a VPC, you provide this parameter identifying the list of security group IDs and subnet IDs. These must belong to the same VPC. You must provide at least one security group and two subnet IDs.
    public struct VPCConfig: Swift.Equatable {
        /// A boolean indicating whether to assign a public IP address.
        public var assignPublicIp: Swift.Bool
        /// A list of one or more security groups IDs in your VPC.
        public var securityGroups: [Swift.String]?
        /// A list of one or more subnet IDs in your VPC.
        /// This member is required.
        public var subnets: [Swift.String]?

        public init (
            assignPublicIp: Swift.Bool = false,
            securityGroups: [Swift.String]? = nil,
            subnets: [Swift.String]? = nil
        )
        {
            self.assignPublicIp = assignPublicIp
            self.securityGroups = securityGroups
            self.subnets = subnets
        }
    }

}

extension RoboMakerClientTypes.VPCConfigResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignPublicIp
        case securityGroups
        case subnets
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if assignPublicIp != false {
            try encodeContainer.encode(assignPublicIp, forKey: .assignPublicIp)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for nonemptystring0 in securityGroups {
                try securityGroupsContainer.encode(nonemptystring0)
            }
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for nonemptystring0 in subnets {
                try subnetsContainer.encode(nonemptystring0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnets)
        var subnetsDecoded0:[Swift.String]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [Swift.String]()
            for string0 in subnetsContainer {
                if let string0 = string0 {
                    subnetsDecoded0?.append(string0)
                }
            }
        }
        subnets = subnetsDecoded0
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let assignPublicIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .assignPublicIp) ?? false
        assignPublicIp = assignPublicIpDecoded
    }
}

extension RoboMakerClientTypes {
    /// VPC configuration associated with your simulation job.
    public struct VPCConfigResponse: Swift.Equatable {
        /// A boolean indicating if a public IP was assigned.
        public var assignPublicIp: Swift.Bool
        /// A list of security group IDs associated with the simulation job.
        public var securityGroups: [Swift.String]?
        /// A list of subnet IDs associated with the simulation job.
        public var subnets: [Swift.String]?
        /// The VPC ID associated with your simulation job.
        public var vpcId: Swift.String?

        public init (
            assignPublicIp: Swift.Bool = false,
            securityGroups: [Swift.String]? = nil,
            subnets: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.assignPublicIp = assignPublicIp
            self.securityGroups = securityGroups
            self.subnets = subnets
            self.vpcId = vpcId
        }
    }

}

extension RoboMakerClientTypes.WorldConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case world
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let world = self.world {
            try encodeContainer.encode(world, forKey: .world)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let worldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .world)
        world = worldDecoded
    }
}

extension RoboMakerClientTypes {
    /// Configuration information for a world.
    public struct WorldConfig: Swift.Equatable {
        /// The world generated by Simulation WorldForge.
        public var world: Swift.String?

        public init (
            world: Swift.String? = nil
        )
        {
            self.world = world
        }
    }

}

extension RoboMakerClientTypes.WorldCount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case floorplanCount
        case interiorCountPerFloorplan
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let floorplanCount = self.floorplanCount {
            try encodeContainer.encode(floorplanCount, forKey: .floorplanCount)
        }
        if let interiorCountPerFloorplan = self.interiorCountPerFloorplan {
            try encodeContainer.encode(interiorCountPerFloorplan, forKey: .interiorCountPerFloorplan)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let floorplanCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .floorplanCount)
        floorplanCount = floorplanCountDecoded
        let interiorCountPerFloorplanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .interiorCountPerFloorplan)
        interiorCountPerFloorplan = interiorCountPerFloorplanDecoded
    }
}

extension RoboMakerClientTypes {
    /// The number of worlds that will be created. You can configure the number of unique floorplans and the number of unique interiors for each floor plan. For example, if you want 1 world with 20 unique interiors, you set floorplanCount = 1 and interiorCountPerFloorplan = 20. This will result in 20 worlds (floorplanCount * interiorCountPerFloorplan). If you set floorplanCount = 4 and interiorCountPerFloorplan = 5, there will be 20 worlds with 5 unique floor plans.
    public struct WorldCount: Swift.Equatable {
        /// The number of unique floorplans.
        public var floorplanCount: Swift.Int?
        /// The number of unique interiors per floorplan.
        public var interiorCountPerFloorplan: Swift.Int?

        public init (
            floorplanCount: Swift.Int? = nil,
            interiorCountPerFloorplan: Swift.Int? = nil
        )
        {
            self.floorplanCount = floorplanCount
            self.interiorCountPerFloorplan = interiorCountPerFloorplan
        }
    }

}

extension RoboMakerClientTypes {
    public enum WorldExportJobErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessdenied
        case internalserviceerror
        case invalidinput
        case limitexceeded
        case requestthrottled
        case resourcenotfound
        case sdkUnknown(Swift.String)

        public static var allCases: [WorldExportJobErrorCode] {
            return [
                .accessdenied,
                .internalserviceerror,
                .invalidinput,
                .limitexceeded,
                .requestthrottled,
                .resourcenotfound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdenied: return "AccessDenied"
            case .internalserviceerror: return "InternalServiceError"
            case .invalidinput: return "InvalidInput"
            case .limitexceeded: return "LimitExceeded"
            case .requestthrottled: return "RequestThrottled"
            case .resourcenotfound: return "ResourceNotFound"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorldExportJobErrorCode(rawValue: rawValue) ?? WorldExportJobErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes {
    public enum WorldExportJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case canceling
        case completed
        case failed
        case pending
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [WorldExportJobStatus] {
            return [
                .canceled,
                .canceling,
                .completed,
                .failed,
                .pending,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "Canceled"
            case .canceling: return "Canceling"
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .pending: return "Pending"
            case .running: return "Running"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorldExportJobStatus(rawValue: rawValue) ?? WorldExportJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.WorldExportJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case outputLocation
        case status
        case worlds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let outputLocation = self.outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let worlds = worlds {
            var worldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .worlds)
            for arn0 in worlds {
                try worldsContainer.encode(arn0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldExportJobStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let worldsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .worlds)
        var worldsDecoded0:[Swift.String]? = nil
        if let worldsContainer = worldsContainer {
            worldsDecoded0 = [Swift.String]()
            for string0 in worldsContainer {
                if let string0 = string0 {
                    worldsDecoded0?.append(string0)
                }
            }
        }
        worlds = worldsDecoded0
        let outputLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a world export job.
    public struct WorldExportJobSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the world export job.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the world export job was created.
        public var createdAt: ClientRuntime.Date?
        /// The output location.
        public var outputLocation: RoboMakerClientTypes.OutputLocation?
        /// The status of the world export job. Pending The world export job request is pending. Running The world export job is running. Completed The world export job completed. Failed The world export job failed. See failureCode for more information. Canceled The world export job was cancelled. Canceling The world export job is being cancelled.
        public var status: RoboMakerClientTypes.WorldExportJobStatus?
        /// A list of worlds.
        public var worlds: [Swift.String]?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
            status: RoboMakerClientTypes.WorldExportJobStatus? = nil,
            worlds: [Swift.String]? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.outputLocation = outputLocation
            self.status = status
            self.worlds = worlds
        }
    }

}

extension RoboMakerClientTypes.WorldFailure: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureCode
        case failureCount
        case sampleFailureReason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureCode = self.failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if failureCount != 0 {
            try encodeContainer.encode(failureCount, forKey: .failureCount)
        }
        if let sampleFailureReason = self.sampleFailureReason {
            try encodeContainer.encode(sampleFailureReason, forKey: .sampleFailureReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldGenerationJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let sampleFailureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sampleFailureReason)
        sampleFailureReason = sampleFailureReasonDecoded
        let failureCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failureCount) ?? 0
        failureCount = failureCountDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a failed world.
    public struct WorldFailure: Swift.Equatable {
        /// The failure code of the world export job if it failed: InternalServiceError Internal service error. LimitExceeded The requested resource exceeds the maximum number allowed, or the number of concurrent stream requests exceeds the maximum number allowed. ResourceNotFound The specified resource could not be found. RequestThrottled The request was throttled. InvalidInput An input parameter in the request is not valid.
        public var failureCode: RoboMakerClientTypes.WorldGenerationJobErrorCode?
        /// The number of failed worlds.
        public var failureCount: Swift.Int
        /// The sample reason why the world failed. World errors are aggregated. A sample is used as the sampleFailureReason.
        public var sampleFailureReason: Swift.String?

        public init (
            failureCode: RoboMakerClientTypes.WorldGenerationJobErrorCode? = nil,
            failureCount: Swift.Int = 0,
            sampleFailureReason: Swift.String? = nil
        )
        {
            self.failureCode = failureCode
            self.failureCount = failureCount
            self.sampleFailureReason = sampleFailureReason
        }
    }

}

extension RoboMakerClientTypes {
    public enum WorldGenerationJobErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allworldgenerationfailed
        case internalserviceerror
        case invalidinput
        case limitexceeded
        case requestthrottled
        case resourcenotfound
        case sdkUnknown(Swift.String)

        public static var allCases: [WorldGenerationJobErrorCode] {
            return [
                .allworldgenerationfailed,
                .internalserviceerror,
                .invalidinput,
                .limitexceeded,
                .requestthrottled,
                .resourcenotfound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allworldgenerationfailed: return "AllWorldGenerationFailed"
            case .internalserviceerror: return "InternalServiceError"
            case .invalidinput: return "InvalidInput"
            case .limitexceeded: return "LimitExceeded"
            case .requestthrottled: return "RequestThrottled"
            case .resourcenotfound: return "ResourceNotFound"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorldGenerationJobErrorCode(rawValue: rawValue) ?? WorldGenerationJobErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes {
    public enum WorldGenerationJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case canceling
        case completed
        case failed
        case partialfailed
        case pending
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [WorldGenerationJobStatus] {
            return [
                .canceled,
                .canceling,
                .completed,
                .failed,
                .partialfailed,
                .pending,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "Canceled"
            case .canceling: return "Canceling"
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .partialfailed: return "PartialFailed"
            case .pending: return "Pending"
            case .running: return "Running"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorldGenerationJobStatus(rawValue: rawValue) ?? WorldGenerationJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.WorldGenerationJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case failedWorldCount
        case status
        case succeededWorldCount
        case template
        case worldCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if failedWorldCount != 0 {
            try encodeContainer.encode(failedWorldCount, forKey: .failedWorldCount)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if succeededWorldCount != 0 {
            try encodeContainer.encode(succeededWorldCount, forKey: .succeededWorldCount)
        }
        if let template = self.template {
            try encodeContainer.encode(template, forKey: .template)
        }
        if let worldCount = self.worldCount {
            try encodeContainer.encode(worldCount, forKey: .worldCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldGenerationJobStatus.self, forKey: .status)
        status = statusDecoded
        let worldCountDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldCount.self, forKey: .worldCount)
        worldCount = worldCountDecoded
        let succeededWorldCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .succeededWorldCount) ?? 0
        succeededWorldCount = succeededWorldCountDecoded
        let failedWorldCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failedWorldCount) ?? 0
        failedWorldCount = failedWorldCountDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a world generator job.
    public struct WorldGenerationJobSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the world generator job.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the world generator job was created.
        public var createdAt: ClientRuntime.Date?
        /// The number of worlds that failed.
        public var failedWorldCount: Swift.Int
        /// The status of the world generator job: Pending The world generator job request is pending. Running The world generator job is running. Completed The world generator job completed. Failed The world generator job failed. See failureCode for more information. PartialFailed Some worlds did not generate. Canceled The world generator job was cancelled. Canceling The world generator job is being cancelled.
        public var status: RoboMakerClientTypes.WorldGenerationJobStatus?
        /// The number of worlds that were generated.
        public var succeededWorldCount: Swift.Int
        /// The Amazon Resource Name (arn) of the world template.
        public var template: Swift.String?
        /// Information about the world count.
        public var worldCount: RoboMakerClientTypes.WorldCount?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            failedWorldCount: Swift.Int = 0,
            status: RoboMakerClientTypes.WorldGenerationJobStatus? = nil,
            succeededWorldCount: Swift.Int = 0,
            template: Swift.String? = nil,
            worldCount: RoboMakerClientTypes.WorldCount? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.failedWorldCount = failedWorldCount
            self.status = status
            self.succeededWorldCount = succeededWorldCount
            self.template = template
            self.worldCount = worldCount
        }
    }

}

extension RoboMakerClientTypes.WorldSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case generationJob
        case template
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let generationJob = self.generationJob {
            try encodeContainer.encode(generationJob, forKey: .generationJob)
        }
        if let template = self.template {
            try encodeContainer.encode(template, forKey: .template)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let generationJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generationJob)
        generationJob = generationJobDecoded
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a world.
    public struct WorldSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the world.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the world was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name (arn) of the world generation job.
        public var generationJob: Swift.String?
        /// The Amazon Resource Name (arn) of the world template.
        public var template: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            generationJob: Swift.String? = nil,
            template: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.generationJob = generationJob
            self.template = template
        }
    }

}
