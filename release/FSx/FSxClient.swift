// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation

public class FSxClient {
    let client: SdkHttpClient
    let config: FSxClientConfiguration
    let serviceName = "FSx"
    let encoder: RequestEncoder
    let decoder: ResponseDecoder

    public init(config: FSxClientConfiguration) {
        client = SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.encoder = config.encoder ?? encoder
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public class FSxClientConfiguration: ClientRuntime.Configuration, AWSClientConfiguration {

        public var region: String
        public var credentialsProvider: AWSCredentialsProvider
        public var signingRegion: String
        public var endpointResolver: EndpointResolver

        public init (
            credentialsProvider: AWSCredentialsProvider,
            endpointResolver: EndpointResolver,
            region: String,
            signingRegion: String
        ) throws
        {
            self.credentialsProvider = credentialsProvider
            self.endpointResolver = endpointResolver
            self.region = region
            self.signingRegion = signingRegion
        }

        public convenience init(credentialsProvider: AWSCredentialsProvider) throws {
            let region = "us-east-1"
            let signingRegion = "us-east-1"
            let endpointResolver = DefaultEndpointResolver()
            try self.init(
                credentialsProvider: credentialsProvider,
                endpointResolver: endpointResolver,
                region: region,
                signingRegion: signingRegion
            )
        }

        public static func `default`() throws -> FSxClientConfiguration {
            let awsCredsProvider = try AWSCredentialsProvider.fromEnv()
            return try FSxClientConfiguration(credentialsProvider: awsCredsProvider)
        }
    }
}

extension FSxClient: FSxClientProtocol {
    /// <p>Use this action to associate one or more Domain Name Server (DNS) aliases with an existing Amazon FSx for Windows File Server file system.
    ///         A file systen can have a maximum of 50 DNS aliases associated with it at any one time. If you try to
    ///         associate a DNS alias that is already associated with the file system, FSx takes no action on that alias in the request.
    ///         For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/managing-dns-aliases.html">Working with DNS Aliases</a> and
    ///             <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/walkthrough05-file-system-custom-CNAME.html">Walkthrough 5: Using DNS aliases to access your file system</a>, including
    ///              additional steps you must take to be able to access your file system using a DNS alias.</p>
    ///         <p>The system response shows the DNS aliases that
    ///             Amazon FSx is attempting to associate with the file system.
    ///             Use the  API
    ///             operation to monitor the status of the aliases Amazon FSx is
    ///             associating with the file system.</p>
    public func associateFileSystemAliases(input: AssociateFileSystemAliasesInput, completion: @escaping (SdkResult<AssociateFileSystemAliasesOutputResponse, AssociateFileSystemAliasesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "associateFileSystemAliases")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "fsx.\(config.region).amazonaws.com")
                      .withSigningName(value: "fsx")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AssociateFileSystemAliasesInput, AssociateFileSystemAliasesOutputResponse, AssociateFileSystemAliasesOutputError>(id: "associateFileSystemAliases")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<AssociateFileSystemAliasesOutputResponse>, SdkError<AssociateFileSystemAliasesOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: AssociateFileSystemAliasesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AssociateFileSystemAliasesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AssociateFileSystemAliasesInput, AssociateFileSystemAliasesOutputResponse, AssociateFileSystemAliasesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: AssociateFileSystemAliasesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<AssociateFileSystemAliasesInput, AssociateFileSystemAliasesOutputResponse, AssociateFileSystemAliasesOutputError>(xAmzTarget: "AWSSimbaAPIService_v20180301.AssociateFileSystemAliases"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Cancels an existing Amazon FSx for Lustre data repository task if that task is in either the
    ///             <code>PENDING</code> or <code>EXECUTING</code> state. When you cancel a task, Amazon FSx does the following.</p>
    ///             <ul>
    ///             <li>
    ///                <p>Any files that FSx has already exported are not reverted.</p>
    ///             </li>
    ///             <li>
    ///                <p>FSx continues to export any files that are "in-flight" when the cancel operation is received.</p>
    ///             </li>
    ///             <li>
    ///                <p>FSx does not export any files that have not yet been exported.</p>
    ///             </li>
    ///          </ul>
    public func cancelDataRepositoryTask(input: CancelDataRepositoryTaskInput, completion: @escaping (SdkResult<CancelDataRepositoryTaskOutputResponse, CancelDataRepositoryTaskOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "cancelDataRepositoryTask")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "fsx.\(config.region).amazonaws.com")
                      .withSigningName(value: "fsx")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CancelDataRepositoryTaskInput, CancelDataRepositoryTaskOutputResponse, CancelDataRepositoryTaskOutputError>(id: "cancelDataRepositoryTask")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CancelDataRepositoryTaskInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CancelDataRepositoryTaskInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CancelDataRepositoryTaskInput, CancelDataRepositoryTaskOutputResponse, CancelDataRepositoryTaskOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CancelDataRepositoryTaskInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CancelDataRepositoryTaskInput, CancelDataRepositoryTaskOutputResponse, CancelDataRepositoryTaskOutputError>(xAmzTarget: "AWSSimbaAPIService_v20180301.CancelDataRepositoryTask"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Copies an existing backup within the same AWS account to another Region
    ///          (cross-Region copy) or within the same Region (in-Region copy). You can have up to five
    ///          backup copy requests in progress to a single destination Region per account.</p>
    ///          <p>You can use cross-Region backup copies for cross-region disaster recovery.
    ///          You periodically take backups and copy them to another Region so that in the
    ///          event of a disaster in the primary Region, you can restore from backup and recover
    ///          availability quickly in the other Region. You can make cross-Region copies
    ///          only within your AWS partition.</p>
    ///          <p> You can also use backup copies to clone your file data set to another Region
    ///          or within the same Region.</p>
    ///          <p>You can use the <code>SourceRegion</code> parameter to specify the AWS Region
    ///          from which the backup will be copied. For example, if you make the call from the
    ///          <code>us-west-1</code> Region and want to copy a backup from the <code>us-east-2</code>
    ///          Region, you specify <code>us-east-2</code> in the <code>SourceRegion</code> parameter
    ///          to make a cross-Region copy. If you don't specify a Region, the backup copy is
    ///          created in the same Region where the request is sent from (in-Region copy).</p>
    ///          <p>For more information on creating backup copies, see
    ///          <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/using-backups.html#copy-backups">
    ///             Copying backups</a> in the <i>Amazon FSx for Windows User Guide</i> and
    ///          <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/using-backups-fsx.html#copy-backups">Copying backups</a>
    ///          in the <i>Amazon FSx for Lustre User Guide</i>.</p>
    public func copyBackup(input: CopyBackupInput, completion: @escaping (SdkResult<CopyBackupOutputResponse, CopyBackupOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "copyBackup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "fsx.\(config.region).amazonaws.com")
                      .withSigningName(value: "fsx")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CopyBackupInput, CopyBackupOutputResponse, CopyBackupOutputError>(id: "copyBackup")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CopyBackupOutputResponse>, SdkError<CopyBackupOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CopyBackupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CopyBackupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CopyBackupInput, CopyBackupOutputResponse, CopyBackupOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CopyBackupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CopyBackupInput, CopyBackupOutputResponse, CopyBackupOutputError>(xAmzTarget: "AWSSimbaAPIService_v20180301.CopyBackup"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a backup of an existing Amazon FSx file system.
    ///             Creating regular backups for your file system is a best practice, enabling you to restore a file system
    ///             from a backup if an issue arises with the original file system.</p>
    ///         <p>For Amazon FSx for Lustre file systems, you can create a backup only
    ///             for file systems with the following configuration:</p>
    ///         <ul>
    ///             <li>
    ///                <p>a Persistent deployment type</p>
    ///             </li>
    ///             <li>
    ///                <p>is <i>not</i> linked to a data respository.</p>
    ///             </li>
    ///          </ul>
    ///             <p>For more information about backing up Amazon FSx for Lustre file systems,
    ///                 see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/using-backups-fsx.html">Working with FSx for Lustre backups</a>.</p>
    ///         <p>For more information about backing up Amazon FSx for Windows file systems,
    ///             see <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/using-backups.html">Working with FSx for Windows backups</a>.</p>
    ///
    ///         <p>If a backup with the specified client request token exists, and the parameters
    ///             match, this operation returns the description of the existing backup. If a backup
    ///             specified client request token exists, and the parameters don't match, this
    ///             operation returns <code>IncompatibleParameterError</code>. If a backup with the
    ///             specified client request token doesn't exist, <code>CreateBackup</code> does the
    ///             following: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>Creates a new Amazon FSx backup with an assigned ID, and an initial
    ///                     lifecycle state of <code>CREATING</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Returns the description of the backup.</p>
    ///             </li>
    ///          </ul>
    ///
    ///         <p>By using the idempotent operation, you can retry a <code>CreateBackup</code>
    ///             operation without the risk of creating an extra backup. This approach can be useful when
    ///             an initial call fails in a way that makes it unclear whether a backup was created. If
    ///             you use the same client request token and the initial call created a backup, the
    ///             operation returns a successful result because all the parameters are the same.</p>
    ///
    ///         <p>The <code>CreateBackup</code> operation returns while the backup's
    ///             lifecycle state is still <code>CREATING</code>. You can check the backup creation
    ///             status by calling the <a>DescribeBackups</a> operation, which returns the
    ///             backup state along with other information.</p>
    public func createBackup(input: CreateBackupInput, completion: @escaping (SdkResult<CreateBackupOutputResponse, CreateBackupOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createBackup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "fsx.\(config.region).amazonaws.com")
                      .withSigningName(value: "fsx")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateBackupInput, CreateBackupOutputResponse, CreateBackupOutputError>(id: "createBackup")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreateBackupOutputResponse>, SdkError<CreateBackupOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateBackupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateBackupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateBackupInput, CreateBackupOutputResponse, CreateBackupOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CreateBackupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CreateBackupInput, CreateBackupOutputResponse, CreateBackupOutputError>(xAmzTarget: "AWSSimbaAPIService_v20180301.CreateBackup"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates an Amazon FSx for Lustre data repository task. You use data repository tasks
    ///             to perform bulk operations between your Amazon FSx file system and its linked data
    ///             repository. An example of a data repository task is
    ///             exporting any data and metadata changes, including POSIX metadata, to files, directories, and symbolic links (symlinks) from your FSx file system to its linked data repository. A
    ///                 <code>CreateDataRepositoryTask</code> operation will fail if a data repository is not
    ///             linked to the FSx file system. To learn more about data repository tasks, see
    ///             <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/data-repository-tasks.html">Data Repository Tasks</a>.
    ///             To learn more about linking a data repository to your file system, see
    ///             <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/create-fs-linked-data-repo.html">Linking your file system to an S3 bucket</a>.</p>
    public func createDataRepositoryTask(input: CreateDataRepositoryTaskInput, completion: @escaping (SdkResult<CreateDataRepositoryTaskOutputResponse, CreateDataRepositoryTaskOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createDataRepositoryTask")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "fsx.\(config.region).amazonaws.com")
                      .withSigningName(value: "fsx")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateDataRepositoryTaskInput, CreateDataRepositoryTaskOutputResponse, CreateDataRepositoryTaskOutputError>(id: "createDataRepositoryTask")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreateDataRepositoryTaskOutputResponse>, SdkError<CreateDataRepositoryTaskOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateDataRepositoryTaskInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateDataRepositoryTaskInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateDataRepositoryTaskInput, CreateDataRepositoryTaskOutputResponse, CreateDataRepositoryTaskOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CreateDataRepositoryTaskInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CreateDataRepositoryTaskInput, CreateDataRepositoryTaskOutputResponse, CreateDataRepositoryTaskOutputError>(xAmzTarget: "AWSSimbaAPIService_v20180301.CreateDataRepositoryTask"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new, empty Amazon FSx file system.</p>
    ///
    ///         <p>If a file system with the specified client request token exists and the parameters
    ///             match, <code>CreateFileSystem</code> returns the description of the existing file
    ///             system. If a file system specified client request token exists and the parameters
    ///             don't match, this call returns <code>IncompatibleParameterError</code>. If a file
    ///             system with the specified client request token doesn't exist,
    ///                 <code>CreateFileSystem</code> does the following: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>Creates a new, empty Amazon FSx file system with an assigned ID, and an
    ///                     initial lifecycle state of <code>CREATING</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Returns the description of the file system.</p>
    ///             </li>
    ///          </ul>
    ///
    ///         <p>This operation requires a client request token in the request that Amazon FSx uses
    ///             to ensure idempotent creation. This means that calling the operation multiple times with
    ///             the same client request token has no effect. By using the idempotent operation, you can
    ///             retry a <code>CreateFileSystem</code> operation without the risk of creating an extra
    ///             file system. This approach can be useful when an initial call fails in a way that makes
    ///             it unclear whether a file system was created. Examples are if a transport level timeout
    ///             occurred, or your connection was reset. If you use the same client request token and the
    ///             initial call created a file system, the client receives success as long as the
    ///             parameters are the same.</p>
    ///         <note>
    ///             <p>The <code>CreateFileSystem</code> call returns while the file system's
    ///                 lifecycle state is still <code>CREATING</code>. You can check the file-system
    ///                 creation status by calling the <a>DescribeFileSystems</a> operation,
    ///                 which returns the file system state along with other information.</p>
    ///         </note>
    public func createFileSystem(input: CreateFileSystemInput, completion: @escaping (SdkResult<CreateFileSystemOutputResponse, CreateFileSystemOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createFileSystem")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "fsx.\(config.region).amazonaws.com")
                      .withSigningName(value: "fsx")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateFileSystemInput, CreateFileSystemOutputResponse, CreateFileSystemOutputError>(id: "createFileSystem")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreateFileSystemOutputResponse>, SdkError<CreateFileSystemOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateFileSystemInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateFileSystemInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateFileSystemInput, CreateFileSystemOutputResponse, CreateFileSystemOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CreateFileSystemInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CreateFileSystemInput, CreateFileSystemOutputResponse, CreateFileSystemOutputError>(xAmzTarget: "AWSSimbaAPIService_v20180301.CreateFileSystem"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new Amazon FSx file system from an existing Amazon FSx backup.</p>
    ///
    ///         <p>If a file system with the specified client request token exists and the parameters
    ///             match, this operation returns the description of the file system. If a client
    ///             request token specified by the file system exists and the parameters don't match,
    ///             this call returns <code>IncompatibleParameterError</code>. If a file system with the
    ///             specified client request token doesn't exist, this operation does the following:</p>
    ///
    ///         <ul>
    ///             <li>
    ///                 <p>Creates a new Amazon FSx file system from backup with an assigned ID, and
    ///                     an initial lifecycle state of <code>CREATING</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Returns the description of the file system.</p>
    ///             </li>
    ///          </ul>
    ///
    ///         <p>Parameters like Active Directory, default share name, automatic backup, and backup
    ///             settings default to the parameters of the file system that was backed up, unless
    ///             overridden. You can explicitly supply other settings.</p>
    ///
    ///         <p>By using the idempotent operation, you can retry a
    ///                 <code>CreateFileSystemFromBackup</code> call without the risk of creating an extra
    ///             file system. This approach can be useful when an initial call fails in a way that makes
    ///             it unclear whether a file system was created. Examples are if a transport level timeout
    ///             occurred, or your connection was reset. If you use the same client request token and the
    ///             initial call created a file system, the client receives success as long as the
    ///             parameters are the same.</p>
    ///         <note>
    ///             <p>The <code>CreateFileSystemFromBackup</code> call returns while the file
    ///                 system's lifecycle state is still <code>CREATING</code>. You can check the
    ///                 file-system creation status by calling the <a>DescribeFileSystems</a>
    ///                 operation, which returns the file system state along with other
    ///                 information.</p>
    ///         </note>
    public func createFileSystemFromBackup(input: CreateFileSystemFromBackupInput, completion: @escaping (SdkResult<CreateFileSystemFromBackupOutputResponse, CreateFileSystemFromBackupOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createFileSystemFromBackup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "fsx.\(config.region).amazonaws.com")
                      .withSigningName(value: "fsx")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateFileSystemFromBackupInput, CreateFileSystemFromBackupOutputResponse, CreateFileSystemFromBackupOutputError>(id: "createFileSystemFromBackup")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreateFileSystemFromBackupOutputResponse>, SdkError<CreateFileSystemFromBackupOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateFileSystemFromBackupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateFileSystemFromBackupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateFileSystemFromBackupInput, CreateFileSystemFromBackupOutputResponse, CreateFileSystemFromBackupOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CreateFileSystemFromBackupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CreateFileSystemFromBackupInput, CreateFileSystemFromBackupOutputResponse, CreateFileSystemFromBackupOutputError>(xAmzTarget: "AWSSimbaAPIService_v20180301.CreateFileSystemFromBackup"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes an Amazon FSx backup, deleting its contents. After deletion, the backup no longer exists, and its data is gone.</p>
    ///
    ///         <p>The <code>DeleteBackup</code> call returns instantly. The backup will not show up
    ///             in later <code>DescribeBackups</code> calls.</p>
    ///
    ///         <important>
    ///             <p>The data in a deleted backup is also deleted and can't be recovered by any
    ///                 means.</p>
    ///         </important>
    public func deleteBackup(input: DeleteBackupInput, completion: @escaping (SdkResult<DeleteBackupOutputResponse, DeleteBackupOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteBackup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "fsx.\(config.region).amazonaws.com")
                      .withSigningName(value: "fsx")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteBackupInput, DeleteBackupOutputResponse, DeleteBackupOutputError>(id: "deleteBackup")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<DeleteBackupOutputResponse>, SdkError<DeleteBackupOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: DeleteBackupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteBackupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteBackupInput, DeleteBackupOutputResponse, DeleteBackupOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteBackupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteBackupInput, DeleteBackupOutputResponse, DeleteBackupOutputError>(xAmzTarget: "AWSSimbaAPIService_v20180301.DeleteBackup"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a file system, deleting its contents. After deletion, the file system no
    ///             longer exists, and its data is gone. Any existing automatic backups will also be
    ///             deleted.</p>
    ///         <p>By default, when you delete an Amazon FSx for Windows File Server file system, a
    ///             final backup is created upon deletion. This final backup is not subject to the file
    ///             system's retention policy, and must be manually deleted.</p>
    ///
    ///
    ///         <p>The <code>DeleteFileSystem</code> action returns while the file system has the
    ///                 <code>DELETING</code> status. You can check the file system deletion status by
    ///             calling the <a>DescribeFileSystems</a> action, which returns a list of file
    ///             systems in your account. If you pass the file system ID for a deleted file system, the
    ///                 <a>DescribeFileSystems</a> returns a <code>FileSystemNotFound</code>
    ///             error.</p>
    ///         <note>
    ///             <p>Deleting an Amazon FSx for Lustre file system will fail with a 400 BadRequest if
    ///             a data repository task is in a <code>PENDING</code> or <code>EXECUTING</code>
    ///             state.</p>
    ///          </note>
    ///         <important>
    ///             <p>The data in a deleted file system is also deleted and can't be recovered by
    ///                 any means.</p>
    ///         </important>
    public func deleteFileSystem(input: DeleteFileSystemInput, completion: @escaping (SdkResult<DeleteFileSystemOutputResponse, DeleteFileSystemOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteFileSystem")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "fsx.\(config.region).amazonaws.com")
                      .withSigningName(value: "fsx")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteFileSystemInput, DeleteFileSystemOutputResponse, DeleteFileSystemOutputError>(id: "deleteFileSystem")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<DeleteFileSystemOutputResponse>, SdkError<DeleteFileSystemOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: DeleteFileSystemInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteFileSystemInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteFileSystemInput, DeleteFileSystemOutputResponse, DeleteFileSystemOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteFileSystemInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteFileSystemInput, DeleteFileSystemOutputResponse, DeleteFileSystemOutputError>(xAmzTarget: "AWSSimbaAPIService_v20180301.DeleteFileSystem"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the description of specific Amazon FSx backups, if
    ///             a <code>BackupIds</code> value is provided for that backup. Otherwise, it returns all
    ///             backups owned by your AWS account in the AWS Region of the endpoint that you're
    ///             calling.</p>
    ///
    ///         <p>When retrieving all backups, you can optionally specify the <code>MaxResults</code>
    ///             parameter to limit the number of backups in a response. If more backups remain, Amazon
    ///             FSx returns a <code>NextToken</code> value in the response. In this case, send a later
    ///             request with the <code>NextToken</code> request parameter set to the value of
    ///                 <code>NextToken</code> from the last response.</p>
    ///
    ///         <p>This action is used in an iterative process to retrieve a list of your backups.
    ///                 <code>DescribeBackups</code> is called first without a <code>NextToken</code>value.
    ///             Then the action continues to be called with the <code>NextToken</code> parameter set to
    ///             the value of the last <code>NextToken</code> value until a response has no
    ///                 <code>NextToken</code>.</p>
    ///
    ///         <p>When using this action, keep the following in mind:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>The implementation might return fewer than <code>MaxResults</code> file
    ///                     system descriptions while still including a <code>NextToken</code>
    ///                     value.</p>
    ///
    ///             </li>
    ///             <li>
    ///                 <p>The order of backups returned in the response of one
    ///                         <code>DescribeBackups</code> call and the order of backups returned across
    ///                     the responses of a multi-call iteration is unspecified.</p>
    ///             </li>
    ///          </ul>
    public func describeBackups(input: DescribeBackupsInput, completion: @escaping (SdkResult<DescribeBackupsOutputResponse, DescribeBackupsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeBackups")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "fsx.\(config.region).amazonaws.com")
                      .withSigningName(value: "fsx")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeBackupsInput, DescribeBackupsOutputResponse, DescribeBackupsOutputError>(id: "describeBackups")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeBackupsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeBackupsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeBackupsInput, DescribeBackupsOutputResponse, DescribeBackupsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeBackupsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeBackupsInput, DescribeBackupsOutputResponse, DescribeBackupsOutputError>(xAmzTarget: "AWSSimbaAPIService_v20180301.DescribeBackups"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the description of specific Amazon FSx for Lustre data repository tasks, if
    ///             one or more <code>TaskIds</code> values are provided in the request, or if filters are used in the request.
    ///             You can use filters to narrow the response to include just tasks for specific file systems,
    ///             or tasks in a specific lifecycle state. Otherwise, it returns all data repository tasks owned
    ///             by your AWS account in the AWS Region of the endpoint that you're calling.</p>
    ///
    ///         <p>When retrieving all tasks, you can paginate the response by using  the optional <code>MaxResults</code>
    ///             parameter to limit the number of tasks returned in a response. If more tasks remain, Amazon
    ///             FSx returns a <code>NextToken</code> value in the response. In this case, send a later
    ///             request with the <code>NextToken</code> request parameter set to the value of
    ///             <code>NextToken</code> from the last response.</p>
    public func describeDataRepositoryTasks(input: DescribeDataRepositoryTasksInput, completion: @escaping (SdkResult<DescribeDataRepositoryTasksOutputResponse, DescribeDataRepositoryTasksOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeDataRepositoryTasks")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "fsx.\(config.region).amazonaws.com")
                      .withSigningName(value: "fsx")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeDataRepositoryTasksInput, DescribeDataRepositoryTasksOutputResponse, DescribeDataRepositoryTasksOutputError>(id: "describeDataRepositoryTasks")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeDataRepositoryTasksInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeDataRepositoryTasksInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeDataRepositoryTasksInput, DescribeDataRepositoryTasksOutputResponse, DescribeDataRepositoryTasksOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeDataRepositoryTasksInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeDataRepositoryTasksInput, DescribeDataRepositoryTasksOutputResponse, DescribeDataRepositoryTasksOutputError>(xAmzTarget: "AWSSimbaAPIService_v20180301.DescribeDataRepositoryTasks"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the DNS aliases that are associated with the specified Amazon FSx for Windows File Server file system. A history of
    ///             all DNS aliases that have been associated with and disassociated from the file system is available in the list of <a>AdministrativeAction</a>
    ///         provided in the <a>DescribeFileSystems</a> operation response.</p>
    public func describeFileSystemAliases(input: DescribeFileSystemAliasesInput, completion: @escaping (SdkResult<DescribeFileSystemAliasesOutputResponse, DescribeFileSystemAliasesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeFileSystemAliases")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "fsx.\(config.region).amazonaws.com")
                      .withSigningName(value: "fsx")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeFileSystemAliasesInput, DescribeFileSystemAliasesOutputResponse, DescribeFileSystemAliasesOutputError>(id: "describeFileSystemAliases")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<DescribeFileSystemAliasesOutputResponse>, SdkError<DescribeFileSystemAliasesOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: DescribeFileSystemAliasesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeFileSystemAliasesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeFileSystemAliasesInput, DescribeFileSystemAliasesOutputResponse, DescribeFileSystemAliasesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeFileSystemAliasesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeFileSystemAliasesInput, DescribeFileSystemAliasesOutputResponse, DescribeFileSystemAliasesOutputError>(xAmzTarget: "AWSSimbaAPIService_v20180301.DescribeFileSystemAliases"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the description of specific Amazon FSx file systems, if a
    ///                 <code>FileSystemIds</code> value is provided for that file system. Otherwise, it
    ///             returns descriptions of all file systems owned by your AWS account in the AWS Region of
    ///             the endpoint that you're calling.</p>
    ///
    ///         <p>When retrieving all file system descriptions, you can optionally specify the
    ///                 <code>MaxResults</code> parameter to limit the number of descriptions in a response.
    ///             If more file system descriptions remain, Amazon FSx returns a <code>NextToken</code>
    ///             value in the response. In this case, send a later request with the
    ///                 <code>NextToken</code> request parameter set to the value of <code>NextToken</code>
    ///             from the last response.</p>
    ///
    ///         <p>This action is used in an iterative process to retrieve a list of your file system
    ///             descriptions. <code>DescribeFileSystems</code> is called first without a
    ///                 <code>NextToken</code>value. Then the action continues to be called with the
    ///                 <code>NextToken</code> parameter set to the value of the last <code>NextToken</code>
    ///             value until a response has no <code>NextToken</code>.</p>
    ///
    ///         <p>When using this action, keep the following in mind:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>The implementation might return fewer than <code>MaxResults</code> file
    ///                     system descriptions while still including a <code>NextToken</code>
    ///                     value.</p>
    ///
    ///             </li>
    ///             <li>
    ///                 <p>The order of file systems returned in the response of one
    ///                         <code>DescribeFileSystems</code> call and the order of file systems returned
    ///                     across the responses of a multicall iteration is unspecified.</p>
    ///             </li>
    ///          </ul>
    public func describeFileSystems(input: DescribeFileSystemsInput, completion: @escaping (SdkResult<DescribeFileSystemsOutputResponse, DescribeFileSystemsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeFileSystems")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "fsx.\(config.region).amazonaws.com")
                      .withSigningName(value: "fsx")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeFileSystemsInput, DescribeFileSystemsOutputResponse, DescribeFileSystemsOutputError>(id: "describeFileSystems")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeFileSystemsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeFileSystemsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeFileSystemsInput, DescribeFileSystemsOutputResponse, DescribeFileSystemsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeFileSystemsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeFileSystemsInput, DescribeFileSystemsOutputResponse, DescribeFileSystemsOutputError>(xAmzTarget: "AWSSimbaAPIService_v20180301.DescribeFileSystems"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Use this action to disassociate, or remove, one or more Domain Name Service (DNS) aliases
    ///             from an Amazon FSx for Windows File Server file system. If you attempt to disassociate a DNS alias that is not
    ///             associated with the file system, Amazon FSx responds with a 400 Bad Request. For more information, see
    ///             <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/managing-dns-aliases.html">Working with DNS Aliases</a>.</p>
    ///         <p>The system generated response showing the DNS aliases that
    ///             Amazon FSx is attempting to disassociate from the file system.
    ///             Use the  API
    ///             operation to monitor the status of the aliases Amazon FSx is
    ///             disassociating with the file system.</p>
    public func disassociateFileSystemAliases(input: DisassociateFileSystemAliasesInput, completion: @escaping (SdkResult<DisassociateFileSystemAliasesOutputResponse, DisassociateFileSystemAliasesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "disassociateFileSystemAliases")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "fsx.\(config.region).amazonaws.com")
                      .withSigningName(value: "fsx")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DisassociateFileSystemAliasesInput, DisassociateFileSystemAliasesOutputResponse, DisassociateFileSystemAliasesOutputError>(id: "disassociateFileSystemAliases")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<DisassociateFileSystemAliasesOutputResponse>, SdkError<DisassociateFileSystemAliasesOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: DisassociateFileSystemAliasesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DisassociateFileSystemAliasesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DisassociateFileSystemAliasesInput, DisassociateFileSystemAliasesOutputResponse, DisassociateFileSystemAliasesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DisassociateFileSystemAliasesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DisassociateFileSystemAliasesInput, DisassociateFileSystemAliasesOutputResponse, DisassociateFileSystemAliasesOutputError>(xAmzTarget: "AWSSimbaAPIService_v20180301.DisassociateFileSystemAliases"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists tags for an Amazon FSx file systems and backups in the case of Amazon FSx for
    ///             Windows File Server.</p>
    ///
    ///         <p>When retrieving all tags, you can optionally specify the <code>MaxResults</code>
    ///             parameter to limit the number of tags in a response. If more tags remain, Amazon FSx
    ///             returns a <code>NextToken</code> value in the response. In this case, send a later
    ///             request with the <code>NextToken</code> request parameter set to the value of
    ///                 <code>NextToken</code> from the last response.</p>
    ///
    ///         <p>This action is used in an iterative process to retrieve a list of your tags.
    ///                 <code>ListTagsForResource</code> is called first without a
    ///             <code>NextToken</code>value. Then the action continues to be called with the
    ///                 <code>NextToken</code> parameter set to the value of the last <code>NextToken</code>
    ///             value until a response has no <code>NextToken</code>.</p>
    ///
    ///         <p>When using this action, keep the following in mind:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>The implementation might return fewer than <code>MaxResults</code> file
    ///                     system descriptions while still including a <code>NextToken</code>
    ///                     value.</p>
    ///
    ///             </li>
    ///             <li>
    ///                 <p>The order of tags returned in the response of one
    ///                         <code>ListTagsForResource</code> call and the order of tags returned across
    ///                     the responses of a multi-call iteration is unspecified.</p>
    ///             </li>
    ///          </ul>
    public func listTagsForResource(input: ListTagsForResourceInput, completion: @escaping (SdkResult<ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTagsForResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "fsx.\(config.region).amazonaws.com")
                      .withSigningName(value: "fsx")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(id: "listTagsForResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(xAmzTarget: "AWSSimbaAPIService_v20180301.ListTagsForResource"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Tags an Amazon FSx resource.</p>
    public func tagResource(input: TagResourceInput, completion: @escaping (SdkResult<TagResourceOutputResponse, TagResourceOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "tagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "fsx.\(config.region).amazonaws.com")
                      .withSigningName(value: "fsx")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(id: "tagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(xAmzTarget: "AWSSimbaAPIService_v20180301.TagResource"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This action removes a tag from an Amazon FSx resource.</p>
    public func untagResource(input: UntagResourceInput, completion: @escaping (SdkResult<UntagResourceOutputResponse, UntagResourceOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "untagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "fsx.\(config.region).amazonaws.com")
                      .withSigningName(value: "fsx")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(id: "untagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(xAmzTarget: "AWSSimbaAPIService_v20180301.UntagResource"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Use this operation to update the configuration of an existing Amazon FSx file system.
    ///       You can update multiple properties in a single request.</p>
    ///          <p>For Amazon FSx for Windows File Server file systems, you can update the following
    ///     properties:</p>
    ///          <ul>
    ///             <li>
    ///                <p>AutomaticBackupRetentionDays</p>
    ///             </li>
    ///             <li>
    ///                <p>DailyAutomaticBackupStartTime</p>
    ///             </li>
    ///             <li>
    ///                <p>SelfManagedActiveDirectoryConfiguration</p>
    ///             </li>
    ///             <li>
    ///                <p>StorageCapacity</p>
    ///             </li>
    ///             <li>
    ///                <p>ThroughputCapacity</p>
    ///             </li>
    ///             <li>
    ///                <p>WeeklyMaintenanceStartTime</p>
    ///             </li>
    ///          </ul>
    ///          <p>For Amazon FSx for Lustre file systems, you can update the following
    ///       properties:</p>
    ///          <ul>
    ///             <li>
    ///                <p>AutoImportPolicy</p>
    ///             </li>
    ///             <li>
    ///                <p>AutomaticBackupRetentionDays</p>
    ///             </li>
    ///             <li>
    ///                <p>DailyAutomaticBackupStartTime</p>
    ///             </li>
    ///             <li>
    ///                <p>DataCompressionType</p>
    ///             </li>
    ///             <li>
    ///                <p>StorageCapacity</p>
    ///             </li>
    ///             <li>
    ///                <p>WeeklyMaintenanceStartTime</p>
    ///             </li>
    ///          </ul>
    public func updateFileSystem(input: UpdateFileSystemInput, completion: @escaping (SdkResult<UpdateFileSystemOutputResponse, UpdateFileSystemOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateFileSystem")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "fsx.\(config.region).amazonaws.com")
                      .withSigningName(value: "fsx")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateFileSystemInput, UpdateFileSystemOutputResponse, UpdateFileSystemOutputError>(id: "updateFileSystem")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<UpdateFileSystemOutputResponse>, SdkError<UpdateFileSystemOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: UpdateFileSystemInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateFileSystemInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateFileSystemInput, UpdateFileSystemOutputResponse, UpdateFileSystemOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateFileSystemInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UpdateFileSystemInput, UpdateFileSystemOutputResponse, UpdateFileSystemOutputError>(xAmzTarget: "AWSSimbaAPIService_v20180301.UpdateFileSystem"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
