// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ActiveDirectoryBackupAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activeDirectoryId = "ActiveDirectoryId"
        case domainName = "DomainName"
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeDirectoryId = activeDirectoryId {
            try encodeContainer.encode(activeDirectoryId, forKey: .activeDirectoryId)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let activeDirectoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .activeDirectoryId)
        activeDirectoryId = activeDirectoryIdDecoded
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ActiveDirectoryBackupAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActiveDirectoryBackupAttributes(activeDirectoryId: \(String(describing: activeDirectoryId)), domainName: \(String(describing: domainName)), resourceARN: \(String(describing: resourceARN)))"}
}

/// <p>The Microsoft AD attributes of the Amazon FSx for Windows File Server file system.</p>
public struct ActiveDirectoryBackupAttributes: Equatable {
    /// <p>The ID of the AWS Managed Microsoft Active Directory instance to which the file system is joined.</p>
    public let activeDirectoryId: String?
    /// <p>The fully qualified domain name of the self-managed AD directory.</p>
    public let domainName: String?
    /// <p>The Amazon Resource Name (ARN) for a given resource. ARNs uniquely identify AWS
    ///             resources. We require an ARN when you need to specify a resource unambiguously across
    ///             all of AWS. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)
    ///                 and AWS Service Namespaces</a> in the <i>AWS General
    ///             Reference</i>.</p>
    public let resourceARN: String?

    public init (
        activeDirectoryId: String? = nil,
        domainName: String? = nil,
        resourceARN: String? = nil
    )
    {
        self.activeDirectoryId = activeDirectoryId
        self.domainName = domainName
        self.resourceARN = resourceARN
    }
}

extension ActiveDirectoryError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActiveDirectoryError(activeDirectoryId: \(String(describing: activeDirectoryId)), message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension ActiveDirectoryError: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ActiveDirectoryErrorBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.activeDirectoryId = output.activeDirectoryId
            self.message = output.message
            self.type = output.type
        } else {
            self.activeDirectoryId = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An Active Directory error.</p>
public struct ActiveDirectoryError: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The directory ID of the directory that an error pertains to.</p>
    public var activeDirectoryId: String?
    /// <p>A detailed error message.</p>
    public var message: String?
    /// <p>The type of Active Directory error.</p>
    public var type: ActiveDirectoryErrorType?

    public init (
        activeDirectoryId: String? = nil,
        message: String? = nil,
        type: ActiveDirectoryErrorType? = nil
    )
    {
        self.activeDirectoryId = activeDirectoryId
        self.message = message
        self.type = type
    }
}

struct ActiveDirectoryErrorBody: Equatable {
    public let activeDirectoryId: String?
    public let type: ActiveDirectoryErrorType?
    public let message: String?
}

extension ActiveDirectoryErrorBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case activeDirectoryId = "ActiveDirectoryId"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeDirectoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .activeDirectoryId)
        activeDirectoryId = activeDirectoryIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ActiveDirectoryErrorType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

/// <p>The type of error relating to Microsoft Active Directory. NOT_FOUND means that no
///             directory was found by specifying the given directory. INCOMPATIBLE_MODE means that the
///             directory specified is not a Microsoft AD directory. WRONG_VPC means that the specified
///             directory isn't accessible from the specified VPC. WRONG_STAGE means that the
///             specified directory isn't currently in the ACTIVE state.</p>
public enum ActiveDirectoryErrorType {
    case domainNotFound
    case incompatibleDomainMode
    case invalidDomainStage
    case wrongVpc
    case sdkUnknown(String)
}

extension ActiveDirectoryErrorType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ActiveDirectoryErrorType] {
        return [
            .domainNotFound,
            .incompatibleDomainMode,
            .invalidDomainStage,
            .wrongVpc,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .domainNotFound: return "DOMAIN_NOT_FOUND"
        case .incompatibleDomainMode: return "INCOMPATIBLE_DOMAIN_MODE"
        case .invalidDomainStage: return "INVALID_DOMAIN_STAGE"
        case .wrongVpc: return "WRONG_VPC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ActiveDirectoryErrorType(rawValue: rawValue) ?? ActiveDirectoryErrorType.sdkUnknown(rawValue)
    }
}

extension AdministrativeAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case administrativeActionType = "AdministrativeActionType"
        case failureDetails = "FailureDetails"
        case progressPercent = "ProgressPercent"
        case requestTime = "RequestTime"
        case status = "Status"
        case targetFileSystemValues = "TargetFileSystemValues"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let administrativeActionType = administrativeActionType {
            try encodeContainer.encode(administrativeActionType.rawValue, forKey: .administrativeActionType)
        }
        if let failureDetails = failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let progressPercent = progressPercent {
            try encodeContainer.encode(progressPercent, forKey: .progressPercent)
        }
        if let requestTime = requestTime {
            try encodeContainer.encode(requestTime.timeIntervalSince1970, forKey: .requestTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targetFileSystemValues = targetFileSystemValues {
            try encodeContainer.encode(targetFileSystemValues, forKey: .targetFileSystemValues)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let administrativeActionTypeDecoded = try containerValues.decodeIfPresent(AdministrativeActionType.self, forKey: .administrativeActionType)
        administrativeActionType = administrativeActionTypeDecoded
        let progressPercentDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .progressPercent)
        progressPercent = progressPercentDecoded
        let requestTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .requestTime)
        requestTime = requestTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
        let targetFileSystemValuesDecoded = try containerValues.decodeIfPresent(FileSystem.self, forKey: .targetFileSystemValues)
        targetFileSystemValues = targetFileSystemValuesDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(AdministrativeActionFailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
    }
}

extension AdministrativeAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdministrativeAction(administrativeActionType: \(String(describing: administrativeActionType)), failureDetails: \(String(describing: failureDetails)), progressPercent: \(String(describing: progressPercent)), requestTime: \(String(describing: requestTime)), status: \(String(describing: status)), targetFileSystemValues: \(String(describing: targetFileSystemValues)))"}
}

/// <p>Describes a specific Amazon FSx administrative action for the current Windows or
///             Lustre file system.</p>
public struct AdministrativeAction: Equatable {
    /// <p>Describes the type of administrative action, as follows:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>FILE_SYSTEM_UPDATE</code> - A file system update administrative action initiated by the user from the
    ///                     Amazon FSx console, API (UpdateFileSystem), or CLI (update-file-system).</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>STORAGE_OPTIMIZATION</code> - Once the <code>FILE_SYSTEM_UPDATE</code>
    ///                     task to increase a file system's storage capacity completes successfully, a
    ///                     <code>STORAGE_OPTIMIZATION</code> task starts.
    ///                     </p>
    ///                 <ul>
    ///                   <li>
    ///                      <p>For Windows, storage optimization is the process of migrating the file system data
    ///                         to the new, larger disks.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>For Lustre, storage optimization consists of rebalancing the data across the existing and
    ///                             newly added file servers.</p>
    ///                   </li>
    ///                </ul>
    ///                 <p>You can track the storage optimization progress using the
    ///                         <code>ProgressPercent</code> property. When
    ///                         <code>STORAGE_OPTIMIZATION</code> completes successfully, the parent
    ///                         <code>FILE_SYSTEM_UPDATE</code> action status changes to
    ///                         <code>COMPLETED</code>. For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/managing-storage-capacity.html">Managing
    ///                         storage capacity</a> in the <i>Amazon FSx for Windows File Server
    ///                         User Guide</i> and <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/managing-storage-capacity.html">Managing storage
    ///                         and throughput capacity</a> in the <i>Amazon FSx for Lustre User
    ///                         Guide</i>. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FILE_SYSTEM_ALIAS_ASSOCIATION</code> - A file system update to associate a new DNS alias with the file system.
    ///                 For more information, see
    ///                 .</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FILE_SYSTEM_ALIAS_DISASSOCIATION</code> - A file system update to disassociate a DNS alias from the file system.
    ///                 For more information, see .</p>
    ///             </li>
    ///          </ul>
    public let administrativeActionType: AdministrativeActionType?
    /// <p>Provides information about a failed administrative action.</p>
    public let failureDetails: AdministrativeActionFailureDetails?
    /// <p>Provides the percent complete of a <code>STORAGE_OPTIMIZATION</code> administrative action.
    ///             Does not apply to any other administrative action type.</p>
    public let progressPercent: Int?
    /// <p>Time that the administrative action request was received.</p>
    public let requestTime: Date?
    /// <p>Describes the status of the administrative action, as follows:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code> - Amazon FSx failed to process the administrative action successfully.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IN_PROGRESS</code> - Amazon FSx is processing the administrative action.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PENDING</code> - Amazon FSx is waiting to process the administrative action.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>COMPLETED</code> - Amazon FSx has finished processing the administrative task.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UPDATED_OPTIMIZING</code> - For a storage capacity increase update, Amazon FSx has
    ///                     updated the file system with the new storage capacity, and is now performing the
    ///                     storage optimization process. For more information, see
    ///                         <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/managing-storage-capacity.html">Managing
    ///                         storage capacity</a> in the <i>Amazon FSx for Windows File Server
    ///                         User Guide</i> and <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/managing-storage-capacity.html">Managing storage
    ///                         and throughput capacity</a> in the <i>Amazon FSx for Lustre User
    ///                         Guide</i>.</p>
    ///             </li>
    ///          </ul>
    public let status: Status?
    /// <p>Describes the target value for the administration action,
    ///             provided in the <code>UpdateFileSystem</code> operation.
    ///            Returned for <code>FILE_SYSTEM_UPDATE</code> administrative actions.
    ///          </p>
    public let targetFileSystemValues: FileSystem?

    public init (
        administrativeActionType: AdministrativeActionType? = nil,
        failureDetails: AdministrativeActionFailureDetails? = nil,
        progressPercent: Int? = nil,
        requestTime: Date? = nil,
        status: Status? = nil,
        targetFileSystemValues: FileSystem? = nil
    )
    {
        self.administrativeActionType = administrativeActionType
        self.failureDetails = failureDetails
        self.progressPercent = progressPercent
        self.requestTime = requestTime
        self.status = status
        self.targetFileSystemValues = targetFileSystemValues
    }
}

extension AdministrativeActionFailureDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AdministrativeActionFailureDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdministrativeActionFailureDetails(message: \(String(describing: message)))"}
}

/// <p>Provides information about a failed administrative action.</p>
public struct AdministrativeActionFailureDetails: Equatable {
    /// <p>Error message providing details about the failed administrative action.</p>
    public let message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

/// <p>Describes the type of administrative action, as follows:</p>
///         <ul>
///             <li>
///                 <p>
///                   <code>FILE_SYSTEM_UPDATE</code> - A file system update administrative action initiated by the user from the
///                     Amazon FSx console, API (UpdateFileSystem), or CLI (update-file-system).</p>
///             </li>
///             <li>
///                 <p>
///                   <code>STORAGE_OPTIMIZATION</code> - Once the <code>FILE_SYSTEM_UPDATE</code>
///                     task to increase a file system's storage capacity completes successfully, a
///                     <code>STORAGE_OPTIMIZATION</code> task starts.
///                     </p>
///                 <ul>
///                   <li>
///                      <p>For Windows, storage optimization is the process of migrating the file system data
///                         to the new, larger disks.</p>
///                   </li>
///                   <li>
///                      <p>For Lustre, storage optimization consists of rebalancing the data across the existing and
///                             newly added file servers.</p>
///                   </li>
///                </ul>
///                 <p>You can track the storage optimization progress using the
///                         <code>ProgressPercent</code> property. When
///                         <code>STORAGE_OPTIMIZATION</code> completes successfully, the parent
///                         <code>FILE_SYSTEM_UPDATE</code> action status changes to
///                         <code>COMPLETED</code>. For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/managing-storage-capacity.html">Managing
///                         storage capacity</a> in the <i>Amazon FSx for Windows File Server
///                         User Guide</i> and <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/managing-storage-capacity.html">Managing storage
///                         and throughput capacity</a> in the <i>Amazon FSx for Lustre User
///                         Guide</i>. </p>
///             </li>
///             <li>
///                <p>
///                   <code>FILE_SYSTEM_ALIAS_ASSOCIATION</code> - A file system update to associate a new DNS alias with the file system.
///                 For more information, see
///                 .</p>
///             </li>
///             <li>
///                <p>
///                   <code>FILE_SYSTEM_ALIAS_DISASSOCIATION</code> - A file system update to disassociate a DNS alias from the file system.
///                 For more information, see .</p>
///             </li>
///          </ul>
public enum AdministrativeActionType {
    case fileSystemAliasAssociation
    case fileSystemAliasDisassociation
    case fileSystemUpdate
    case storageOptimization
    case sdkUnknown(String)
}

extension AdministrativeActionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AdministrativeActionType] {
        return [
            .fileSystemAliasAssociation,
            .fileSystemAliasDisassociation,
            .fileSystemUpdate,
            .storageOptimization,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .fileSystemAliasAssociation: return "FILE_SYSTEM_ALIAS_ASSOCIATION"
        case .fileSystemAliasDisassociation: return "FILE_SYSTEM_ALIAS_DISASSOCIATION"
        case .fileSystemUpdate: return "FILE_SYSTEM_UPDATE"
        case .storageOptimization: return "STORAGE_OPTIMIZATION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AdministrativeActionType(rawValue: rawValue) ?? AdministrativeActionType.sdkUnknown(rawValue)
    }
}

extension Alias: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lifecycle = "Lifecycle"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lifecycle = lifecycle {
            try encodeContainer.encode(lifecycle.rawValue, forKey: .lifecycle)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(AliasLifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
    }
}

extension Alias: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Alias(lifecycle: \(String(describing: lifecycle)), name: \(String(describing: name)))"}
}

/// <p>A DNS alias that is associated with the file system. You can use a DNS alias to access a file system using
///             user-defined DNS names, in addition to the default DNS name
///             that Amazon FSx assigns to the file system. For more information, see
///             <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/managing-dns-aliases.html">DNS aliases</a>
///             in the <i>FSx for Windows File Server User Guide</i>.</p>
public struct Alias: Equatable {
    /// <p>Describes the state of the DNS alias.</p>
    ///         <ul>
    ///             <li>
    ///                <p>AVAILABLE - The DNS alias is associated with an Amazon FSx file system.</p>
    ///             </li>
    ///             <li>
    ///                <p>CREATING - Amazon FSx is creating the DNS alias and associating it with the file system.</p>
    ///             </li>
    ///             <li>
    ///                <p>CREATE_FAILED - Amazon FSx was unable to associate the DNS alias with the file system.</p>
    ///             </li>
    ///             <li>
    ///                <p>DELETING - Amazon FSx is disassociating the DNS alias from the file system and deleting it.</p>
    ///             </li>
    ///             <li>
    ///                <p>DELETE_FAILED - Amazon FSx was unable to disassocate the DNS alias from the file system.</p>
    ///             </li>
    ///          </ul>
    public let lifecycle: AliasLifecycle?
    /// <p>The name of the DNS alias. The alias name has to meet the following requirements:</p>
    ///         <ul>
    ///             <li>
    ///                <p>Formatted as a fully-qualified domain name (FQDN), <code>hostname.domain</code>, for example, <code>accounting.example.com</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can contain alphanumeric characters, the underscore (_), and the hyphen (-).</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot start or end with a hyphen.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can start with a numeric.</p>
    ///             </li>
    ///          </ul>
    ///         <p>For DNS names, Amazon FSx stores alphabetic characters as lowercase letters (a-z), regardless of how you specify them:
    ///             as uppercase letters, lowercase letters, or the corresponding letters in escape codes.</p>
    public let name: String?

    public init (
        lifecycle: AliasLifecycle? = nil,
        name: String? = nil
    )
    {
        self.lifecycle = lifecycle
        self.name = name
    }
}

public enum AliasLifecycle {
    case available
    case createFailed
    case creating
    case deleteFailed
    case deleting
    case sdkUnknown(String)
}

extension AliasLifecycle : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AliasLifecycle] {
        return [
            .available,
            .createFailed,
            .creating,
            .deleteFailed,
            .deleting,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .createFailed: return "CREATE_FAILED"
        case .creating: return "CREATING"
        case .deleteFailed: return "DELETE_FAILED"
        case .deleting: return "DELETING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AliasLifecycle(rawValue: rawValue) ?? AliasLifecycle.sdkUnknown(rawValue)
    }
}

public struct AssociateFileSystemAliasesInputBodyMiddleware: Middleware {
    public let id: String = "AssociateFileSystemAliasesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateFileSystemAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateFileSystemAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateFileSystemAliasesInput>
    public typealias MOutput = OperationOutput<AssociateFileSystemAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateFileSystemAliasesOutputError>
}

extension AssociateFileSystemAliasesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateFileSystemAliasesInput(aliases: \(String(describing: aliases)), clientRequestToken: \(String(describing: clientRequestToken)), fileSystemId: \(String(describing: fileSystemId)))"}
}

extension AssociateFileSystemAliasesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aliases = "Aliases"
        case clientRequestToken = "ClientRequestToken"
        case fileSystemId = "FileSystemId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliases = aliases {
            var aliasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aliases)
            for alternatednsnames0 in aliases {
                try aliasesContainer.encode(alternatednsnames0)
            }
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
    }
}

public struct AssociateFileSystemAliasesInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateFileSystemAliasesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateFileSystemAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateFileSystemAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateFileSystemAliasesInput>
    public typealias MOutput = OperationOutput<AssociateFileSystemAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateFileSystemAliasesOutputError>
}

public struct AssociateFileSystemAliasesInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateFileSystemAliasesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateFileSystemAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateFileSystemAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateFileSystemAliasesInput>
    public typealias MOutput = OperationOutput<AssociateFileSystemAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateFileSystemAliasesOutputError>
}

/// <p>The request object specifying one or more DNS alias names to associate with an Amazon FSx for Windows File Server file system.</p>
public struct AssociateFileSystemAliasesInput: Equatable {
    /// <p>An array of one or more DNS alias names to associate with the file system.
    ///             The alias name has to comply with the following formatting requirements:</p>
    ///             <ul>
    ///             <li>
    ///                <p>Formatted as a fully-qualified domain name (FQDN), <i>
    ///                      <code>hostname.domain</code>
    ///                   </i>,
    ///                     for example, <code>accounting.corp.example.com</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can contain alphanumeric characters and the hyphen (-).</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot start or end with a hyphen.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can start with a numeric.</p>
    ///             </li>
    ///          </ul>
    ///         <p>For DNS alias names, Amazon FSx stores alphabetic characters as lowercase letters (a-z), regardless of how you specify them:
    ///             as uppercase letters, lowercase letters, or the corresponding letters in escape codes.</p>
    public let aliases: [String]?
    /// <p>(Optional) An idempotency token for resource creation, in a string of up to 64
    ///             ASCII characters. This token is automatically filled on your behalf when you use the AWS
    ///             Command Line Interface (AWS CLI) or an AWS SDK.</p>
    public var clientRequestToken: String?
    /// <p>Specifies the file system with which you want to associate one or more DNS aliases.</p>
    public let fileSystemId: String?

    public init (
        aliases: [String]? = nil,
        clientRequestToken: String? = nil,
        fileSystemId: String? = nil
    )
    {
        self.aliases = aliases
        self.clientRequestToken = clientRequestToken
        self.fileSystemId = fileSystemId
    }
}

struct AssociateFileSystemAliasesInputBody: Equatable {
    public let clientRequestToken: String?
    public let fileSystemId: String?
    public let aliases: [String]?
}

extension AssociateFileSystemAliasesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aliases = "Aliases"
        case clientRequestToken = "ClientRequestToken"
        case fileSystemId = "FileSystemId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let aliasesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .aliases)
        var aliasesDecoded0:[String]? = nil
        if let aliasesContainer = aliasesContainer {
            aliasesDecoded0 = [String]()
            for string0 in aliasesContainer {
                if let string0 = string0 {
                    aliasesDecoded0?.append(string0)
                }
            }
        }
        aliases = aliasesDecoded0
    }
}

extension AssociateFileSystemAliasesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateFileSystemAliasesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateFileSystemAliasesOutputError: Equatable {
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateFileSystemAliasesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateFileSystemAliasesOutputResponse(aliases: \(String(describing: aliases)))"}
}

extension AssociateFileSystemAliasesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateFileSystemAliasesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.aliases = output.aliases
        } else {
            self.aliases = nil
        }
    }
}

/// <p>The system generated response showing the DNS aliases that
///             Amazon FSx is attempting to associate with the file system.
///             Use the  API
///             operation to monitor the status of the aliases Amazon FSx is
///             associating with the file system. It can take up to 2.5 minutes for
///         the alias status to change from <code>CREATING</code> to <code>AVAILABLE</code>. </p>
public struct AssociateFileSystemAliasesOutputResponse: Equatable {
    /// <p>An array of the DNS aliases that Amazon FSx is associating with the file system.</p>
    public let aliases: [Alias]?

    public init (
        aliases: [Alias]? = nil
    )
    {
        self.aliases = aliases
    }
}

struct AssociateFileSystemAliasesOutputResponseBody: Equatable {
    public let aliases: [Alias]?
}

extension AssociateFileSystemAliasesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aliases = "Aliases"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasesContainer = try containerValues.decodeIfPresent([Alias?].self, forKey: .aliases)
        var aliasesDecoded0:[Alias]? = nil
        if let aliasesContainer = aliasesContainer {
            aliasesDecoded0 = [Alias]()
            for structure0 in aliasesContainer {
                if let structure0 = structure0 {
                    aliasesDecoded0?.append(structure0)
                }
            }
        }
        aliases = aliasesDecoded0
    }
}

public enum AutoImportPolicyType {
    case new
    case newChanged
    case `none`
    case sdkUnknown(String)
}

extension AutoImportPolicyType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AutoImportPolicyType] {
        return [
            .new,
            .newChanged,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .new: return "NEW"
        case .newChanged: return "NEW_CHANGED"
        case .none: return "NONE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AutoImportPolicyType(rawValue: rawValue) ?? AutoImportPolicyType.sdkUnknown(rawValue)
    }
}

extension Backup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupId = "BackupId"
        case creationTime = "CreationTime"
        case directoryInformation = "DirectoryInformation"
        case failureDetails = "FailureDetails"
        case fileSystem = "FileSystem"
        case kmsKeyId = "KmsKeyId"
        case lifecycle = "Lifecycle"
        case ownerId = "OwnerId"
        case progressPercent = "ProgressPercent"
        case resourceARN = "ResourceARN"
        case sourceBackupId = "SourceBackupId"
        case sourceBackupRegion = "SourceBackupRegion"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupId = backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let directoryInformation = directoryInformation {
            try encodeContainer.encode(directoryInformation, forKey: .directoryInformation)
        }
        if let failureDetails = failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let fileSystem = fileSystem {
            try encodeContainer.encode(fileSystem, forKey: .fileSystem)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let lifecycle = lifecycle {
            try encodeContainer.encode(lifecycle.rawValue, forKey: .lifecycle)
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let progressPercent = progressPercent {
            try encodeContainer.encode(progressPercent, forKey: .progressPercent)
        }
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let sourceBackupId = sourceBackupId {
            try encodeContainer.encode(sourceBackupId, forKey: .sourceBackupId)
        }
        if let sourceBackupRegion = sourceBackupRegion {
            try encodeContainer.encode(sourceBackupRegion, forKey: .sourceBackupRegion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupId)
        backupId = backupIdDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(BackupLifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(BackupFailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
        let typeDecoded = try containerValues.decodeIfPresent(BackupType.self, forKey: .type)
        type = typeDecoded
        let progressPercentDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .progressPercent)
        progressPercent = progressPercentDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let fileSystemDecoded = try containerValues.decodeIfPresent(FileSystem.self, forKey: .fileSystem)
        fileSystem = fileSystemDecoded
        let directoryInformationDecoded = try containerValues.decodeIfPresent(ActiveDirectoryBackupAttributes.self, forKey: .directoryInformation)
        directoryInformation = directoryInformationDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let sourceBackupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceBackupId)
        sourceBackupId = sourceBackupIdDecoded
        let sourceBackupRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceBackupRegion)
        sourceBackupRegion = sourceBackupRegionDecoded
    }
}

extension Backup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Backup(backupId: \(String(describing: backupId)), creationTime: \(String(describing: creationTime)), directoryInformation: \(String(describing: directoryInformation)), failureDetails: \(String(describing: failureDetails)), fileSystem: \(String(describing: fileSystem)), kmsKeyId: \(String(describing: kmsKeyId)), lifecycle: \(String(describing: lifecycle)), ownerId: \(String(describing: ownerId)), progressPercent: \(String(describing: progressPercent)), resourceARN: \(String(describing: resourceARN)), sourceBackupId: \(String(describing: sourceBackupId)), sourceBackupRegion: \(String(describing: sourceBackupRegion)), tags: \(String(describing: tags)), type: \(String(describing: type)))"}
}

/// <p>A backup of an Amazon FSx file system.</p>
public struct Backup: Equatable {
    /// <p>The ID of the backup.</p>
    public let backupId: String?
    /// <p>The time when a particular backup was created.</p>
    public let creationTime: Date?
    /// <p>The configuration of the self-managed Microsoft Active Directory (AD) to which the Windows File Server instance is joined.</p>
    public let directoryInformation: ActiveDirectoryBackupAttributes?
    /// <p>Details explaining any failures that occur when creating a backup.</p>
    public let failureDetails: BackupFailureDetails?
    /// <p>Metadata of the file system associated with the backup. This metadata is persisted
    ///             even if the file system is deleted.</p>
    public let fileSystem: FileSystem?
    /// <p>The ID of the AWS Key Management Service (AWS KMS) key used to encrypt the
    ///               backup of the Amazon FSx file system's data at rest.
    ///               </p>
    public let kmsKeyId: String?
    /// <p>The lifecycle status of the backup.</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>AVAILABLE</code> - The backup is fully available.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PENDING</code> - For user-initiated backups on Lustre file systems only; Amazon FSx has not started creating the backup.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATING</code> - Amazon FSx is creating the backup.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TRANSFERRING</code> - For user-initiated backups on Lustre file systems only; Amazon FSx is transferring the backup to S3.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>COPYING</code> - Amazon FSx is copying the backup.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETED</code> - Amazon FSx deleted the backup and it is no longer available.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code> - Amazon FSx could not complete the backup.</p>
    ///             </li>
    ///          </ul>
    public let lifecycle: BackupLifecycle?
    /// <p>An AWS account ID. This ID is a 12-digit number that you use to construct Amazon
    ///             Resource Names (ARNs) for resources.</p>
    public let ownerId: String?
    /// <p>The current percent of progress of an asynchronous task.</p>
    public let progressPercent: Int?
    /// <p>The Amazon Resource Name (ARN) for the backup resource.</p>
    public let resourceARN: String?
    /// <p>The ID of the source backup. Specifies the backup you are copying.</p>
    public let sourceBackupId: String?
    /// <p>The source Region of the backup. Specifies the Region from where this backup
    ///             is copied.</p>
    public let sourceBackupRegion: String?
    /// <p>Tags associated with a particular file system.</p>
    public let tags: [Tag]?
    /// <p>The type of the file system backup.</p>
    public let type: BackupType?

    public init (
        backupId: String? = nil,
        creationTime: Date? = nil,
        directoryInformation: ActiveDirectoryBackupAttributes? = nil,
        failureDetails: BackupFailureDetails? = nil,
        fileSystem: FileSystem? = nil,
        kmsKeyId: String? = nil,
        lifecycle: BackupLifecycle? = nil,
        ownerId: String? = nil,
        progressPercent: Int? = nil,
        resourceARN: String? = nil,
        sourceBackupId: String? = nil,
        sourceBackupRegion: String? = nil,
        tags: [Tag]? = nil,
        type: BackupType? = nil
    )
    {
        self.backupId = backupId
        self.creationTime = creationTime
        self.directoryInformation = directoryInformation
        self.failureDetails = failureDetails
        self.fileSystem = fileSystem
        self.kmsKeyId = kmsKeyId
        self.lifecycle = lifecycle
        self.ownerId = ownerId
        self.progressPercent = progressPercent
        self.resourceARN = resourceARN
        self.sourceBackupId = sourceBackupId
        self.sourceBackupRegion = sourceBackupRegion
        self.tags = tags
        self.type = type
    }
}

extension BackupBeingCopied: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BackupBeingCopied(backupId: \(String(describing: backupId)), message: \(String(describing: message)))"}
}

extension BackupBeingCopied: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BackupBeingCopiedBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backupId = output.backupId
            self.message = output.message
        } else {
            self.backupId = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You can't delete a backup while it's being copied.</p>
public struct BackupBeingCopied: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The ID of the source backup. Specifies the backup you are copying.</p>
    public var backupId: String?
    /// <p>A detailed error message.</p>
    public var message: String?

    public init (
        backupId: String? = nil,
        message: String? = nil
    )
    {
        self.backupId = backupId
        self.message = message
    }
}

struct BackupBeingCopiedBody: Equatable {
    public let message: String?
    public let backupId: String?
}

extension BackupBeingCopiedBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupId = "BackupId"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let backupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupId)
        backupId = backupIdDecoded
    }
}

extension BackupFailureDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BackupFailureDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BackupFailureDetails(message: \(String(describing: message)))"}
}

/// <p>If backup creation fails, this structure contains the details of that
///             failure.</p>
public struct BackupFailureDetails: Equatable {
    /// <p>A message describing the backup creation failure.</p>
    public let message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

extension BackupInProgress: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BackupInProgress(message: \(String(describing: message)))"}
}

extension BackupInProgress: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BackupInProgressBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Another backup is already under way. Wait for completion before initiating
///             additional backups of this file system.</p>
public struct BackupInProgress: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BackupInProgressBody: Equatable {
    public let message: String?
}

extension BackupInProgressBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

/// <p>The lifecycle status of the backup.</p>
///         <ul>
///             <li>
///                <p>
///                   <code>AVAILABLE</code> - The backup is fully available.</p>
///             </li>
///             <li>
///                <p>
///                   <code>PENDING</code> - For user-initiated backups on Lustre file systems only; Amazon FSx has not started creating the backup.</p>
///             </li>
///             <li>
///                <p>
///                   <code>CREATING</code> - Amazon FSx is creating the new user-intiated backup</p>
///             </li>
///             <li>
///                <p>
///                   <code>TRANSFERRING</code> - For user-initiated backups on Lustre file systems only; Amazon FSx is backing up the file system.</p>
///             </li>
///             <li>
///                <p>
///                   <code>COPYING</code> - Amazon FSx is copying the backup.</p>
///             </li>
///             <li>
///                <p>
///                   <code>DELETED</code> - Amazon FSx deleted the backup and it is no longer available.</p>
///             </li>
///             <li>
///                <p>
///                   <code>FAILED</code> - Amazon FSx could not complete the backup.</p>
///             </li>
///          </ul>
public enum BackupLifecycle {
    case available
    case copying
    case creating
    case deleted
    case failed
    case pending
    case transferring
    case sdkUnknown(String)
}

extension BackupLifecycle : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BackupLifecycle] {
        return [
            .available,
            .copying,
            .creating,
            .deleted,
            .failed,
            .pending,
            .transferring,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .copying: return "COPYING"
        case .creating: return "CREATING"
        case .deleted: return "DELETED"
        case .failed: return "FAILED"
        case .pending: return "PENDING"
        case .transferring: return "TRANSFERRING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BackupLifecycle(rawValue: rawValue) ?? BackupLifecycle.sdkUnknown(rawValue)
    }
}

extension BackupNotFound: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BackupNotFound(message: \(String(describing: message)))"}
}

extension BackupNotFound: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BackupNotFoundBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>No Amazon FSx backups were found based upon the supplied parameters.</p>
public struct BackupNotFound: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BackupNotFoundBody: Equatable {
    public let message: String?
}

extension BackupNotFoundBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BackupRestoring: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BackupRestoring(fileSystemId: \(String(describing: fileSystemId)), message: \(String(describing: message)))"}
}

extension BackupRestoring: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BackupRestoringBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fileSystemId = output.fileSystemId
            self.message = output.message
        } else {
            self.fileSystemId = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You can't delete a backup while it's being used to restore a file
///             system.</p>
public struct BackupRestoring: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The ID of a file system being restored from the backup.</p>
    public var fileSystemId: String?
    /// <p>A detailed error message.</p>
    public var message: String?

    public init (
        fileSystemId: String? = nil,
        message: String? = nil
    )
    {
        self.fileSystemId = fileSystemId
        self.message = message
    }
}

struct BackupRestoringBody: Equatable {
    public let message: String?
    public let fileSystemId: String?
}

extension BackupRestoringBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileSystemId = "FileSystemId"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
    }
}

/// <p>The type of the backup.</p>
public enum BackupType {
    case automatic
    case awsBackup
    case userInitiated
    case sdkUnknown(String)
}

extension BackupType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BackupType] {
        return [
            .automatic,
            .awsBackup,
            .userInitiated,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .automatic: return "AUTOMATIC"
        case .awsBackup: return "AWS_BACKUP"
        case .userInitiated: return "USER_INITIATED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BackupType(rawValue: rawValue) ?? BackupType.sdkUnknown(rawValue)
    }
}

extension BadRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequest(message: \(String(describing: message)))"}
}

extension BadRequest: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadRequestBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A generic error indicating a failure with a client request.</p>
public struct BadRequest: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestBody: Equatable {
    public let message: String?
}

extension BadRequestBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CancelDataRepositoryTaskInputBodyMiddleware: Middleware {
    public let id: String = "CancelDataRepositoryTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelDataRepositoryTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelDataRepositoryTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelDataRepositoryTaskInput>
    public typealias MOutput = OperationOutput<CancelDataRepositoryTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelDataRepositoryTaskOutputError>
}

extension CancelDataRepositoryTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelDataRepositoryTaskInput(taskId: \(String(describing: taskId)))"}
}

extension CancelDataRepositoryTaskInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case taskId = "TaskId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let taskId = taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
    }
}

public struct CancelDataRepositoryTaskInputHeadersMiddleware: Middleware {
    public let id: String = "CancelDataRepositoryTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelDataRepositoryTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelDataRepositoryTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelDataRepositoryTaskInput>
    public typealias MOutput = OperationOutput<CancelDataRepositoryTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelDataRepositoryTaskOutputError>
}

public struct CancelDataRepositoryTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelDataRepositoryTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelDataRepositoryTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelDataRepositoryTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelDataRepositoryTaskInput>
    public typealias MOutput = OperationOutput<CancelDataRepositoryTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelDataRepositoryTaskOutputError>
}

/// <p>Cancels a data repository task.</p>
public struct CancelDataRepositoryTaskInput: Equatable {
    /// <p>Specifies the data repository task to cancel.</p>
    public let taskId: String?

    public init (
        taskId: String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct CancelDataRepositoryTaskInputBody: Equatable {
    public let taskId: String?
}

extension CancelDataRepositoryTaskInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case taskId = "TaskId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskId)
        taskId = taskIdDecoded
    }
}

extension CancelDataRepositoryTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelDataRepositoryTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataRepositoryTaskEnded" : self = .dataRepositoryTaskEnded(try DataRepositoryTaskEnded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataRepositoryTaskNotFound" : self = .dataRepositoryTaskNotFound(try DataRepositoryTaskNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelDataRepositoryTaskOutputError: Equatable {
    case badRequest(BadRequest)
    case dataRepositoryTaskEnded(DataRepositoryTaskEnded)
    case dataRepositoryTaskNotFound(DataRepositoryTaskNotFound)
    case internalServerError(InternalServerError)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelDataRepositoryTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelDataRepositoryTaskOutputResponse(lifecycle: \(String(describing: lifecycle)), taskId: \(String(describing: taskId)))"}
}

extension CancelDataRepositoryTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CancelDataRepositoryTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lifecycle = output.lifecycle
            self.taskId = output.taskId
        } else {
            self.lifecycle = nil
            self.taskId = nil
        }
    }
}

public struct CancelDataRepositoryTaskOutputResponse: Equatable {
    /// <p>The lifecycle status of the data repository task, as follows:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>PENDING</code> - Amazon FSx has not started the task.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>EXECUTING</code> - Amazon FSx is processing the task.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code> -  Amazon FSx was not able to complete the task. For example, there may be files the task failed to process.
    ///                 The <a>DataRepositoryTaskFailureDetails</a> property provides more information about task failures.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SUCCEEDED</code> - FSx completed the task successfully.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CANCELED</code> - Amazon FSx canceled the task and it did not complete.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CANCELING</code> - FSx is in process of canceling the task.</p>
    ///             </li>
    ///          </ul>
    public let lifecycle: DataRepositoryTaskLifecycle?
    /// <p>The ID of the task being canceled.</p>
    public let taskId: String?

    public init (
        lifecycle: DataRepositoryTaskLifecycle? = nil,
        taskId: String? = nil
    )
    {
        self.lifecycle = lifecycle
        self.taskId = taskId
    }
}

struct CancelDataRepositoryTaskOutputResponseBody: Equatable {
    public let lifecycle: DataRepositoryTaskLifecycle?
    public let taskId: String?
}

extension CancelDataRepositoryTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lifecycle = "Lifecycle"
        case taskId = "TaskId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecycleDecoded = try containerValues.decodeIfPresent(DataRepositoryTaskLifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let taskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskId)
        taskId = taskIdDecoded
    }
}

extension CompletionReport: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case format = "Format"
        case path = "Path"
        case scope = "Scope"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let scope = scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let formatDecoded = try containerValues.decodeIfPresent(ReportFormat.self, forKey: .format)
        format = formatDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(ReportScope.self, forKey: .scope)
        scope = scopeDecoded
    }
}

extension CompletionReport: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CompletionReport(enabled: \(String(describing: enabled)), format: \(String(describing: format)), path: \(String(describing: path)), scope: \(String(describing: scope)))"}
}

/// <p>Provides a report detailing the data repository task results of the files processed that match the criteria specified in the report <code>Scope</code> parameter.
///             FSx delivers the report to the file system's linked data repository in Amazon S3,
///             using the path specified in the report <code>Path</code> parameter.
///             You can specify whether or not a report gets generated for a task using the <code>Enabled</code> parameter.</p>
public struct CompletionReport: Equatable {
    /// <p>Set <code>Enabled</code> to <code>True</code> to generate a <code>CompletionReport</code> when the task completes.
    ///             If set to <code>true</code>, then you need to provide a report <code>Scope</code>, <code>Path</code>, and <code>Format</code>.
    ///             Set <code>Enabled</code> to <code>False</code> if you do not want a <code>CompletionReport</code> generated when the task completes.</p>
    public let enabled: Bool?
    /// <p>Required if <code>Enabled</code> is set to <code>true</code>. Specifies the format of the <code>CompletionReport</code>. <code>REPORT_CSV_20191124</code> is the only format currently supported.
    ///             When <code>Format</code> is set to <code>REPORT_CSV_20191124</code>, the <code>CompletionReport</code> is provided in CSV format, and is delivered to
    ///             <code>{path}/task-{id}/failures.csv</code>.
    ///         </p>
    public let format: ReportFormat?
    /// <p>Required if <code>Enabled</code> is set to <code>true</code>. Specifies the location of the report on the file system's linked S3 data repository. An absolute path that defines where the completion report will be stored in the destination location.
    ///             The <code>Path</code> you provide must be located within the file system’s ExportPath.
    ///             An example <code>Path</code> value is "s3://myBucket/myExportPath/optionalPrefix". The report provides the following information for each file in the report:
    ///             FilePath, FileStatus, and ErrorCode. To learn more about a file system's <code>ExportPath</code>, see .
    ///             </p>
    public let path: String?
    /// <p>Required if <code>Enabled</code> is set to <code>true</code>. Specifies the scope of the <code>CompletionReport</code>; <code>FAILED_FILES_ONLY</code> is the only scope currently supported.
    ///             When <code>Scope</code> is set to <code>FAILED_FILES_ONLY</code>, the <code>CompletionReport</code> only contains information about files that the data repository task failed to process.</p>
    public let scope: ReportScope?

    public init (
        enabled: Bool? = nil,
        format: ReportFormat? = nil,
        path: String? = nil,
        scope: ReportScope? = nil
    )
    {
        self.enabled = enabled
        self.format = format
        self.path = path
        self.scope = scope
    }
}

public struct CopyBackupInputBodyMiddleware: Middleware {
    public let id: String = "CopyBackupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyBackupInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyBackupInput>
    public typealias MOutput = OperationOutput<CopyBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyBackupOutputError>
}

extension CopyBackupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyBackupInput(clientRequestToken: \(String(describing: clientRequestToken)), copyTags: \(String(describing: copyTags)), kmsKeyId: \(String(describing: kmsKeyId)), sourceBackupId: \(String(describing: sourceBackupId)), sourceRegion: \(String(describing: sourceRegion)), tags: \(String(describing: tags)))"}
}

extension CopyBackupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case copyTags = "CopyTags"
        case kmsKeyId = "KmsKeyId"
        case sourceBackupId = "SourceBackupId"
        case sourceRegion = "SourceRegion"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let copyTags = copyTags {
            try encodeContainer.encode(copyTags, forKey: .copyTags)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let sourceBackupId = sourceBackupId {
            try encodeContainer.encode(sourceBackupId, forKey: .sourceBackupId)
        }
        if let sourceRegion = sourceRegion {
            try encodeContainer.encode(sourceRegion, forKey: .sourceRegion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CopyBackupInputHeadersMiddleware: Middleware {
    public let id: String = "CopyBackupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyBackupInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyBackupInput>
    public typealias MOutput = OperationOutput<CopyBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyBackupOutputError>
}

public struct CopyBackupInputQueryItemMiddleware: Middleware {
    public let id: String = "CopyBackupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyBackupInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyBackupInput>
    public typealias MOutput = OperationOutput<CopyBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyBackupOutputError>
}

public struct CopyBackupInput: Equatable {
    /// <p>(Optional) An idempotency token for resource creation, in a string of up to 64
    ///             ASCII characters. This token is automatically filled on your behalf when you use the AWS
    ///             Command Line Interface (AWS CLI) or an AWS SDK.</p>
    public var clientRequestToken: String?
    /// <p>A boolean flag indicating whether tags from the source backup
    ///          should be copied to the backup copy. This value defaults to false.</p>
    ///          <p>If you set <code>CopyTags</code> to true and the source backup has
    ///          existing tags, you can use the <code>Tags</code> parameter to create new
    ///          tags, provided that the sum of the source backup tags and the new tags
    ///          doesn't exceed 50. Both sets of tags are merged. If there are tag
    ///          conflicts (for example, two tags with the same key but different values),
    ///          the tags created with the <code>Tags</code> parameter take precedence.</p>
    public let copyTags: Bool?
    /// <p>The ID of the AWS Key Management Service (AWS KMS) key used to encrypt the file system's data
    ///             for Amazon FSx for Windows File Server file systems and Amazon FSx for Lustre <code>PERSISTENT_1</code> file
    ///             systems at rest. In either case, if not specified, the Amazon FSx managed key
    ///             is used. The Amazon FSx for Lustre <code>SCRATCH_1</code> and <code>SCRATCH_2</code> file systems are always encrypted at rest using
    ///             Amazon FSx managed keys. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html">Encrypt</a>
    ///             in the <i>AWS Key Management Service API Reference</i>.</p>
    public let kmsKeyId: String?
    /// <p>The ID of the source backup. Specifies the ID of the backup that is
    ///          being copied.</p>
    public let sourceBackupId: String?
    /// <p>The source AWS Region of the backup. Specifies the AWS Region from which
    ///          the backup is being copied. The source and destination Regions must be in
    ///          the same AWS partition. If you don't specify a Region, it defaults to
    ///          the Region where the request is sent from (in-Region copy).</p>
    public let sourceRegion: String?
    /// <p>A list of <code>Tag</code> values, with a maximum of 50 elements.</p>
    public let tags: [Tag]?

    public init (
        clientRequestToken: String? = nil,
        copyTags: Bool? = nil,
        kmsKeyId: String? = nil,
        sourceBackupId: String? = nil,
        sourceRegion: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.copyTags = copyTags
        self.kmsKeyId = kmsKeyId
        self.sourceBackupId = sourceBackupId
        self.sourceRegion = sourceRegion
        self.tags = tags
    }
}

struct CopyBackupInputBody: Equatable {
    public let clientRequestToken: String?
    public let sourceBackupId: String?
    public let sourceRegion: String?
    public let kmsKeyId: String?
    public let copyTags: Bool?
    public let tags: [Tag]?
}

extension CopyBackupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case copyTags = "CopyTags"
        case kmsKeyId = "KmsKeyId"
        case sourceBackupId = "SourceBackupId"
        case sourceRegion = "SourceRegion"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let sourceBackupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceBackupId)
        sourceBackupId = sourceBackupIdDecoded
        let sourceRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceRegion)
        sourceRegion = sourceRegionDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CopyBackupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CopyBackupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BackupNotFound" : self = .backupNotFound(try BackupNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleParameterError" : self = .incompatibleParameterError(try IncompatibleParameterError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleRegionForMultiAZ" : self = .incompatibleRegionForMultiAZ(try IncompatibleRegionForMultiAZ(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDestinationKmsKey" : self = .invalidDestinationKmsKey(try InvalidDestinationKmsKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRegion" : self = .invalidRegion(try InvalidRegion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSourceKmsKey" : self = .invalidSourceKmsKey(try InvalidSourceKmsKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceeded" : self = .serviceLimitExceeded(try ServiceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SourceBackupUnavailable" : self = .sourceBackupUnavailable(try SourceBackupUnavailable(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyBackupOutputError: Equatable {
    case backupNotFound(BackupNotFound)
    case badRequest(BadRequest)
    case incompatibleParameterError(IncompatibleParameterError)
    case incompatibleRegionForMultiAZ(IncompatibleRegionForMultiAZ)
    case internalServerError(InternalServerError)
    case invalidDestinationKmsKey(InvalidDestinationKmsKey)
    case invalidRegion(InvalidRegion)
    case invalidSourceKmsKey(InvalidSourceKmsKey)
    case serviceLimitExceeded(ServiceLimitExceeded)
    case sourceBackupUnavailable(SourceBackupUnavailable)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyBackupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyBackupOutputResponse(backup: \(String(describing: backup)))"}
}

extension CopyBackupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CopyBackupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backup = output.backup
        } else {
            self.backup = nil
        }
    }
}

public struct CopyBackupOutputResponse: Equatable {
    /// <p>A backup of an Amazon FSx file system.</p>
    public let backup: Backup?

    public init (
        backup: Backup? = nil
    )
    {
        self.backup = backup
    }
}

struct CopyBackupOutputResponseBody: Equatable {
    public let backup: Backup?
}

extension CopyBackupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backup = "Backup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupDecoded = try containerValues.decodeIfPresent(Backup.self, forKey: .backup)
        backup = backupDecoded
    }
}

public struct CreateBackupInputBodyMiddleware: Middleware {
    public let id: String = "CreateBackupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBackupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBackupInput>
    public typealias MOutput = OperationOutput<CreateBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBackupOutputError>
}

extension CreateBackupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBackupInput(clientRequestToken: \(String(describing: clientRequestToken)), fileSystemId: \(String(describing: fileSystemId)), tags: \(String(describing: tags)))"}
}

extension CreateBackupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case fileSystemId = "FileSystemId"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateBackupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateBackupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBackupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBackupInput>
    public typealias MOutput = OperationOutput<CreateBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBackupOutputError>
}

public struct CreateBackupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateBackupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBackupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBackupInput>
    public typealias MOutput = OperationOutput<CreateBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBackupOutputError>
}

/// <p>The request object for the <code>CreateBackup</code> operation.</p>
public struct CreateBackupInput: Equatable {
    /// <p>(Optional) A string of up to 64 ASCII characters that Amazon FSx uses to ensure
    ///             idempotent creation. This string is automatically filled on your behalf when you use the
    ///             AWS Command Line Interface (AWS CLI) or an AWS SDK.</p>
    public var clientRequestToken: String?
    /// <p>The ID of the file system to back up.</p>
    public let fileSystemId: String?
    /// <p>(Optional) The tags to apply to the backup at backup creation. The key value of the
    ///             <code>Name</code> tag appears in the console as the backup name. If you have set <code>CopyTagsToBackups</code> to true, and
    ///             you specify one or more tags using the <code>CreateBackup</code> action, no existing file system tags are copied from the file system to the backup.</p>
    public let tags: [Tag]?

    public init (
        clientRequestToken: String? = nil,
        fileSystemId: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.fileSystemId = fileSystemId
        self.tags = tags
    }
}

struct CreateBackupInputBody: Equatable {
    public let fileSystemId: String?
    public let clientRequestToken: String?
    public let tags: [Tag]?
}

extension CreateBackupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case fileSystemId = "FileSystemId"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateBackupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBackupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BackupInProgress" : self = .backupInProgress(try BackupInProgress(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleParameterError" : self = .incompatibleParameterError(try IncompatibleParameterError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceeded" : self = .serviceLimitExceeded(try ServiceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBackupOutputError: Equatable {
    case backupInProgress(BackupInProgress)
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case incompatibleParameterError(IncompatibleParameterError)
    case internalServerError(InternalServerError)
    case serviceLimitExceeded(ServiceLimitExceeded)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBackupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBackupOutputResponse(backup: \(String(describing: backup)))"}
}

extension CreateBackupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateBackupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backup = output.backup
        } else {
            self.backup = nil
        }
    }
}

/// <p>The response object for the <code>CreateBackup</code> operation.</p>
public struct CreateBackupOutputResponse: Equatable {
    /// <p>A description of the backup.</p>
    public let backup: Backup?

    public init (
        backup: Backup? = nil
    )
    {
        self.backup = backup
    }
}

struct CreateBackupOutputResponseBody: Equatable {
    public let backup: Backup?
}

extension CreateBackupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backup = "Backup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupDecoded = try containerValues.decodeIfPresent(Backup.self, forKey: .backup)
        backup = backupDecoded
    }
}

public struct CreateDataRepositoryTaskInputBodyMiddleware: Middleware {
    public let id: String = "CreateDataRepositoryTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDataRepositoryTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDataRepositoryTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDataRepositoryTaskInput>
    public typealias MOutput = OperationOutput<CreateDataRepositoryTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDataRepositoryTaskOutputError>
}

extension CreateDataRepositoryTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDataRepositoryTaskInput(clientRequestToken: \(String(describing: clientRequestToken)), fileSystemId: \(String(describing: fileSystemId)), paths: \(String(describing: paths)), report: \(String(describing: report)), tags: \(String(describing: tags)), type: \(String(describing: type)))"}
}

extension CreateDataRepositoryTaskInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case fileSystemId = "FileSystemId"
        case paths = "Paths"
        case report = "Report"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let paths = paths {
            var pathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .paths)
            for datarepositorytaskpaths0 in paths {
                try pathsContainer.encode(datarepositorytaskpaths0)
            }
        }
        if let report = report {
            try encodeContainer.encode(report, forKey: .report)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateDataRepositoryTaskInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDataRepositoryTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDataRepositoryTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDataRepositoryTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDataRepositoryTaskInput>
    public typealias MOutput = OperationOutput<CreateDataRepositoryTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDataRepositoryTaskOutputError>
}

public struct CreateDataRepositoryTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDataRepositoryTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDataRepositoryTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDataRepositoryTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDataRepositoryTaskInput>
    public typealias MOutput = OperationOutput<CreateDataRepositoryTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDataRepositoryTaskOutputError>
}

public struct CreateDataRepositoryTaskInput: Equatable {
    /// <p>(Optional) An idempotency token for resource creation, in a string of up to 64
    ///             ASCII characters. This token is automatically filled on your behalf when you use the AWS
    ///             Command Line Interface (AWS CLI) or an AWS SDK.</p>
    public var clientRequestToken: String?
    /// <p>The globally unique ID of the file system, assigned by Amazon FSx.</p>
    public let fileSystemId: String?
    /// <p>(Optional) The path or paths on the Amazon FSx file system to use when the data repository task is processed.
    ///             The default path is the file system root directory. The paths you provide need to be relative to the mount point of the file system.
    ///             If the mount point is <code>/mnt/fsx</code> and <code>/mnt/fsx/path1</code> is a directory or
    ///             file on the file system you want to export, then the path to provide is <code>path1</code>.
    ///             If a path that you provide isn't valid, the task fails.</p>
    public let paths: [String]?
    /// <p>Defines whether or not Amazon FSx provides a CompletionReport once the task has completed.
    ///             A CompletionReport provides a detailed  report on the files that Amazon FSx processed that meet the criteria specified by the
    ///             <code>Scope</code> parameter. For more information, see
    ///             <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/task-completion-report.html">Working with Task Completion Reports</a>.</p>
    public let report: CompletionReport?
    /// <p>A list of <code>Tag</code> values, with a maximum of 50 elements.</p>
    public let tags: [Tag]?
    /// <p>Specifies the type of data repository task to create.</p>
    public let type: DataRepositoryTaskType?

    public init (
        clientRequestToken: String? = nil,
        fileSystemId: String? = nil,
        paths: [String]? = nil,
        report: CompletionReport? = nil,
        tags: [Tag]? = nil,
        type: DataRepositoryTaskType? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.fileSystemId = fileSystemId
        self.paths = paths
        self.report = report
        self.tags = tags
        self.type = type
    }
}

struct CreateDataRepositoryTaskInputBody: Equatable {
    public let type: DataRepositoryTaskType?
    public let paths: [String]?
    public let fileSystemId: String?
    public let report: CompletionReport?
    public let clientRequestToken: String?
    public let tags: [Tag]?
}

extension CreateDataRepositoryTaskInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case fileSystemId = "FileSystemId"
        case paths = "Paths"
        case report = "Report"
        case tags = "Tags"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(DataRepositoryTaskType.self, forKey: .type)
        type = typeDecoded
        let pathsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .paths)
        var pathsDecoded0:[String]? = nil
        if let pathsContainer = pathsContainer {
            pathsDecoded0 = [String]()
            for string0 in pathsContainer {
                if let string0 = string0 {
                    pathsDecoded0?.append(string0)
                }
            }
        }
        paths = pathsDecoded0
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let reportDecoded = try containerValues.decodeIfPresent(CompletionReport.self, forKey: .report)
        report = reportDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDataRepositoryTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDataRepositoryTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataRepositoryTaskExecuting" : self = .dataRepositoryTaskExecuting(try DataRepositoryTaskExecuting(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleParameterError" : self = .incompatibleParameterError(try IncompatibleParameterError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceeded" : self = .serviceLimitExceeded(try ServiceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDataRepositoryTaskOutputError: Equatable {
    case badRequest(BadRequest)
    case dataRepositoryTaskExecuting(DataRepositoryTaskExecuting)
    case fileSystemNotFound(FileSystemNotFound)
    case incompatibleParameterError(IncompatibleParameterError)
    case internalServerError(InternalServerError)
    case serviceLimitExceeded(ServiceLimitExceeded)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDataRepositoryTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDataRepositoryTaskOutputResponse(dataRepositoryTask: \(String(describing: dataRepositoryTask)))"}
}

extension CreateDataRepositoryTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDataRepositoryTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dataRepositoryTask = output.dataRepositoryTask
        } else {
            self.dataRepositoryTask = nil
        }
    }
}

public struct CreateDataRepositoryTaskOutputResponse: Equatable {
    /// <p>The description of the data repository task that you just created.</p>
    public let dataRepositoryTask: DataRepositoryTask?

    public init (
        dataRepositoryTask: DataRepositoryTask? = nil
    )
    {
        self.dataRepositoryTask = dataRepositoryTask
    }
}

struct CreateDataRepositoryTaskOutputResponseBody: Equatable {
    public let dataRepositoryTask: DataRepositoryTask?
}

extension CreateDataRepositoryTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataRepositoryTask = "DataRepositoryTask"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataRepositoryTaskDecoded = try containerValues.decodeIfPresent(DataRepositoryTask.self, forKey: .dataRepositoryTask)
        dataRepositoryTask = dataRepositoryTaskDecoded
    }
}

public struct CreateFileSystemFromBackupInputBodyMiddleware: Middleware {
    public let id: String = "CreateFileSystemFromBackupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFileSystemFromBackupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFileSystemFromBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFileSystemFromBackupInput>
    public typealias MOutput = OperationOutput<CreateFileSystemFromBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFileSystemFromBackupOutputError>
}

extension CreateFileSystemFromBackupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFileSystemFromBackupInput(backupId: \(String(describing: backupId)), clientRequestToken: \(String(describing: clientRequestToken)), kmsKeyId: \(String(describing: kmsKeyId)), lustreConfiguration: \(String(describing: lustreConfiguration)), securityGroupIds: \(String(describing: securityGroupIds)), storageType: \(String(describing: storageType)), subnetIds: \(String(describing: subnetIds)), tags: \(String(describing: tags)), windowsConfiguration: \(String(describing: windowsConfiguration)))"}
}

extension CreateFileSystemFromBackupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupId = "BackupId"
        case clientRequestToken = "ClientRequestToken"
        case kmsKeyId = "KmsKeyId"
        case lustreConfiguration = "LustreConfiguration"
        case securityGroupIds = "SecurityGroupIds"
        case storageType = "StorageType"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
        case windowsConfiguration = "WindowsConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupId = backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let lustreConfiguration = lustreConfiguration {
            try encodeContainer.encode(lustreConfiguration, forKey: .lustreConfiguration)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let storageType = storageType {
            try encodeContainer.encode(storageType.rawValue, forKey: .storageType)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let windowsConfiguration = windowsConfiguration {
            try encodeContainer.encode(windowsConfiguration, forKey: .windowsConfiguration)
        }
    }
}

public struct CreateFileSystemFromBackupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateFileSystemFromBackupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFileSystemFromBackupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFileSystemFromBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFileSystemFromBackupInput>
    public typealias MOutput = OperationOutput<CreateFileSystemFromBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFileSystemFromBackupOutputError>
}

public struct CreateFileSystemFromBackupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateFileSystemFromBackupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFileSystemFromBackupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFileSystemFromBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFileSystemFromBackupInput>
    public typealias MOutput = OperationOutput<CreateFileSystemFromBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFileSystemFromBackupOutputError>
}

/// <p>The request object for the <code>CreateFileSystemFromBackup</code>
///             operation.</p>
public struct CreateFileSystemFromBackupInput: Equatable {
    /// <p>The ID of the source backup. Specifies the backup you are copying.</p>
    public let backupId: String?
    /// <p>A string of up to 64 ASCII characters that Amazon FSx uses to ensure
    ///             idempotent creation. This string is automatically filled on your behalf when you use the
    ///             AWS Command Line Interface (AWS CLI) or an AWS SDK.</p>
    public var clientRequestToken: String?
    /// <p>The ID of the AWS Key Management Service (AWS KMS) key used to encrypt the file system's data
    ///             for Amazon FSx for Windows File Server file systems and Amazon FSx for Lustre <code>PERSISTENT_1</code> file
    ///             systems at rest. In either case, if not specified, the Amazon FSx managed key
    ///             is used. The Amazon FSx for Lustre <code>SCRATCH_1</code> and <code>SCRATCH_2</code> file systems are always encrypted at rest using
    ///             Amazon FSx managed keys. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html">Encrypt</a>
    ///             in the <i>AWS Key Management Service API Reference</i>.</p>
    public let kmsKeyId: String?
    /// <p>The Lustre configuration for the file system being created.
    ///             </p>
    public let lustreConfiguration: CreateFileSystemLustreConfiguration?
    /// <p>A list of IDs for the security groups that apply to the specified network
    ///             interfaces created for file system access. These security groups apply to all network
    ///             interfaces. This value isn't returned in later DescribeFileSystem requests.</p>
    public let securityGroupIds: [String]?
    /// <p>Sets the storage type for the Windows file system you're creating from a backup.
    ///             Valid values are <code>SSD</code> and <code>HDD</code>.</p>
    ///         <ul>
    ///             <li>
    ///                <p>Set to <code>SSD</code> to use solid state drive storage.
    ///                 Supported on all Windows deployment types.</p>
    ///             </li>
    ///             <li>
    ///                <p>Set to <code>HDD</code> to use hard disk drive storage.
    ///                 Supported on <code>SINGLE_AZ_2</code> and <code>MULTI_AZ_1</code> Windows file system deployment types.
    ///                 </p>
    ///             </li>
    ///          </ul>
    ///         <p>
    ///             Default value is <code>SSD</code>.
    ///         </p>
    ///         <note>
    ///             <p>HDD and SSD storage types have different minimum storage capacity requirements.
    ///             A restored file system's storage capacity is tied to the file system that was backed up.
    ///             You can create a file system that uses HDD storage from a backup of a file system that
    ///             used SSD storage only if the original SSD file system had a storage capacity of at least 2000 GiB.
    ///         </p>
    ///          </note>
    public let storageType: StorageType?
    /// <p>Specifies the IDs of the subnets that the file system will be accessible from. For Windows <code>MULTI_AZ_1</code>
    ///             file system deployment types, provide exactly two subnet IDs, one for the preferred file server
    ///             and one for the standby file server. You specify one of these subnets as the preferred subnet
    ///             using the <code>WindowsConfiguration > PreferredSubnetID</code> property.</p>
    ///         <p>For Windows <code>SINGLE_AZ_1</code> and <code>SINGLE_AZ_2</code> deployment
    ///             types and Lustre file systems, provide exactly one subnet ID.
    ///             The file server is launched in that subnet's Availability Zone.</p>
    public let subnetIds: [String]?
    /// <p>The tags to be applied to the file system at file system creation. The key value of
    ///             the <code>Name</code> tag appears in the console as the file system
    ///             name.</p>
    public let tags: [Tag]?
    /// <p>The configuration for this Microsoft Windows file system.</p>
    public let windowsConfiguration: CreateFileSystemWindowsConfiguration?

    public init (
        backupId: String? = nil,
        clientRequestToken: String? = nil,
        kmsKeyId: String? = nil,
        lustreConfiguration: CreateFileSystemLustreConfiguration? = nil,
        securityGroupIds: [String]? = nil,
        storageType: StorageType? = nil,
        subnetIds: [String]? = nil,
        tags: [Tag]? = nil,
        windowsConfiguration: CreateFileSystemWindowsConfiguration? = nil
    )
    {
        self.backupId = backupId
        self.clientRequestToken = clientRequestToken
        self.kmsKeyId = kmsKeyId
        self.lustreConfiguration = lustreConfiguration
        self.securityGroupIds = securityGroupIds
        self.storageType = storageType
        self.subnetIds = subnetIds
        self.tags = tags
        self.windowsConfiguration = windowsConfiguration
    }
}

struct CreateFileSystemFromBackupInputBody: Equatable {
    public let backupId: String?
    public let clientRequestToken: String?
    public let subnetIds: [String]?
    public let securityGroupIds: [String]?
    public let tags: [Tag]?
    public let windowsConfiguration: CreateFileSystemWindowsConfiguration?
    public let lustreConfiguration: CreateFileSystemLustreConfiguration?
    public let storageType: StorageType?
    public let kmsKeyId: String?
}

extension CreateFileSystemFromBackupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupId = "BackupId"
        case clientRequestToken = "ClientRequestToken"
        case kmsKeyId = "KmsKeyId"
        case lustreConfiguration = "LustreConfiguration"
        case securityGroupIds = "SecurityGroupIds"
        case storageType = "StorageType"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
        case windowsConfiguration = "WindowsConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupId)
        backupId = backupIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let windowsConfigurationDecoded = try containerValues.decodeIfPresent(CreateFileSystemWindowsConfiguration.self, forKey: .windowsConfiguration)
        windowsConfiguration = windowsConfigurationDecoded
        let lustreConfigurationDecoded = try containerValues.decodeIfPresent(CreateFileSystemLustreConfiguration.self, forKey: .lustreConfiguration)
        lustreConfiguration = lustreConfigurationDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(StorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension CreateFileSystemFromBackupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFileSystemFromBackupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ActiveDirectoryError" : self = .activeDirectoryError(try ActiveDirectoryError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BackupNotFound" : self = .backupNotFound(try BackupNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleParameterError" : self = .incompatibleParameterError(try IncompatibleParameterError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNetworkSettings" : self = .invalidNetworkSettings(try InvalidNetworkSettings(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPerUnitStorageThroughput" : self = .invalidPerUnitStorageThroughput(try InvalidPerUnitStorageThroughput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingFileSystemConfiguration" : self = .missingFileSystemConfiguration(try MissingFileSystemConfiguration(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceeded" : self = .serviceLimitExceeded(try ServiceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFileSystemFromBackupOutputError: Equatable {
    case activeDirectoryError(ActiveDirectoryError)
    case backupNotFound(BackupNotFound)
    case badRequest(BadRequest)
    case incompatibleParameterError(IncompatibleParameterError)
    case internalServerError(InternalServerError)
    case invalidNetworkSettings(InvalidNetworkSettings)
    case invalidPerUnitStorageThroughput(InvalidPerUnitStorageThroughput)
    case missingFileSystemConfiguration(MissingFileSystemConfiguration)
    case serviceLimitExceeded(ServiceLimitExceeded)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFileSystemFromBackupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFileSystemFromBackupOutputResponse(fileSystem: \(String(describing: fileSystem)))"}
}

extension CreateFileSystemFromBackupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateFileSystemFromBackupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fileSystem = output.fileSystem
        } else {
            self.fileSystem = nil
        }
    }
}

/// <p>The response object for the <code>CreateFileSystemFromBackup</code>
///             operation.</p>
public struct CreateFileSystemFromBackupOutputResponse: Equatable {
    /// <p>A description of the file system.</p>
    public let fileSystem: FileSystem?

    public init (
        fileSystem: FileSystem? = nil
    )
    {
        self.fileSystem = fileSystem
    }
}

struct CreateFileSystemFromBackupOutputResponseBody: Equatable {
    public let fileSystem: FileSystem?
}

extension CreateFileSystemFromBackupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileSystem = "FileSystem"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemDecoded = try containerValues.decodeIfPresent(FileSystem.self, forKey: .fileSystem)
        fileSystem = fileSystemDecoded
    }
}

public struct CreateFileSystemInputBodyMiddleware: Middleware {
    public let id: String = "CreateFileSystemInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFileSystemInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFileSystemInput>
    public typealias MOutput = OperationOutput<CreateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFileSystemOutputError>
}

extension CreateFileSystemInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFileSystemInput(clientRequestToken: \(String(describing: clientRequestToken)), fileSystemType: \(String(describing: fileSystemType)), kmsKeyId: \(String(describing: kmsKeyId)), lustreConfiguration: \(String(describing: lustreConfiguration)), securityGroupIds: \(String(describing: securityGroupIds)), storageCapacity: \(String(describing: storageCapacity)), storageType: \(String(describing: storageType)), subnetIds: \(String(describing: subnetIds)), tags: \(String(describing: tags)), windowsConfiguration: \(String(describing: windowsConfiguration)))"}
}

extension CreateFileSystemInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case fileSystemType = "FileSystemType"
        case kmsKeyId = "KmsKeyId"
        case lustreConfiguration = "LustreConfiguration"
        case securityGroupIds = "SecurityGroupIds"
        case storageCapacity = "StorageCapacity"
        case storageType = "StorageType"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
        case windowsConfiguration = "WindowsConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let fileSystemType = fileSystemType {
            try encodeContainer.encode(fileSystemType.rawValue, forKey: .fileSystemType)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let lustreConfiguration = lustreConfiguration {
            try encodeContainer.encode(lustreConfiguration, forKey: .lustreConfiguration)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let storageCapacity = storageCapacity {
            try encodeContainer.encode(storageCapacity, forKey: .storageCapacity)
        }
        if let storageType = storageType {
            try encodeContainer.encode(storageType.rawValue, forKey: .storageType)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let windowsConfiguration = windowsConfiguration {
            try encodeContainer.encode(windowsConfiguration, forKey: .windowsConfiguration)
        }
    }
}

public struct CreateFileSystemInputHeadersMiddleware: Middleware {
    public let id: String = "CreateFileSystemInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFileSystemInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFileSystemInput>
    public typealias MOutput = OperationOutput<CreateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFileSystemOutputError>
}

public struct CreateFileSystemInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateFileSystemInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFileSystemInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFileSystemInput>
    public typealias MOutput = OperationOutput<CreateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFileSystemOutputError>
}

/// <p>The request object used to create a new Amazon FSx file system.</p>
public struct CreateFileSystemInput: Equatable {
    /// <p>A string of up to 64 ASCII characters that Amazon FSx uses to ensure
    ///             idempotent creation. This string is automatically filled on your behalf when you use the
    ///             AWS Command Line Interface (AWS CLI) or an AWS SDK.</p>
    public var clientRequestToken: String?
    /// <p>The type of Amazon FSx file system to create, either <code>WINDOWS</code> or <code>LUSTRE</code>.</p>
    public let fileSystemType: FileSystemType?
    /// <p>The ID of the AWS Key Management Service (AWS KMS) key used to encrypt the file system's data
    ///             for Amazon FSx for Windows File Server file systems and Amazon FSx for Lustre <code>PERSISTENT_1</code> file
    ///             systems at rest. In either case, if not specified, the Amazon FSx managed key
    ///             is used. The Amazon FSx for Lustre <code>SCRATCH_1</code> and <code>SCRATCH_2</code> file systems are always encrypted at rest using
    ///             Amazon FSx managed keys. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html">Encrypt</a>
    ///             in the <i>AWS Key Management Service API Reference</i>.</p>
    public let kmsKeyId: String?
    /// <p>The Lustre configuration for the file system being created.
    ///             </p>
    public let lustreConfiguration: CreateFileSystemLustreConfiguration?
    /// <p>A list of IDs specifying the security groups to apply to all network interfaces
    ///             created for file system access. This list isn't returned in later requests to
    ///             describe the file system.</p>
    public let securityGroupIds: [String]?
    /// <p>Sets the storage capacity of the file system that you're creating.</p>
    ///         <p>For Lustre file systems:</p>
    ///         <ul>
    ///             <li>
    ///                <p>For <code>SCRATCH_2</code> and <code>PERSISTENT_1 SSD</code> deployment types, valid values are
    ///                 1200 GiB, 2400 GiB, and increments of 2400 GiB.</p>
    ///             </li>
    ///             <li>
    ///                <p>For <code>PERSISTENT HDD</code> file systems, valid values are increments of 6000 GiB for
    ///                 12 MB/s/TiB file systems and increments of 1800 GiB for 40 MB/s/TiB file systems.</p>
    ///             </li>
    ///             <li>
    ///                <p>For <code>SCRATCH_1</code> deployment type, valid values are
    ///                 1200 GiB, 2400 GiB, and increments of 3600 GiB.</p>
    ///             </li>
    ///          </ul>
    ///         <p>For Windows file systems:</p>
    ///         <ul>
    ///             <li>
    ///                <p>If <code>StorageType=SSD</code>, valid values are 32 GiB - 65,536 GiB (64 TiB).</p>
    ///             </li>
    ///             <li>
    ///                <p>If <code>StorageType=HDD</code>, valid values are 2000 GiB - 65,536 GiB (64 TiB).</p>
    ///             </li>
    ///          </ul>
    public let storageCapacity: Int?
    /// <p>Sets the storage type for the file system you're creating.
    ///             Valid values are <code>SSD</code> and <code>HDD</code>.</p>
    ///         <ul>
    ///             <li>
    ///                <p>Set to <code>SSD</code> to use solid state drive storage.
    ///                 SSD is supported on all Windows and Lustre deployment types.</p>
    ///             </li>
    ///             <li>
    ///                <p>Set to <code>HDD</code> to use hard disk drive storage.
    ///                 HDD is supported on <code>SINGLE_AZ_2</code> and <code>MULTI_AZ_1</code> Windows file system deployment types,
    ///                 and on <code>PERSISTENT</code> Lustre file system deployment types.
    ///                 </p>
    ///             </li>
    ///          </ul>
    ///         <p>
    ///             Default value is <code>SSD</code>. For more information, see
    ///             <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/optimize-fsx-costs.html#storage-type-options">
    ///             Storage Type Options</a> in the <i>Amazon FSx for Windows User Guide</i> and
    ///             <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/what-is.html#storage-options">Multiple Storage Options</a>
    ///             in the <i>Amazon FSx for Lustre User Guide</i>.
    ///         </p>
    public let storageType: StorageType?
    /// <p>Specifies the IDs of the subnets that the file system will be accessible from. For Windows <code>MULTI_AZ_1</code>
    ///             file system deployment types, provide exactly two subnet IDs, one for the preferred file server
    ///             and one for the standby file server. You specify one of these subnets as the preferred subnet
    ///             using the <code>WindowsConfiguration > PreferredSubnetID</code> property. For more information,
    ///             see <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/high-availability-multiAZ.html">
    ///                 Availability and durability: Single-AZ and Multi-AZ file systems</a>.</p>
    ///         <p>For Windows <code>SINGLE_AZ_1</code> and <code>SINGLE_AZ_2</code> file system deployment types and Lustre file systems, provide exactly one subnet ID.
    ///            The file server is launched in that subnet's Availability Zone.</p>
    public let subnetIds: [String]?
    /// <p>The tags to apply to the file system being created. The key value of
    ///             the <code>Name</code> tag appears in the console as the file system name.</p>
    public let tags: [Tag]?
    /// <p>The Microsoft Windows configuration for the file system being created.
    ///             </p>
    public let windowsConfiguration: CreateFileSystemWindowsConfiguration?

    public init (
        clientRequestToken: String? = nil,
        fileSystemType: FileSystemType? = nil,
        kmsKeyId: String? = nil,
        lustreConfiguration: CreateFileSystemLustreConfiguration? = nil,
        securityGroupIds: [String]? = nil,
        storageCapacity: Int? = nil,
        storageType: StorageType? = nil,
        subnetIds: [String]? = nil,
        tags: [Tag]? = nil,
        windowsConfiguration: CreateFileSystemWindowsConfiguration? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.fileSystemType = fileSystemType
        self.kmsKeyId = kmsKeyId
        self.lustreConfiguration = lustreConfiguration
        self.securityGroupIds = securityGroupIds
        self.storageCapacity = storageCapacity
        self.storageType = storageType
        self.subnetIds = subnetIds
        self.tags = tags
        self.windowsConfiguration = windowsConfiguration
    }
}

struct CreateFileSystemInputBody: Equatable {
    public let clientRequestToken: String?
    public let fileSystemType: FileSystemType?
    public let storageCapacity: Int?
    public let storageType: StorageType?
    public let subnetIds: [String]?
    public let securityGroupIds: [String]?
    public let tags: [Tag]?
    public let kmsKeyId: String?
    public let windowsConfiguration: CreateFileSystemWindowsConfiguration?
    public let lustreConfiguration: CreateFileSystemLustreConfiguration?
}

extension CreateFileSystemInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case fileSystemType = "FileSystemType"
        case kmsKeyId = "KmsKeyId"
        case lustreConfiguration = "LustreConfiguration"
        case securityGroupIds = "SecurityGroupIds"
        case storageCapacity = "StorageCapacity"
        case storageType = "StorageType"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
        case windowsConfiguration = "WindowsConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let fileSystemTypeDecoded = try containerValues.decodeIfPresent(FileSystemType.self, forKey: .fileSystemType)
        fileSystemType = fileSystemTypeDecoded
        let storageCapacityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .storageCapacity)
        storageCapacity = storageCapacityDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(StorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let windowsConfigurationDecoded = try containerValues.decodeIfPresent(CreateFileSystemWindowsConfiguration.self, forKey: .windowsConfiguration)
        windowsConfiguration = windowsConfigurationDecoded
        let lustreConfigurationDecoded = try containerValues.decodeIfPresent(CreateFileSystemLustreConfiguration.self, forKey: .lustreConfiguration)
        lustreConfiguration = lustreConfigurationDecoded
    }
}

extension CreateFileSystemLustreConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoImportPolicy = "AutoImportPolicy"
        case automaticBackupRetentionDays = "AutomaticBackupRetentionDays"
        case copyTagsToBackups = "CopyTagsToBackups"
        case dailyAutomaticBackupStartTime = "DailyAutomaticBackupStartTime"
        case dataCompressionType = "DataCompressionType"
        case deploymentType = "DeploymentType"
        case driveCacheType = "DriveCacheType"
        case exportPath = "ExportPath"
        case importPath = "ImportPath"
        case importedFileChunkSize = "ImportedFileChunkSize"
        case perUnitStorageThroughput = "PerUnitStorageThroughput"
        case weeklyMaintenanceStartTime = "WeeklyMaintenanceStartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoImportPolicy = autoImportPolicy {
            try encodeContainer.encode(autoImportPolicy.rawValue, forKey: .autoImportPolicy)
        }
        if let automaticBackupRetentionDays = automaticBackupRetentionDays {
            try encodeContainer.encode(automaticBackupRetentionDays, forKey: .automaticBackupRetentionDays)
        }
        if let copyTagsToBackups = copyTagsToBackups {
            try encodeContainer.encode(copyTagsToBackups, forKey: .copyTagsToBackups)
        }
        if let dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTime {
            try encodeContainer.encode(dailyAutomaticBackupStartTime, forKey: .dailyAutomaticBackupStartTime)
        }
        if let dataCompressionType = dataCompressionType {
            try encodeContainer.encode(dataCompressionType.rawValue, forKey: .dataCompressionType)
        }
        if let deploymentType = deploymentType {
            try encodeContainer.encode(deploymentType.rawValue, forKey: .deploymentType)
        }
        if let driveCacheType = driveCacheType {
            try encodeContainer.encode(driveCacheType.rawValue, forKey: .driveCacheType)
        }
        if let exportPath = exportPath {
            try encodeContainer.encode(exportPath, forKey: .exportPath)
        }
        if let importPath = importPath {
            try encodeContainer.encode(importPath, forKey: .importPath)
        }
        if let importedFileChunkSize = importedFileChunkSize {
            try encodeContainer.encode(importedFileChunkSize, forKey: .importedFileChunkSize)
        }
        if let perUnitStorageThroughput = perUnitStorageThroughput {
            try encodeContainer.encode(perUnitStorageThroughput, forKey: .perUnitStorageThroughput)
        }
        if let weeklyMaintenanceStartTime = weeklyMaintenanceStartTime {
            try encodeContainer.encode(weeklyMaintenanceStartTime, forKey: .weeklyMaintenanceStartTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let weeklyMaintenanceStartTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .weeklyMaintenanceStartTime)
        weeklyMaintenanceStartTime = weeklyMaintenanceStartTimeDecoded
        let importPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .importPath)
        importPath = importPathDecoded
        let exportPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exportPath)
        exportPath = exportPathDecoded
        let importedFileChunkSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .importedFileChunkSize)
        importedFileChunkSize = importedFileChunkSizeDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(LustreDeploymentType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let autoImportPolicyDecoded = try containerValues.decodeIfPresent(AutoImportPolicyType.self, forKey: .autoImportPolicy)
        autoImportPolicy = autoImportPolicyDecoded
        let perUnitStorageThroughputDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .perUnitStorageThroughput)
        perUnitStorageThroughput = perUnitStorageThroughputDecoded
        let dailyAutomaticBackupStartTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dailyAutomaticBackupStartTime)
        dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTimeDecoded
        let automaticBackupRetentionDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .automaticBackupRetentionDays)
        automaticBackupRetentionDays = automaticBackupRetentionDaysDecoded
        let copyTagsToBackupsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .copyTagsToBackups)
        copyTagsToBackups = copyTagsToBackupsDecoded
        let driveCacheTypeDecoded = try containerValues.decodeIfPresent(DriveCacheType.self, forKey: .driveCacheType)
        driveCacheType = driveCacheTypeDecoded
        let dataCompressionTypeDecoded = try containerValues.decodeIfPresent(DataCompressionType.self, forKey: .dataCompressionType)
        dataCompressionType = dataCompressionTypeDecoded
    }
}

extension CreateFileSystemLustreConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFileSystemLustreConfiguration(autoImportPolicy: \(String(describing: autoImportPolicy)), automaticBackupRetentionDays: \(String(describing: automaticBackupRetentionDays)), copyTagsToBackups: \(String(describing: copyTagsToBackups)), dailyAutomaticBackupStartTime: \(String(describing: dailyAutomaticBackupStartTime)), dataCompressionType: \(String(describing: dataCompressionType)), deploymentType: \(String(describing: deploymentType)), driveCacheType: \(String(describing: driveCacheType)), exportPath: \(String(describing: exportPath)), importPath: \(String(describing: importPath)), importedFileChunkSize: \(String(describing: importedFileChunkSize)), perUnitStorageThroughput: \(String(describing: perUnitStorageThroughput)), weeklyMaintenanceStartTime: \(String(describing: weeklyMaintenanceStartTime)))"}
}

/// <p>The Lustre configuration for the file system being created.
///             </p>
public struct CreateFileSystemLustreConfiguration: Equatable {
    /// <p> (Optional) When you create your file system, your existing S3 objects appear as file and directory listings.
    ///             Use this property to choose how Amazon FSx keeps your file and directory listings up to date
    ///             as you add or modify objects in your linked S3 bucket. <code>AutoImportPolicy</code> can
    ///             have the following values:</p>
    ///
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>NONE</code> - (Default) AutoImport is off. Amazon FSx only updates
    ///                 file and directory listings from the linked S3 bucket
    ///                 when the file system is created. FSx does not update file and directory
    ///                 listings for any new or changed objects after choosing this option.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NEW</code> - AutoImport is on. Amazon FSx automatically imports
    ///                 directory listings of any new objects added to the linked S3 bucket that
    ///                 do not currently exist in the FSx file system. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NEW_CHANGED</code> - AutoImport is on. Amazon FSx automatically imports
    ///                 file and directory listings of any new objects added to the S3 bucket and any
    ///                 existing objects that are changed in the S3 bucket after you choose this option.
    ///             </p>
    ///             </li>
    ///          </ul>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/autoimport-data-repo.html">Automatically import updates from your S3 bucket</a>.</p>
    public let autoImportPolicy: AutoImportPolicyType?
    /// <p>The number of days to retain automatic backups. Setting this to 0 disables
    ///             automatic backups. You can retain automatic backups for a maximum of 90 days. The default is 0.</p>
    public let automaticBackupRetentionDays: Int?
    /// <p>(Optional) Not available to use with file systems that are linked to a data repository.
    ///             A boolean flag indicating whether tags for the file system should be copied to
    ///             backups. The default value is false. If it's set to true, all file system
    ///             tags are copied to all automatic and user-initiated backups when the user
    ///             doesn't specify any backup-specific tags. If this value is true, and you specify one or more backup tags, only
    ///             the specified tags are copied to backups. If you specify one or more tags when creating a
    ///             user-initiated backup, no tags are copied from the file system, regardless of this value.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/using-backups-fsx.html">Working with backups</a>.</p>
    public let copyTagsToBackups: Bool?
    /// <p>A recurring daily time, in the format <code>HH:MM</code>. <code>HH</code> is the
    ///             zero-padded hour of the day (0-23), and <code>MM</code> is the zero-padded minute of the
    ///             hour. For example, <code>05:00</code> specifies 5 AM daily. </p>
    public let dailyAutomaticBackupStartTime: String?
    /// <p>Sets the data compression configuration for the file system. <code>DataCompressionType</code>
    ///             can have the following values:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>NONE</code> - (Default) Data compression is turned off when
    ///                 the file system is created.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LZ4</code> - Data compression is turned on with the LZ4
    ///                 algorithm.</p>
    ///             </li>
    ///          </ul>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/data-compression.html">Lustre data compression</a>.</p>
    public let dataCompressionType: DataCompressionType?
    /// <p>
    ///             Choose <code>SCRATCH_1</code> and <code>SCRATCH_2</code> deployment
    ///             types when you need temporary storage and shorter-term processing of data.
    ///             The <code>SCRATCH_2</code> deployment type provides in-transit encryption of data and higher burst
    ///             throughput capacity than <code>SCRATCH_1</code>.</p>
    ///
    ///             <p>Choose <code>PERSISTENT_1</code> deployment type for longer-term storage
    ///                 and workloads and encryption of data in transit. To learn more about deployment types, see
    ///                 <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/lustre-deployment-types.html">
    ///                     FSx for Lustre Deployment Options</a>.</p>
    ///             <p>Encryption of data in-transit is automatically
    ///             enabled when you access a <code>SCRATCH_2</code> or <code>PERSISTENT_1</code>
    ///             file system from Amazon EC2 instances that <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/data-                 protection.html">support this feature</a>.
    ///             (Default = <code>SCRATCH_1</code>)
    ///         </p>
    ///             <p>Encryption of data in-transit for <code>SCRATCH_2</code> and <code>PERSISTENT_1</code>
    ///                 deployment types is supported when accessed from supported instance types in supported AWS Regions. To learn more,
    ///                 <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/encryption-in-transit-fsxl.html">Encrypting Data in Transit</a>.</p>
    public let deploymentType: LustreDeploymentType?
    /// <p>The type of drive cache used by PERSISTENT_1 file systems that are provisioned with
    ///             HDD storage devices. This parameter is required when storage type is HDD. Set to
    ///             <code>READ</code>, improve the performance for frequently accessed files and allows 20%
    ///             of the total storage capacity of the file system to be cached. </p>
    ///         <p>This parameter is required when <code>StorageType</code> is set to HDD.</p>
    public let driveCacheType: DriveCacheType?
    /// <p>(Optional) The path in Amazon S3 where the root of your Amazon FSx file system is exported.
    ///             The path must use the same Amazon S3 bucket as specified in ImportPath. You can provide an optional prefix to which
    ///             new and changed data is to be exported from your Amazon FSx for Lustre file system. If
    ///             an <code>ExportPath</code> value is not provided, Amazon FSx sets a default export path,
    ///             <code>s3://import-bucket/FSxLustre[creation-timestamp]</code>. The timestamp is in
    ///             UTC format, for example
    ///             <code>s3://import-bucket/FSxLustre20181105T222312Z</code>.</p>
    ///
    ///         <p>The Amazon S3 export bucket must be the same as the import bucket specified by
    ///             <code>ImportPath</code>. If you only specify a bucket name, such as
    ///             <code>s3://import-bucket</code>, you get a 1:1 mapping of file system objects to S3
    ///             bucket objects. This mapping means that the input data in S3 is overwritten on export.
    ///             If you provide a custom prefix in the export path, such as
    ///             <code>s3://import-bucket/[custom-optional-prefix]</code>, Amazon FSx exports the contents of your file
    ///             system to that export prefix in the Amazon S3 bucket.</p>
    public let exportPath: String?
    /// <p>(Optional) The path to the Amazon S3 bucket (including the optional prefix) that
    ///             you're using as the data repository for your Amazon FSx for Lustre file system.
    ///             The root of your FSx for Lustre file system will
    ///             be mapped to the root of the Amazon S3 bucket you select. An
    ///             example is <code>s3://import-bucket/optional-prefix</code>. If you specify a prefix
    ///             after the Amazon S3 bucket name, only object keys with that prefix are loaded into the
    ///             file system.</p>
    public let importPath: String?
    /// <p>(Optional) For files imported from a data repository, this value determines the stripe
    ///             count and maximum amount of data per file (in MiB) stored on a single physical disk. The
    ///             maximum number of disks that a single file can be striped across is limited by the total
    ///             number of disks that make up the file system.</p>
    ///
    ///         <p>The default chunk size is 1,024 MiB (1 GiB) and can go as high as 512,000 MiB (500
    ///             GiB). Amazon S3 objects have a maximum size of 5 TB.</p>
    public let importedFileChunkSize: Int?
    /// <p>
    ///             Required for the <code>PERSISTENT_1</code> deployment type, describes the amount of read and write
    ///             throughput for each 1 tebibyte of storage, in MB/s/TiB.
    ///             File system throughput capacity is calculated by multiplying ﬁle system storage capacity (TiB) by the PerUnitStorageThroughput
    ///             (MB/s/TiB). For a 2.4 TiB ﬁle system, provisioning 50 MB/s/TiB of PerUnitStorageThroughput
    ///             yields 120 MB/s of ﬁle system throughput. You pay for the amount of throughput that you
    ///             provision.
    ///         </p>
    ///         <p>Valid values for  SSD storage: 50, 100, 200. Valid values for  HDD storage: 12, 40.</p>
    public let perUnitStorageThroughput: Int?
    /// <p>(Optional) The preferred start time to perform weekly maintenance, formatted d:HH:MM in the UTC
    ///             time zone, where d is the weekday number, from 1 through 7, beginning with Monday and ending with Sunday.</p>
    public let weeklyMaintenanceStartTime: String?

    public init (
        autoImportPolicy: AutoImportPolicyType? = nil,
        automaticBackupRetentionDays: Int? = nil,
        copyTagsToBackups: Bool? = nil,
        dailyAutomaticBackupStartTime: String? = nil,
        dataCompressionType: DataCompressionType? = nil,
        deploymentType: LustreDeploymentType? = nil,
        driveCacheType: DriveCacheType? = nil,
        exportPath: String? = nil,
        importPath: String? = nil,
        importedFileChunkSize: Int? = nil,
        perUnitStorageThroughput: Int? = nil,
        weeklyMaintenanceStartTime: String? = nil
    )
    {
        self.autoImportPolicy = autoImportPolicy
        self.automaticBackupRetentionDays = automaticBackupRetentionDays
        self.copyTagsToBackups = copyTagsToBackups
        self.dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTime
        self.dataCompressionType = dataCompressionType
        self.deploymentType = deploymentType
        self.driveCacheType = driveCacheType
        self.exportPath = exportPath
        self.importPath = importPath
        self.importedFileChunkSize = importedFileChunkSize
        self.perUnitStorageThroughput = perUnitStorageThroughput
        self.weeklyMaintenanceStartTime = weeklyMaintenanceStartTime
    }
}

extension CreateFileSystemOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFileSystemOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ActiveDirectoryError" : self = .activeDirectoryError(try ActiveDirectoryError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleParameterError" : self = .incompatibleParameterError(try IncompatibleParameterError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidExportPath" : self = .invalidExportPath(try InvalidExportPath(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidImportPath" : self = .invalidImportPath(try InvalidImportPath(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNetworkSettings" : self = .invalidNetworkSettings(try InvalidNetworkSettings(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPerUnitStorageThroughput" : self = .invalidPerUnitStorageThroughput(try InvalidPerUnitStorageThroughput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingFileSystemConfiguration" : self = .missingFileSystemConfiguration(try MissingFileSystemConfiguration(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceeded" : self = .serviceLimitExceeded(try ServiceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFileSystemOutputError: Equatable {
    case activeDirectoryError(ActiveDirectoryError)
    case badRequest(BadRequest)
    case incompatibleParameterError(IncompatibleParameterError)
    case internalServerError(InternalServerError)
    case invalidExportPath(InvalidExportPath)
    case invalidImportPath(InvalidImportPath)
    case invalidNetworkSettings(InvalidNetworkSettings)
    case invalidPerUnitStorageThroughput(InvalidPerUnitStorageThroughput)
    case missingFileSystemConfiguration(MissingFileSystemConfiguration)
    case serviceLimitExceeded(ServiceLimitExceeded)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFileSystemOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFileSystemOutputResponse(fileSystem: \(String(describing: fileSystem)))"}
}

extension CreateFileSystemOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateFileSystemOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fileSystem = output.fileSystem
        } else {
            self.fileSystem = nil
        }
    }
}

/// <p>The response object returned after the file system is created.</p>
public struct CreateFileSystemOutputResponse: Equatable {
    /// <p>The configuration of the file system that was created.</p>
    public let fileSystem: FileSystem?

    public init (
        fileSystem: FileSystem? = nil
    )
    {
        self.fileSystem = fileSystem
    }
}

struct CreateFileSystemOutputResponseBody: Equatable {
    public let fileSystem: FileSystem?
}

extension CreateFileSystemOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileSystem = "FileSystem"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemDecoded = try containerValues.decodeIfPresent(FileSystem.self, forKey: .fileSystem)
        fileSystem = fileSystemDecoded
    }
}

extension CreateFileSystemWindowsConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activeDirectoryId = "ActiveDirectoryId"
        case aliases = "Aliases"
        case automaticBackupRetentionDays = "AutomaticBackupRetentionDays"
        case copyTagsToBackups = "CopyTagsToBackups"
        case dailyAutomaticBackupStartTime = "DailyAutomaticBackupStartTime"
        case deploymentType = "DeploymentType"
        case preferredSubnetId = "PreferredSubnetId"
        case selfManagedActiveDirectoryConfiguration = "SelfManagedActiveDirectoryConfiguration"
        case throughputCapacity = "ThroughputCapacity"
        case weeklyMaintenanceStartTime = "WeeklyMaintenanceStartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeDirectoryId = activeDirectoryId {
            try encodeContainer.encode(activeDirectoryId, forKey: .activeDirectoryId)
        }
        if let aliases = aliases {
            var aliasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aliases)
            for alternatednsnames0 in aliases {
                try aliasesContainer.encode(alternatednsnames0)
            }
        }
        if let automaticBackupRetentionDays = automaticBackupRetentionDays {
            try encodeContainer.encode(automaticBackupRetentionDays, forKey: .automaticBackupRetentionDays)
        }
        if let copyTagsToBackups = copyTagsToBackups {
            try encodeContainer.encode(copyTagsToBackups, forKey: .copyTagsToBackups)
        }
        if let dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTime {
            try encodeContainer.encode(dailyAutomaticBackupStartTime, forKey: .dailyAutomaticBackupStartTime)
        }
        if let deploymentType = deploymentType {
            try encodeContainer.encode(deploymentType.rawValue, forKey: .deploymentType)
        }
        if let preferredSubnetId = preferredSubnetId {
            try encodeContainer.encode(preferredSubnetId, forKey: .preferredSubnetId)
        }
        if let selfManagedActiveDirectoryConfiguration = selfManagedActiveDirectoryConfiguration {
            try encodeContainer.encode(selfManagedActiveDirectoryConfiguration, forKey: .selfManagedActiveDirectoryConfiguration)
        }
        if let throughputCapacity = throughputCapacity {
            try encodeContainer.encode(throughputCapacity, forKey: .throughputCapacity)
        }
        if let weeklyMaintenanceStartTime = weeklyMaintenanceStartTime {
            try encodeContainer.encode(weeklyMaintenanceStartTime, forKey: .weeklyMaintenanceStartTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeDirectoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .activeDirectoryId)
        activeDirectoryId = activeDirectoryIdDecoded
        let selfManagedActiveDirectoryConfigurationDecoded = try containerValues.decodeIfPresent(SelfManagedActiveDirectoryConfiguration.self, forKey: .selfManagedActiveDirectoryConfiguration)
        selfManagedActiveDirectoryConfiguration = selfManagedActiveDirectoryConfigurationDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(WindowsDeploymentType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let preferredSubnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredSubnetId)
        preferredSubnetId = preferredSubnetIdDecoded
        let throughputCapacityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .throughputCapacity)
        throughputCapacity = throughputCapacityDecoded
        let weeklyMaintenanceStartTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .weeklyMaintenanceStartTime)
        weeklyMaintenanceStartTime = weeklyMaintenanceStartTimeDecoded
        let dailyAutomaticBackupStartTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dailyAutomaticBackupStartTime)
        dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTimeDecoded
        let automaticBackupRetentionDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .automaticBackupRetentionDays)
        automaticBackupRetentionDays = automaticBackupRetentionDaysDecoded
        let copyTagsToBackupsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .copyTagsToBackups)
        copyTagsToBackups = copyTagsToBackupsDecoded
        let aliasesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .aliases)
        var aliasesDecoded0:[String]? = nil
        if let aliasesContainer = aliasesContainer {
            aliasesDecoded0 = [String]()
            for string0 in aliasesContainer {
                if let string0 = string0 {
                    aliasesDecoded0?.append(string0)
                }
            }
        }
        aliases = aliasesDecoded0
    }
}

extension CreateFileSystemWindowsConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFileSystemWindowsConfiguration(activeDirectoryId: \(String(describing: activeDirectoryId)), aliases: \(String(describing: aliases)), automaticBackupRetentionDays: \(String(describing: automaticBackupRetentionDays)), copyTagsToBackups: \(String(describing: copyTagsToBackups)), dailyAutomaticBackupStartTime: \(String(describing: dailyAutomaticBackupStartTime)), deploymentType: \(String(describing: deploymentType)), preferredSubnetId: \(String(describing: preferredSubnetId)), selfManagedActiveDirectoryConfiguration: \(String(describing: selfManagedActiveDirectoryConfiguration)), throughputCapacity: \(String(describing: throughputCapacity)), weeklyMaintenanceStartTime: \(String(describing: weeklyMaintenanceStartTime)))"}
}

/// <p>The configuration object for the Microsoft Windows file system used in
///                 <code>CreateFileSystem</code> and <code>CreateFileSystemFromBackup</code>
///             operations.</p>
public struct CreateFileSystemWindowsConfiguration: Equatable {
    /// <p>The ID for an existing AWS Managed Microsoft Active Directory (AD) instance that the
    ///             file system should join when it's created.</p>
    public let activeDirectoryId: String?
    /// <p>An array of one or more DNS alias names that you want to associate with the Amazon FSx file system.
    ///             Aliases allow you to use existing DNS names to access the data in your Amazon FSx file system.
    ///             You can associate up to 50 aliases with a file system at any time.
    ///             You can associate additional DNS aliases after you create the file system using the AssociateFileSystemAliases operation.
    ///             You can remove DNS aliases from the file system after it is created using the DisassociateFileSystemAliases operation.
    ///             You only need to specify the alias name in the request payload.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/managing-dns-aliases.html">Working with DNS Aliases</a> and
    ///         <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/walkthrough05-file-system-custom-CNAME.html">Walkthrough 5: Using DNS aliases to access your file system</a>, including
    ///         additional steps you must take to be able to access your file system using a DNS alias.</p>
    ///          <p>An alias name has to meet the following requirements:</p>
    ///             <ul>
    ///             <li>
    ///                <p>Formatted as a fully-qualified domain name (FQDN), <code>hostname.domain</code>, for example, <code>accounting.example.com</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can contain alphanumeric characters, the underscore (_), and the hyphen (-).</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot start or end with a hyphen.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can start with a numeric.</p>
    ///             </li>
    ///          </ul>
    ///         <p>For DNS alias names, Amazon FSx stores alphabetic characters as lowercase letters (a-z), regardless of how you specify them:
    ///             as uppercase letters, lowercase letters, or the corresponding letters in escape codes.</p>
    public let aliases: [String]?
    /// <p>The number of days to retain automatic backups. The default is to retain backups for 7
    ///             days. Setting this value to 0 disables the creation of automatic backups. The maximum
    ///             retention period for backups is 90 days.</p>
    public let automaticBackupRetentionDays: Int?
    /// <p>A boolean flag indicating whether tags for the file system should be copied to
    ///             backups. This value defaults to false. If it's set to true, all tags for the file
    ///             system are copied to all automatic and user-initiated backups where the user
    ///             doesn't specify tags. If this value is true, and you specify one or more tags, only
    ///             the specified tags are copied to backups. If you specify one or more tags when creating a
    ///             user-initiated backup, no tags are copied from the file system, regardless of this value.</p>
    public let copyTagsToBackups: Bool?
    /// <p>The preferred time to take daily automatic backups, formatted HH:MM in the UTC time
    ///             zone.</p>
    public let dailyAutomaticBackupStartTime: String?
    /// <p>Specifies the file system deployment type, valid values are the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>MULTI_AZ_1</code> - Deploys a high availability file system that is configured
    ///                     for Multi-AZ redundancy to tolerate temporary Availability Zone (AZ) unavailability. You
    ///                     can only deploy a Multi-AZ file system in AWS Regions that have a minimum of three Availability Zones. Also
    ///                 supports HDD storage type</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SINGLE_AZ_1</code> - (Default) Choose to deploy a file system that is configured for single AZ redundancy.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SINGLE_AZ_2</code> - The latest generation Single AZ file system.
    ///                     Specifies a file system that is configured for single AZ redundancy and supports HDD storage type.</p>
    ///             </li>
    ///          </ul>
    ///         <p>For more information, see
    ///             <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/high-availability-multiAZ.html">
    ///                 Availability and Durability: Single-AZ and Multi-AZ File Systems</a>.</p>
    public let deploymentType: WindowsDeploymentType?
    /// <p>Required when <code>DeploymentType</code> is set to <code>MULTI_AZ_1</code>. This specifies the subnet
    ///             in which you want the preferred file server to be located. For in-AWS applications, we recommend that you launch
    ///             your clients in the same Availability Zone (AZ) as your preferred file server to reduce cross-AZ
    ///             data transfer costs and minimize latency. </p>
    public let preferredSubnetId: String?
    /// <p>The configuration that Amazon FSx uses to join the Windows File Server instance to
    ///             your self-managed (including on-premises) Microsoft Active Directory (AD)
    ///             directory. For more information, see
    ///             <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/self-managed-AD.html">
    ///                 Using Amazon FSx with your self-managed Microsoft Active Directory</a>.</p>
    public let selfManagedActiveDirectoryConfiguration: SelfManagedActiveDirectoryConfiguration?
    /// <p>The throughput of an Amazon FSx file system, measured in megabytes per second, in 2 to
    ///             the <i>n</i>th increments, between 2^3 (8) and 2^11 (2048).</p>
    public let throughputCapacity: Int?
    /// <p>The preferred start time to perform weekly maintenance, formatted d:HH:MM in the UTC
    ///             time zone, where d is the weekday number, from 1 through 7, beginning with Monday and ending with Sunday.</p>
    public let weeklyMaintenanceStartTime: String?

    public init (
        activeDirectoryId: String? = nil,
        aliases: [String]? = nil,
        automaticBackupRetentionDays: Int? = nil,
        copyTagsToBackups: Bool? = nil,
        dailyAutomaticBackupStartTime: String? = nil,
        deploymentType: WindowsDeploymentType? = nil,
        preferredSubnetId: String? = nil,
        selfManagedActiveDirectoryConfiguration: SelfManagedActiveDirectoryConfiguration? = nil,
        throughputCapacity: Int? = nil,
        weeklyMaintenanceStartTime: String? = nil
    )
    {
        self.activeDirectoryId = activeDirectoryId
        self.aliases = aliases
        self.automaticBackupRetentionDays = automaticBackupRetentionDays
        self.copyTagsToBackups = copyTagsToBackups
        self.dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTime
        self.deploymentType = deploymentType
        self.preferredSubnetId = preferredSubnetId
        self.selfManagedActiveDirectoryConfiguration = selfManagedActiveDirectoryConfiguration
        self.throughputCapacity = throughputCapacity
        self.weeklyMaintenanceStartTime = weeklyMaintenanceStartTime
    }
}

public enum DataCompressionType {
    case lz4
    case `none`
    case sdkUnknown(String)
}

extension DataCompressionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataCompressionType] {
        return [
            .lz4,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .lz4: return "LZ4"
        case .none: return "NONE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataCompressionType(rawValue: rawValue) ?? DataCompressionType.sdkUnknown(rawValue)
    }
}

extension DataRepositoryConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoImportPolicy = "AutoImportPolicy"
        case exportPath = "ExportPath"
        case failureDetails = "FailureDetails"
        case importPath = "ImportPath"
        case importedFileChunkSize = "ImportedFileChunkSize"
        case lifecycle = "Lifecycle"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoImportPolicy = autoImportPolicy {
            try encodeContainer.encode(autoImportPolicy.rawValue, forKey: .autoImportPolicy)
        }
        if let exportPath = exportPath {
            try encodeContainer.encode(exportPath, forKey: .exportPath)
        }
        if let failureDetails = failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let importPath = importPath {
            try encodeContainer.encode(importPath, forKey: .importPath)
        }
        if let importedFileChunkSize = importedFileChunkSize {
            try encodeContainer.encode(importedFileChunkSize, forKey: .importedFileChunkSize)
        }
        if let lifecycle = lifecycle {
            try encodeContainer.encode(lifecycle.rawValue, forKey: .lifecycle)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecycleDecoded = try containerValues.decodeIfPresent(DataRepositoryLifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let importPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .importPath)
        importPath = importPathDecoded
        let exportPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exportPath)
        exportPath = exportPathDecoded
        let importedFileChunkSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .importedFileChunkSize)
        importedFileChunkSize = importedFileChunkSizeDecoded
        let autoImportPolicyDecoded = try containerValues.decodeIfPresent(AutoImportPolicyType.self, forKey: .autoImportPolicy)
        autoImportPolicy = autoImportPolicyDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(DataRepositoryFailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
    }
}

extension DataRepositoryConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataRepositoryConfiguration(autoImportPolicy: \(String(describing: autoImportPolicy)), exportPath: \(String(describing: exportPath)), failureDetails: \(String(describing: failureDetails)), importPath: \(String(describing: importPath)), importedFileChunkSize: \(String(describing: importedFileChunkSize)), lifecycle: \(String(describing: lifecycle)))"}
}

/// <p>The data repository configuration object for Lustre file systems returned in the response of
///             the <code>CreateFileSystem</code> operation.</p>
public struct DataRepositoryConfiguration: Equatable {
    /// <p>Describes the file system's linked S3 data repository's <code>AutoImportPolicy</code>.
    ///             The AutoImportPolicy configures how Amazon FSx keeps your file and directory listings up to date
    ///             as you add or modify objects in your linked S3 bucket. <code>AutoImportPolicy</code> can have the following values:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>NONE</code> - (Default) AutoImport is off. Amazon FSx only updates
    ///                 file and directory listings from the linked S3 bucket
    ///                 when the file system is created. FSx does not update file and directory
    ///                 listings for any new or changed objects after choosing this option.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NEW</code> - AutoImport is on. Amazon FSx automatically imports
    ///                 directory listings of any new objects added to the linked S3 bucket that
    ///                 do not currently exist in the FSx file system. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NEW_CHANGED</code> - AutoImport is on. Amazon FSx automatically imports
    ///                 file and directory listings of any new objects added to the S3 bucket and any
    ///                 existing objects that are changed in the S3 bucket after you choose this option.
    ///             </p>
    ///             </li>
    ///          </ul>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/autoimport-data-repo.html">Automatically import updates from your S3 bucket</a>.</p>
    public let autoImportPolicy: AutoImportPolicyType?
    /// <p>The export path to the Amazon S3 bucket (and prefix) that you are using to store new and
    ///             changed Lustre file system files in S3.</p>
    public let exportPath: String?
    /// <p>Provides detailed information about the data respository if its <code>Lifecycle</code> is
    ///             set to <code>MISCONFIGURED</code>.</p>
    public let failureDetails: DataRepositoryFailureDetails?
    /// <p>The import path to the Amazon S3 bucket (and optional prefix) that you're using
    ///             as the data repository for your FSx for Lustre file system, for example
    ///                 <code>s3://import-bucket/optional-prefix</code>. If a prefix is specified after the
    ///             Amazon S3 bucket name, only object keys with that prefix are loaded into the file
    ///             system.</p>
    public let importPath: String?
    /// <p>For files imported from a data repository, this value determines the stripe count and
    ///             maximum amount of data per file (in MiB) stored on a single physical disk. The maximum
    ///             number of disks that a single file can be striped across is limited by the total number
    ///             of disks that make up the file system.</p>
    ///
    ///         <p>The default chunk size is 1,024 MiB (1 GiB) and can go as high as 512,000 MiB (500
    ///             GiB). Amazon S3 objects have a maximum size of 5 TB.</p>
    public let importedFileChunkSize: Int?
    /// <p>Describes the state of the file system's S3 durable data repository, if it is configured with an S3 repository.
    ///         The lifecycle can have the following values:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CREATING</code> - The data repository configuration between
    ///                 the FSx file system and the linked S3 data repository is being created.
    ///                 The data repository is unavailable.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>AVAILABLE</code> - The data repository is available for use.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MISCONFIGURED</code> - Amazon FSx cannot automatically import updates from the S3 bucket
    ///                 until the data repository configuration is corrected. For more information, see
    ///                 <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/troubleshooting.html#troubleshooting-misconfigured-data-repository">Troubleshooting a Misconfigured linked S3 bucket</a>.
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UPDATING</code> - The data repository is undergoing a customer initiated update and availability may be impacted.</p>
    ///             </li>
    ///          </ul>
    public let lifecycle: DataRepositoryLifecycle?

    public init (
        autoImportPolicy: AutoImportPolicyType? = nil,
        exportPath: String? = nil,
        failureDetails: DataRepositoryFailureDetails? = nil,
        importPath: String? = nil,
        importedFileChunkSize: Int? = nil,
        lifecycle: DataRepositoryLifecycle? = nil
    )
    {
        self.autoImportPolicy = autoImportPolicy
        self.exportPath = exportPath
        self.failureDetails = failureDetails
        self.importPath = importPath
        self.importedFileChunkSize = importedFileChunkSize
        self.lifecycle = lifecycle
    }
}

extension DataRepositoryFailureDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DataRepositoryFailureDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataRepositoryFailureDetails(message: \(String(describing: message)))"}
}

/// <p>Provides detailed information about the data respository if its <code>Lifecycle</code> is
///             set to <code>MISCONFIGURED</code>.</p>
public struct DataRepositoryFailureDetails: Equatable {
    /// <p>A detailed error message.</p>
    public let message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

public enum DataRepositoryLifecycle {
    case available
    case creating
    case deleting
    case misconfigured
    case updating
    case sdkUnknown(String)
}

extension DataRepositoryLifecycle : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataRepositoryLifecycle] {
        return [
            .available,
            .creating,
            .deleting,
            .misconfigured,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case .misconfigured: return "MISCONFIGURED"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataRepositoryLifecycle(rawValue: rawValue) ?? DataRepositoryLifecycle.sdkUnknown(rawValue)
    }
}

extension DataRepositoryTask: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime = "CreationTime"
        case endTime = "EndTime"
        case failureDetails = "FailureDetails"
        case fileSystemId = "FileSystemId"
        case lifecycle = "Lifecycle"
        case paths = "Paths"
        case report = "Report"
        case resourceARN = "ResourceARN"
        case startTime = "StartTime"
        case status = "Status"
        case tags = "Tags"
        case taskId = "TaskId"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let failureDetails = failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let lifecycle = lifecycle {
            try encodeContainer.encode(lifecycle.rawValue, forKey: .lifecycle)
        }
        if let paths = paths {
            var pathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .paths)
            for datarepositorytaskpaths0 in paths {
                try pathsContainer.encode(datarepositorytaskpaths0)
            }
        }
        if let report = report {
            try encodeContainer.encode(report, forKey: .report)
        }
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let taskId = taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(DataRepositoryTaskLifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataRepositoryTaskType.self, forKey: .type)
        type = typeDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let pathsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .paths)
        var pathsDecoded0:[String]? = nil
        if let pathsContainer = pathsContainer {
            pathsDecoded0 = [String]()
            for string0 in pathsContainer {
                if let string0 = string0 {
                    pathsDecoded0?.append(string0)
                }
            }
        }
        paths = pathsDecoded0
        let failureDetailsDecoded = try containerValues.decodeIfPresent(DataRepositoryTaskFailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataRepositoryTaskStatus.self, forKey: .status)
        status = statusDecoded
        let reportDecoded = try containerValues.decodeIfPresent(CompletionReport.self, forKey: .report)
        report = reportDecoded
    }
}

extension DataRepositoryTask: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataRepositoryTask(creationTime: \(String(describing: creationTime)), endTime: \(String(describing: endTime)), failureDetails: \(String(describing: failureDetails)), fileSystemId: \(String(describing: fileSystemId)), lifecycle: \(String(describing: lifecycle)), paths: \(String(describing: paths)), report: \(String(describing: report)), resourceARN: \(String(describing: resourceARN)), startTime: \(String(describing: startTime)), status: \(String(describing: status)), tags: \(String(describing: tags)), taskId: \(String(describing: taskId)), type: \(String(describing: type)))"}
}

/// <p>A description of the data repository task. You use data repository tasks
///             to perform bulk transfer operations between your Amazon FSx file system and its linked data
///             repository.</p>
public struct DataRepositoryTask: Equatable {
    /// <p>The time that the resource was created, in seconds (since 1970-01-01T00:00:00Z),
    ///             also known as Unix time.</p>
    public let creationTime: Date?
    /// <p>The time that Amazon FSx completed processing the task, populated after the task is complete.</p>
    public let endTime: Date?
    /// <p>Failure message describing why the task failed, it is populated only when <code>Lifecycle</code> is set to <code>FAILED</code>.</p>
    public let failureDetails: DataRepositoryTaskFailureDetails?
    /// <p>The globally unique ID of the file system, assigned by Amazon FSx.</p>
    public let fileSystemId: String?
    /// <p>The lifecycle status of the data repository task, as follows:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>PENDING</code> - Amazon FSx has not started the task.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>EXECUTING</code> - Amazon FSx is processing the task.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code> -  Amazon FSx was not able to complete the task. For example, there may be files the task failed to process.
    ///                 The <a>DataRepositoryTaskFailureDetails</a> property provides more information about task failures.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SUCCEEDED</code> - FSx completed the task successfully.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CANCELED</code> - Amazon FSx canceled the task and it did not complete.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CANCELING</code> - FSx is in process of canceling the task.</p>
    ///             </li>
    ///          </ul>
    ///         <note>
    ///             <p>You cannot delete an FSx for Lustre file system if there are data
    ///                 repository tasks for the file system in the <code>PENDING</code> or <code>EXECUTING</code> states.
    ///                 Please retry when the data repository task is finished (with a status of <code>CANCELED</code>, <code>SUCCEEDED</code>, or <code>FAILED</code>).
    ///                 You can use the DescribeDataRepositoryTask action to monitor the task status. Contact the FSx team if you need to delete your file system immediately.</p>
    ///         </note>
    public let lifecycle: DataRepositoryTaskLifecycle?
    /// <p>An array of paths on the Amazon FSx for Lustre file system that specify the data for the data repository task to process.
    ///             For example, in an EXPORT_TO_REPOSITORY task, the paths specify which data to export to the linked data repository.</p>
    ///             <p>(Default) If <code>Paths</code> is not specified, Amazon FSx uses the file system root directory.</p>
    public let paths: [String]?
    /// <p>Provides a report detailing the data repository task results of the files processed that match the criteria specified in the report <code>Scope</code> parameter.
    ///             FSx delivers the report to the file system's linked data repository in Amazon S3,
    ///             using the path specified in the report <code>Path</code> parameter.
    ///             You can specify whether or not a report gets generated for a task using the <code>Enabled</code> parameter.</p>
    public let report: CompletionReport?
    /// <p>The Amazon Resource Name (ARN) for a given resource. ARNs uniquely identify AWS
    ///             resources. We require an ARN when you need to specify a resource unambiguously across
    ///             all of AWS. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)
    ///                 and AWS Service Namespaces</a> in the <i>AWS General
    ///             Reference</i>.</p>
    public let resourceARN: String?
    /// <p>The time that Amazon FSx began processing the task.</p>
    public let startTime: Date?
    /// <p>Provides the status of the number of files that the task has processed successfully and failed to process.</p>
    public let status: DataRepositoryTaskStatus?
    /// <p>A list of <code>Tag</code> values, with a maximum of 50 elements.</p>
    public let tags: [Tag]?
    /// <p>The system-generated, unique 17-digit ID of the data repository task.</p>
    public let taskId: String?
    /// <p>The type of data repository task; EXPORT_TO_REPOSITORY is the only type currently supported.</p>
    public let type: DataRepositoryTaskType?

    public init (
        creationTime: Date? = nil,
        endTime: Date? = nil,
        failureDetails: DataRepositoryTaskFailureDetails? = nil,
        fileSystemId: String? = nil,
        lifecycle: DataRepositoryTaskLifecycle? = nil,
        paths: [String]? = nil,
        report: CompletionReport? = nil,
        resourceARN: String? = nil,
        startTime: Date? = nil,
        status: DataRepositoryTaskStatus? = nil,
        tags: [Tag]? = nil,
        taskId: String? = nil,
        type: DataRepositoryTaskType? = nil
    )
    {
        self.creationTime = creationTime
        self.endTime = endTime
        self.failureDetails = failureDetails
        self.fileSystemId = fileSystemId
        self.lifecycle = lifecycle
        self.paths = paths
        self.report = report
        self.resourceARN = resourceARN
        self.startTime = startTime
        self.status = status
        self.tags = tags
        self.taskId = taskId
        self.type = type
    }
}

extension DataRepositoryTaskEnded: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataRepositoryTaskEnded(message: \(String(describing: message)))"}
}

extension DataRepositoryTaskEnded: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DataRepositoryTaskEndedBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The data repository task could not be canceled because the task has already ended.</p>
public struct DataRepositoryTaskEnded: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DataRepositoryTaskEndedBody: Equatable {
    public let message: String?
}

extension DataRepositoryTaskEndedBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DataRepositoryTaskExecuting: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataRepositoryTaskExecuting(message: \(String(describing: message)))"}
}

extension DataRepositoryTaskExecuting: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DataRepositoryTaskExecutingBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An existing data repository task is currently executing on the file system.
///         Wait until the existing task has completed, then create the new task.</p>
public struct DataRepositoryTaskExecuting: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DataRepositoryTaskExecutingBody: Equatable {
    public let message: String?
}

extension DataRepositoryTaskExecutingBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DataRepositoryTaskFailureDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DataRepositoryTaskFailureDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataRepositoryTaskFailureDetails(message: \(String(describing: message)))"}
}

/// <p>Provides information about why a data repository task failed. Only populated when the task <code>Lifecycle</code> is set to <code>FAILED</code>.</p>
public struct DataRepositoryTaskFailureDetails: Equatable {
    /// <p>A detailed error message.</p>
    public let message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

extension DataRepositoryTaskFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for datarepositorytaskfiltervalues0 in values {
                try valuesContainer.encode(datarepositorytaskfiltervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(DataRepositoryTaskFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension DataRepositoryTaskFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataRepositoryTaskFilter(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>(Optional) An array of filter objects you can use to filter the response of data repository tasks you will see in the the response.
///             You can filter the tasks returned in the response by one or more file system IDs, task lifecycles, and by task type.
///             A filter object consists of a filter <code>Name</code>, and one or more <code>Values</code> for the filter.</p>
public struct DataRepositoryTaskFilter: Equatable {
    /// <p>Name of the task property to use in filtering the tasks returned in the response.</p>
    ///         <ul>
    ///             <li>
    ///                <p>Use <code>file-system-id</code> to retrieve data repository tasks for specific file systems.</p>
    ///             </li>
    ///             <li>
    ///                <p>Use <code>task-lifecycle</code> to retrieve data repository tasks with one or more specific lifecycle states,
    ///                 as follows: CANCELED, EXECUTING, FAILED, PENDING, and SUCCEEDED.</p>
    ///             </li>
    ///          </ul>
    public let name: DataRepositoryTaskFilterName?
    /// <p>Use Values to include the specific file system IDs and task
    ///             lifecycle states for the filters you are using.</p>
    public let values: [String]?

    public init (
        name: DataRepositoryTaskFilterName? = nil,
        values: [String]? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

public enum DataRepositoryTaskFilterName {
    case fileSystemId
    case taskLifecycle
    case sdkUnknown(String)
}

extension DataRepositoryTaskFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataRepositoryTaskFilterName] {
        return [
            .fileSystemId,
            .taskLifecycle,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .fileSystemId: return "file-system-id"
        case .taskLifecycle: return "task-lifecycle"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataRepositoryTaskFilterName(rawValue: rawValue) ?? DataRepositoryTaskFilterName.sdkUnknown(rawValue)
    }
}

public enum DataRepositoryTaskLifecycle {
    case canceled
    case canceling
    case executing
    case failed
    case pending
    case succeeded
    case sdkUnknown(String)
}

extension DataRepositoryTaskLifecycle : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataRepositoryTaskLifecycle] {
        return [
            .canceled,
            .canceling,
            .executing,
            .failed,
            .pending,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .canceled: return "CANCELED"
        case .canceling: return "CANCELING"
        case .executing: return "EXECUTING"
        case .failed: return "FAILED"
        case .pending: return "PENDING"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataRepositoryTaskLifecycle(rawValue: rawValue) ?? DataRepositoryTaskLifecycle.sdkUnknown(rawValue)
    }
}

extension DataRepositoryTaskNotFound: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataRepositoryTaskNotFound(message: \(String(describing: message)))"}
}

extension DataRepositoryTaskNotFound: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DataRepositoryTaskNotFoundBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The data repository task or tasks you specified could not be found.</p>
public struct DataRepositoryTaskNotFound: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DataRepositoryTaskNotFoundBody: Equatable {
    public let message: String?
}

extension DataRepositoryTaskNotFoundBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DataRepositoryTaskStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case failedCount = "FailedCount"
        case lastUpdatedTime = "LastUpdatedTime"
        case succeededCount = "SucceededCount"
        case totalCount = "TotalCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failedCount = failedCount {
            try encodeContainer.encode(failedCount, forKey: .failedCount)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let succeededCount = succeededCount {
            try encodeContainer.encode(succeededCount, forKey: .succeededCount)
        }
        if let totalCount = totalCount {
            try encodeContainer.encode(totalCount, forKey: .totalCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
        let succeededCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .succeededCount)
        succeededCount = succeededCountDecoded
        let failedCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .failedCount)
        failedCount = failedCountDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension DataRepositoryTaskStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataRepositoryTaskStatus(failedCount: \(String(describing: failedCount)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), succeededCount: \(String(describing: succeededCount)), totalCount: \(String(describing: totalCount)))"}
}

/// <p>Provides the task status showing a running total of the total number of files to be processed,
///             the number successfully processed, and the number of files the task failed to process.</p>
public struct DataRepositoryTaskStatus: Equatable {
    /// <p>A running total of the number of files that the task failed to process.</p>
    public let failedCount: Int?
    /// <p>The time at which the task status was last updated.</p>
    public let lastUpdatedTime: Date?
    /// <p>A running total of the number of files that the task has successfully processed.</p>
    public let succeededCount: Int?
    /// <p>The total number of files that the task will process. While a task is executing, the sum of
    ///             <code>SucceededCount</code> plus <code>FailedCount</code> may not equal <code>TotalCount</code>. When the task is complete,
    ///             <code>TotalCount</code> equals the sum of <code>SucceededCount</code> plus <code>FailedCount</code>.</p>
    public let totalCount: Int?

    public init (
        failedCount: Int? = nil,
        lastUpdatedTime: Date? = nil,
        succeededCount: Int? = nil,
        totalCount: Int? = nil
    )
    {
        self.failedCount = failedCount
        self.lastUpdatedTime = lastUpdatedTime
        self.succeededCount = succeededCount
        self.totalCount = totalCount
    }
}

public enum DataRepositoryTaskType {
    case export
    case sdkUnknown(String)
}

extension DataRepositoryTaskType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataRepositoryTaskType] {
        return [
            .export,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .export: return "EXPORT_TO_REPOSITORY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataRepositoryTaskType(rawValue: rawValue) ?? DataRepositoryTaskType.sdkUnknown(rawValue)
    }
}

public struct DeleteBackupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteBackupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBackupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBackupInput>
    public typealias MOutput = OperationOutput<DeleteBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBackupOutputError>
}

extension DeleteBackupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBackupInput(backupId: \(String(describing: backupId)), clientRequestToken: \(String(describing: clientRequestToken)))"}
}

extension DeleteBackupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupId = "BackupId"
        case clientRequestToken = "ClientRequestToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupId = backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
    }
}

public struct DeleteBackupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBackupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBackupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBackupInput>
    public typealias MOutput = OperationOutput<DeleteBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBackupOutputError>
}

public struct DeleteBackupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBackupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBackupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBackupInput>
    public typealias MOutput = OperationOutput<DeleteBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBackupOutputError>
}

/// <p>The request object for <code>DeleteBackup</code> operation.</p>
public struct DeleteBackupInput: Equatable {
    /// <p>The ID of the backup you want to delete.</p>
    public let backupId: String?
    /// <p>A string of up to 64 ASCII characters that Amazon FSx uses to ensure
    ///             idempotent deletion. This is automatically filled on your behalf when using the AWS CLI
    ///             or SDK.</p>
    public var clientRequestToken: String?

    public init (
        backupId: String? = nil,
        clientRequestToken: String? = nil
    )
    {
        self.backupId = backupId
        self.clientRequestToken = clientRequestToken
    }
}

struct DeleteBackupInputBody: Equatable {
    public let backupId: String?
    public let clientRequestToken: String?
}

extension DeleteBackupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupId = "BackupId"
        case clientRequestToken = "ClientRequestToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupId)
        backupId = backupIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension DeleteBackupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BackupBeingCopied" : self = .backupBeingCopied(try BackupBeingCopied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BackupInProgress" : self = .backupInProgress(try BackupInProgress(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BackupNotFound" : self = .backupNotFound(try BackupNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BackupRestoring" : self = .backupRestoring(try BackupRestoring(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleParameterError" : self = .incompatibleParameterError(try IncompatibleParameterError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBackupOutputError: Equatable {
    case backupBeingCopied(BackupBeingCopied)
    case backupInProgress(BackupInProgress)
    case backupNotFound(BackupNotFound)
    case backupRestoring(BackupRestoring)
    case badRequest(BadRequest)
    case incompatibleParameterError(IncompatibleParameterError)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBackupOutputResponse(backupId: \(String(describing: backupId)), lifecycle: \(String(describing: lifecycle)))"}
}

extension DeleteBackupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteBackupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backupId = output.backupId
            self.lifecycle = output.lifecycle
        } else {
            self.backupId = nil
            self.lifecycle = nil
        }
    }
}

/// <p>The response object for <code>DeleteBackup</code> operation.</p>
public struct DeleteBackupOutputResponse: Equatable {
    /// <p>The ID of the backup deleted.</p>
    public let backupId: String?
    /// <p>The lifecycle of the backup. Should be <code>DELETED</code>.</p>
    public let lifecycle: BackupLifecycle?

    public init (
        backupId: String? = nil,
        lifecycle: BackupLifecycle? = nil
    )
    {
        self.backupId = backupId
        self.lifecycle = lifecycle
    }
}

struct DeleteBackupOutputResponseBody: Equatable {
    public let backupId: String?
    public let lifecycle: BackupLifecycle?
}

extension DeleteBackupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupId = "BackupId"
        case lifecycle = "Lifecycle"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupId)
        backupId = backupIdDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(BackupLifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
    }
}

public struct DeleteFileSystemInputBodyMiddleware: Middleware {
    public let id: String = "DeleteFileSystemInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFileSystemInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFileSystemInput>
    public typealias MOutput = OperationOutput<DeleteFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFileSystemOutputError>
}

extension DeleteFileSystemInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFileSystemInput(clientRequestToken: \(String(describing: clientRequestToken)), fileSystemId: \(String(describing: fileSystemId)), lustreConfiguration: \(String(describing: lustreConfiguration)), windowsConfiguration: \(String(describing: windowsConfiguration)))"}
}

extension DeleteFileSystemInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case fileSystemId = "FileSystemId"
        case lustreConfiguration = "LustreConfiguration"
        case windowsConfiguration = "WindowsConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let lustreConfiguration = lustreConfiguration {
            try encodeContainer.encode(lustreConfiguration, forKey: .lustreConfiguration)
        }
        if let windowsConfiguration = windowsConfiguration {
            try encodeContainer.encode(windowsConfiguration, forKey: .windowsConfiguration)
        }
    }
}

public struct DeleteFileSystemInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFileSystemInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFileSystemInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFileSystemInput>
    public typealias MOutput = OperationOutput<DeleteFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFileSystemOutputError>
}

public struct DeleteFileSystemInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFileSystemInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFileSystemInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFileSystemInput>
    public typealias MOutput = OperationOutput<DeleteFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFileSystemOutputError>
}

/// <p>The request object for <code>DeleteFileSystem</code> operation.</p>
public struct DeleteFileSystemInput: Equatable {
    /// <p>A string of up to 64 ASCII characters that Amazon FSx uses to ensure
    ///             idempotent deletion. This is automatically filled on your behalf when using the AWS CLI
    ///             or SDK.</p>
    public var clientRequestToken: String?
    /// <p>The ID of the file system you want to delete.</p>
    public let fileSystemId: String?
    /// <p>The configuration object for the Amazon FSx for Lustre file system being deleted in the
    ///                 <code>DeleteFileSystem</code> operation.</p>
    public let lustreConfiguration: DeleteFileSystemLustreConfiguration?
    /// <p>The configuration object for the Microsoft Windows file system used in the
    ///                 <code>DeleteFileSystem</code> operation.</p>
    public let windowsConfiguration: DeleteFileSystemWindowsConfiguration?

    public init (
        clientRequestToken: String? = nil,
        fileSystemId: String? = nil,
        lustreConfiguration: DeleteFileSystemLustreConfiguration? = nil,
        windowsConfiguration: DeleteFileSystemWindowsConfiguration? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.fileSystemId = fileSystemId
        self.lustreConfiguration = lustreConfiguration
        self.windowsConfiguration = windowsConfiguration
    }
}

struct DeleteFileSystemInputBody: Equatable {
    public let fileSystemId: String?
    public let clientRequestToken: String?
    public let windowsConfiguration: DeleteFileSystemWindowsConfiguration?
    public let lustreConfiguration: DeleteFileSystemLustreConfiguration?
}

extension DeleteFileSystemInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case fileSystemId = "FileSystemId"
        case lustreConfiguration = "LustreConfiguration"
        case windowsConfiguration = "WindowsConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let windowsConfigurationDecoded = try containerValues.decodeIfPresent(DeleteFileSystemWindowsConfiguration.self, forKey: .windowsConfiguration)
        windowsConfiguration = windowsConfigurationDecoded
        let lustreConfigurationDecoded = try containerValues.decodeIfPresent(DeleteFileSystemLustreConfiguration.self, forKey: .lustreConfiguration)
        lustreConfiguration = lustreConfigurationDecoded
    }
}

extension DeleteFileSystemLustreConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case finalBackupTags = "FinalBackupTags"
        case skipFinalBackup = "SkipFinalBackup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let finalBackupTags = finalBackupTags {
            var finalBackupTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .finalBackupTags)
            for tags0 in finalBackupTags {
                try finalBackupTagsContainer.encode(tags0)
            }
        }
        if let skipFinalBackup = skipFinalBackup {
            try encodeContainer.encode(skipFinalBackup, forKey: .skipFinalBackup)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skipFinalBackupDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .skipFinalBackup)
        skipFinalBackup = skipFinalBackupDecoded
        let finalBackupTagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .finalBackupTags)
        var finalBackupTagsDecoded0:[Tag]? = nil
        if let finalBackupTagsContainer = finalBackupTagsContainer {
            finalBackupTagsDecoded0 = [Tag]()
            for structure0 in finalBackupTagsContainer {
                if let structure0 = structure0 {
                    finalBackupTagsDecoded0?.append(structure0)
                }
            }
        }
        finalBackupTags = finalBackupTagsDecoded0
    }
}

extension DeleteFileSystemLustreConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFileSystemLustreConfiguration(finalBackupTags: \(String(describing: finalBackupTags)), skipFinalBackup: \(String(describing: skipFinalBackup)))"}
}

/// <p>The configuration object for the Amazon FSx for Lustre file system being deleted in the
///                 <code>DeleteFileSystem</code> operation.</p>
public struct DeleteFileSystemLustreConfiguration: Equatable {
    /// <p>Use if <code>SkipFinalBackup</code> is set to <code>false</code>,
    ///             and you want to apply an array of tags to the final backup. If you have set the file system property
    ///             <code>CopyTagsToBackups</code> to true, and
    ///             you specify one or more <code>FinalBackupTags</code> when deleting a file system, Amazon FSx will not copy any existing file system tags to the backup.</p>
    public let finalBackupTags: [Tag]?
    /// <p>Set <code>SkipFinalBackup</code> to false if you want to take a final backup of the file
    ///             system you are deleting. By default, Amazon FSx will not take a final backup on your behalf when the
    ///                 <code>DeleteFileSystem</code> operation is invoked. (Default = true)</p>
    public let skipFinalBackup: Bool?

    public init (
        finalBackupTags: [Tag]? = nil,
        skipFinalBackup: Bool? = nil
    )
    {
        self.finalBackupTags = finalBackupTags
        self.skipFinalBackup = skipFinalBackup
    }
}

extension DeleteFileSystemLustreResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case finalBackupId = "FinalBackupId"
        case finalBackupTags = "FinalBackupTags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let finalBackupId = finalBackupId {
            try encodeContainer.encode(finalBackupId, forKey: .finalBackupId)
        }
        if let finalBackupTags = finalBackupTags {
            var finalBackupTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .finalBackupTags)
            for tags0 in finalBackupTags {
                try finalBackupTagsContainer.encode(tags0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let finalBackupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .finalBackupId)
        finalBackupId = finalBackupIdDecoded
        let finalBackupTagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .finalBackupTags)
        var finalBackupTagsDecoded0:[Tag]? = nil
        if let finalBackupTagsContainer = finalBackupTagsContainer {
            finalBackupTagsDecoded0 = [Tag]()
            for structure0 in finalBackupTagsContainer {
                if let structure0 = structure0 {
                    finalBackupTagsDecoded0?.append(structure0)
                }
            }
        }
        finalBackupTags = finalBackupTagsDecoded0
    }
}

extension DeleteFileSystemLustreResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFileSystemLustreResponse(finalBackupId: \(String(describing: finalBackupId)), finalBackupTags: \(String(describing: finalBackupTags)))"}
}

/// <p>The response object for the Amazon FSx for Lustre file system being deleted in the
///                 <code>DeleteFileSystem</code> operation.</p>
public struct DeleteFileSystemLustreResponse: Equatable {
    /// <p>The ID of the final backup for this file system.</p>
    public let finalBackupId: String?
    /// <p>The set of tags applied to the final backup.</p>
    public let finalBackupTags: [Tag]?

    public init (
        finalBackupId: String? = nil,
        finalBackupTags: [Tag]? = nil
    )
    {
        self.finalBackupId = finalBackupId
        self.finalBackupTags = finalBackupTags
    }
}

extension DeleteFileSystemOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFileSystemOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleParameterError" : self = .incompatibleParameterError(try IncompatibleParameterError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceeded" : self = .serviceLimitExceeded(try ServiceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFileSystemOutputError: Equatable {
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case incompatibleParameterError(IncompatibleParameterError)
    case internalServerError(InternalServerError)
    case serviceLimitExceeded(ServiceLimitExceeded)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFileSystemOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFileSystemOutputResponse(fileSystemId: \(String(describing: fileSystemId)), lifecycle: \(String(describing: lifecycle)), lustreResponse: \(String(describing: lustreResponse)), windowsResponse: \(String(describing: windowsResponse)))"}
}

extension DeleteFileSystemOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteFileSystemOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fileSystemId = output.fileSystemId
            self.lifecycle = output.lifecycle
            self.lustreResponse = output.lustreResponse
            self.windowsResponse = output.windowsResponse
        } else {
            self.fileSystemId = nil
            self.lifecycle = nil
            self.lustreResponse = nil
            self.windowsResponse = nil
        }
    }
}

/// <p>The response object for the <code>DeleteFileSystem</code> operation.</p>
public struct DeleteFileSystemOutputResponse: Equatable {
    /// <p>The ID of the file system being deleted.</p>
    public let fileSystemId: String?
    /// <p>The file system lifecycle for the deletion request. Should be
    ///             <code>DELETING</code>.</p>
    public let lifecycle: FileSystemLifecycle?
    /// <p>The response object for the Amazon FSx for Lustre file system being deleted in the
    ///                 <code>DeleteFileSystem</code> operation.</p>
    public let lustreResponse: DeleteFileSystemLustreResponse?
    /// <p>The response object for the Microsoft Windows file system used in the
    ///                 <code>DeleteFileSystem</code> operation.</p>
    public let windowsResponse: DeleteFileSystemWindowsResponse?

    public init (
        fileSystemId: String? = nil,
        lifecycle: FileSystemLifecycle? = nil,
        lustreResponse: DeleteFileSystemLustreResponse? = nil,
        windowsResponse: DeleteFileSystemWindowsResponse? = nil
    )
    {
        self.fileSystemId = fileSystemId
        self.lifecycle = lifecycle
        self.lustreResponse = lustreResponse
        self.windowsResponse = windowsResponse
    }
}

struct DeleteFileSystemOutputResponseBody: Equatable {
    public let fileSystemId: String?
    public let lifecycle: FileSystemLifecycle?
    public let windowsResponse: DeleteFileSystemWindowsResponse?
    public let lustreResponse: DeleteFileSystemLustreResponse?
}

extension DeleteFileSystemOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileSystemId = "FileSystemId"
        case lifecycle = "Lifecycle"
        case lustreResponse = "LustreResponse"
        case windowsResponse = "WindowsResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(FileSystemLifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let windowsResponseDecoded = try containerValues.decodeIfPresent(DeleteFileSystemWindowsResponse.self, forKey: .windowsResponse)
        windowsResponse = windowsResponseDecoded
        let lustreResponseDecoded = try containerValues.decodeIfPresent(DeleteFileSystemLustreResponse.self, forKey: .lustreResponse)
        lustreResponse = lustreResponseDecoded
    }
}

extension DeleteFileSystemWindowsConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case finalBackupTags = "FinalBackupTags"
        case skipFinalBackup = "SkipFinalBackup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let finalBackupTags = finalBackupTags {
            var finalBackupTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .finalBackupTags)
            for tags0 in finalBackupTags {
                try finalBackupTagsContainer.encode(tags0)
            }
        }
        if let skipFinalBackup = skipFinalBackup {
            try encodeContainer.encode(skipFinalBackup, forKey: .skipFinalBackup)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skipFinalBackupDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .skipFinalBackup)
        skipFinalBackup = skipFinalBackupDecoded
        let finalBackupTagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .finalBackupTags)
        var finalBackupTagsDecoded0:[Tag]? = nil
        if let finalBackupTagsContainer = finalBackupTagsContainer {
            finalBackupTagsDecoded0 = [Tag]()
            for structure0 in finalBackupTagsContainer {
                if let structure0 = structure0 {
                    finalBackupTagsDecoded0?.append(structure0)
                }
            }
        }
        finalBackupTags = finalBackupTagsDecoded0
    }
}

extension DeleteFileSystemWindowsConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFileSystemWindowsConfiguration(finalBackupTags: \(String(describing: finalBackupTags)), skipFinalBackup: \(String(describing: skipFinalBackup)))"}
}

/// <p>The configuration object for the Microsoft Windows file system used in the
///                 <code>DeleteFileSystem</code> operation.</p>
public struct DeleteFileSystemWindowsConfiguration: Equatable {
    /// <p>A set of tags for your final backup.</p>
    public let finalBackupTags: [Tag]?
    /// <p>By default, Amazon FSx for Windows takes a final backup on your behalf when the
    ///                 <code>DeleteFileSystem</code> operation is invoked. Doing this helps protect you
    ///             from data loss, and we highly recommend taking the final backup. If you want to skip
    ///             this backup, use this flag to do so.</p>
    public let skipFinalBackup: Bool?

    public init (
        finalBackupTags: [Tag]? = nil,
        skipFinalBackup: Bool? = nil
    )
    {
        self.finalBackupTags = finalBackupTags
        self.skipFinalBackup = skipFinalBackup
    }
}

extension DeleteFileSystemWindowsResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case finalBackupId = "FinalBackupId"
        case finalBackupTags = "FinalBackupTags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let finalBackupId = finalBackupId {
            try encodeContainer.encode(finalBackupId, forKey: .finalBackupId)
        }
        if let finalBackupTags = finalBackupTags {
            var finalBackupTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .finalBackupTags)
            for tags0 in finalBackupTags {
                try finalBackupTagsContainer.encode(tags0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let finalBackupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .finalBackupId)
        finalBackupId = finalBackupIdDecoded
        let finalBackupTagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .finalBackupTags)
        var finalBackupTagsDecoded0:[Tag]? = nil
        if let finalBackupTagsContainer = finalBackupTagsContainer {
            finalBackupTagsDecoded0 = [Tag]()
            for structure0 in finalBackupTagsContainer {
                if let structure0 = structure0 {
                    finalBackupTagsDecoded0?.append(structure0)
                }
            }
        }
        finalBackupTags = finalBackupTagsDecoded0
    }
}

extension DeleteFileSystemWindowsResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFileSystemWindowsResponse(finalBackupId: \(String(describing: finalBackupId)), finalBackupTags: \(String(describing: finalBackupTags)))"}
}

/// <p>The response object for the Microsoft Windows file system used in the
///                 <code>DeleteFileSystem</code> operation.</p>
public struct DeleteFileSystemWindowsResponse: Equatable {
    /// <p>The ID of the final backup for this file system.</p>
    public let finalBackupId: String?
    /// <p>The set of tags applied to the final backup.</p>
    public let finalBackupTags: [Tag]?

    public init (
        finalBackupId: String? = nil,
        finalBackupTags: [Tag]? = nil
    )
    {
        self.finalBackupId = finalBackupId
        self.finalBackupTags = finalBackupTags
    }
}

public struct DescribeBackupsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeBackupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBackupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBackupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBackupsInput>
    public typealias MOutput = OperationOutput<DescribeBackupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBackupsOutputError>
}

extension DescribeBackupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBackupsInput(backupIds: \(String(describing: backupIds)), filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeBackupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupIds = "BackupIds"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupIds = backupIds {
            var backupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .backupIds)
            for backupids0 in backupIds {
                try backupIdsContainer.encode(backupids0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeBackupsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeBackupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBackupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBackupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBackupsInput>
    public typealias MOutput = OperationOutput<DescribeBackupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBackupsOutputError>
}

public struct DescribeBackupsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeBackupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBackupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBackupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBackupsInput>
    public typealias MOutput = OperationOutput<DescribeBackupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBackupsOutputError>
}

/// <p>The request object for <code>DescribeBackups</code> operation.</p>
public struct DescribeBackupsInput: Equatable {
    /// <p>IDs of the backups you want to retrieve (String). This overrides any
    ///             filters. If any IDs are not found, BackupNotFound will be thrown.</p>
    public let backupIds: [String]?
    /// <p>Filters structure. Supported names are file-system-id and
    ///             backup-type.</p>
    public let filters: [Filter]?
    /// <p>Maximum number of backups to return in the response (integer). This
    ///             parameter value must be greater than 0. The number of items that Amazon FSx returns is
    ///             the minimum of the <code>MaxResults</code> parameter specified in the request and the
    ///             service's internal maximum number of items per page.</p>
    public let maxResults: Int?
    /// <p>Opaque pagination token returned from a previous
    ///                 <code>DescribeBackups</code> operation (String). If a token present, the action
    ///             continues the list from where the returning call left off.</p>
    public let nextToken: String?

    public init (
        backupIds: [String]? = nil,
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.backupIds = backupIds
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeBackupsInputBody: Equatable {
    public let backupIds: [String]?
    public let filters: [Filter]?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeBackupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupIds = "BackupIds"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .backupIds)
        var backupIdsDecoded0:[String]? = nil
        if let backupIdsContainer = backupIdsContainer {
            backupIdsDecoded0 = [String]()
            for string0 in backupIdsContainer {
                if let string0 = string0 {
                    backupIdsDecoded0?.append(string0)
                }
            }
        }
        backupIds = backupIdsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBackupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBackupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BackupNotFound" : self = .backupNotFound(try BackupNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBackupsOutputError: Equatable {
    case backupNotFound(BackupNotFound)
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBackupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBackupsOutputResponse(backups: \(String(describing: backups)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeBackupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeBackupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backups = output.backups
            self.nextToken = output.nextToken
        } else {
            self.backups = nil
            self.nextToken = nil
        }
    }
}

/// <p>Response object for <code>DescribeBackups</code> operation.</p>
public struct DescribeBackupsOutputResponse: Equatable {
    /// <p>An array of backups.</p>
    public let backups: [Backup]?
    /// <p>This is present if there are more backups than returned in the response (String).
    ///             You can use the <code>NextToken</code> value in the later request to fetch the backups.
    ///         </p>
    public let nextToken: String?

    public init (
        backups: [Backup]? = nil,
        nextToken: String? = nil
    )
    {
        self.backups = backups
        self.nextToken = nextToken
    }
}

struct DescribeBackupsOutputResponseBody: Equatable {
    public let backups: [Backup]?
    public let nextToken: String?
}

extension DescribeBackupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backups = "Backups"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupsContainer = try containerValues.decodeIfPresent([Backup?].self, forKey: .backups)
        var backupsDecoded0:[Backup]? = nil
        if let backupsContainer = backupsContainer {
            backupsDecoded0 = [Backup]()
            for structure0 in backupsContainer {
                if let structure0 = structure0 {
                    backupsDecoded0?.append(structure0)
                }
            }
        }
        backups = backupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeDataRepositoryTasksInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDataRepositoryTasksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDataRepositoryTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDataRepositoryTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDataRepositoryTasksInput>
    public typealias MOutput = OperationOutput<DescribeDataRepositoryTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDataRepositoryTasksOutputError>
}

extension DescribeDataRepositoryTasksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDataRepositoryTasksInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), taskIds: \(String(describing: taskIds)))"}
}

extension DescribeDataRepositoryTasksInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case taskIds = "TaskIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for datarepositorytaskfilters0 in filters {
                try filtersContainer.encode(datarepositorytaskfilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let taskIds = taskIds {
            var taskIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .taskIds)
            for taskids0 in taskIds {
                try taskIdsContainer.encode(taskids0)
            }
        }
    }
}

public struct DescribeDataRepositoryTasksInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDataRepositoryTasksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDataRepositoryTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDataRepositoryTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDataRepositoryTasksInput>
    public typealias MOutput = OperationOutput<DescribeDataRepositoryTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDataRepositoryTasksOutputError>
}

public struct DescribeDataRepositoryTasksInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDataRepositoryTasksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDataRepositoryTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDataRepositoryTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDataRepositoryTasksInput>
    public typealias MOutput = OperationOutput<DescribeDataRepositoryTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDataRepositoryTasksOutputError>
}

public struct DescribeDataRepositoryTasksInput: Equatable {
    /// <p>(Optional) You can use filters to narrow the <code>DescribeDataRepositoryTasks</code> response to
    ///             include just tasks for specific file systems, or tasks in a specific lifecycle state.</p>
    public let filters: [DataRepositoryTaskFilter]?
    /// <p>The maximum number of resources to return in the response. This value must be an
    ///             integer greater than zero.</p>
    public let maxResults: Int?
    /// <p>(Optional) Opaque pagination token returned from a previous operation (String). If
    ///             present, this token indicates from what point you can continue processing the request, where
    ///             the previous <code>NextToken</code> value left off.</p>
    public let nextToken: String?
    /// <p>(Optional) IDs of the tasks whose descriptions you want to retrieve
    ///             (String).</p>
    public let taskIds: [String]?

    public init (
        filters: [DataRepositoryTaskFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        taskIds: [String]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.taskIds = taskIds
    }
}

struct DescribeDataRepositoryTasksInputBody: Equatable {
    public let taskIds: [String]?
    public let filters: [DataRepositoryTaskFilter]?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeDataRepositoryTasksInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case taskIds = "TaskIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .taskIds)
        var taskIdsDecoded0:[String]? = nil
        if let taskIdsContainer = taskIdsContainer {
            taskIdsDecoded0 = [String]()
            for string0 in taskIdsContainer {
                if let string0 = string0 {
                    taskIdsDecoded0?.append(string0)
                }
            }
        }
        taskIds = taskIdsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([DataRepositoryTaskFilter?].self, forKey: .filters)
        var filtersDecoded0:[DataRepositoryTaskFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DataRepositoryTaskFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDataRepositoryTasksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDataRepositoryTasksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataRepositoryTaskNotFound" : self = .dataRepositoryTaskNotFound(try DataRepositoryTaskNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDataRepositoryTasksOutputError: Equatable {
    case badRequest(BadRequest)
    case dataRepositoryTaskNotFound(DataRepositoryTaskNotFound)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDataRepositoryTasksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDataRepositoryTasksOutputResponse(dataRepositoryTasks: \(String(describing: dataRepositoryTasks)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeDataRepositoryTasksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDataRepositoryTasksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dataRepositoryTasks = output.dataRepositoryTasks
            self.nextToken = output.nextToken
        } else {
            self.dataRepositoryTasks = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeDataRepositoryTasksOutputResponse: Equatable {
    /// <p>The collection of data repository task descriptions returned.</p>
    public let dataRepositoryTasks: [DataRepositoryTask]?
    /// <p>(Optional) Opaque pagination token returned from a previous operation (String). If
    ///             present, this token indicates from what point you can continue processing the request, where
    ///             the previous <code>NextToken</code> value left off.</p>
    public let nextToken: String?

    public init (
        dataRepositoryTasks: [DataRepositoryTask]? = nil,
        nextToken: String? = nil
    )
    {
        self.dataRepositoryTasks = dataRepositoryTasks
        self.nextToken = nextToken
    }
}

struct DescribeDataRepositoryTasksOutputResponseBody: Equatable {
    public let dataRepositoryTasks: [DataRepositoryTask]?
    public let nextToken: String?
}

extension DescribeDataRepositoryTasksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataRepositoryTasks = "DataRepositoryTasks"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataRepositoryTasksContainer = try containerValues.decodeIfPresent([DataRepositoryTask?].self, forKey: .dataRepositoryTasks)
        var dataRepositoryTasksDecoded0:[DataRepositoryTask]? = nil
        if let dataRepositoryTasksContainer = dataRepositoryTasksContainer {
            dataRepositoryTasksDecoded0 = [DataRepositoryTask]()
            for structure0 in dataRepositoryTasksContainer {
                if let structure0 = structure0 {
                    dataRepositoryTasksDecoded0?.append(structure0)
                }
            }
        }
        dataRepositoryTasks = dataRepositoryTasksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeFileSystemAliasesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeFileSystemAliasesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFileSystemAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFileSystemAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFileSystemAliasesInput>
    public typealias MOutput = OperationOutput<DescribeFileSystemAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFileSystemAliasesOutputError>
}

extension DescribeFileSystemAliasesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFileSystemAliasesInput(clientRequestToken: \(String(describing: clientRequestToken)), fileSystemId: \(String(describing: fileSystemId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeFileSystemAliasesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case fileSystemId = "FileSystemId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeFileSystemAliasesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeFileSystemAliasesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFileSystemAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFileSystemAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFileSystemAliasesInput>
    public typealias MOutput = OperationOutput<DescribeFileSystemAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFileSystemAliasesOutputError>
}

public struct DescribeFileSystemAliasesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeFileSystemAliasesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFileSystemAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFileSystemAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFileSystemAliasesInput>
    public typealias MOutput = OperationOutput<DescribeFileSystemAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFileSystemAliasesOutputError>
}

/// <p>The request object for <code>DescribeFileSystemAliases</code> operation.</p>
public struct DescribeFileSystemAliasesInput: Equatable {
    /// <p>(Optional) An idempotency token for resource creation, in a string of up to 64
    ///             ASCII characters. This token is automatically filled on your behalf when you use the AWS
    ///             Command Line Interface (AWS CLI) or an AWS SDK.</p>
    public var clientRequestToken: String?
    /// <p>The ID of the file system to return the associated DNS aliases for
    ///             (String).</p>
    public let fileSystemId: String?
    /// <p>Maximum number of DNS aliases to return in the response (integer). This
    ///             parameter value must be greater than 0. The number of items that Amazon FSx returns is
    ///             the minimum of the <code>MaxResults</code> parameter specified in the request and the
    ///             service's internal maximum number of items per page.</p>
    public let maxResults: Int?
    /// <p>Opaque pagination token returned from a previous
    ///                 <code>DescribeFileSystemAliases</code> operation (String). If a token is included in the request, the action
    ///             continues the list from where the previous returning call left off.</p>
    public let nextToken: String?

    public init (
        clientRequestToken: String? = nil,
        fileSystemId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.fileSystemId = fileSystemId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeFileSystemAliasesInputBody: Equatable {
    public let clientRequestToken: String?
    public let fileSystemId: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeFileSystemAliasesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case fileSystemId = "FileSystemId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeFileSystemAliasesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFileSystemAliasesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFileSystemAliasesOutputError: Equatable {
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFileSystemAliasesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFileSystemAliasesOutputResponse(aliases: \(String(describing: aliases)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeFileSystemAliasesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeFileSystemAliasesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.aliases = output.aliases
            self.nextToken = output.nextToken
        } else {
            self.aliases = nil
            self.nextToken = nil
        }
    }
}

/// <p>The response object for <code>DescribeFileSystemAliases</code> operation.</p>
public struct DescribeFileSystemAliasesOutputResponse: Equatable {
    /// <p>An array of one or more DNS aliases currently associated with the specified file system.</p>
    public let aliases: [Alias]?
    /// <p>Present if there are more DNS aliases than returned in the response (String). You
    ///             can use the <code>NextToken</code> value in a later request to fetch additional
    ///             descriptions. </p>
    public let nextToken: String?

    public init (
        aliases: [Alias]? = nil,
        nextToken: String? = nil
    )
    {
        self.aliases = aliases
        self.nextToken = nextToken
    }
}

struct DescribeFileSystemAliasesOutputResponseBody: Equatable {
    public let aliases: [Alias]?
    public let nextToken: String?
}

extension DescribeFileSystemAliasesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aliases = "Aliases"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasesContainer = try containerValues.decodeIfPresent([Alias?].self, forKey: .aliases)
        var aliasesDecoded0:[Alias]? = nil
        if let aliasesContainer = aliasesContainer {
            aliasesDecoded0 = [Alias]()
            for structure0 in aliasesContainer {
                if let structure0 = structure0 {
                    aliasesDecoded0?.append(structure0)
                }
            }
        }
        aliases = aliasesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeFileSystemsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeFileSystemsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFileSystemsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFileSystemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFileSystemsInput>
    public typealias MOutput = OperationOutput<DescribeFileSystemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFileSystemsOutputError>
}

extension DescribeFileSystemsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFileSystemsInput(fileSystemIds: \(String(describing: fileSystemIds)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeFileSystemsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fileSystemIds = "FileSystemIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileSystemIds = fileSystemIds {
            var fileSystemIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemIds)
            for filesystemids0 in fileSystemIds {
                try fileSystemIdsContainer.encode(filesystemids0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeFileSystemsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeFileSystemsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFileSystemsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFileSystemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFileSystemsInput>
    public typealias MOutput = OperationOutput<DescribeFileSystemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFileSystemsOutputError>
}

public struct DescribeFileSystemsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeFileSystemsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFileSystemsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFileSystemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFileSystemsInput>
    public typealias MOutput = OperationOutput<DescribeFileSystemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFileSystemsOutputError>
}

/// <p>The request object for <code>DescribeFileSystems</code> operation.</p>
public struct DescribeFileSystemsInput: Equatable {
    /// <p>IDs of the file systems whose descriptions you want to retrieve
    ///             (String).</p>
    public let fileSystemIds: [String]?
    /// <p>Maximum number of file systems to return in the response (integer). This
    ///             parameter value must be greater than 0. The number of items that Amazon FSx returns is
    ///             the minimum of the <code>MaxResults</code> parameter specified in the request and the
    ///             service's internal maximum number of items per page.</p>
    public let maxResults: Int?
    /// <p>Opaque pagination token returned from a previous
    ///                 <code>DescribeFileSystems</code> operation (String). If a token present, the action
    ///             continues the list from where the returning call left off.</p>
    public let nextToken: String?

    public init (
        fileSystemIds: [String]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.fileSystemIds = fileSystemIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeFileSystemsInputBody: Equatable {
    public let fileSystemIds: [String]?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeFileSystemsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileSystemIds = "FileSystemIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .fileSystemIds)
        var fileSystemIdsDecoded0:[String]? = nil
        if let fileSystemIdsContainer = fileSystemIdsContainer {
            fileSystemIdsDecoded0 = [String]()
            for string0 in fileSystemIdsContainer {
                if let string0 = string0 {
                    fileSystemIdsDecoded0?.append(string0)
                }
            }
        }
        fileSystemIds = fileSystemIdsDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeFileSystemsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFileSystemsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFileSystemsOutputError: Equatable {
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFileSystemsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFileSystemsOutputResponse(fileSystems: \(String(describing: fileSystems)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeFileSystemsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeFileSystemsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fileSystems = output.fileSystems
            self.nextToken = output.nextToken
        } else {
            self.fileSystems = nil
            self.nextToken = nil
        }
    }
}

/// <p>The response object for <code>DescribeFileSystems</code> operation.</p>
public struct DescribeFileSystemsOutputResponse: Equatable {
    /// <p>An array of file system descriptions.</p>
    public let fileSystems: [FileSystem]?
    /// <p>Present if there are more file systems than returned in the response (String). You
    ///             can use the <code>NextToken</code> value in the later request to fetch the
    ///             descriptions. </p>
    public let nextToken: String?

    public init (
        fileSystems: [FileSystem]? = nil,
        nextToken: String? = nil
    )
    {
        self.fileSystems = fileSystems
        self.nextToken = nextToken
    }
}

struct DescribeFileSystemsOutputResponseBody: Equatable {
    public let fileSystems: [FileSystem]?
    public let nextToken: String?
}

extension DescribeFileSystemsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileSystems = "FileSystems"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemsContainer = try containerValues.decodeIfPresent([FileSystem?].self, forKey: .fileSystems)
        var fileSystemsDecoded0:[FileSystem]? = nil
        if let fileSystemsContainer = fileSystemsContainer {
            fileSystemsDecoded0 = [FileSystem]()
            for structure0 in fileSystemsContainer {
                if let structure0 = structure0 {
                    fileSystemsDecoded0?.append(structure0)
                }
            }
        }
        fileSystems = fileSystemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DisassociateFileSystemAliasesInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateFileSystemAliasesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateFileSystemAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateFileSystemAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateFileSystemAliasesInput>
    public typealias MOutput = OperationOutput<DisassociateFileSystemAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateFileSystemAliasesOutputError>
}

extension DisassociateFileSystemAliasesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateFileSystemAliasesInput(aliases: \(String(describing: aliases)), clientRequestToken: \(String(describing: clientRequestToken)), fileSystemId: \(String(describing: fileSystemId)))"}
}

extension DisassociateFileSystemAliasesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aliases = "Aliases"
        case clientRequestToken = "ClientRequestToken"
        case fileSystemId = "FileSystemId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliases = aliases {
            var aliasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aliases)
            for alternatednsnames0 in aliases {
                try aliasesContainer.encode(alternatednsnames0)
            }
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
    }
}

public struct DisassociateFileSystemAliasesInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateFileSystemAliasesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateFileSystemAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateFileSystemAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateFileSystemAliasesInput>
    public typealias MOutput = OperationOutput<DisassociateFileSystemAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateFileSystemAliasesOutputError>
}

public struct DisassociateFileSystemAliasesInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateFileSystemAliasesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateFileSystemAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateFileSystemAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateFileSystemAliasesInput>
    public typealias MOutput = OperationOutput<DisassociateFileSystemAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateFileSystemAliasesOutputError>
}

/// <p>The request object of DNS aliases to disassociate from an Amazon FSx for Windows File Server file system.</p>
public struct DisassociateFileSystemAliasesInput: Equatable {
    /// <p>An array of one or more DNS alias names to disassociate, or remove, from the file system.</p>
    public let aliases: [String]?
    /// <p>(Optional) An idempotency token for resource creation, in a string of up to 64
    ///             ASCII characters. This token is automatically filled on your behalf when you use the AWS
    ///             Command Line Interface (AWS CLI) or an AWS SDK.</p>
    public var clientRequestToken: String?
    /// <p>Specifies the file system from which to disassociate the DNS aliases.</p>
    public let fileSystemId: String?

    public init (
        aliases: [String]? = nil,
        clientRequestToken: String? = nil,
        fileSystemId: String? = nil
    )
    {
        self.aliases = aliases
        self.clientRequestToken = clientRequestToken
        self.fileSystemId = fileSystemId
    }
}

struct DisassociateFileSystemAliasesInputBody: Equatable {
    public let clientRequestToken: String?
    public let fileSystemId: String?
    public let aliases: [String]?
}

extension DisassociateFileSystemAliasesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aliases = "Aliases"
        case clientRequestToken = "ClientRequestToken"
        case fileSystemId = "FileSystemId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let aliasesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .aliases)
        var aliasesDecoded0:[String]? = nil
        if let aliasesContainer = aliasesContainer {
            aliasesDecoded0 = [String]()
            for string0 in aliasesContainer {
                if let string0 = string0 {
                    aliasesDecoded0?.append(string0)
                }
            }
        }
        aliases = aliasesDecoded0
    }
}

extension DisassociateFileSystemAliasesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateFileSystemAliasesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateFileSystemAliasesOutputError: Equatable {
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateFileSystemAliasesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateFileSystemAliasesOutputResponse(aliases: \(String(describing: aliases)))"}
}

extension DisassociateFileSystemAliasesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DisassociateFileSystemAliasesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.aliases = output.aliases
        } else {
            self.aliases = nil
        }
    }
}

/// <p>The system generated response showing the DNS aliases that Amazon FSx is attempting to disassociate from the file system.
///         Use the  API operation to monitor the status of the aliases Amazon FSx is removing from the file system.</p>
public struct DisassociateFileSystemAliasesOutputResponse: Equatable {
    /// <p>An array of one or more DNS aliases that Amazon FSx is attempting to disassociate from the file system.</p>
    public let aliases: [Alias]?

    public init (
        aliases: [Alias]? = nil
    )
    {
        self.aliases = aliases
    }
}

struct DisassociateFileSystemAliasesOutputResponseBody: Equatable {
    public let aliases: [Alias]?
}

extension DisassociateFileSystemAliasesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aliases = "Aliases"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasesContainer = try containerValues.decodeIfPresent([Alias?].self, forKey: .aliases)
        var aliasesDecoded0:[Alias]? = nil
        if let aliasesContainer = aliasesContainer {
            aliasesDecoded0 = [Alias]()
            for structure0 in aliasesContainer {
                if let structure0 = structure0 {
                    aliasesDecoded0?.append(structure0)
                }
            }
        }
        aliases = aliasesDecoded0
    }
}

public enum DriveCacheType {
    case `none`
    case read
    case sdkUnknown(String)
}

extension DriveCacheType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DriveCacheType] {
        return [
            .none,
            .read,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .none: return "NONE"
        case .read: return "READ"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DriveCacheType(rawValue: rawValue) ?? DriveCacheType.sdkUnknown(rawValue)
    }
}

extension FileSystem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case administrativeActions = "AdministrativeActions"
        case creationTime = "CreationTime"
        case dNSName = "DNSName"
        case failureDetails = "FailureDetails"
        case fileSystemId = "FileSystemId"
        case fileSystemType = "FileSystemType"
        case kmsKeyId = "KmsKeyId"
        case lifecycle = "Lifecycle"
        case lustreConfiguration = "LustreConfiguration"
        case networkInterfaceIds = "NetworkInterfaceIds"
        case ownerId = "OwnerId"
        case resourceARN = "ResourceARN"
        case storageCapacity = "StorageCapacity"
        case storageType = "StorageType"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
        case vpcId = "VpcId"
        case windowsConfiguration = "WindowsConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let administrativeActions = administrativeActions {
            var administrativeActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .administrativeActions)
            for administrativeactions0 in administrativeActions {
                try administrativeActionsContainer.encode(administrativeactions0)
            }
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let dNSName = dNSName {
            try encodeContainer.encode(dNSName, forKey: .dNSName)
        }
        if let failureDetails = failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let fileSystemType = fileSystemType {
            try encodeContainer.encode(fileSystemType.rawValue, forKey: .fileSystemType)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let lifecycle = lifecycle {
            try encodeContainer.encode(lifecycle.rawValue, forKey: .lifecycle)
        }
        if let lustreConfiguration = lustreConfiguration {
            try encodeContainer.encode(lustreConfiguration, forKey: .lustreConfiguration)
        }
        if let networkInterfaceIds = networkInterfaceIds {
            var networkInterfaceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfaceIds)
            for networkinterfaceids0 in networkInterfaceIds {
                try networkInterfaceIdsContainer.encode(networkinterfaceids0)
            }
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let storageCapacity = storageCapacity {
            try encodeContainer.encode(storageCapacity, forKey: .storageCapacity)
        }
        if let storageType = storageType {
            try encodeContainer.encode(storageType.rawValue, forKey: .storageType)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
        if let windowsConfiguration = windowsConfiguration {
            try encodeContainer.encode(windowsConfiguration, forKey: .windowsConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let fileSystemTypeDecoded = try containerValues.decodeIfPresent(FileSystemType.self, forKey: .fileSystemType)
        fileSystemType = fileSystemTypeDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(FileSystemLifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(FileSystemFailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
        let storageCapacityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .storageCapacity)
        storageCapacity = storageCapacityDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(StorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let networkInterfaceIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .networkInterfaceIds)
        var networkInterfaceIdsDecoded0:[String]? = nil
        if let networkInterfaceIdsContainer = networkInterfaceIdsContainer {
            networkInterfaceIdsDecoded0 = [String]()
            for string0 in networkInterfaceIdsContainer {
                if let string0 = string0 {
                    networkInterfaceIdsDecoded0?.append(string0)
                }
            }
        }
        networkInterfaceIds = networkInterfaceIdsDecoded0
        let dNSNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dNSName)
        dNSName = dNSNameDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let windowsConfigurationDecoded = try containerValues.decodeIfPresent(WindowsFileSystemConfiguration.self, forKey: .windowsConfiguration)
        windowsConfiguration = windowsConfigurationDecoded
        let lustreConfigurationDecoded = try containerValues.decodeIfPresent(LustreFileSystemConfiguration.self, forKey: .lustreConfiguration)
        lustreConfiguration = lustreConfigurationDecoded
        let administrativeActionsContainer = try containerValues.decodeIfPresent([AdministrativeAction?].self, forKey: .administrativeActions)
        var administrativeActionsDecoded0:[AdministrativeAction]? = nil
        if let administrativeActionsContainer = administrativeActionsContainer {
            administrativeActionsDecoded0 = [AdministrativeAction]()
            for structure0 in administrativeActionsContainer {
                if let structure0 = structure0 {
                    administrativeActionsDecoded0?.append(structure0)
                }
            }
        }
        administrativeActions = administrativeActionsDecoded0
    }
}

extension FileSystem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FileSystem(administrativeActions: \(String(describing: administrativeActions)), creationTime: \(String(describing: creationTime)), dNSName: \(String(describing: dNSName)), failureDetails: \(String(describing: failureDetails)), fileSystemId: \(String(describing: fileSystemId)), fileSystemType: \(String(describing: fileSystemType)), kmsKeyId: \(String(describing: kmsKeyId)), lifecycle: \(String(describing: lifecycle)), lustreConfiguration: \(String(describing: lustreConfiguration)), networkInterfaceIds: \(String(describing: networkInterfaceIds)), ownerId: \(String(describing: ownerId)), resourceARN: \(String(describing: resourceARN)), storageCapacity: \(String(describing: storageCapacity)), storageType: \(String(describing: storageType)), subnetIds: \(String(describing: subnetIds)), tags: \(String(describing: tags)), vpcId: \(String(describing: vpcId)), windowsConfiguration: \(String(describing: windowsConfiguration)))"}
}

/// <p>A description of a specific Amazon FSx file system.</p>
public struct FileSystem: Equatable {
    /// <p>A list of administrative actions for the file system that are in process or waiting to be processed.
    ///             Administrative actions describe changes to the Windows file system that you have initiated using the <code>UpdateFileSystem</code> action.
    ///         </p>
    public let administrativeActions: [AdministrativeAction]?
    /// <p>The time that the file system was created, in seconds (since 1970-01-01T00:00:00Z),
    ///             also known as Unix time.</p>
    public let creationTime: Date?
    /// <p>The DNS name for the file system.</p>
    public let dNSName: String?
    /// <p>A structure providing details of any failures that occur when creating the file system
    ///             has failed.</p>
    public let failureDetails: FileSystemFailureDetails?
    /// <p>The system-generated, unique 17-digit ID of the file system.</p>
    public let fileSystemId: String?
    /// <p>The type of Amazon FSx file system, either <code>LUSTRE</code> or <code>WINDOWS</code>.</p>
    public let fileSystemType: FileSystemType?
    /// <p>The ID of the AWS Key Management Service (AWS KMS) key used to encrypt the file system's data
    ///             for Amazon FSx for Windows File Server file systems and persistent Amazon FSx for Lustre file
    ///             systems at rest. In either case, if not specified, the Amazon FSx managed key
    ///             is used. The scratch Amazon FSx for Lustre file systems are always encrypted at rest using
    ///             Amazon FSx managed keys. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html">Encrypt</a>
    ///             in the <i>AWS Key Management Service API Reference</i>.</p>
    public let kmsKeyId: String?
    /// <p>The lifecycle status of the file system, following are the possible values and what they mean:</p>
    ///             <ul>
    ///             <li>
    ///                <p>
    ///                   <code>AVAILABLE</code> - The file system is in a healthy state, and is reachable and available for use.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATING</code> - Amazon FSx is creating the new file system.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETING</code> - Amazon FSx is deleting an existing file system.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code> - An existing file system has experienced an unrecoverable failure.
    ///                     When creating a new file system, Amazon FSx was unable to create the file system.</p>
    ///             </li>
    ///             <li>
    ///                     <p>
    ///                   <code>MISCONFIGURED</code> indicates that the file system is in a failed but recoverable state.</p>
    ///                 </li>
    ///             <li>
    ///                     <p>
    ///                   <code>UPDATING</code> indicates that the file system is undergoing a customer initiated update.</p>
    ///                 </li>
    ///          </ul>
    public let lifecycle: FileSystemLifecycle?
    /// <p>The configuration for the Amazon FSx for Lustre file system.</p>
    public let lustreConfiguration: LustreFileSystemConfiguration?
    /// <p>The IDs of the elastic network interface from which a specific file system is
    ///             accessible. The elastic network interface is automatically created in the same VPC that
    ///             the Amazon FSx file system was created in. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html">Elastic Network
    ///                 Interfaces</a> in the <i>Amazon EC2 User Guide.</i>
    ///          </p>
    ///
    ///         <p>For an Amazon FSx for Windows File Server file system, you can have one network
    ///             interface ID. For an Amazon FSx for Lustre file system, you can have more than
    ///             one.</p>
    public let networkInterfaceIds: [String]?
    /// <p>The AWS account that created the file system. If the file system was created by an AWS
    ///             Identity and Access Management (IAM) user, the AWS account to which the IAM user belongs
    ///             is the owner.</p>
    public let ownerId: String?
    /// <p>The Amazon Resource Name (ARN) for the file system resource.</p>
    public let resourceARN: String?
    /// <p>The storage capacity of the file system in gibibytes (GiB).</p>
    public let storageCapacity: Int?
    /// <p>The storage type of the file system.
    ///             Valid values are <code>SSD</code> and <code>HDD</code>.
    ///             If set to <code>SSD</code>, the file system uses solid state drive storage.
    ///             If set to <code>HDD</code>, the file system uses hard disk drive storage.
    ///         </p>
    public let storageType: StorageType?
    /// <p>Specifies the IDs of the subnets that the file system is accessible from. For Windows <code>MULTI_AZ_1</code>
    ///             file system deployment type, there are two subnet IDs, one for the preferred file server
    ///             and one for the standby file server. The preferred file server subnet identified in the
    ///             <code>PreferredSubnetID</code> property. All other file systems have only one subnet ID.</p>
    ///         <p>For Lustre file systems, and Single-AZ Windows file systems, this is the ID of
    ///             the subnet that contains the endpoint for the file system. For <code>MULTI_AZ_1</code> Windows file systems,
    ///             the endpoint for the file system is available in the <code>PreferredSubnetID</code>.</p>
    public let subnetIds: [String]?
    /// <p>The tags to associate with the file system. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html">Tagging Your
    ///                 Amazon EC2 Resources</a> in the <i>Amazon EC2 User
    ///             Guide</i>.</p>
    public let tags: [Tag]?
    /// <p>The ID of the primary VPC for the file system.</p>
    public let vpcId: String?
    /// <p>The configuration for this Microsoft Windows file system.</p>
    public let windowsConfiguration: WindowsFileSystemConfiguration?

    public init (
        administrativeActions: [AdministrativeAction]? = nil,
        creationTime: Date? = nil,
        dNSName: String? = nil,
        failureDetails: FileSystemFailureDetails? = nil,
        fileSystemId: String? = nil,
        fileSystemType: FileSystemType? = nil,
        kmsKeyId: String? = nil,
        lifecycle: FileSystemLifecycle? = nil,
        lustreConfiguration: LustreFileSystemConfiguration? = nil,
        networkInterfaceIds: [String]? = nil,
        ownerId: String? = nil,
        resourceARN: String? = nil,
        storageCapacity: Int? = nil,
        storageType: StorageType? = nil,
        subnetIds: [String]? = nil,
        tags: [Tag]? = nil,
        vpcId: String? = nil,
        windowsConfiguration: WindowsFileSystemConfiguration? = nil
    )
    {
        self.administrativeActions = administrativeActions
        self.creationTime = creationTime
        self.dNSName = dNSName
        self.failureDetails = failureDetails
        self.fileSystemId = fileSystemId
        self.fileSystemType = fileSystemType
        self.kmsKeyId = kmsKeyId
        self.lifecycle = lifecycle
        self.lustreConfiguration = lustreConfiguration
        self.networkInterfaceIds = networkInterfaceIds
        self.ownerId = ownerId
        self.resourceARN = resourceARN
        self.storageCapacity = storageCapacity
        self.storageType = storageType
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcId = vpcId
        self.windowsConfiguration = windowsConfiguration
    }
}

extension FileSystemFailureDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FileSystemFailureDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FileSystemFailureDetails(message: \(String(describing: message)))"}
}

/// <p>A structure providing details of any failures that occur when creating the file system
///             has failed.</p>
public struct FileSystemFailureDetails: Equatable {
    /// <p>A message describing any failures that occurred during file system creation.</p>
    public let message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

/// <p>The lifecycle status of the file system.</p>
public enum FileSystemLifecycle {
    case available
    case creating
    case deleting
    case failed
    case misconfigured
    case updating
    case sdkUnknown(String)
}

extension FileSystemLifecycle : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FileSystemLifecycle] {
        return [
            .available,
            .creating,
            .deleting,
            .failed,
            .misconfigured,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .misconfigured: return "MISCONFIGURED"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FileSystemLifecycle(rawValue: rawValue) ?? FileSystemLifecycle.sdkUnknown(rawValue)
    }
}

/// <p>An enumeration specifying the currently ongoing maintenance operation.</p>
public enum FileSystemMaintenanceOperation {
    case backingUp
    case patching
    case sdkUnknown(String)
}

extension FileSystemMaintenanceOperation : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FileSystemMaintenanceOperation] {
        return [
            .backingUp,
            .patching,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .backingUp: return "BACKING_UP"
        case .patching: return "PATCHING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FileSystemMaintenanceOperation(rawValue: rawValue) ?? FileSystemMaintenanceOperation.sdkUnknown(rawValue)
    }
}

extension FileSystemNotFound: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FileSystemNotFound(message: \(String(describing: message)))"}
}

extension FileSystemNotFound: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: FileSystemNotFoundBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>No Amazon FSx file systems were found based upon supplied parameters.</p>
public struct FileSystemNotFound: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct FileSystemNotFoundBody: Equatable {
    public let message: String?
}

extension FileSystemNotFoundBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

/// <p>The type of file system.</p>
public enum FileSystemType {
    case lustre
    case windows
    case sdkUnknown(String)
}

extension FileSystemType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FileSystemType] {
        return [
            .lustre,
            .windows,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .lustre: return "LUSTRE"
        case .windows: return "WINDOWS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FileSystemType(rawValue: rawValue) ?? FileSystemType.sdkUnknown(rawValue)
    }
}

extension Filter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(FilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension Filter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Filter(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>A filter used to restrict the results of describe calls. You can use multiple
///             filters to return results that meet all applied filter requirements.</p>
public struct Filter: Equatable {
    /// <p>The name for this filter.</p>
    public let name: FilterName?
    /// <p>The values of the filter. These are all the values for any of the applied
    ///             filters.</p>
    public let values: [String]?

    public init (
        name: FilterName? = nil,
        values: [String]? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

/// <p>The name for a filter.</p>
public enum FilterName {
    case backupType
    case fileSystemId
    case fileSystemType
    case sdkUnknown(String)
}

extension FilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FilterName] {
        return [
            .backupType,
            .fileSystemId,
            .fileSystemType,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .backupType: return "backup-type"
        case .fileSystemId: return "file-system-id"
        case .fileSystemType: return "file-system-type"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FilterName(rawValue: rawValue) ?? FilterName.sdkUnknown(rawValue)
    }
}

extension IncompatibleParameterError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IncompatibleParameterError(message: \(String(describing: message)), parameter: \(String(describing: parameter)))"}
}

extension IncompatibleParameterError: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IncompatibleParameterErrorBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.parameter = output.parameter
        } else {
            self.message = nil
            self.parameter = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The error returned when a second request is received with the same client request
///             token but different parameters settings. A client request token should always uniquely
///             identify a single request.</p>
public struct IncompatibleParameterError: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: String?
    /// <p>A parameter that is incompatible with the earlier request.</p>
    public var parameter: String?

    public init (
        message: String? = nil,
        parameter: String? = nil
    )
    {
        self.message = message
        self.parameter = parameter
    }
}

struct IncompatibleParameterErrorBody: Equatable {
    public let parameter: String?
    public let message: String?
}

extension IncompatibleParameterErrorBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case parameter = "Parameter"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameter)
        parameter = parameterDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IncompatibleRegionForMultiAZ: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IncompatibleRegionForMultiAZ(message: \(String(describing: message)))"}
}

extension IncompatibleRegionForMultiAZ: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IncompatibleRegionForMultiAZBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Amazon FSx doesn't support Multi-AZ Windows File Server
///          copy backup in the destination Region, so the copied backup
///          can't be restored.</p>
public struct IncompatibleRegionForMultiAZ: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IncompatibleRegionForMultiAZBody: Equatable {
    public let message: String?
}

extension IncompatibleRegionForMultiAZBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServerError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerError(message: \(String(describing: message)))"}
}

extension InternalServerError: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerErrorBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A generic error indicating a server-side failure.</p>
public struct InternalServerError: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>A detailed error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorBody: Equatable {
    public let message: String?
}

extension InternalServerErrorBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDestinationKmsKey: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDestinationKmsKey(message: \(String(describing: message)))"}
}

extension InvalidDestinationKmsKey: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidDestinationKmsKeyBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The AWS Key Management Service (AWS KMS) key of the destination
///          backup is invalid.</p>
public struct InvalidDestinationKmsKey: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDestinationKmsKeyBody: Equatable {
    public let message: String?
}

extension InvalidDestinationKmsKeyBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidExportPath: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidExportPath(message: \(String(describing: message)))"}
}

extension InvalidExportPath: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidExportPathBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The path provided for data repository export isn't valid.</p>
public struct InvalidExportPath: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidExportPathBody: Equatable {
    public let message: String?
}

extension InvalidExportPathBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidImportPath: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidImportPath(message: \(String(describing: message)))"}
}

extension InvalidImportPath: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidImportPathBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The path provided for data repository import isn't valid.</p>
public struct InvalidImportPath: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidImportPathBody: Equatable {
    public let message: String?
}

extension InvalidImportPathBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNetworkSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidNetworkSettings(invalidSecurityGroupId: \(String(describing: invalidSecurityGroupId)), invalidSubnetId: \(String(describing: invalidSubnetId)), message: \(String(describing: message)))"}
}

extension InvalidNetworkSettings: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidNetworkSettingsBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.invalidSecurityGroupId = output.invalidSecurityGroupId
            self.invalidSubnetId = output.invalidSubnetId
            self.message = output.message
        } else {
            self.invalidSecurityGroupId = nil
            self.invalidSubnetId = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more network settings specified in the request are invalid.
///                 <code>InvalidVpcId</code> means that the ID passed for the virtual private cloud
///             (VPC) is invalid. <code>InvalidSubnetIds</code> returns the list of IDs for subnets that
///             are either invalid or not part of the VPC specified.
///                 <code>InvalidSecurityGroupIds</code> returns the list of IDs for security groups
///             that are either invalid or not part of the VPC specified.</p>
public struct InvalidNetworkSettings: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The ID of your Amazon EC2 security group. This ID is used to control network access
    ///             to the endpoint that Amazon FSx creates on your behalf in each subnet. For more
    ///             information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-network-security.html">Amazon EC2 Security
    ///                 Groups for Linux Instances</a> in the <i>Amazon EC2 User
    ///             Guide</i>.</p>
    public var invalidSecurityGroupId: String?
    /// <p>The ID for a subnet. A <i>subnet</i> is a range of IP addresses in
    ///             your virtual private cloud (VPC). For more information, see <a href="https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Subnets.html">VPC and Subnets</a> in the
    ///                 <i>Amazon VPC User Guide.</i>
    ///          </p>
    public var invalidSubnetId: String?
    /// <p>A detailed error message.</p>
    public var message: String?

    public init (
        invalidSecurityGroupId: String? = nil,
        invalidSubnetId: String? = nil,
        message: String? = nil
    )
    {
        self.invalidSecurityGroupId = invalidSecurityGroupId
        self.invalidSubnetId = invalidSubnetId
        self.message = message
    }
}

struct InvalidNetworkSettingsBody: Equatable {
    public let message: String?
    public let invalidSubnetId: String?
    public let invalidSecurityGroupId: String?
}

extension InvalidNetworkSettingsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case invalidSecurityGroupId = "InvalidSecurityGroupId"
        case invalidSubnetId = "InvalidSubnetId"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let invalidSubnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invalidSubnetId)
        invalidSubnetId = invalidSubnetIdDecoded
        let invalidSecurityGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invalidSecurityGroupId)
        invalidSecurityGroupId = invalidSecurityGroupIdDecoded
    }
}

extension InvalidPerUnitStorageThroughput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidPerUnitStorageThroughput(message: \(String(describing: message)))"}
}

extension InvalidPerUnitStorageThroughput: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidPerUnitStorageThroughputBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An invalid value for <code>PerUnitStorageThroughput</code> was provided. Please create your file system again, using a valid value.</p>
public struct InvalidPerUnitStorageThroughput: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPerUnitStorageThroughputBody: Equatable {
    public let message: String?
}

extension InvalidPerUnitStorageThroughputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRegion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRegion(message: \(String(describing: message)))"}
}

extension InvalidRegion: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRegionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Region provided for <code>Source Region</code> is invalid or
///          is in a different AWS partition.</p>
public struct InvalidRegion: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRegionBody: Equatable {
    public let message: String?
}

extension InvalidRegionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSourceKmsKey: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSourceKmsKey(message: \(String(describing: message)))"}
}

extension InvalidSourceKmsKey: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidSourceKmsKeyBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The AWS Key Management Service (AWS KMS) key of the source backup
///          is invalid.</p>
public struct InvalidSourceKmsKey: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSourceKmsKeyBody: Equatable {
    public let message: String?
}

extension InvalidSourceKmsKeyBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceARN: \(String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

/// <p>The request object for <code>ListTagsForResource</code> operation.</p>
public struct ListTagsForResourceInput: Equatable {
    /// <p>Maximum number of tags to return in the response (integer). This
    ///             parameter value must be greater than 0. The number of items that Amazon FSx returns is
    ///             the minimum of the <code>MaxResults</code> parameter specified in the request and the
    ///             service's internal maximum number of items per page.</p>
    public let maxResults: Int?
    /// <p>Opaque pagination token returned from a previous
    ///                 <code>ListTagsForResource</code> operation (String). If a token present, the action
    ///             continues the list from where the returning call left off.</p>
    public let nextToken: String?
    /// <p>The ARN of the Amazon FSx resource that will have its tags listed.</p>
    public let resourceARN: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceARN: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceARN: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotServiceResourceError" : self = .notServiceResourceError(try NotServiceResourceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDoesNotSupportTagging" : self = .resourceDoesNotSupportTagging(try ResourceDoesNotSupportTagging(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFound(try ResourceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case badRequest(BadRequest)
    case internalServerError(InternalServerError)
    case notServiceResourceError(NotServiceResourceError)
    case resourceDoesNotSupportTagging(ResourceDoesNotSupportTagging)
    case resourceNotFound(ResourceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

/// <p>The response object for <code>ListTagsForResource</code> operation.</p>
public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>This is present if there are more tags than returned in the response (String). You
    ///             can use the <code>NextToken</code> value in the later request to fetch the tags.
    ///         </p>
    public let nextToken: String?
    /// <p>A list of tags on the resource.</p>
    public let tags: [Tag]?

    public init (
        nextToken: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
    public let nextToken: String?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public enum LustreDeploymentType {
    case persistent1
    case scratch1
    case scratch2
    case sdkUnknown(String)
}

extension LustreDeploymentType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LustreDeploymentType] {
        return [
            .persistent1,
            .scratch1,
            .scratch2,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .persistent1: return "PERSISTENT_1"
        case .scratch1: return "SCRATCH_1"
        case .scratch2: return "SCRATCH_2"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LustreDeploymentType(rawValue: rawValue) ?? LustreDeploymentType.sdkUnknown(rawValue)
    }
}

extension LustreFileSystemConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case automaticBackupRetentionDays = "AutomaticBackupRetentionDays"
        case copyTagsToBackups = "CopyTagsToBackups"
        case dailyAutomaticBackupStartTime = "DailyAutomaticBackupStartTime"
        case dataCompressionType = "DataCompressionType"
        case dataRepositoryConfiguration = "DataRepositoryConfiguration"
        case deploymentType = "DeploymentType"
        case driveCacheType = "DriveCacheType"
        case mountName = "MountName"
        case perUnitStorageThroughput = "PerUnitStorageThroughput"
        case weeklyMaintenanceStartTime = "WeeklyMaintenanceStartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automaticBackupRetentionDays = automaticBackupRetentionDays {
            try encodeContainer.encode(automaticBackupRetentionDays, forKey: .automaticBackupRetentionDays)
        }
        if let copyTagsToBackups = copyTagsToBackups {
            try encodeContainer.encode(copyTagsToBackups, forKey: .copyTagsToBackups)
        }
        if let dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTime {
            try encodeContainer.encode(dailyAutomaticBackupStartTime, forKey: .dailyAutomaticBackupStartTime)
        }
        if let dataCompressionType = dataCompressionType {
            try encodeContainer.encode(dataCompressionType.rawValue, forKey: .dataCompressionType)
        }
        if let dataRepositoryConfiguration = dataRepositoryConfiguration {
            try encodeContainer.encode(dataRepositoryConfiguration, forKey: .dataRepositoryConfiguration)
        }
        if let deploymentType = deploymentType {
            try encodeContainer.encode(deploymentType.rawValue, forKey: .deploymentType)
        }
        if let driveCacheType = driveCacheType {
            try encodeContainer.encode(driveCacheType.rawValue, forKey: .driveCacheType)
        }
        if let mountName = mountName {
            try encodeContainer.encode(mountName, forKey: .mountName)
        }
        if let perUnitStorageThroughput = perUnitStorageThroughput {
            try encodeContainer.encode(perUnitStorageThroughput, forKey: .perUnitStorageThroughput)
        }
        if let weeklyMaintenanceStartTime = weeklyMaintenanceStartTime {
            try encodeContainer.encode(weeklyMaintenanceStartTime, forKey: .weeklyMaintenanceStartTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let weeklyMaintenanceStartTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .weeklyMaintenanceStartTime)
        weeklyMaintenanceStartTime = weeklyMaintenanceStartTimeDecoded
        let dataRepositoryConfigurationDecoded = try containerValues.decodeIfPresent(DataRepositoryConfiguration.self, forKey: .dataRepositoryConfiguration)
        dataRepositoryConfiguration = dataRepositoryConfigurationDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(LustreDeploymentType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let perUnitStorageThroughputDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .perUnitStorageThroughput)
        perUnitStorageThroughput = perUnitStorageThroughputDecoded
        let mountNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mountName)
        mountName = mountNameDecoded
        let dailyAutomaticBackupStartTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dailyAutomaticBackupStartTime)
        dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTimeDecoded
        let automaticBackupRetentionDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .automaticBackupRetentionDays)
        automaticBackupRetentionDays = automaticBackupRetentionDaysDecoded
        let copyTagsToBackupsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .copyTagsToBackups)
        copyTagsToBackups = copyTagsToBackupsDecoded
        let driveCacheTypeDecoded = try containerValues.decodeIfPresent(DriveCacheType.self, forKey: .driveCacheType)
        driveCacheType = driveCacheTypeDecoded
        let dataCompressionTypeDecoded = try containerValues.decodeIfPresent(DataCompressionType.self, forKey: .dataCompressionType)
        dataCompressionType = dataCompressionTypeDecoded
    }
}

extension LustreFileSystemConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LustreFileSystemConfiguration(automaticBackupRetentionDays: \(String(describing: automaticBackupRetentionDays)), copyTagsToBackups: \(String(describing: copyTagsToBackups)), dailyAutomaticBackupStartTime: \(String(describing: dailyAutomaticBackupStartTime)), dataCompressionType: \(String(describing: dataCompressionType)), dataRepositoryConfiguration: \(String(describing: dataRepositoryConfiguration)), deploymentType: \(String(describing: deploymentType)), driveCacheType: \(String(describing: driveCacheType)), mountName: \(String(describing: mountName)), perUnitStorageThroughput: \(String(describing: perUnitStorageThroughput)), weeklyMaintenanceStartTime: \(String(describing: weeklyMaintenanceStartTime)))"}
}

/// <p>The configuration for the Amazon FSx for Lustre file system.</p>
public struct LustreFileSystemConfiguration: Equatable {
    /// <p>The number of days to retain automatic backups. Setting this to 0 disables
    ///             automatic backups. You can retain automatic backups for a maximum of 90 days. The default is 0.</p>
    public let automaticBackupRetentionDays: Int?
    /// <p>A boolean flag indicating whether tags on the file system should be copied to backups.
    ///             If it's set to true, all tags on the file system are
    ///             copied to all automatic backups and any user-initiated backups where the user
    ///             doesn't specify any tags. If this value is true, and you specify one or more tags,
    ///             only the specified tags are copied to backups. If you specify one or more tags when
    ///             creating a user-initiated backup, no tags are copied from the file system,
    ///             regardless of this value. (Default = false)</p>
    public let copyTagsToBackups: Bool?
    /// <p>A recurring daily time, in the format <code>HH:MM</code>. <code>HH</code> is the
    ///             zero-padded hour of the day (0-23), and <code>MM</code> is the zero-padded minute of the
    ///             hour. For example, <code>05:00</code> specifies 5 AM daily. </p>
    public let dailyAutomaticBackupStartTime: String?
    /// <p>The data compression configuration for the file system. <code>DataCompressionType</code>
    ///             can have the following values:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>NONE</code> - Data compression is turned off for
    ///                 the file system.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LZ4</code> - Data compression is turned on with the LZ4
    ///                 algorithm.</p>
    ///             </li>
    ///          </ul>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/data-compression.html">Lustre data compression</a>.</p>
    public let dataCompressionType: DataCompressionType?
    /// <p>The data repository configuration object for Lustre file systems returned in the response of
    ///             the <code>CreateFileSystem</code> operation.</p>
    public let dataRepositoryConfiguration: DataRepositoryConfiguration?
    /// <p>The deployment type of the FSX for Lustre file system. <i>Scratch deployment type</i> is designed for temporary storage
    ///             and shorter-term processing of data.</p>
    ///         <p>
    ///             <code>SCRATCH_1</code> and <code>SCRATCH_2</code> deployment
    ///         types are best suited for when you need temporary storage and shorter-term processing of data.
    ///         The <code>SCRATCH_2</code> deployment type provides in-transit encryption of data and higher burst
    ///         throughput capacity than <code>SCRATCH_1</code>.</p>
    ///         <p>The <code>PERSISTENT_1</code> deployment type is used for longer-term storage
    ///             and workloads and encryption of data in transit. To learn more about deployment types, see
    ///             <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/lustre-deployment-types.html">
    ///                 FSx for Lustre Deployment Options</a>. (Default = <code>SCRATCH_1</code>)</p>
    public let deploymentType: LustreDeploymentType?
    /// <p>The type of drive cache used by PERSISTENT_1 file systems that are provisioned with
    ///             HDD storage devices. This parameter is required when storage type is HDD. Set to
    ///             <code>READ</code>, improve the performance for frequently accessed files and allows 20%
    ///             of the total storage capacity of the file system to be cached.  </p>
    ///         <p>This parameter is required when <code>StorageType</code> is set to HDD.</p>
    public let driveCacheType: DriveCacheType?
    /// <p>You use the <code>MountName</code> value when mounting the file system.</p>
    ///         <p>For the <code>SCRATCH_1</code> deployment type, this value is always "<code>fsx</code>".
    ///             For <code>SCRATCH_2</code> and <code>PERSISTENT_1</code> deployment types, this
    ///             value is a string that is unique within an AWS Region.
    ///
    ///         </p>
    public let mountName: String?
    /// <p> Per unit storage throughput represents the megabytes per second of read or write
    ///             throughput per 1 tebibyte of storage provisioned. File system throughput capacity is
    ///             equal to Storage capacity (TiB) * PerUnitStorageThroughput (MB/s/TiB). This option is
    ///             only valid for <code>PERSISTENT_1</code> deployment types. </p>
    ///         <p>Valid values for SSD storage: 50, 100, 200. Valid values for HDD storage: 12, 40. </p>
    public let perUnitStorageThroughput: Int?
    /// <p>The preferred start time to perform weekly maintenance, formatted d:HH:MM in the UTC
    ///             time zone. d is the weekday number, from 1 through 7, beginning with Monday and ending with Sunday.</p>
    public let weeklyMaintenanceStartTime: String?

    public init (
        automaticBackupRetentionDays: Int? = nil,
        copyTagsToBackups: Bool? = nil,
        dailyAutomaticBackupStartTime: String? = nil,
        dataCompressionType: DataCompressionType? = nil,
        dataRepositoryConfiguration: DataRepositoryConfiguration? = nil,
        deploymentType: LustreDeploymentType? = nil,
        driveCacheType: DriveCacheType? = nil,
        mountName: String? = nil,
        perUnitStorageThroughput: Int? = nil,
        weeklyMaintenanceStartTime: String? = nil
    )
    {
        self.automaticBackupRetentionDays = automaticBackupRetentionDays
        self.copyTagsToBackups = copyTagsToBackups
        self.dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTime
        self.dataCompressionType = dataCompressionType
        self.dataRepositoryConfiguration = dataRepositoryConfiguration
        self.deploymentType = deploymentType
        self.driveCacheType = driveCacheType
        self.mountName = mountName
        self.perUnitStorageThroughput = perUnitStorageThroughput
        self.weeklyMaintenanceStartTime = weeklyMaintenanceStartTime
    }
}

extension MissingFileSystemConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MissingFileSystemConfiguration(message: \(String(describing: message)))"}
}

extension MissingFileSystemConfiguration: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MissingFileSystemConfigurationBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A file system configuration is required for this operation.</p>
public struct MissingFileSystemConfiguration: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MissingFileSystemConfigurationBody: Equatable {
    public let message: String?
}

extension MissingFileSystemConfigurationBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotServiceResourceError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotServiceResourceError(message: \(String(describing: message)), resourceARN: \(String(describing: resourceARN)))"}
}

extension NotServiceResourceError: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotServiceResourceErrorBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceARN = output.resourceARN
        } else {
            self.message = nil
            self.resourceARN = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource specified for the tagging operation is not a resource type owned by
///             Amazon FSx. Use the API of the relevant service to perform the operation. </p>
public struct NotServiceResourceError: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: String?
    /// <p>The Amazon Resource Name (ARN) of the non-Amazon FSx resource.</p>
    public var resourceARN: String?

    public init (
        message: String? = nil,
        resourceARN: String? = nil
    )
    {
        self.message = message
        self.resourceARN = resourceARN
    }
}

struct NotServiceResourceErrorBody: Equatable {
    public let resourceARN: String?
    public let message: String?
}

extension NotServiceResourceErrorBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ReportFormat {
    case reportCsv20191124
    case sdkUnknown(String)
}

extension ReportFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReportFormat] {
        return [
            .reportCsv20191124,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .reportCsv20191124: return "REPORT_CSV_20191124"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReportFormat(rawValue: rawValue) ?? ReportFormat.sdkUnknown(rawValue)
    }
}

public enum ReportScope {
    case failedFilesOnly
    case sdkUnknown(String)
}

extension ReportScope : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReportScope] {
        return [
            .failedFilesOnly,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failedFilesOnly: return "FAILED_FILES_ONLY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReportScope(rawValue: rawValue) ?? ReportScope.sdkUnknown(rawValue)
    }
}

extension ResourceDoesNotSupportTagging: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceDoesNotSupportTagging(message: \(String(describing: message)), resourceARN: \(String(describing: resourceARN)))"}
}

extension ResourceDoesNotSupportTagging: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceDoesNotSupportTaggingBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceARN = output.resourceARN
        } else {
            self.message = nil
            self.resourceARN = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource specified does not support tagging. </p>
public struct ResourceDoesNotSupportTagging: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: String?
    /// <p>The Amazon Resource Name (ARN) of the resource that doesn't support
    ///             tagging.</p>
    public var resourceARN: String?

    public init (
        message: String? = nil,
        resourceARN: String? = nil
    )
    {
        self.message = message
        self.resourceARN = resourceARN
    }
}

struct ResourceDoesNotSupportTaggingBody: Equatable {
    public let resourceARN: String?
    public let message: String?
}

extension ResourceDoesNotSupportTaggingBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFound: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFound(message: \(String(describing: message)), resourceARN: \(String(describing: resourceARN)))"}
}

extension ResourceNotFound: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceARN = output.resourceARN
        } else {
            self.message = nil
            self.resourceARN = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource specified by the Amazon Resource Name (ARN) can't be found.</p>
public struct ResourceNotFound: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: String?
    /// <p>The resource ARN of the resource that can't be found.</p>
    public var resourceARN: String?

    public init (
        message: String? = nil,
        resourceARN: String? = nil
    )
    {
        self.message = message
        self.resourceARN = resourceARN
    }
}

struct ResourceNotFoundBody: Equatable {
    public let resourceARN: String?
    public let message: String?
}

extension ResourceNotFoundBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SelfManagedActiveDirectoryAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dnsIps = "DnsIps"
        case domainName = "DomainName"
        case fileSystemAdministratorsGroup = "FileSystemAdministratorsGroup"
        case organizationalUnitDistinguishedName = "OrganizationalUnitDistinguishedName"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnsIps = dnsIps {
            var dnsIpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsIps)
            for dnsips0 in dnsIps {
                try dnsIpsContainer.encode(dnsips0)
            }
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fileSystemAdministratorsGroup = fileSystemAdministratorsGroup {
            try encodeContainer.encode(fileSystemAdministratorsGroup, forKey: .fileSystemAdministratorsGroup)
        }
        if let organizationalUnitDistinguishedName = organizationalUnitDistinguishedName {
            try encodeContainer.encode(organizationalUnitDistinguishedName, forKey: .organizationalUnitDistinguishedName)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let organizationalUnitDistinguishedNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationalUnitDistinguishedName)
        organizationalUnitDistinguishedName = organizationalUnitDistinguishedNameDecoded
        let fileSystemAdministratorsGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemAdministratorsGroup)
        fileSystemAdministratorsGroup = fileSystemAdministratorsGroupDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let dnsIpsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .dnsIps)
        var dnsIpsDecoded0:[String]? = nil
        if let dnsIpsContainer = dnsIpsContainer {
            dnsIpsDecoded0 = [String]()
            for string0 in dnsIpsContainer {
                if let string0 = string0 {
                    dnsIpsDecoded0?.append(string0)
                }
            }
        }
        dnsIps = dnsIpsDecoded0
    }
}

extension SelfManagedActiveDirectoryAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SelfManagedActiveDirectoryAttributes(dnsIps: \(String(describing: dnsIps)), domainName: \(String(describing: domainName)), fileSystemAdministratorsGroup: \(String(describing: fileSystemAdministratorsGroup)), organizationalUnitDistinguishedName: \(String(describing: organizationalUnitDistinguishedName)), userName: \(String(describing: userName)))"}
}

/// <p>The configuration of the self-managed Microsoft Active Directory (AD) directory to
///             which the Windows File Server instance is joined.</p>
public struct SelfManagedActiveDirectoryAttributes: Equatable {
    /// <p>A list of up to two IP addresses of DNS servers or domain controllers in the
    ///             self-managed AD directory.</p>
    public let dnsIps: [String]?
    /// <p>The fully qualified domain name of the self-managed AD directory.</p>
    public let domainName: String?
    /// <p>The name of the domain group whose members have administrative privileges for the FSx
    ///             file system.</p>
    public let fileSystemAdministratorsGroup: String?
    /// <p>The fully qualified distinguished name of the organizational unit within the
    ///             self-managed AD directory to which the Windows File Server instance is joined.</p>
    public let organizationalUnitDistinguishedName: String?
    /// <p>The user name for the service account on your self-managed AD domain that FSx uses to
    ///             join to your AD domain.</p>
    public let userName: String?

    public init (
        dnsIps: [String]? = nil,
        domainName: String? = nil,
        fileSystemAdministratorsGroup: String? = nil,
        organizationalUnitDistinguishedName: String? = nil,
        userName: String? = nil
    )
    {
        self.dnsIps = dnsIps
        self.domainName = domainName
        self.fileSystemAdministratorsGroup = fileSystemAdministratorsGroup
        self.organizationalUnitDistinguishedName = organizationalUnitDistinguishedName
        self.userName = userName
    }
}

extension SelfManagedActiveDirectoryConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dnsIps = "DnsIps"
        case domainName = "DomainName"
        case fileSystemAdministratorsGroup = "FileSystemAdministratorsGroup"
        case organizationalUnitDistinguishedName = "OrganizationalUnitDistinguishedName"
        case password = "Password"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnsIps = dnsIps {
            var dnsIpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsIps)
            for dnsips0 in dnsIps {
                try dnsIpsContainer.encode(dnsips0)
            }
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fileSystemAdministratorsGroup = fileSystemAdministratorsGroup {
            try encodeContainer.encode(fileSystemAdministratorsGroup, forKey: .fileSystemAdministratorsGroup)
        }
        if let organizationalUnitDistinguishedName = organizationalUnitDistinguishedName {
            try encodeContainer.encode(organizationalUnitDistinguishedName, forKey: .organizationalUnitDistinguishedName)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let organizationalUnitDistinguishedNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationalUnitDistinguishedName)
        organizationalUnitDistinguishedName = organizationalUnitDistinguishedNameDecoded
        let fileSystemAdministratorsGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemAdministratorsGroup)
        fileSystemAdministratorsGroup = fileSystemAdministratorsGroupDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let dnsIpsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .dnsIps)
        var dnsIpsDecoded0:[String]? = nil
        if let dnsIpsContainer = dnsIpsContainer {
            dnsIpsDecoded0 = [String]()
            for string0 in dnsIpsContainer {
                if let string0 = string0 {
                    dnsIpsDecoded0?.append(string0)
                }
            }
        }
        dnsIps = dnsIpsDecoded0
    }
}

extension SelfManagedActiveDirectoryConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SelfManagedActiveDirectoryConfiguration(dnsIps: \(String(describing: dnsIps)), domainName: \(String(describing: domainName)), fileSystemAdministratorsGroup: \(String(describing: fileSystemAdministratorsGroup)), organizationalUnitDistinguishedName: \(String(describing: organizationalUnitDistinguishedName)), password: \(String(describing: password)), userName: \(String(describing: userName)))"}
}

/// <p>The configuration that Amazon FSx uses to join the Windows File Server instance to
///             your self-managed (including on-premises) Microsoft Active Directory (AD)
///             directory. For more information, see
///             <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/self-managed-AD.html">
///                 Using Amazon FSx with your self-managed Microsoft Active Directory</a>.</p>
public struct SelfManagedActiveDirectoryConfiguration: Equatable {
    /// <p>A list of up to two IP addresses of DNS servers or domain controllers in the
    ///             self-managed AD directory. </p>
    public let dnsIps: [String]?
    /// <p>The fully qualified domain name of the self-managed AD directory, such as
    ///                 <code>corp.example.com</code>.</p>
    public let domainName: String?
    /// <p>(Optional) The name of the domain group whose members are granted administrative
    ///             privileges for the file system. Administrative privileges include taking ownership of
    ///             files and folders, setting audit controls (audit ACLs) on files and folders, and
    ///                 administering the file system remotely by using the FSx Remote PowerShell.
    ///             The group that you specify must already exist in your domain. If you don't provide one,
    ///             your AD domain's Domain Admins group is used.</p>
    public let fileSystemAdministratorsGroup: String?
    /// <p>(Optional) The fully qualified distinguished name of the organizational unit within
    ///             your self-managed AD directory that the Windows File Server instance will join. Amazon
    ///             FSx only accepts OU as the direct parent of the file system. An example is
    ///                 <code>OU=FSx,DC=yourdomain,DC=corp,DC=com</code>. To learn more, see <a href="https://tools.ietf.org/html/rfc2253">RFC 2253</a>. If none is provided, the
    ///             FSx file system is created in the default location of your self-managed AD directory. </p>
    ///         <important>
    ///             <p>Only Organizational Unit (OU) objects can be the direct parent of the file system
    ///                 that you're creating.</p>
    ///         </important>
    public let organizationalUnitDistinguishedName: String?
    /// <p>The password for the service account on your self-managed AD domain that Amazon FSx
    ///             will use to join to your AD domain.</p>
    public let password: String?
    /// <p>The user name for the service account on your self-managed AD domain that Amazon FSx
    ///             will use to join to your AD domain. This account must have the permission to join
    ///             computers to the domain in the organizational unit provided in
    ///                 <code>OrganizationalUnitDistinguishedName</code>, or in the default location of your
    ///             AD domain.</p>
    public let userName: String?

    public init (
        dnsIps: [String]? = nil,
        domainName: String? = nil,
        fileSystemAdministratorsGroup: String? = nil,
        organizationalUnitDistinguishedName: String? = nil,
        password: String? = nil,
        userName: String? = nil
    )
    {
        self.dnsIps = dnsIps
        self.domainName = domainName
        self.fileSystemAdministratorsGroup = fileSystemAdministratorsGroup
        self.organizationalUnitDistinguishedName = organizationalUnitDistinguishedName
        self.password = password
        self.userName = userName
    }
}

extension SelfManagedActiveDirectoryConfigurationUpdates: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dnsIps = "DnsIps"
        case password = "Password"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnsIps = dnsIps {
            var dnsIpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsIps)
            for dnsips0 in dnsIps {
                try dnsIpsContainer.encode(dnsips0)
            }
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let dnsIpsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .dnsIps)
        var dnsIpsDecoded0:[String]? = nil
        if let dnsIpsContainer = dnsIpsContainer {
            dnsIpsDecoded0 = [String]()
            for string0 in dnsIpsContainer {
                if let string0 = string0 {
                    dnsIpsDecoded0?.append(string0)
                }
            }
        }
        dnsIps = dnsIpsDecoded0
    }
}

extension SelfManagedActiveDirectoryConfigurationUpdates: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SelfManagedActiveDirectoryConfigurationUpdates(dnsIps: \(String(describing: dnsIps)), password: \(String(describing: password)), userName: \(String(describing: userName)))"}
}

/// <p>The configuration that Amazon FSx uses to join the Windows File Server instance to a
///             self-managed Microsoft Active Directory (AD) directory.</p>
public struct SelfManagedActiveDirectoryConfigurationUpdates: Equatable {
    /// <p>A list of up to two IP addresses of DNS servers or domain controllers in the
    ///             self-managed AD directory.</p>
    public let dnsIps: [String]?
    /// <p>The password for the service account on your self-managed AD domain that Amazon FSx will use to join to
    ///             your AD domain.</p>
    public let password: String?
    /// <p>The user name for the service account on your self-managed AD domain that Amazon FSx will use to join to
    ///             your AD domain. This account must have the permission to join
    ///             computers to the domain in the organizational unit provided in
    ///             <code>OrganizationalUnitDistinguishedName</code>.</p>
    public let userName: String?

    public init (
        dnsIps: [String]? = nil,
        password: String? = nil,
        userName: String? = nil
    )
    {
        self.dnsIps = dnsIps
        self.password = password
        self.userName = userName
    }
}

/// <p>The types of limits on your service utilization. Limits include file system count,
///             total throughput capacity, total storage, and total user-initiated backups. These limits
///             apply for a specific account in a specific AWS Region. You can increase some of them by
///             contacting AWS Support. </p>
public enum ServiceLimit {
    case fileSystemCount
    case totalInProgressCopyBackups
    case totalStorage
    case totalThroughputCapacity
    case totalUserInitiatedBackups
    case totalUserTags
    case sdkUnknown(String)
}

extension ServiceLimit : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ServiceLimit] {
        return [
            .fileSystemCount,
            .totalInProgressCopyBackups,
            .totalStorage,
            .totalThroughputCapacity,
            .totalUserInitiatedBackups,
            .totalUserTags,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .fileSystemCount: return "FILE_SYSTEM_COUNT"
        case .totalInProgressCopyBackups: return "TOTAL_IN_PROGRESS_COPY_BACKUPS"
        case .totalStorage: return "TOTAL_STORAGE"
        case .totalThroughputCapacity: return "TOTAL_THROUGHPUT_CAPACITY"
        case .totalUserInitiatedBackups: return "TOTAL_USER_INITIATED_BACKUPS"
        case .totalUserTags: return "TOTAL_USER_TAGS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ServiceLimit(rawValue: rawValue) ?? ServiceLimit.sdkUnknown(rawValue)
    }
}

extension ServiceLimitExceeded: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceLimitExceeded(limit: \(String(describing: limit)), message: \(String(describing: message)))"}
}

extension ServiceLimitExceeded: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceLimitExceededBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.limit = output.limit
            self.message = output.message
        } else {
            self.limit = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An error indicating that a particular service limit was exceeded. You can increase
///             some service limits by contacting AWS Support.
///             </p>
public struct ServiceLimitExceeded: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Enumeration of the service limit that was exceeded. </p>
    public var limit: ServiceLimit?
    /// <p>A detailed error message.</p>
    public var message: String?

    public init (
        limit: ServiceLimit? = nil,
        message: String? = nil
    )
    {
        self.limit = limit
        self.message = message
    }
}

struct ServiceLimitExceededBody: Equatable {
    public let limit: ServiceLimit?
    public let message: String?
}

extension ServiceLimitExceededBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitDecoded = try containerValues.decodeIfPresent(ServiceLimit.self, forKey: .limit)
        limit = limitDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SourceBackupUnavailable: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceBackupUnavailable(backupId: \(String(describing: backupId)), message: \(String(describing: message)))"}
}

extension SourceBackupUnavailable: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SourceBackupUnavailableBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backupId = output.backupId
            self.message = output.message
        } else {
            self.backupId = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the lifecycle status of the
///          source backup is not <code>AVAILABLE</code>.</p>
public struct SourceBackupUnavailable: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The ID of the source backup. Specifies the backup you are copying.</p>
    public var backupId: String?
    /// <p>A detailed error message.</p>
    public var message: String?

    public init (
        backupId: String? = nil,
        message: String? = nil
    )
    {
        self.backupId = backupId
        self.message = message
    }
}

struct SourceBackupUnavailableBody: Equatable {
    public let message: String?
    public let backupId: String?
}

extension SourceBackupUnavailableBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupId = "BackupId"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let backupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupId)
        backupId = backupIdDecoded
    }
}

public enum Status {
    case completed
    case failed
    case inProgress
    case pending
    case updatedOptimizing
    case sdkUnknown(String)
}

extension Status : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Status] {
        return [
            .completed,
            .failed,
            .inProgress,
            .pending,
            .updatedOptimizing,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "COMPLETED"
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .pending: return "PENDING"
        case .updatedOptimizing: return "UPDATED_OPTIMIZING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
    }
}

/// <p>The storage type for your Amazon FSx file system.</p>
public enum StorageType {
    case hdd
    case ssd
    case sdkUnknown(String)
}

extension StorageType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StorageType] {
        return [
            .hdd,
            .ssd,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .hdd: return "HDD"
        case .ssd: return "SSD"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StorageType(rawValue: rawValue) ?? StorageType.sdkUnknown(rawValue)
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Specifies a key-value pair for a resource tag.</p>
public struct Tag: Equatable {
    /// <p>A value that specifies the <code>TagKey</code>, the name of the tag. Tag keys must
    ///             be unique for the resource to which they are attached.</p>
    public let key: String?
    /// <p>A value that specifies the <code>TagValue</code>, the value assigned to the
    ///             corresponding tag key. Tag values can be null and don't have to be unique in a tag set.
    ///             For example, you can have a key-value pair in a tag set of <code>finances : April</code>
    ///             and also of <code>payroll : April</code>.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceARN: \(String(describing: resourceARN)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

/// <p>The request object for the <code>TagResource</code> operation.</p>
public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Amazon FSx resource that you want to
    ///             tag.</p>
    public let resourceARN: String?
    /// <p>A list of tags for the resource. If a tag with a given key already exists, the
    ///             value is replaced by the one specified in this parameter.</p>
    public let tags: [Tag]?

    public init (
        resourceARN: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotServiceResourceError" : self = .notServiceResourceError(try NotServiceResourceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDoesNotSupportTagging" : self = .resourceDoesNotSupportTagging(try ResourceDoesNotSupportTagging(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFound(try ResourceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case badRequest(BadRequest)
    case internalServerError(InternalServerError)
    case notServiceResourceError(NotServiceResourceError)
    case resourceDoesNotSupportTagging(ResourceDoesNotSupportTagging)
    case resourceNotFound(ResourceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The response object for the <code>TagResource</code> operation.</p>
public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UnsupportedOperation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedOperation(message: \(String(describing: message)))"}
}

extension UnsupportedOperation: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedOperationBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested operation is not supported for this resource or API.</p>
public struct UnsupportedOperation: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOperationBody: Equatable {
    public let message: String?
}

extension UnsupportedOperationBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceARN: \(String(describing: resourceARN)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeys0 in tagKeys {
                try tagKeysContainer.encode(tagkeys0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

/// <p>The request object for <code>UntagResource</code> action.</p>
public struct UntagResourceInput: Equatable {
    /// <p>The ARN of the Amazon FSx resource to untag.</p>
    public let resourceARN: String?
    /// <p>A list of keys of tags on the resource to untag. In case the tag key doesn't exist,
    ///             the call will still succeed to be idempotent.</p>
    public let tagKeys: [String]?

    public init (
        resourceARN: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotServiceResourceError" : self = .notServiceResourceError(try NotServiceResourceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDoesNotSupportTagging" : self = .resourceDoesNotSupportTagging(try ResourceDoesNotSupportTagging(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFound(try ResourceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case badRequest(BadRequest)
    case internalServerError(InternalServerError)
    case notServiceResourceError(NotServiceResourceError)
    case resourceDoesNotSupportTagging(ResourceDoesNotSupportTagging)
    case resourceNotFound(ResourceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The response object for <code>UntagResource</code> action.</p>
public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateFileSystemInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFileSystemInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFileSystemInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFileSystemInput>
    public typealias MOutput = OperationOutput<UpdateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFileSystemOutputError>
}

extension UpdateFileSystemInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFileSystemInput(clientRequestToken: \(String(describing: clientRequestToken)), fileSystemId: \(String(describing: fileSystemId)), lustreConfiguration: \(String(describing: lustreConfiguration)), storageCapacity: \(String(describing: storageCapacity)), windowsConfiguration: \(String(describing: windowsConfiguration)))"}
}

extension UpdateFileSystemInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case fileSystemId = "FileSystemId"
        case lustreConfiguration = "LustreConfiguration"
        case storageCapacity = "StorageCapacity"
        case windowsConfiguration = "WindowsConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let lustreConfiguration = lustreConfiguration {
            try encodeContainer.encode(lustreConfiguration, forKey: .lustreConfiguration)
        }
        if let storageCapacity = storageCapacity {
            try encodeContainer.encode(storageCapacity, forKey: .storageCapacity)
        }
        if let windowsConfiguration = windowsConfiguration {
            try encodeContainer.encode(windowsConfiguration, forKey: .windowsConfiguration)
        }
    }
}

public struct UpdateFileSystemInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFileSystemInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFileSystemInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFileSystemInput>
    public typealias MOutput = OperationOutput<UpdateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFileSystemOutputError>
}

public struct UpdateFileSystemInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFileSystemInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFileSystemInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFileSystemInput>
    public typealias MOutput = OperationOutput<UpdateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFileSystemOutputError>
}

/// <p>The request object for the <code>UpdateFileSystem</code> operation.</p>
public struct UpdateFileSystemInput: Equatable {
    /// <p>A string of up to 64 ASCII characters that Amazon FSx uses to ensure
    ///           idempotent updates. This string is automatically filled on your behalf when you use the AWS
    ///           Command Line Interface (AWS CLI) or an AWS SDK.</p>
    public var clientRequestToken: String?
    /// <p>Identifies the file system that you are updating.</p>
    public let fileSystemId: String?
    /// <p>The configuration object for Amazon FSx for Lustre file systems used in the
    ///                 <code>UpdateFileSystem</code> operation.</p>
    public let lustreConfiguration: UpdateFileSystemLustreConfiguration?
    /// <p>Use this parameter to increase the storage capacity of an Amazon FSx file system.
    ///       Specifies the storage capacity target value, GiB, to increase the storage capacity for the
    ///       file system that you're updating. You cannot make a storage capacity increase request if
    ///       there is an existing storage capacity increase request in progress.</p>
    ///          <p>For Windows file systems, the storage capacity target value must be at least 10 percent
    ///       (%) greater than the current storage capacity value. In order to increase storage capacity,
    ///       the file system must have at least 16 MB/s of throughput capacity.</p>
    ///          <p>For Lustre file systems, the storage capacity target value can be the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>For <code>SCRATCH_2</code> and <code>PERSISTENT_1 SSD</code> deployment types, valid values
    ///           are in multiples of 2400 GiB. The value must be greater than the current storage capacity.</p>
    ///             </li>
    ///             <li>
    ///                <p>For <code>PERSISTENT HDD</code> file systems, valid values are multiples of 6000 GiB for
    ///           12 MB/s/TiB file systems and multiples of 1800 GiB for 40 MB/s/TiB file systems. The values must be greater
    ///           than the current storage capacity.</p>
    ///             </li>
    ///             <li>
    ///                <p>For <code>SCRATCH_1</code> file systems, you cannot increase the storage capacity.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/managing-storage-capacity.html">Managing storage
    ///         capacity</a> in the <i>Amazon FSx for Windows File Server User Guide</i>
    ///       and <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/managing-storage-capacity.html">Managing storage and throughput capacity</a> in the <i>Amazon FSx for Lustre
    ///         User Guide</i>.</p>
    public let storageCapacity: Int?
    /// <p>The configuration updates for an Amazon FSx for Windows File Server file system.</p>
    public let windowsConfiguration: UpdateFileSystemWindowsConfiguration?

    public init (
        clientRequestToken: String? = nil,
        fileSystemId: String? = nil,
        lustreConfiguration: UpdateFileSystemLustreConfiguration? = nil,
        storageCapacity: Int? = nil,
        windowsConfiguration: UpdateFileSystemWindowsConfiguration? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.fileSystemId = fileSystemId
        self.lustreConfiguration = lustreConfiguration
        self.storageCapacity = storageCapacity
        self.windowsConfiguration = windowsConfiguration
    }
}

struct UpdateFileSystemInputBody: Equatable {
    public let fileSystemId: String?
    public let clientRequestToken: String?
    public let storageCapacity: Int?
    public let windowsConfiguration: UpdateFileSystemWindowsConfiguration?
    public let lustreConfiguration: UpdateFileSystemLustreConfiguration?
}

extension UpdateFileSystemInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case fileSystemId = "FileSystemId"
        case lustreConfiguration = "LustreConfiguration"
        case storageCapacity = "StorageCapacity"
        case windowsConfiguration = "WindowsConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let storageCapacityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .storageCapacity)
        storageCapacity = storageCapacityDecoded
        let windowsConfigurationDecoded = try containerValues.decodeIfPresent(UpdateFileSystemWindowsConfiguration.self, forKey: .windowsConfiguration)
        windowsConfiguration = windowsConfigurationDecoded
        let lustreConfigurationDecoded = try containerValues.decodeIfPresent(UpdateFileSystemLustreConfiguration.self, forKey: .lustreConfiguration)
        lustreConfiguration = lustreConfigurationDecoded
    }
}

extension UpdateFileSystemLustreConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoImportPolicy = "AutoImportPolicy"
        case automaticBackupRetentionDays = "AutomaticBackupRetentionDays"
        case dailyAutomaticBackupStartTime = "DailyAutomaticBackupStartTime"
        case dataCompressionType = "DataCompressionType"
        case weeklyMaintenanceStartTime = "WeeklyMaintenanceStartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoImportPolicy = autoImportPolicy {
            try encodeContainer.encode(autoImportPolicy.rawValue, forKey: .autoImportPolicy)
        }
        if let automaticBackupRetentionDays = automaticBackupRetentionDays {
            try encodeContainer.encode(automaticBackupRetentionDays, forKey: .automaticBackupRetentionDays)
        }
        if let dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTime {
            try encodeContainer.encode(dailyAutomaticBackupStartTime, forKey: .dailyAutomaticBackupStartTime)
        }
        if let dataCompressionType = dataCompressionType {
            try encodeContainer.encode(dataCompressionType.rawValue, forKey: .dataCompressionType)
        }
        if let weeklyMaintenanceStartTime = weeklyMaintenanceStartTime {
            try encodeContainer.encode(weeklyMaintenanceStartTime, forKey: .weeklyMaintenanceStartTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let weeklyMaintenanceStartTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .weeklyMaintenanceStartTime)
        weeklyMaintenanceStartTime = weeklyMaintenanceStartTimeDecoded
        let dailyAutomaticBackupStartTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dailyAutomaticBackupStartTime)
        dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTimeDecoded
        let automaticBackupRetentionDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .automaticBackupRetentionDays)
        automaticBackupRetentionDays = automaticBackupRetentionDaysDecoded
        let autoImportPolicyDecoded = try containerValues.decodeIfPresent(AutoImportPolicyType.self, forKey: .autoImportPolicy)
        autoImportPolicy = autoImportPolicyDecoded
        let dataCompressionTypeDecoded = try containerValues.decodeIfPresent(DataCompressionType.self, forKey: .dataCompressionType)
        dataCompressionType = dataCompressionTypeDecoded
    }
}

extension UpdateFileSystemLustreConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFileSystemLustreConfiguration(autoImportPolicy: \(String(describing: autoImportPolicy)), automaticBackupRetentionDays: \(String(describing: automaticBackupRetentionDays)), dailyAutomaticBackupStartTime: \(String(describing: dailyAutomaticBackupStartTime)), dataCompressionType: \(String(describing: dataCompressionType)), weeklyMaintenanceStartTime: \(String(describing: weeklyMaintenanceStartTime)))"}
}

/// <p>The configuration object for Amazon FSx for Lustre file systems used in the
///                 <code>UpdateFileSystem</code> operation.</p>
public struct UpdateFileSystemLustreConfiguration: Equatable {
    /// <p> (Optional) When you create your file system, your existing S3 objects appear as file and directory listings.
    ///             Use this property to choose how Amazon FSx keeps your file and directory listing up to date
    ///             as you add or modify objects in your linked S3 bucket. <code>AutoImportPolicy</code> can
    ///             have the following values:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>NONE</code> - (Default) AutoImport is off. Amazon FSx only updates
    ///                 file and directory listings from the linked S3 bucket
    ///                 when the file system is created. FSx does not update the file and directory
    ///                 listing for any new or changed objects after choosing this option.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NEW</code> - AutoImport is on. Amazon FSx automatically imports
    ///                 directory listings of any new objects added to the linked S3 bucket that
    ///                 do not currently exist in the FSx file system. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NEW_CHANGED</code> - AutoImport is on. Amazon FSx automatically imports
    ///                 file and directory listings of any new objects added to the S3 bucket and any
    ///                 existing objects that are changed in the S3 bucket after you choose this option.
    ///             </p>
    ///             </li>
    ///          </ul>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/autoimport-data-repo.html">Automatically import updates from your S3 bucket</a>.</p>
    public let autoImportPolicy: AutoImportPolicyType?
    /// <p>The number of days to retain automatic backups. Setting this to 0 disables
    ///             automatic backups. You can retain automatic backups for a maximum of 90 days. The default is 0.</p>
    public let automaticBackupRetentionDays: Int?
    /// <p>A recurring daily time, in the format <code>HH:MM</code>. <code>HH</code> is the
    ///             zero-padded hour of the day (0-23), and <code>MM</code> is the zero-padded minute of the
    ///             hour. For example, <code>05:00</code> specifies 5 AM daily. </p>
    public let dailyAutomaticBackupStartTime: String?
    /// <p>Sets the data compression configuration for the file system. <code>DataCompressionType</code>
    ///             can have the following values:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>NONE</code> - Data compression is turned off for
    ///                 the file system.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LZ4</code> - Data compression is turned on with the LZ4
    ///                 algorithm.</p>
    ///             </li>
    ///          </ul>
    ///         <p>If you don't use <code>DataCompressionType</code>, the file system retains
    ///             its current data compression configuration.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/data-compression.html">Lustre data compression</a>.</p>
    public let dataCompressionType: DataCompressionType?
    /// <p>(Optional) The preferred start time to perform weekly maintenance, formatted d:HH:MM in the UTC
    ///             time zone. d is the weekday number, from 1 through 7, beginning with Monday and ending with Sunday.</p>
    public let weeklyMaintenanceStartTime: String?

    public init (
        autoImportPolicy: AutoImportPolicyType? = nil,
        automaticBackupRetentionDays: Int? = nil,
        dailyAutomaticBackupStartTime: String? = nil,
        dataCompressionType: DataCompressionType? = nil,
        weeklyMaintenanceStartTime: String? = nil
    )
    {
        self.autoImportPolicy = autoImportPolicy
        self.automaticBackupRetentionDays = automaticBackupRetentionDays
        self.dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTime
        self.dataCompressionType = dataCompressionType
        self.weeklyMaintenanceStartTime = weeklyMaintenanceStartTime
    }
}

extension UpdateFileSystemOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFileSystemOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleParameterError" : self = .incompatibleParameterError(try IncompatibleParameterError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingFileSystemConfiguration" : self = .missingFileSystemConfiguration(try MissingFileSystemConfiguration(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceeded" : self = .serviceLimitExceeded(try ServiceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFileSystemOutputError: Equatable {
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case incompatibleParameterError(IncompatibleParameterError)
    case internalServerError(InternalServerError)
    case missingFileSystemConfiguration(MissingFileSystemConfiguration)
    case serviceLimitExceeded(ServiceLimitExceeded)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFileSystemOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFileSystemOutputResponse(fileSystem: \(String(describing: fileSystem)))"}
}

extension UpdateFileSystemOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateFileSystemOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fileSystem = output.fileSystem
        } else {
            self.fileSystem = nil
        }
    }
}

/// <p>The response object for the <code>UpdateFileSystem</code> operation.</p>
public struct UpdateFileSystemOutputResponse: Equatable {
    /// <p>A description of the file system that was updated.</p>
    public let fileSystem: FileSystem?

    public init (
        fileSystem: FileSystem? = nil
    )
    {
        self.fileSystem = fileSystem
    }
}

struct UpdateFileSystemOutputResponseBody: Equatable {
    public let fileSystem: FileSystem?
}

extension UpdateFileSystemOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileSystem = "FileSystem"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemDecoded = try containerValues.decodeIfPresent(FileSystem.self, forKey: .fileSystem)
        fileSystem = fileSystemDecoded
    }
}

extension UpdateFileSystemWindowsConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case automaticBackupRetentionDays = "AutomaticBackupRetentionDays"
        case dailyAutomaticBackupStartTime = "DailyAutomaticBackupStartTime"
        case selfManagedActiveDirectoryConfiguration = "SelfManagedActiveDirectoryConfiguration"
        case throughputCapacity = "ThroughputCapacity"
        case weeklyMaintenanceStartTime = "WeeklyMaintenanceStartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automaticBackupRetentionDays = automaticBackupRetentionDays {
            try encodeContainer.encode(automaticBackupRetentionDays, forKey: .automaticBackupRetentionDays)
        }
        if let dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTime {
            try encodeContainer.encode(dailyAutomaticBackupStartTime, forKey: .dailyAutomaticBackupStartTime)
        }
        if let selfManagedActiveDirectoryConfiguration = selfManagedActiveDirectoryConfiguration {
            try encodeContainer.encode(selfManagedActiveDirectoryConfiguration, forKey: .selfManagedActiveDirectoryConfiguration)
        }
        if let throughputCapacity = throughputCapacity {
            try encodeContainer.encode(throughputCapacity, forKey: .throughputCapacity)
        }
        if let weeklyMaintenanceStartTime = weeklyMaintenanceStartTime {
            try encodeContainer.encode(weeklyMaintenanceStartTime, forKey: .weeklyMaintenanceStartTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let weeklyMaintenanceStartTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .weeklyMaintenanceStartTime)
        weeklyMaintenanceStartTime = weeklyMaintenanceStartTimeDecoded
        let dailyAutomaticBackupStartTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dailyAutomaticBackupStartTime)
        dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTimeDecoded
        let automaticBackupRetentionDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .automaticBackupRetentionDays)
        automaticBackupRetentionDays = automaticBackupRetentionDaysDecoded
        let throughputCapacityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .throughputCapacity)
        throughputCapacity = throughputCapacityDecoded
        let selfManagedActiveDirectoryConfigurationDecoded = try containerValues.decodeIfPresent(SelfManagedActiveDirectoryConfigurationUpdates.self, forKey: .selfManagedActiveDirectoryConfiguration)
        selfManagedActiveDirectoryConfiguration = selfManagedActiveDirectoryConfigurationDecoded
    }
}

extension UpdateFileSystemWindowsConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFileSystemWindowsConfiguration(automaticBackupRetentionDays: \(String(describing: automaticBackupRetentionDays)), dailyAutomaticBackupStartTime: \(String(describing: dailyAutomaticBackupStartTime)), selfManagedActiveDirectoryConfiguration: \(String(describing: selfManagedActiveDirectoryConfiguration)), throughputCapacity: \(String(describing: throughputCapacity)), weeklyMaintenanceStartTime: \(String(describing: weeklyMaintenanceStartTime)))"}
}

/// <p>Updates the configuration for an existing Amazon FSx for Windows
///             File Server file system. Amazon FSx only overwrites existing properties with non-null values
///             provided in the request.</p>
public struct UpdateFileSystemWindowsConfiguration: Equatable {
    /// <p>The number of days to retain automatic daily backups. Setting this to zero (0) disables automatic daily
    ///             backups. You can retain automatic daily backups for a maximum of 90 days. For more information, see
    ///             <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/using-backups.html#automatic-backups">Working with Automatic Daily Backups</a>.</p>
    public let automaticBackupRetentionDays: Int?
    /// <p>The preferred time to start the daily automatic backup, in the UTC time zone, for example, <code>02:00</code>
    ///          </p>
    public let dailyAutomaticBackupStartTime: String?
    /// <p>The configuration Amazon FSx uses to join the Windows File Server instance to the
    ///             self-managed Microsoft AD directory. You cannot make a self-managed Microsoft AD update request if there is an existing self-managed Microsoft AD update request in progress.</p>
    public let selfManagedActiveDirectoryConfiguration: SelfManagedActiveDirectoryConfigurationUpdates?
    /// <p>Sets the target value for a file system's throughput capacity, in MB/s, that you are updating the file system to. Valid values are
    ///             8, 16, 32, 64, 128, 256, 512, 1024, 2048. You cannot make a throughput capacity update request if there is an existing throughput capacity update request in progress. For more information,
    ///             see <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/managing-throughput-capacity.html">Managing Throughput Capacity</a>.</p>
    public let throughputCapacity: Int?
    /// <p>The preferred start time to perform weekly maintenance, formatted d:HH:MM in the UTC
    ///             time zone. Where d is the weekday number, from 1 through 7, with 1 = Monday and 7 = Sunday.</p>
    public let weeklyMaintenanceStartTime: String?

    public init (
        automaticBackupRetentionDays: Int? = nil,
        dailyAutomaticBackupStartTime: String? = nil,
        selfManagedActiveDirectoryConfiguration: SelfManagedActiveDirectoryConfigurationUpdates? = nil,
        throughputCapacity: Int? = nil,
        weeklyMaintenanceStartTime: String? = nil
    )
    {
        self.automaticBackupRetentionDays = automaticBackupRetentionDays
        self.dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTime
        self.selfManagedActiveDirectoryConfiguration = selfManagedActiveDirectoryConfiguration
        self.throughputCapacity = throughputCapacity
        self.weeklyMaintenanceStartTime = weeklyMaintenanceStartTime
    }
}

public enum WindowsDeploymentType {
    case multiAz1
    case singleAz1
    case singleAz2
    case sdkUnknown(String)
}

extension WindowsDeploymentType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WindowsDeploymentType] {
        return [
            .multiAz1,
            .singleAz1,
            .singleAz2,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .multiAz1: return "MULTI_AZ_1"
        case .singleAz1: return "SINGLE_AZ_1"
        case .singleAz2: return "SINGLE_AZ_2"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WindowsDeploymentType(rawValue: rawValue) ?? WindowsDeploymentType.sdkUnknown(rawValue)
    }
}

extension WindowsFileSystemConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activeDirectoryId = "ActiveDirectoryId"
        case aliases = "Aliases"
        case automaticBackupRetentionDays = "AutomaticBackupRetentionDays"
        case copyTagsToBackups = "CopyTagsToBackups"
        case dailyAutomaticBackupStartTime = "DailyAutomaticBackupStartTime"
        case deploymentType = "DeploymentType"
        case maintenanceOperationsInProgress = "MaintenanceOperationsInProgress"
        case preferredFileServerIp = "PreferredFileServerIp"
        case preferredSubnetId = "PreferredSubnetId"
        case remoteAdministrationEndpoint = "RemoteAdministrationEndpoint"
        case selfManagedActiveDirectoryConfiguration = "SelfManagedActiveDirectoryConfiguration"
        case throughputCapacity = "ThroughputCapacity"
        case weeklyMaintenanceStartTime = "WeeklyMaintenanceStartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeDirectoryId = activeDirectoryId {
            try encodeContainer.encode(activeDirectoryId, forKey: .activeDirectoryId)
        }
        if let aliases = aliases {
            var aliasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aliases)
            for aliases0 in aliases {
                try aliasesContainer.encode(aliases0)
            }
        }
        if let automaticBackupRetentionDays = automaticBackupRetentionDays {
            try encodeContainer.encode(automaticBackupRetentionDays, forKey: .automaticBackupRetentionDays)
        }
        if let copyTagsToBackups = copyTagsToBackups {
            try encodeContainer.encode(copyTagsToBackups, forKey: .copyTagsToBackups)
        }
        if let dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTime {
            try encodeContainer.encode(dailyAutomaticBackupStartTime, forKey: .dailyAutomaticBackupStartTime)
        }
        if let deploymentType = deploymentType {
            try encodeContainer.encode(deploymentType.rawValue, forKey: .deploymentType)
        }
        if let maintenanceOperationsInProgress = maintenanceOperationsInProgress {
            var maintenanceOperationsInProgressContainer = encodeContainer.nestedUnkeyedContainer(forKey: .maintenanceOperationsInProgress)
            for filesystemmaintenanceoperations0 in maintenanceOperationsInProgress {
                try maintenanceOperationsInProgressContainer.encode(filesystemmaintenanceoperations0.rawValue)
            }
        }
        if let preferredFileServerIp = preferredFileServerIp {
            try encodeContainer.encode(preferredFileServerIp, forKey: .preferredFileServerIp)
        }
        if let preferredSubnetId = preferredSubnetId {
            try encodeContainer.encode(preferredSubnetId, forKey: .preferredSubnetId)
        }
        if let remoteAdministrationEndpoint = remoteAdministrationEndpoint {
            try encodeContainer.encode(remoteAdministrationEndpoint, forKey: .remoteAdministrationEndpoint)
        }
        if let selfManagedActiveDirectoryConfiguration = selfManagedActiveDirectoryConfiguration {
            try encodeContainer.encode(selfManagedActiveDirectoryConfiguration, forKey: .selfManagedActiveDirectoryConfiguration)
        }
        if let throughputCapacity = throughputCapacity {
            try encodeContainer.encode(throughputCapacity, forKey: .throughputCapacity)
        }
        if let weeklyMaintenanceStartTime = weeklyMaintenanceStartTime {
            try encodeContainer.encode(weeklyMaintenanceStartTime, forKey: .weeklyMaintenanceStartTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeDirectoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .activeDirectoryId)
        activeDirectoryId = activeDirectoryIdDecoded
        let selfManagedActiveDirectoryConfigurationDecoded = try containerValues.decodeIfPresent(SelfManagedActiveDirectoryAttributes.self, forKey: .selfManagedActiveDirectoryConfiguration)
        selfManagedActiveDirectoryConfiguration = selfManagedActiveDirectoryConfigurationDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(WindowsDeploymentType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let remoteAdministrationEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .remoteAdministrationEndpoint)
        remoteAdministrationEndpoint = remoteAdministrationEndpointDecoded
        let preferredSubnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredSubnetId)
        preferredSubnetId = preferredSubnetIdDecoded
        let preferredFileServerIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredFileServerIp)
        preferredFileServerIp = preferredFileServerIpDecoded
        let throughputCapacityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .throughputCapacity)
        throughputCapacity = throughputCapacityDecoded
        let maintenanceOperationsInProgressContainer = try containerValues.decodeIfPresent([FileSystemMaintenanceOperation?].self, forKey: .maintenanceOperationsInProgress)
        var maintenanceOperationsInProgressDecoded0:[FileSystemMaintenanceOperation]? = nil
        if let maintenanceOperationsInProgressContainer = maintenanceOperationsInProgressContainer {
            maintenanceOperationsInProgressDecoded0 = [FileSystemMaintenanceOperation]()
            for string0 in maintenanceOperationsInProgressContainer {
                if let string0 = string0 {
                    maintenanceOperationsInProgressDecoded0?.append(string0)
                }
            }
        }
        maintenanceOperationsInProgress = maintenanceOperationsInProgressDecoded0
        let weeklyMaintenanceStartTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .weeklyMaintenanceStartTime)
        weeklyMaintenanceStartTime = weeklyMaintenanceStartTimeDecoded
        let dailyAutomaticBackupStartTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dailyAutomaticBackupStartTime)
        dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTimeDecoded
        let automaticBackupRetentionDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .automaticBackupRetentionDays)
        automaticBackupRetentionDays = automaticBackupRetentionDaysDecoded
        let copyTagsToBackupsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .copyTagsToBackups)
        copyTagsToBackups = copyTagsToBackupsDecoded
        let aliasesContainer = try containerValues.decodeIfPresent([Alias?].self, forKey: .aliases)
        var aliasesDecoded0:[Alias]? = nil
        if let aliasesContainer = aliasesContainer {
            aliasesDecoded0 = [Alias]()
            for structure0 in aliasesContainer {
                if let structure0 = structure0 {
                    aliasesDecoded0?.append(structure0)
                }
            }
        }
        aliases = aliasesDecoded0
    }
}

extension WindowsFileSystemConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WindowsFileSystemConfiguration(activeDirectoryId: \(String(describing: activeDirectoryId)), aliases: \(String(describing: aliases)), automaticBackupRetentionDays: \(String(describing: automaticBackupRetentionDays)), copyTagsToBackups: \(String(describing: copyTagsToBackups)), dailyAutomaticBackupStartTime: \(String(describing: dailyAutomaticBackupStartTime)), deploymentType: \(String(describing: deploymentType)), maintenanceOperationsInProgress: \(String(describing: maintenanceOperationsInProgress)), preferredFileServerIp: \(String(describing: preferredFileServerIp)), preferredSubnetId: \(String(describing: preferredSubnetId)), remoteAdministrationEndpoint: \(String(describing: remoteAdministrationEndpoint)), selfManagedActiveDirectoryConfiguration: \(String(describing: selfManagedActiveDirectoryConfiguration)), throughputCapacity: \(String(describing: throughputCapacity)), weeklyMaintenanceStartTime: \(String(describing: weeklyMaintenanceStartTime)))"}
}

/// <p>The configuration for this Microsoft Windows file system.</p>
public struct WindowsFileSystemConfiguration: Equatable {
    /// <p>The ID for an existing AWS Managed Microsoft Active Directory instance that the file system is joined to.</p>
    public let activeDirectoryId: String?
    /// <p>An array of one or more DNS aliases that are currently associated with the Amazon FSx file system.
    ///             Aliases allow you to use existing DNS names to access the data in your Amazon FSx file system.
    ///             You can associate up to 50 aliases with a file system at any time.
    ///             You can associate additional DNS aliases after you create the file system using the AssociateFileSystemAliases operation.
    ///             You can remove DNS aliases from the file system after it is created using the DisassociateFileSystemAliases operation.
    ///             You only need to specify the alias name in the request payload. For more information, see
    ///             <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/managing-dns-aliases.html">DNS aliases</a>.</p>
    public let aliases: [Alias]?
    /// <p>The number of days to retain automatic backups. Setting this to 0 disables automatic
    ///             backups. You can retain automatic backups for a maximum of 90 days.</p>
    public let automaticBackupRetentionDays: Int?
    /// <p>A boolean flag indicating whether tags on the file system should be copied to backups.
    ///             This value defaults to false. If it's set to true, all tags on the file system are
    ///             copied to all automatic backups and any user-initiated backups where the user
    ///             doesn't specify any tags. If this value is true, and you specify one or more tags,
    ///             only the specified tags are copied to backups. If you specify one or more tags when
    ///             creating a user-initiated backup, no tags are copied from the file system,
    ///             regardless of this value.</p>
    public let copyTagsToBackups: Bool?
    /// <p>The preferred time to take daily automatic backups, in the UTC time zone.</p>
    public let dailyAutomaticBackupStartTime: String?
    /// <p>Specifies the file system deployment type, valid values are the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>MULTI_AZ_1</code> - Specifies a high availability file system that is configured for Multi-AZ
    ///                     redundancy to tolerate temporary Availability Zone (AZ) unavailability, and supports SSD and HDD storage.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SINGLE_AZ_1</code> - (Default) Specifies a file system that is configured for single AZ redundancy,
    ///                     only supports SSD storage.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SINGLE_AZ_2</code> - Latest generation Single AZ file system.
    ///                     Specifies a file system that is configured for single AZ redundancy and supports SSD and HDD storage.</p>
    ///             </li>
    ///          </ul>
    ///         <p>For more information, see
    ///          <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/high-availability-multiAZ.html">Single-AZ and Multi-AZ File Systems</a>.</p>
    public let deploymentType: WindowsDeploymentType?
    /// <p>The list of maintenance operations in progress for this file system.</p>
    public let maintenanceOperationsInProgress: [FileSystemMaintenanceOperation]?
    /// <p>For <code>MULTI_AZ_1</code> deployment types, the IP address of the primary, or preferred, file server.</p>
    ///         <p>Use this IP address when mounting the file system on Linux SMB clients or Windows SMB clients that
    ///             are not joined to a Microsoft Active Directory.
    ///             Applicable for all Windows file system deployment types.
    ///             This IP address is temporarily unavailable
    ///             when the file system is undergoing maintenance. For Linux and Windows
    ///             SMB clients that are joined to an Active Directory, use the file system's DNSName instead. For more information
    ///             on mapping and mounting file shares, see
    ///             <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/accessing-file-shares.html">Accessing File Shares</a>.</p>
    public let preferredFileServerIp: String?
    /// <p>For <code>MULTI_AZ_1</code> deployment types, it specifies the ID of the subnet where the preferred file server is located.
    ///             Must be one of the two subnet IDs specified in <code>SubnetIds</code> property.
    ///             Amazon FSx serves traffic from this subnet except in the event of a failover to the secondary file server.</p>
    ///         <p>For <code>SINGLE_AZ_1</code> and <code>SINGLE_AZ_2</code> deployment types, this value is the same as that for <code>SubnetIDs</code>.
    ///             For more information, see
    ///             <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/high-availability-multiAZ.html#single-multi-az-resources">Availability and durability: Single-AZ and Multi-AZ file systems</a>.</p>
    public let preferredSubnetId: String?
    /// <p>For <code>MULTI_AZ_1</code> deployment types, use this endpoint when performing administrative tasks on the file system using
    ///             Amazon FSx Remote PowerShell.</p>
    ///         <p>For <code>SINGLE_AZ_1</code> and <code>SINGLE_AZ_2</code> deployment types, this is the DNS name of the file system.</p>
    ///         <p>This endpoint is temporarily unavailable when the file system is undergoing maintenance.</p>
    public let remoteAdministrationEndpoint: String?
    /// <p>The configuration of the self-managed Microsoft Active Directory (AD) directory to
    ///             which the Windows File Server instance is joined.</p>
    public let selfManagedActiveDirectoryConfiguration: SelfManagedActiveDirectoryAttributes?
    /// <p>The throughput of the Amazon FSx file system, measured in megabytes per
    ///             second.</p>
    public let throughputCapacity: Int?
    /// <p>The preferred start time to perform weekly maintenance, formatted d:HH:MM in the UTC
    ///             time zone. d is the weekday number, from 1 through 7, beginning with Monday and ending with Sunday.</p>
    public let weeklyMaintenanceStartTime: String?

    public init (
        activeDirectoryId: String? = nil,
        aliases: [Alias]? = nil,
        automaticBackupRetentionDays: Int? = nil,
        copyTagsToBackups: Bool? = nil,
        dailyAutomaticBackupStartTime: String? = nil,
        deploymentType: WindowsDeploymentType? = nil,
        maintenanceOperationsInProgress: [FileSystemMaintenanceOperation]? = nil,
        preferredFileServerIp: String? = nil,
        preferredSubnetId: String? = nil,
        remoteAdministrationEndpoint: String? = nil,
        selfManagedActiveDirectoryConfiguration: SelfManagedActiveDirectoryAttributes? = nil,
        throughputCapacity: Int? = nil,
        weeklyMaintenanceStartTime: String? = nil
    )
    {
        self.activeDirectoryId = activeDirectoryId
        self.aliases = aliases
        self.automaticBackupRetentionDays = automaticBackupRetentionDays
        self.copyTagsToBackups = copyTagsToBackups
        self.dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTime
        self.deploymentType = deploymentType
        self.maintenanceOperationsInProgress = maintenanceOperationsInProgress
        self.preferredFileServerIp = preferredFileServerIp
        self.preferredSubnetId = preferredSubnetId
        self.remoteAdministrationEndpoint = remoteAdministrationEndpoint
        self.selfManagedActiveDirectoryConfiguration = selfManagedActiveDirectoryConfiguration
        self.throughputCapacity = throughputCapacity
        self.weeklyMaintenanceStartTime = weeklyMaintenanceStartTime
    }
}
