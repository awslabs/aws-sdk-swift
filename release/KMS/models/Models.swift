// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public enum AlgorithmSpec {
    case rsaesOaepSha1
    case rsaesOaepSha256
    case rsaesPkcs1V15
    case sdkUnknown(String)
}

extension AlgorithmSpec : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AlgorithmSpec] {
        return [
            .rsaesOaepSha1,
            .rsaesOaepSha256,
            .rsaesPkcs1V15,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .rsaesOaepSha1: return "RSAES_OAEP_SHA_1"
        case .rsaesOaepSha256: return "RSAES_OAEP_SHA_256"
        case .rsaesPkcs1V15: return "RSAES_PKCS1_V1_5"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AlgorithmSpec(rawValue: rawValue) ?? AlgorithmSpec.sdkUnknown(rawValue)
    }
}

extension AliasListEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aliasArn = "AliasArn"
        case aliasName = "AliasName"
        case creationDate = "CreationDate"
        case lastUpdatedDate = "LastUpdatedDate"
        case targetKeyId = "TargetKeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasArn = aliasArn {
            try encodeContainer.encode(aliasArn, forKey: .aliasArn)
        }
        if let aliasName = aliasName {
            try encodeContainer.encode(aliasName, forKey: .aliasName)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let lastUpdatedDate = lastUpdatedDate {
            try encodeContainer.encode(lastUpdatedDate.timeIntervalSince1970, forKey: .lastUpdatedDate)
        }
        if let targetKeyId = targetKeyId {
            try encodeContainer.encode(targetKeyId, forKey: .targetKeyId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aliasName)
        aliasName = aliasNameDecoded
        let aliasArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aliasArn)
        aliasArn = aliasArnDecoded
        let targetKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetKeyId)
        targetKeyId = targetKeyIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
    }
}

extension AliasListEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AliasListEntry(aliasArn: \(String(describing: aliasArn)), aliasName: \(String(describing: aliasName)), creationDate: \(String(describing: creationDate)), lastUpdatedDate: \(String(describing: lastUpdatedDate)), targetKeyId: \(String(describing: targetKeyId)))"}
}

/// <p>Contains information about an alias.</p>
public struct AliasListEntry: Equatable {
    /// <p>String that contains the key ARN.</p>
    public let aliasArn: String?
    /// <p>String that contains the alias. This value begins with <code>alias/</code>.</p>
    public let aliasName: String?
    public let creationDate: Date?
    public let lastUpdatedDate: Date?
    /// <p>String that contains the key identifier referred to by the alias.</p>
    public let targetKeyId: String?

    public init (
        aliasArn: String? = nil,
        aliasName: String? = nil,
        creationDate: Date? = nil,
        lastUpdatedDate: Date? = nil,
        targetKeyId: String? = nil
    )
    {
        self.aliasArn = aliasArn
        self.aliasName = aliasName
        self.creationDate = creationDate
        self.lastUpdatedDate = lastUpdatedDate
        self.targetKeyId = targetKeyId
    }
}

extension AlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AlreadyExistsException(message: \(String(describing: message)))"}
}

extension AlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because it attempted to create a resource that already
///       exists.</p>
public struct AlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension AlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CancelKeyDeletionInputBodyMiddleware: Middleware {
    public let id: String = "CancelKeyDeletionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelKeyDeletionInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelKeyDeletionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelKeyDeletionInput>
    public typealias MOutput = OperationOutput<CancelKeyDeletionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelKeyDeletionOutputError>
}

extension CancelKeyDeletionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelKeyDeletionInput(keyId: \(String(describing: keyId)))"}
}

extension CancelKeyDeletionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
    }
}

public struct CancelKeyDeletionInputHeadersMiddleware: Middleware {
    public let id: String = "CancelKeyDeletionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelKeyDeletionInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelKeyDeletionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelKeyDeletionInput>
    public typealias MOutput = OperationOutput<CancelKeyDeletionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelKeyDeletionOutputError>
}

public struct CancelKeyDeletionInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelKeyDeletionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelKeyDeletionInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelKeyDeletionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelKeyDeletionInput>
    public typealias MOutput = OperationOutput<CancelKeyDeletionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelKeyDeletionOutputError>
}

public struct CancelKeyDeletionInput: Equatable {
    /// <p>The unique identifier for the customer master key (CMK) for which to cancel
    ///       deletion.</p>
    ///          <p>Specify the key ID or the Amazon Resource Name (ARN) of the CMK.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
    public let keyId: String?

    public init (
        keyId: String? = nil
    )
    {
        self.keyId = keyId
    }
}

struct CancelKeyDeletionInputBody: Equatable {
    public let keyId: String?
}

extension CancelKeyDeletionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
    }
}

extension CancelKeyDeletionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelKeyDeletionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelKeyDeletionOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case invalidArnException(InvalidArnException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelKeyDeletionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelKeyDeletionOutputResponse(keyId: \(String(describing: keyId)))"}
}

extension CancelKeyDeletionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CancelKeyDeletionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.keyId = output.keyId
        } else {
            self.keyId = nil
        }
    }
}

public struct CancelKeyDeletionOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN">key ARN</a>) of the CMK whose deletion is canceled.</p>
    public let keyId: String?

    public init (
        keyId: String? = nil
    )
    {
        self.keyId = keyId
    }
}

struct CancelKeyDeletionOutputResponseBody: Equatable {
    public let keyId: String?
}

extension CancelKeyDeletionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
    }
}

extension CloudHsmClusterInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudHsmClusterInUseException(message: \(String(describing: message)))"}
}

extension CloudHsmClusterInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CloudHsmClusterInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the specified AWS CloudHSM cluster is already associated with a
///       custom key store or it shares a backup history with a cluster that is associated with a custom
///       key store. Each custom key store must be associated with a different AWS CloudHSM cluster.</p>
///          <p>Clusters that share a backup history have the same cluster certificate. To view the
///       cluster certificate of a cluster, use the <a href="https://docs.aws.amazon.com/cloudhsm/latest/APIReference/API_DescribeClusters.html">DescribeClusters</a> operation.</p>
public struct CloudHsmClusterInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CloudHsmClusterInUseExceptionBody: Equatable {
    public let message: String?
}

extension CloudHsmClusterInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudHsmClusterInvalidConfigurationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudHsmClusterInvalidConfigurationException(message: \(String(describing: message)))"}
}

extension CloudHsmClusterInvalidConfigurationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CloudHsmClusterInvalidConfigurationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the associated AWS CloudHSM cluster did not meet the
///       configuration requirements for a custom key store.</p>
///
///          <ul>
///             <li>
///                <p>The cluster must be configured with private subnets in at least two different
///           Availability Zones in the Region.</p>
///             </li>
///             <li>
///                <p>The <a href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/configure-sg.html">security group for
///             the cluster</a> (cloudhsm-cluster-<i><cluster-id></i>-sg) must
///           include inbound rules and outbound rules that allow TCP traffic on ports 2223-2225. The
///             <b>Source</b> in the inbound rules and the <b>Destination</b> in the outbound rules must match the security group
///           ID. These rules are set by default when you create the cluster. Do not delete or change
///           them. To get information about a particular security group, use the <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSecurityGroups.html">DescribeSecurityGroups</a> operation.</p>
///             </li>
///             <li>
///                <p>The cluster must contain at least as many HSMs as the operation requires. To add HSMs,
///           use the AWS CloudHSM <a href="https://docs.aws.amazon.com/cloudhsm/latest/APIReference/API_CreateHsm.html">CreateHsm</a> operation.</p>
///                <p>For the <a>CreateCustomKeyStore</a>, <a>UpdateCustomKeyStore</a>, and <a>CreateKey</a> operations, the AWS CloudHSM cluster must have at least two
///           active HSMs, each in a different Availability Zone. For the <a>ConnectCustomKeyStore</a> operation, the AWS CloudHSM must contain at least one active
///           HSM.</p>
///             </li>
///          </ul>
///          <p>For information about the requirements for an AWS CloudHSM cluster that is associated with a
///       custom key store, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/create-keystore.html#before-keystore">Assemble the Prerequisites</a>
///       in the <i>AWS Key Management Service Developer Guide</i>. For information about creating a private subnet for an AWS CloudHSM cluster,
///       see <a href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/create-subnets.html">Create a Private
///         Subnet</a> in the <i>AWS CloudHSM User Guide</i>. For information about cluster security groups, see
///         <a href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/configure-sg.html">Configure a Default Security
///         Group</a> in the <i>
///                <i>AWS CloudHSM User Guide</i>
///             </i>. </p>
public struct CloudHsmClusterInvalidConfigurationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CloudHsmClusterInvalidConfigurationExceptionBody: Equatable {
    public let message: String?
}

extension CloudHsmClusterInvalidConfigurationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudHsmClusterNotActiveException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudHsmClusterNotActiveException(message: \(String(describing: message)))"}
}

extension CloudHsmClusterNotActiveException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CloudHsmClusterNotActiveExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the AWS CloudHSM cluster that is associated with the custom key
///       store is not active. Initialize and activate the cluster and try the command again. For
///       detailed instructions, see <a href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/getting-started.html">Getting Started</a> in the <i>AWS CloudHSM User Guide</i>.</p>
public struct CloudHsmClusterNotActiveException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CloudHsmClusterNotActiveExceptionBody: Equatable {
    public let message: String?
}

extension CloudHsmClusterNotActiveExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudHsmClusterNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudHsmClusterNotFoundException(message: \(String(describing: message)))"}
}

extension CloudHsmClusterNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CloudHsmClusterNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because AWS KMS cannot find the AWS CloudHSM cluster with the specified
///       cluster ID. Retry the request with a different cluster ID.</p>
public struct CloudHsmClusterNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CloudHsmClusterNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension CloudHsmClusterNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudHsmClusterNotRelatedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudHsmClusterNotRelatedException(message: \(String(describing: message)))"}
}

extension CloudHsmClusterNotRelatedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CloudHsmClusterNotRelatedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the specified AWS CloudHSM cluster has a different cluster
///       certificate than the original cluster. You cannot use the operation to specify an unrelated
///       cluster.</p>
///          <p>Specify a cluster that shares a backup history with the original cluster. This includes
///       clusters that were created from a backup of the current cluster, and clusters that were
///       created from the same backup that produced the current cluster.</p>
///          <p>Clusters that share a backup history have the same cluster certificate. To view the
///       cluster certificate of a cluster, use the <a href="https://docs.aws.amazon.com/cloudhsm/latest/APIReference/API_DescribeClusters.html">DescribeClusters</a> operation.</p>
public struct CloudHsmClusterNotRelatedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CloudHsmClusterNotRelatedExceptionBody: Equatable {
    public let message: String?
}

extension CloudHsmClusterNotRelatedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ConnectCustomKeyStoreInputBodyMiddleware: Middleware {
    public let id: String = "ConnectCustomKeyStoreInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConnectCustomKeyStoreInput>,
                  next: H) -> Swift.Result<OperationOutput<ConnectCustomKeyStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConnectCustomKeyStoreInput>
    public typealias MOutput = OperationOutput<ConnectCustomKeyStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConnectCustomKeyStoreOutputError>
}

extension ConnectCustomKeyStoreInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectCustomKeyStoreInput(customKeyStoreId: \(String(describing: customKeyStoreId)))"}
}

extension ConnectCustomKeyStoreInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customKeyStoreId = "CustomKeyStoreId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customKeyStoreId = customKeyStoreId {
            try encodeContainer.encode(customKeyStoreId, forKey: .customKeyStoreId)
        }
    }
}

public struct ConnectCustomKeyStoreInputHeadersMiddleware: Middleware {
    public let id: String = "ConnectCustomKeyStoreInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConnectCustomKeyStoreInput>,
                  next: H) -> Swift.Result<OperationOutput<ConnectCustomKeyStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConnectCustomKeyStoreInput>
    public typealias MOutput = OperationOutput<ConnectCustomKeyStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConnectCustomKeyStoreOutputError>
}

public struct ConnectCustomKeyStoreInputQueryItemMiddleware: Middleware {
    public let id: String = "ConnectCustomKeyStoreInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConnectCustomKeyStoreInput>,
                  next: H) -> Swift.Result<OperationOutput<ConnectCustomKeyStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConnectCustomKeyStoreInput>
    public typealias MOutput = OperationOutput<ConnectCustomKeyStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConnectCustomKeyStoreOutputError>
}

public struct ConnectCustomKeyStoreInput: Equatable {
    /// <p>Enter the key store ID of the custom key store that you want to connect.
    ///       To find the ID of a custom key store, use the <a>DescribeCustomKeyStores</a> operation.</p>
    public let customKeyStoreId: String?

    public init (
        customKeyStoreId: String? = nil
    )
    {
        self.customKeyStoreId = customKeyStoreId
    }
}

struct ConnectCustomKeyStoreInputBody: Equatable {
    public let customKeyStoreId: String?
}

extension ConnectCustomKeyStoreInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customKeyStoreId = "CustomKeyStoreId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customKeyStoreIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customKeyStoreId)
        customKeyStoreId = customKeyStoreIdDecoded
    }
}

extension ConnectCustomKeyStoreOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ConnectCustomKeyStoreOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmClusterInvalidConfigurationException" : self = .cloudHsmClusterInvalidConfigurationException(try CloudHsmClusterInvalidConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmClusterNotActiveException" : self = .cloudHsmClusterNotActiveException(try CloudHsmClusterNotActiveException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CustomKeyStoreInvalidStateException" : self = .customKeyStoreInvalidStateException(try CustomKeyStoreInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CustomKeyStoreNotFoundException" : self = .customKeyStoreNotFoundException(try CustomKeyStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ConnectCustomKeyStoreOutputError: Equatable {
    case cloudHsmClusterInvalidConfigurationException(CloudHsmClusterInvalidConfigurationException)
    case cloudHsmClusterNotActiveException(CloudHsmClusterNotActiveException)
    case customKeyStoreInvalidStateException(CustomKeyStoreInvalidStateException)
    case customKeyStoreNotFoundException(CustomKeyStoreNotFoundException)
    case kMSInternalException(KMSInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ConnectCustomKeyStoreOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectCustomKeyStoreOutputResponse()"}
}

extension ConnectCustomKeyStoreOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ConnectCustomKeyStoreOutputResponse: Equatable {

    public init() {}
}

struct ConnectCustomKeyStoreOutputResponseBody: Equatable {
}

extension ConnectCustomKeyStoreOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum ConnectionErrorCodeType {
    case clusterNotFound
    case insufficientCloudhsmHsms
    case internalError
    case invalidCredentials
    case networkErrors
    case subnetNotFound
    case userLockedOut
    case userLoggedIn
    case userNotFound
    case sdkUnknown(String)
}

extension ConnectionErrorCodeType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConnectionErrorCodeType] {
        return [
            .clusterNotFound,
            .insufficientCloudhsmHsms,
            .internalError,
            .invalidCredentials,
            .networkErrors,
            .subnetNotFound,
            .userLockedOut,
            .userLoggedIn,
            .userNotFound,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .clusterNotFound: return "CLUSTER_NOT_FOUND"
        case .insufficientCloudhsmHsms: return "INSUFFICIENT_CLOUDHSM_HSMS"
        case .internalError: return "INTERNAL_ERROR"
        case .invalidCredentials: return "INVALID_CREDENTIALS"
        case .networkErrors: return "NETWORK_ERRORS"
        case .subnetNotFound: return "SUBNET_NOT_FOUND"
        case .userLockedOut: return "USER_LOCKED_OUT"
        case .userLoggedIn: return "USER_LOGGED_IN"
        case .userNotFound: return "USER_NOT_FOUND"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConnectionErrorCodeType(rawValue: rawValue) ?? ConnectionErrorCodeType.sdkUnknown(rawValue)
    }
}

public enum ConnectionStateType {
    case connected
    case connecting
    case disconnected
    case disconnecting
    case failed
    case sdkUnknown(String)
}

extension ConnectionStateType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConnectionStateType] {
        return [
            .connected,
            .connecting,
            .disconnected,
            .disconnecting,
            .failed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .connected: return "CONNECTED"
        case .connecting: return "CONNECTING"
        case .disconnected: return "DISCONNECTED"
        case .disconnecting: return "DISCONNECTING"
        case .failed: return "FAILED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConnectionStateType(rawValue: rawValue) ?? ConnectionStateType.sdkUnknown(rawValue)
    }
}

public struct CreateAliasInputBodyMiddleware: Middleware {
    public let id: String = "CreateAliasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAliasInput>
    public typealias MOutput = OperationOutput<CreateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAliasOutputError>
}

extension CreateAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAliasInput(aliasName: \(String(describing: aliasName)), targetKeyId: \(String(describing: targetKeyId)))"}
}

extension CreateAliasInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aliasName = "AliasName"
        case targetKeyId = "TargetKeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasName = aliasName {
            try encodeContainer.encode(aliasName, forKey: .aliasName)
        }
        if let targetKeyId = targetKeyId {
            try encodeContainer.encode(targetKeyId, forKey: .targetKeyId)
        }
    }
}

public struct CreateAliasInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAliasInput>
    public typealias MOutput = OperationOutput<CreateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAliasOutputError>
}

public struct CreateAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAliasInput>
    public typealias MOutput = OperationOutput<CreateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAliasOutputError>
}

public struct CreateAliasInput: Equatable {
    /// <p>Specifies the alias name. This value must begin with <code>alias/</code> followed by a
    ///       name, such as <code>alias/ExampleAlias</code>. </p>
    ///          <p>The <code>AliasName</code> value must be string of 1-256 characters. It can contain only alphanumeric characters,
    ///       forward slashes (/), underscores (_), and dashes (-). The alias name cannot begin with <code>alias/aws/</code>. The <code>alias/aws/</code> prefix is reserved
    ///       for <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-managed-cmk">AWS managed CMKs</a>.</p>
    public let aliasName: String?
    /// <p>Associates the alias with the specified <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#customer-cmk">customer managed CMK</a>. The CMK must be
    ///       in the same AWS Region. </p>
    ///          <p>A valid CMK ID is required. If you supply a null or empty string value, this operation
    ///       returns an error.</p>
    ///          <p>For help finding the key ID and ARN, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/viewing-keys.html#find-cmk-id-arn">Finding the Key ID and
    ///         ARN</a> in the <i>AWS Key Management Service Developer Guide</i>.</p>
    ///
    ///          <p>Specify the key ID or the Amazon Resource Name (ARN) of the CMK.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
    public let targetKeyId: String?

    public init (
        aliasName: String? = nil,
        targetKeyId: String? = nil
    )
    {
        self.aliasName = aliasName
        self.targetKeyId = targetKeyId
    }
}

struct CreateAliasInputBody: Equatable {
    public let aliasName: String?
    public let targetKeyId: String?
}

extension CreateAliasInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aliasName = "AliasName"
        case targetKeyId = "TargetKeyId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aliasName)
        aliasName = aliasNameDecoded
        let targetKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetKeyId)
        targetKeyId = targetKeyIdDecoded
    }
}

extension CreateAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAliasNameException" : self = .invalidAliasNameException(try InvalidAliasNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAliasOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case dependencyTimeoutException(DependencyTimeoutException)
    case invalidAliasNameException(InvalidAliasNameException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAliasOutputResponse()"}
}

extension CreateAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateAliasOutputResponse: Equatable {

    public init() {}
}

struct CreateAliasOutputResponseBody: Equatable {
}

extension CreateAliasOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateCustomKeyStoreInputBodyMiddleware: Middleware {
    public let id: String = "CreateCustomKeyStoreInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomKeyStoreInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomKeyStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomKeyStoreInput>
    public typealias MOutput = OperationOutput<CreateCustomKeyStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomKeyStoreOutputError>
}

extension CreateCustomKeyStoreInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCustomKeyStoreInput(cloudHsmClusterId: \(String(describing: cloudHsmClusterId)), customKeyStoreName: \(String(describing: customKeyStoreName)), keyStorePassword: \(String(describing: keyStorePassword)), trustAnchorCertificate: \(String(describing: trustAnchorCertificate)))"}
}

extension CreateCustomKeyStoreInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudHsmClusterId = "CloudHsmClusterId"
        case customKeyStoreName = "CustomKeyStoreName"
        case keyStorePassword = "KeyStorePassword"
        case trustAnchorCertificate = "TrustAnchorCertificate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudHsmClusterId = cloudHsmClusterId {
            try encodeContainer.encode(cloudHsmClusterId, forKey: .cloudHsmClusterId)
        }
        if let customKeyStoreName = customKeyStoreName {
            try encodeContainer.encode(customKeyStoreName, forKey: .customKeyStoreName)
        }
        if let keyStorePassword = keyStorePassword {
            try encodeContainer.encode(keyStorePassword, forKey: .keyStorePassword)
        }
        if let trustAnchorCertificate = trustAnchorCertificate {
            try encodeContainer.encode(trustAnchorCertificate, forKey: .trustAnchorCertificate)
        }
    }
}

public struct CreateCustomKeyStoreInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCustomKeyStoreInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomKeyStoreInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomKeyStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomKeyStoreInput>
    public typealias MOutput = OperationOutput<CreateCustomKeyStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomKeyStoreOutputError>
}

public struct CreateCustomKeyStoreInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCustomKeyStoreInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomKeyStoreInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomKeyStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomKeyStoreInput>
    public typealias MOutput = OperationOutput<CreateCustomKeyStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomKeyStoreOutputError>
}

public struct CreateCustomKeyStoreInput: Equatable {
    /// <p>Identifies the AWS CloudHSM cluster for the custom key store. Enter the cluster ID of any active
    ///       AWS CloudHSM cluster that is not already associated with a custom key store. To find the cluster ID,
    ///       use the <a href="https://docs.aws.amazon.com/cloudhsm/latest/APIReference/API_DescribeClusters.html">DescribeClusters</a> operation.</p>
    public let cloudHsmClusterId: String?
    /// <p>Specifies a friendly name for the custom key store. The name must be unique in your AWS
    ///       account.</p>
    public let customKeyStoreName: String?
    /// <p>Enter the password of the <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-store-concepts.html#concept-kmsuser">
    ///                <code>kmsuser</code> crypto user
    ///         (CU) account</a> in the specified AWS CloudHSM cluster. AWS KMS logs into the cluster as this
    ///       user to manage key material on your behalf.</p>
    ///          <p>The password must be a string of 7 to 32 characters. Its value is case sensitive.</p>
    ///          <p>This parameter tells AWS KMS the <code>kmsuser</code> account password; it does not change
    ///       the password in the AWS CloudHSM cluster.</p>
    public let keyStorePassword: String?
    /// <p>Enter the content of the trust anchor certificate for the cluster. This is the content of
    ///       the <code>customerCA.crt</code> file that you created when you <a href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/initialize-cluster.html">initialized the cluster</a>.</p>
    public let trustAnchorCertificate: String?

    public init (
        cloudHsmClusterId: String? = nil,
        customKeyStoreName: String? = nil,
        keyStorePassword: String? = nil,
        trustAnchorCertificate: String? = nil
    )
    {
        self.cloudHsmClusterId = cloudHsmClusterId
        self.customKeyStoreName = customKeyStoreName
        self.keyStorePassword = keyStorePassword
        self.trustAnchorCertificate = trustAnchorCertificate
    }
}

struct CreateCustomKeyStoreInputBody: Equatable {
    public let customKeyStoreName: String?
    public let cloudHsmClusterId: String?
    public let trustAnchorCertificate: String?
    public let keyStorePassword: String?
}

extension CreateCustomKeyStoreInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cloudHsmClusterId = "CloudHsmClusterId"
        case customKeyStoreName = "CustomKeyStoreName"
        case keyStorePassword = "KeyStorePassword"
        case trustAnchorCertificate = "TrustAnchorCertificate"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customKeyStoreNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customKeyStoreName)
        customKeyStoreName = customKeyStoreNameDecoded
        let cloudHsmClusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudHsmClusterId)
        cloudHsmClusterId = cloudHsmClusterIdDecoded
        let trustAnchorCertificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trustAnchorCertificate)
        trustAnchorCertificate = trustAnchorCertificateDecoded
        let keyStorePasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyStorePassword)
        keyStorePassword = keyStorePasswordDecoded
    }
}

extension CreateCustomKeyStoreOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCustomKeyStoreOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmClusterInUseException" : self = .cloudHsmClusterInUseException(try CloudHsmClusterInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmClusterInvalidConfigurationException" : self = .cloudHsmClusterInvalidConfigurationException(try CloudHsmClusterInvalidConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmClusterNotActiveException" : self = .cloudHsmClusterNotActiveException(try CloudHsmClusterNotActiveException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmClusterNotFoundException" : self = .cloudHsmClusterNotFoundException(try CloudHsmClusterNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CustomKeyStoreNameInUseException" : self = .customKeyStoreNameInUseException(try CustomKeyStoreNameInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectTrustAnchorException" : self = .incorrectTrustAnchorException(try IncorrectTrustAnchorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCustomKeyStoreOutputError: Equatable {
    case cloudHsmClusterInUseException(CloudHsmClusterInUseException)
    case cloudHsmClusterInvalidConfigurationException(CloudHsmClusterInvalidConfigurationException)
    case cloudHsmClusterNotActiveException(CloudHsmClusterNotActiveException)
    case cloudHsmClusterNotFoundException(CloudHsmClusterNotFoundException)
    case customKeyStoreNameInUseException(CustomKeyStoreNameInUseException)
    case incorrectTrustAnchorException(IncorrectTrustAnchorException)
    case kMSInternalException(KMSInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCustomKeyStoreOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCustomKeyStoreOutputResponse(customKeyStoreId: \(String(describing: customKeyStoreId)))"}
}

extension CreateCustomKeyStoreOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateCustomKeyStoreOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.customKeyStoreId = output.customKeyStoreId
        } else {
            self.customKeyStoreId = nil
        }
    }
}

public struct CreateCustomKeyStoreOutputResponse: Equatable {
    /// <p>A unique identifier for the new custom key store.</p>
    public let customKeyStoreId: String?

    public init (
        customKeyStoreId: String? = nil
    )
    {
        self.customKeyStoreId = customKeyStoreId
    }
}

struct CreateCustomKeyStoreOutputResponseBody: Equatable {
    public let customKeyStoreId: String?
}

extension CreateCustomKeyStoreOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customKeyStoreId = "CustomKeyStoreId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customKeyStoreIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customKeyStoreId)
        customKeyStoreId = customKeyStoreIdDecoded
    }
}

public struct CreateGrantInputBodyMiddleware: Middleware {
    public let id: String = "CreateGrantInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGrantInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGrantInput>
    public typealias MOutput = OperationOutput<CreateGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGrantOutputError>
}

extension CreateGrantInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGrantInput(constraints: \(String(describing: constraints)), grantTokens: \(String(describing: grantTokens)), granteePrincipal: \(String(describing: granteePrincipal)), keyId: \(String(describing: keyId)), name: \(String(describing: name)), operations: \(String(describing: operations)), retiringPrincipal: \(String(describing: retiringPrincipal)))"}
}

extension CreateGrantInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case constraints = "Constraints"
        case grantTokens = "GrantTokens"
        case granteePrincipal = "GranteePrincipal"
        case keyId = "KeyId"
        case name = "Name"
        case operations = "Operations"
        case retiringPrincipal = "RetiringPrincipal"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let constraints = constraints {
            try encodeContainer.encode(constraints, forKey: .constraints)
        }
        if let grantTokens = grantTokens {
            var grantTokensContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantTokens)
            for granttokenlist0 in grantTokens {
                try grantTokensContainer.encode(granttokenlist0)
            }
        }
        if let granteePrincipal = granteePrincipal {
            try encodeContainer.encode(granteePrincipal, forKey: .granteePrincipal)
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let operations = operations {
            var operationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operations)
            for grantoperationlist0 in operations {
                try operationsContainer.encode(grantoperationlist0.rawValue)
            }
        }
        if let retiringPrincipal = retiringPrincipal {
            try encodeContainer.encode(retiringPrincipal, forKey: .retiringPrincipal)
        }
    }
}

public struct CreateGrantInputHeadersMiddleware: Middleware {
    public let id: String = "CreateGrantInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGrantInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGrantInput>
    public typealias MOutput = OperationOutput<CreateGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGrantOutputError>
}

public struct CreateGrantInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateGrantInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGrantInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGrantInput>
    public typealias MOutput = OperationOutput<CreateGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGrantOutputError>
}

public struct CreateGrantInput: Equatable {
    /// <p>Allows a <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations">cryptographic operation</a> only when the encryption context matches or includes the encryption
    ///       context specified in this structure. For more information about encryption context, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context">Encryption
    ///         Context</a> in the <i>
    ///                <i>AWS Key Management Service Developer Guide</i>
    ///             </i>.</p>
    ///          <p>Grant constraints are not applied to operations that do not support an encryption context,
    ///       such as cryptographic operations with asymmetric CMKs and management operations, such as
    ///       <a>DescribeKey</a> or <a>RetireGrant</a>.</p>
    public let constraints: GrantConstraints?
    /// <p>A list of grant tokens.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#grant_token">Grant Tokens</a> in the
    ///     <i>AWS Key Management Service Developer Guide</i>.</p>
    public let grantTokens: [String]?
    /// <p>The principal that is given permission to perform the operations that the grant
    ///       permits.</p>
    ///          <p>To specify the principal, use the <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Name (ARN)</a> of an AWS
    ///       principal. Valid AWS principals include AWS accounts (root), IAM users, IAM roles, federated
    ///       users, and assumed role users. For examples of the ARN syntax to use for specifying a
    ///       principal, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-iam">AWS Identity and Access
    ///         Management (IAM)</a> in the Example ARNs section of the <i>AWS General
    ///         Reference</i>.</p>
    public let granteePrincipal: String?
    /// <p>The unique identifier for the customer master key (CMK) that the grant applies to.</p>
    ///
    ///          <p>Specify the key ID or the Amazon Resource Name (ARN) of the CMK. To specify a CMK in a
    /// different AWS account, you must use the key ARN.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
    public let keyId: String?
    /// <p>A friendly name for the grant. Use this value to prevent the unintended
    ///       creation of duplicate grants when retrying this request.</p>
    ///          <p>When this value is absent, all <code>CreateGrant</code> requests result in a new grant
    ///       with a unique <code>GrantId</code> even if all the supplied parameters are identical. This can
    ///       result in unintended duplicates when you retry the <code>CreateGrant</code> request.</p>
    ///          <p>When this value is present, you can retry a <code>CreateGrant</code> request with
    ///       identical parameters; if the grant already exists, the original <code>GrantId</code> is
    ///       returned without creating a new grant. Note that the returned grant token is unique with every
    ///         <code>CreateGrant</code> request, even when a duplicate <code>GrantId</code> is returned.
    ///       All grant tokens for the same grant ID can be used interchangeably.</p>
    public let name: String?
    /// <p>A list of operations that the grant permits.</p>
    public let operations: [GrantOperation]?
    /// <p>The principal that is given permission to retire the grant by using <a>RetireGrant</a> operation.</p>
    ///          <p>To specify the principal, use the <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Name (ARN)</a> of an AWS
    ///       principal. Valid AWS principals include AWS accounts (root), IAM users, federated users, and
    ///       assumed role users. For examples of the ARN syntax to use for specifying a principal, see
    ///         <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-iam">AWS Identity and Access Management (IAM)</a> in the Example ARNs section of the
    ///         <i>AWS General Reference</i>.</p>
    public let retiringPrincipal: String?

    public init (
        constraints: GrantConstraints? = nil,
        grantTokens: [String]? = nil,
        granteePrincipal: String? = nil,
        keyId: String? = nil,
        name: String? = nil,
        operations: [GrantOperation]? = nil,
        retiringPrincipal: String? = nil
    )
    {
        self.constraints = constraints
        self.grantTokens = grantTokens
        self.granteePrincipal = granteePrincipal
        self.keyId = keyId
        self.name = name
        self.operations = operations
        self.retiringPrincipal = retiringPrincipal
    }
}

struct CreateGrantInputBody: Equatable {
    public let keyId: String?
    public let granteePrincipal: String?
    public let retiringPrincipal: String?
    public let operations: [GrantOperation]?
    public let constraints: GrantConstraints?
    public let grantTokens: [String]?
    public let name: String?
}

extension CreateGrantInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case constraints = "Constraints"
        case grantTokens = "GrantTokens"
        case granteePrincipal = "GranteePrincipal"
        case keyId = "KeyId"
        case name = "Name"
        case operations = "Operations"
        case retiringPrincipal = "RetiringPrincipal"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let granteePrincipalDecoded = try containerValues.decodeIfPresent(String.self, forKey: .granteePrincipal)
        granteePrincipal = granteePrincipalDecoded
        let retiringPrincipalDecoded = try containerValues.decodeIfPresent(String.self, forKey: .retiringPrincipal)
        retiringPrincipal = retiringPrincipalDecoded
        let operationsContainer = try containerValues.decodeIfPresent([GrantOperation?].self, forKey: .operations)
        var operationsDecoded0:[GrantOperation]? = nil
        if let operationsContainer = operationsContainer {
            operationsDecoded0 = [GrantOperation]()
            for string0 in operationsContainer {
                if let string0 = string0 {
                    operationsDecoded0?.append(string0)
                }
            }
        }
        operations = operationsDecoded0
        let constraintsDecoded = try containerValues.decodeIfPresent(GrantConstraints.self, forKey: .constraints)
        constraints = constraintsDecoded
        let grantTokensContainer = try containerValues.decodeIfPresent([String?].self, forKey: .grantTokens)
        var grantTokensDecoded0:[String]? = nil
        if let grantTokensContainer = grantTokensContainer {
            grantTokensDecoded0 = [String]()
            for string0 in grantTokensContainer {
                if let string0 = string0 {
                    grantTokensDecoded0?.append(string0)
                }
            }
        }
        grantTokens = grantTokensDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateGrantOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGrantOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledException" : self = .disabledException(try DisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGrantTokenException" : self = .invalidGrantTokenException(try InvalidGrantTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGrantOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case disabledException(DisabledException)
    case invalidArnException(InvalidArnException)
    case invalidGrantTokenException(InvalidGrantTokenException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGrantOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGrantOutputResponse(grantId: \(String(describing: grantId)), grantToken: \(String(describing: grantToken)))"}
}

extension CreateGrantOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateGrantOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.grantId = output.grantId
            self.grantToken = output.grantToken
        } else {
            self.grantId = nil
            self.grantToken = nil
        }
    }
}

public struct CreateGrantOutputResponse: Equatable {
    /// <p>The unique identifier for the grant.</p>
    ///          <p>You can use the <code>GrantId</code> in a <a>ListGrants</a>, <a>RetireGrant</a>, or <a>RevokeGrant</a> operation.</p>
    public let grantId: String?
    /// <p>The grant token.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#grant_token">Grant Tokens</a> in the
    ///     <i>AWS Key Management Service Developer Guide</i>.</p>
    public let grantToken: String?

    public init (
        grantId: String? = nil,
        grantToken: String? = nil
    )
    {
        self.grantId = grantId
        self.grantToken = grantToken
    }
}

struct CreateGrantOutputResponseBody: Equatable {
    public let grantToken: String?
    public let grantId: String?
}

extension CreateGrantOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case grantId = "GrantId"
        case grantToken = "GrantToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grantToken)
        grantToken = grantTokenDecoded
        let grantIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grantId)
        grantId = grantIdDecoded
    }
}

public struct CreateKeyInputBodyMiddleware: Middleware {
    public let id: String = "CreateKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateKeyInput>
    public typealias MOutput = OperationOutput<CreateKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateKeyOutputError>
}

extension CreateKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateKeyInput(bypassPolicyLockoutSafetyCheck: \(String(describing: bypassPolicyLockoutSafetyCheck)), customKeyStoreId: \(String(describing: customKeyStoreId)), customerMasterKeySpec: \(String(describing: customerMasterKeySpec)), description: \(String(describing: description)), keyUsage: \(String(describing: keyUsage)), origin: \(String(describing: origin)), policy: \(String(describing: policy)), tags: \(String(describing: tags)))"}
}

extension CreateKeyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bypassPolicyLockoutSafetyCheck = "BypassPolicyLockoutSafetyCheck"
        case customKeyStoreId = "CustomKeyStoreId"
        case customerMasterKeySpec = "CustomerMasterKeySpec"
        case description = "Description"
        case keyUsage = "KeyUsage"
        case origin = "Origin"
        case policy = "Policy"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if bypassPolicyLockoutSafetyCheck != false {
            try encodeContainer.encode(bypassPolicyLockoutSafetyCheck, forKey: .bypassPolicyLockoutSafetyCheck)
        }
        if let customKeyStoreId = customKeyStoreId {
            try encodeContainer.encode(customKeyStoreId, forKey: .customKeyStoreId)
        }
        if let customerMasterKeySpec = customerMasterKeySpec {
            try encodeContainer.encode(customerMasterKeySpec.rawValue, forKey: .customerMasterKeySpec)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let keyUsage = keyUsage {
            try encodeContainer.encode(keyUsage.rawValue, forKey: .keyUsage)
        }
        if let origin = origin {
            try encodeContainer.encode(origin.rawValue, forKey: .origin)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateKeyInputHeadersMiddleware: Middleware {
    public let id: String = "CreateKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateKeyInput>
    public typealias MOutput = OperationOutput<CreateKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateKeyOutputError>
}

public struct CreateKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateKeyInput>
    public typealias MOutput = OperationOutput<CreateKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateKeyOutputError>
}

public struct CreateKeyInput: Equatable {
    /// <p>A flag to indicate whether to bypass the key policy lockout safety check.</p>
    ///          <important>
    ///             <p>Setting this value to true increases the risk that the CMK becomes unmanageable. Do not
    ///         set this value to true indiscriminately.</p>
    ///             <p>For more information, refer to the scenario in the <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html#key-policy-default-allow-root-enable-iam">Default Key Policy</a> section in the <i>
    ///                   <i>AWS Key Management Service Developer Guide</i>
    ///                </i>.</p>
    ///          </important>
    ///          <p>Use this parameter only when you include a policy in the request and you intend to prevent
    ///       the principal that is making the request from making a subsequent <a>PutKeyPolicy</a> request on the CMK.</p>
    ///          <p>The default value is false.</p>
    public let bypassPolicyLockoutSafetyCheck: Bool
    /// <p>Creates the CMK in the specified <a href="https://docs.aws.amazon.com/kms/latest/developerguide/custom-key-store-overview.html">custom key store</a> and the key material in its associated
    ///       AWS CloudHSM cluster. To create a CMK in a custom key store, you must also specify the
    ///         <code>Origin</code> parameter with a value of <code>AWS_CLOUDHSM</code>. The AWS CloudHSM cluster
    ///       that is associated with the custom key store must have at least two active HSMs, each in a
    ///       different Availability Zone in the Region.</p>
    ///          <p>This parameter is valid only for symmetric CMKs. You cannot create an asymmetric CMK in a
    ///       custom key store.</p>
    ///          <p>To find the ID of a custom key store, use the <a>DescribeCustomKeyStores</a> operation.</p>
    ///          <p>The response includes the custom key store ID and the ID of the AWS CloudHSM cluster.</p>
    ///          <p>This operation is part of the <a href="https://docs.aws.amazon.com/kms/latest/developerguide/custom-key-store-overview.html">Custom Key Store feature</a> feature in AWS KMS, which
    /// combines the convenience and extensive integration of AWS KMS with the isolation and control of a
    /// single-tenant key store.</p>
    public let customKeyStoreId: String?
    /// <p>Specifies the type of CMK to create. The default value, <code>SYMMETRIC_DEFAULT</code>,
    ///       creates a CMK with a 256-bit symmetric key for encryption and decryption. For help choosing a
    ///       key spec for your CMK, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symm-asymm-choose.html">How to Choose Your CMK
    ///         Configuration</a> in the <i>AWS Key Management Service Developer
    ///           Guide</i>.</p>
    ///          <p>The <code>CustomerMasterKeySpec</code> determines whether the CMK contains a symmetric key
    ///       or an asymmetric key pair. It also determines the encryption algorithms or signing algorithms
    ///       that the CMK supports. You can't change the <code>CustomerMasterKeySpec</code> after the CMK
    ///       is created. To further restrict the algorithms that can be used with the CMK, use a condition
    ///       key in its key policy or IAM policy. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/policy-conditions.html#conditions-kms-encryption-algorithm">kms:EncryptionAlgorithm</a> or <a href="https://docs.aws.amazon.com/kms/latest/developerguide/policy-conditions.html#conditions-kms-signing-algorithm">kms:Signing Algorithm</a> in the <i>AWS Key Management Service Developer
    ///         Guide</i>.</p>
    ///          <important>
    ///             <p>
    ///                <a href="http://aws.amazon.com/kms/features/#AWS_Service_Integration">AWS services that
    ///         are integrated with AWS KMS</a> use symmetric CMKs to protect your data. These
    ///         services do not support asymmetric CMKs. For help determining whether a CMK is symmetric or
    ///         asymmetric, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/find-symm-asymm.html">Identifying Symmetric and Asymmetric
    ///           CMKs</a> in the <i>AWS Key Management Service Developer
    ///             Guide</i>.</p>
    ///          </important>
    ///          <p>AWS KMS supports the following key specs for CMKs:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Symmetric key (default)</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>SYMMETRIC_DEFAULT</code> (AES-256-GCM)</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>Asymmetric RSA key pairs</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>RSA_2048</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>RSA_3072</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>RSA_4096</code>
    ///                      </p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>Asymmetric NIST-recommended elliptic curve key pairs</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>ECC_NIST_P256</code> (secp256r1)</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>ECC_NIST_P384</code> (secp384r1)</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>ECC_NIST_P521</code> (secp521r1)</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>Other asymmetric elliptic curve key pairs</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>ECC_SECG_P256K1</code> (secp256k1), commonly used for
    ///               cryptocurrencies.</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let customerMasterKeySpec: CustomerMasterKeySpec?
    /// <p>A description of the CMK.</p>
    ///          <p>Use a description that helps you decide whether the CMK is appropriate for a task.</p>
    public let description: String?
    /// <p>Determines the <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations">cryptographic operations</a> for which you can use the CMK. The default value
    ///       is <code>ENCRYPT_DECRYPT</code>. This parameter is required only for asymmetric CMKs. You
    ///       can't change the <code>KeyUsage</code> value after the CMK is created.</p>
    ///          <p>Select only one valid value.</p>
    ///          <ul>
    ///             <li>
    ///                <p>For symmetric CMKs, omit the parameter or specify <code>ENCRYPT_DECRYPT</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>For asymmetric CMKs with RSA key material, specify <code>ENCRYPT_DECRYPT</code> or
    ///             <code>SIGN_VERIFY</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>For asymmetric CMKs with ECC key material, specify <code>SIGN_VERIFY</code>.</p>
    ///             </li>
    ///          </ul>
    public let keyUsage: KeyUsageType?
    /// <p>The source of the key material for the CMK. You cannot change the origin after you create
    ///       the CMK. The default is <code>AWS_KMS</code>, which means AWS KMS creates the key
    ///       material.</p>
    ///          <p>When the parameter value is <code>EXTERNAL</code>, AWS KMS creates a CMK without key
    ///       material so that you can import key material from your existing key management infrastructure.
    ///       For more information about importing key material into AWS KMS, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/importing-keys.html">Importing Key Material</a> in the
    ///       <i>AWS Key Management Service Developer Guide</i>. This value is valid only for symmetric CMKs.</p>
    ///          <p>When the parameter value is <code>AWS_CLOUDHSM</code>, AWS KMS creates the CMK in an AWS KMS
    ///       <a href="https://docs.aws.amazon.com/kms/latest/developerguide/custom-key-store-overview.html">custom key store</a> and creates its key material in the associated AWS CloudHSM cluster. You must also
    ///       use the <code>CustomKeyStoreId</code> parameter to identify the custom key store. This value
    ///       is valid only for symmetric CMKs.</p>
    public let origin: OriginType?
    /// <p>The key policy to attach to the CMK.</p>
    ///          <p>If you provide a key policy, it must meet the following criteria:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If you don't set <code>BypassPolicyLockoutSafetyCheck</code> to true, the key policy
    ///           must allow the principal that is making the <code>CreateKey</code> request to make a
    ///           subsequent <a>PutKeyPolicy</a> request on the CMK. This reduces the risk that
    ///           the CMK becomes unmanageable. For more information, refer to the scenario in the <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html#key-policy-default-allow-root-enable-iam">Default Key Policy</a> section of the <i>
    ///                      <i>AWS Key Management Service Developer Guide</i>
    ///                   </i>.</p>
    ///             </li>
    ///             <li>
    ///                <p>Each statement in the key policy must contain one or more principals. The principals
    ///           in the key policy must exist and be visible to AWS KMS. When you create a new AWS principal
    ///           (for example, an IAM user or role), you might need to enforce a delay before including the
    ///           new principal in a key policy because the new principal might not be immediately visible
    ///           to AWS KMS. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/troubleshoot_general.html#troubleshoot_general_eventual-consistency">Changes that I make are not always immediately visible</a> in the <i>AWS
    ///             Identity and Access Management User Guide</i>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If you do not provide a key policy, AWS KMS attaches a default key policy to the CMK. For
    ///       more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html#key-policy-default">Default Key Policy</a> in the
    ///       <i>AWS Key Management Service Developer Guide</i>. </p>
    ///          <p>The key policy size quota is 32 kilobytes (32768 bytes).</p>
    ///          <p>For help writing and formatting a JSON policy document, see the <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies.html">IAM JSON Policy Reference</a> in the <i>
    ///                <i>IAM User Guide</i>
    ///             </i>.</p>
    public let policy: String?
    /// <p>One or more tags. Each tag consists of a tag key and a tag value. Both the tag key and the
    ///       tag value are required, but the tag value can be an empty (null) string. </p>
    ///          <p>When you add tags to an AWS resource, AWS generates a cost allocation
    ///               report with usage and costs aggregated by tags. For information about adding, changing, deleting and listing tags for CMKs,
    ///               see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/tagging-keys.html">Tagging Keys</a>.</p>
    ///          <p>Use this parameter to tag the CMK when it is created. To add tags to an
    ///       existing CMK, use the <a>TagResource</a> operation.</p>
    ///          <p>To use this parameter, you must have <a href="https://docs.aws.amazon.com/kms/latest/developerguide/kms-api-permissions-reference.html">kms:TagResource</a> permission in an IAM policy.</p>
    public let tags: [Tag]?

    public init (
        bypassPolicyLockoutSafetyCheck: Bool = false,
        customKeyStoreId: String? = nil,
        customerMasterKeySpec: CustomerMasterKeySpec? = nil,
        description: String? = nil,
        keyUsage: KeyUsageType? = nil,
        origin: OriginType? = nil,
        policy: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.bypassPolicyLockoutSafetyCheck = bypassPolicyLockoutSafetyCheck
        self.customKeyStoreId = customKeyStoreId
        self.customerMasterKeySpec = customerMasterKeySpec
        self.description = description
        self.keyUsage = keyUsage
        self.origin = origin
        self.policy = policy
        self.tags = tags
    }
}

struct CreateKeyInputBody: Equatable {
    public let policy: String?
    public let description: String?
    public let keyUsage: KeyUsageType?
    public let customerMasterKeySpec: CustomerMasterKeySpec?
    public let origin: OriginType?
    public let customKeyStoreId: String?
    public let bypassPolicyLockoutSafetyCheck: Bool
    public let tags: [Tag]?
}

extension CreateKeyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bypassPolicyLockoutSafetyCheck = "BypassPolicyLockoutSafetyCheck"
        case customKeyStoreId = "CustomKeyStoreId"
        case customerMasterKeySpec = "CustomerMasterKeySpec"
        case description = "Description"
        case keyUsage = "KeyUsage"
        case origin = "Origin"
        case policy = "Policy"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let keyUsageDecoded = try containerValues.decodeIfPresent(KeyUsageType.self, forKey: .keyUsage)
        keyUsage = keyUsageDecoded
        let customerMasterKeySpecDecoded = try containerValues.decodeIfPresent(CustomerMasterKeySpec.self, forKey: .customerMasterKeySpec)
        customerMasterKeySpec = customerMasterKeySpecDecoded
        let originDecoded = try containerValues.decodeIfPresent(OriginType.self, forKey: .origin)
        origin = originDecoded
        let customKeyStoreIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customKeyStoreId)
        customKeyStoreId = customKeyStoreIdDecoded
        let bypassPolicyLockoutSafetyCheckDecoded = try containerValues.decode(Bool.self, forKey: .bypassPolicyLockoutSafetyCheck)
        bypassPolicyLockoutSafetyCheck = bypassPolicyLockoutSafetyCheckDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmClusterInvalidConfigurationException" : self = .cloudHsmClusterInvalidConfigurationException(try CloudHsmClusterInvalidConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CustomKeyStoreInvalidStateException" : self = .customKeyStoreInvalidStateException(try CustomKeyStoreInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CustomKeyStoreNotFoundException" : self = .customKeyStoreNotFoundException(try CustomKeyStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocumentException" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagException" : self = .tagException(try TagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateKeyOutputError: Equatable {
    case cloudHsmClusterInvalidConfigurationException(CloudHsmClusterInvalidConfigurationException)
    case customKeyStoreInvalidStateException(CustomKeyStoreInvalidStateException)
    case customKeyStoreNotFoundException(CustomKeyStoreNotFoundException)
    case dependencyTimeoutException(DependencyTimeoutException)
    case invalidArnException(InvalidArnException)
    case kMSInternalException(KMSInternalException)
    case limitExceededException(LimitExceededException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case tagException(TagException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateKeyOutputResponse(keyMetadata: \(String(describing: keyMetadata)))"}
}

extension CreateKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateKeyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.keyMetadata = output.keyMetadata
        } else {
            self.keyMetadata = nil
        }
    }
}

public struct CreateKeyOutputResponse: Equatable {
    /// <p>Metadata associated with the CMK.</p>
    public let keyMetadata: KeyMetadata?

    public init (
        keyMetadata: KeyMetadata? = nil
    )
    {
        self.keyMetadata = keyMetadata
    }
}

struct CreateKeyOutputResponseBody: Equatable {
    public let keyMetadata: KeyMetadata?
}

extension CreateKeyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyMetadata = "KeyMetadata"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyMetadataDecoded = try containerValues.decodeIfPresent(KeyMetadata.self, forKey: .keyMetadata)
        keyMetadata = keyMetadataDecoded
    }
}

extension CustomKeyStoreHasCMKsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomKeyStoreHasCMKsException(message: \(String(describing: message)))"}
}

extension CustomKeyStoreHasCMKsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CustomKeyStoreHasCMKsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the custom key store contains AWS KMS customer master keys
///       (CMKs). After verifying that you do not need to use the CMKs, use the <a>ScheduleKeyDeletion</a> operation to delete the CMKs. After they are deleted, you
///       can delete the custom key store.</p>
public struct CustomKeyStoreHasCMKsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CustomKeyStoreHasCMKsExceptionBody: Equatable {
    public let message: String?
}

extension CustomKeyStoreHasCMKsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CustomKeyStoreInvalidStateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomKeyStoreInvalidStateException(message: \(String(describing: message)))"}
}

extension CustomKeyStoreInvalidStateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CustomKeyStoreInvalidStateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because of the <code>ConnectionState</code> of the custom key
///       store. To get the <code>ConnectionState</code> of a custom key store, use the <a>DescribeCustomKeyStores</a> operation.</p>
///          <p>This exception is thrown under the following conditions:</p>
///          <ul>
///             <li>
///                <p>You requested the <a>CreateKey</a> or <a>GenerateRandom</a>
///           operation in a custom key store that is not connected. These operations are valid only
///           when the custom key store <code>ConnectionState</code> is <code>CONNECTED</code>.</p>
///             </li>
///             <li>
///                <p>You requested the <a>UpdateCustomKeyStore</a> or <a>DeleteCustomKeyStore</a> operation on a custom key store that is not
///           disconnected. This operation is valid only when the custom key store
///             <code>ConnectionState</code> is <code>DISCONNECTED</code>.</p>
///             </li>
///             <li>
///                <p>You requested the <a>ConnectCustomKeyStore</a> operation on a custom key
///           store with a <code>ConnectionState</code> of <code>DISCONNECTING</code> or
///             <code>FAILED</code>. This operation is valid for all other <code>ConnectionState</code>
///           values.</p>
///             </li>
///          </ul>
public struct CustomKeyStoreInvalidStateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CustomKeyStoreInvalidStateExceptionBody: Equatable {
    public let message: String?
}

extension CustomKeyStoreInvalidStateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CustomKeyStoreNameInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomKeyStoreNameInUseException(message: \(String(describing: message)))"}
}

extension CustomKeyStoreNameInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CustomKeyStoreNameInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the specified custom key store name is already assigned
///       to another custom key store in the account. Try again with a custom key store name that is
///       unique in the account.</p>
public struct CustomKeyStoreNameInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CustomKeyStoreNameInUseExceptionBody: Equatable {
    public let message: String?
}

extension CustomKeyStoreNameInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CustomKeyStoreNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomKeyStoreNotFoundException(message: \(String(describing: message)))"}
}

extension CustomKeyStoreNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CustomKeyStoreNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because AWS KMS cannot find a custom key store with the specified
///       key store name or ID.</p>
public struct CustomKeyStoreNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CustomKeyStoreNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension CustomKeyStoreNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CustomKeyStoresListEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudHsmClusterId = "CloudHsmClusterId"
        case connectionErrorCode = "ConnectionErrorCode"
        case connectionState = "ConnectionState"
        case creationDate = "CreationDate"
        case customKeyStoreId = "CustomKeyStoreId"
        case customKeyStoreName = "CustomKeyStoreName"
        case trustAnchorCertificate = "TrustAnchorCertificate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudHsmClusterId = cloudHsmClusterId {
            try encodeContainer.encode(cloudHsmClusterId, forKey: .cloudHsmClusterId)
        }
        if let connectionErrorCode = connectionErrorCode {
            try encodeContainer.encode(connectionErrorCode.rawValue, forKey: .connectionErrorCode)
        }
        if let connectionState = connectionState {
            try encodeContainer.encode(connectionState.rawValue, forKey: .connectionState)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let customKeyStoreId = customKeyStoreId {
            try encodeContainer.encode(customKeyStoreId, forKey: .customKeyStoreId)
        }
        if let customKeyStoreName = customKeyStoreName {
            try encodeContainer.encode(customKeyStoreName, forKey: .customKeyStoreName)
        }
        if let trustAnchorCertificate = trustAnchorCertificate {
            try encodeContainer.encode(trustAnchorCertificate, forKey: .trustAnchorCertificate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customKeyStoreIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customKeyStoreId)
        customKeyStoreId = customKeyStoreIdDecoded
        let customKeyStoreNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customKeyStoreName)
        customKeyStoreName = customKeyStoreNameDecoded
        let cloudHsmClusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudHsmClusterId)
        cloudHsmClusterId = cloudHsmClusterIdDecoded
        let trustAnchorCertificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trustAnchorCertificate)
        trustAnchorCertificate = trustAnchorCertificateDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(ConnectionStateType.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let connectionErrorCodeDecoded = try containerValues.decodeIfPresent(ConnectionErrorCodeType.self, forKey: .connectionErrorCode)
        connectionErrorCode = connectionErrorCodeDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension CustomKeyStoresListEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomKeyStoresListEntry(cloudHsmClusterId: \(String(describing: cloudHsmClusterId)), connectionErrorCode: \(String(describing: connectionErrorCode)), connectionState: \(String(describing: connectionState)), creationDate: \(String(describing: creationDate)), customKeyStoreId: \(String(describing: customKeyStoreId)), customKeyStoreName: \(String(describing: customKeyStoreName)), trustAnchorCertificate: \(String(describing: trustAnchorCertificate)))"}
}

/// <p>Contains information about each custom key store in the custom key store list.</p>
public struct CustomKeyStoresListEntry: Equatable {
    /// <p>A unique identifier for the AWS CloudHSM cluster that is associated with the custom key
    ///       store.</p>
    public let cloudHsmClusterId: String?
    /// <p>Describes the connection error. This field appears in the response only when the <code>ConnectionState</code> is <code>FAILED</code>. For help resolving these errors, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/fix-keystore.html#fix-keystore-failed">How to Fix a Connection Failure</a> in <i>AWS Key Management Service Developer Guide</i>.</p>
    ///          <p>Valid values are:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CLUSTER_NOT_FOUND</code> - AWS KMS cannot find the AWS CloudHSM cluster with the
    ///           specified cluster ID.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INSUFFICIENT_CLOUDHSM_HSMS</code> - The associated AWS CloudHSM cluster does not
    ///           contain any active HSMs. To connect a custom key store to its AWS CloudHSM cluster, the cluster
    ///           must contain at least one active HSM.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INTERNAL_ERROR</code> - AWS KMS could not complete the request due to an internal
    ///           error. Retry the request. For <code>ConnectCustomKeyStore</code> requests, disconnect the
    ///           custom key store before trying to connect again.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INVALID_CREDENTIALS</code> - AWS KMS does not have the correct password for the
    ///             <code>kmsuser</code> crypto user in the AWS CloudHSM cluster. Before you can connect your
    ///           custom key store to its AWS CloudHSM cluster, you must change the <code>kmsuser</code> account
    ///           password and update the key store password value for the custom key store.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NETWORK_ERRORS</code> - Network errors are preventing AWS KMS from connecting to
    ///           the custom key store.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SUBNET_NOT_FOUND</code> - A subnet in the AWS CloudHSM cluster
    ///           configuration was deleted. If AWS KMS cannot find all of the subnets in the cluster configuration, attempts to connect the custom key store to the AWS CloudHSM cluster fail. To fix this error, create a cluster from a recent backup and associate it with your custom key store. (This process creates a new cluster configuration with a VPC and private subnets.) For details, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/fix-keystore.html#fix-keystore-failed">How to Fix a Connection Failure</a> in the
    ///           <i>AWS Key Management Service Developer Guide</i>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>USER_LOCKED_OUT</code> - The <code>kmsuser</code> CU account is locked out of
    ///           the associated AWS CloudHSM cluster due to too many failed password attempts. Before you can
    ///           connect your custom key store to its AWS CloudHSM cluster, you must change the
    ///             <code>kmsuser</code> account password and update the key store password value for the custom key
    ///           store.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>USER_LOGGED_IN</code> - The <code>kmsuser</code> CU account is logged into the
    ///           the associated AWS CloudHSM cluster. This prevents AWS KMS from rotating the <code>kmsuser</code> account password and logging into the cluster. Before you can
    ///           connect your custom key store to its AWS CloudHSM cluster, you must log the <code>kmsuser</code> CU out of the cluster. If you changed the <code>kmsuser</code> password to log into the cluster, you must also and update the key store password value for the custom key
    ///           store. For help, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/fix-keystore.html#login-kmsuser-2">How to Log Out and Reconnect</a> in the <i>AWS Key Management Service Developer Guide</i>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>USER_NOT_FOUND</code> - AWS KMS cannot find a <code>kmsuser</code> CU account in the associated AWS CloudHSM cluster. Before you can
    ///           connect your custom key store to its AWS CloudHSM cluster, you must create a <code>kmsuser</code> CU account in the cluster, and then update the key store password value for the custom key
    ///           store.</p>
    ///             </li>
    ///          </ul>
    public let connectionErrorCode: ConnectionErrorCodeType?
    /// <p>Indicates whether the custom key store is connected to its AWS CloudHSM cluster.</p>
    ///          <p>You can create and use CMKs in your custom key stores only when its connection state is
    ///         <code>CONNECTED</code>.</p>
    ///          <p>The value is <code>DISCONNECTED</code> if the key store has never been connected or you
    ///       use the <a>DisconnectCustomKeyStore</a> operation to disconnect it. If the value is
    ///         <code>CONNECTED</code> but you are having trouble using the custom key store, make sure that
    ///       its associated AWS CloudHSM cluster is active and contains at least one active HSM.</p>
    ///          <p>A value of <code>FAILED</code> indicates that an attempt to connect was unsuccessful. The <code>ConnectionErrorCode</code> field in the response indicates the cause of the failure. For
    ///       help resolving a connection failure, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/fix-keystore.html">Troubleshooting a Custom Key Store</a> in the
    ///       <i>AWS Key Management Service Developer Guide</i>.</p>
    public let connectionState: ConnectionStateType?
    /// <p>The date and time when the custom key store was created.</p>
    public let creationDate: Date?
    /// <p>A unique identifier for the custom key store.</p>
    public let customKeyStoreId: String?
    /// <p>The user-specified friendly name for the custom key store.</p>
    public let customKeyStoreName: String?
    /// <p>The trust anchor certificate of the associated AWS CloudHSM cluster. When you <a href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/initialize-cluster.html#sign-csr">initialize the
    ///         cluster</a>, you create this certificate and save it in the <code>customerCA.crt</code>
    ///       file.</p>
    public let trustAnchorCertificate: String?

    public init (
        cloudHsmClusterId: String? = nil,
        connectionErrorCode: ConnectionErrorCodeType? = nil,
        connectionState: ConnectionStateType? = nil,
        creationDate: Date? = nil,
        customKeyStoreId: String? = nil,
        customKeyStoreName: String? = nil,
        trustAnchorCertificate: String? = nil
    )
    {
        self.cloudHsmClusterId = cloudHsmClusterId
        self.connectionErrorCode = connectionErrorCode
        self.connectionState = connectionState
        self.creationDate = creationDate
        self.customKeyStoreId = customKeyStoreId
        self.customKeyStoreName = customKeyStoreName
        self.trustAnchorCertificate = trustAnchorCertificate
    }
}

public enum CustomerMasterKeySpec {
    case eccNistP256
    case eccNistP384
    case eccNistP521
    case eccSecgP256k1
    case rsa2048
    case rsa3072
    case rsa4096
    case symmetricDefault
    case sdkUnknown(String)
}

extension CustomerMasterKeySpec : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CustomerMasterKeySpec] {
        return [
            .eccNistP256,
            .eccNistP384,
            .eccNistP521,
            .eccSecgP256k1,
            .rsa2048,
            .rsa3072,
            .rsa4096,
            .symmetricDefault,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .eccNistP256: return "ECC_NIST_P256"
        case .eccNistP384: return "ECC_NIST_P384"
        case .eccNistP521: return "ECC_NIST_P521"
        case .eccSecgP256k1: return "ECC_SECG_P256K1"
        case .rsa2048: return "RSA_2048"
        case .rsa3072: return "RSA_3072"
        case .rsa4096: return "RSA_4096"
        case .symmetricDefault: return "SYMMETRIC_DEFAULT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CustomerMasterKeySpec(rawValue: rawValue) ?? CustomerMasterKeySpec.sdkUnknown(rawValue)
    }
}

public enum DataKeyPairSpec {
    case eccNistP256
    case eccNistP384
    case eccNistP521
    case eccSecgP256k1
    case rsa2048
    case rsa3072
    case rsa4096
    case sdkUnknown(String)
}

extension DataKeyPairSpec : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataKeyPairSpec] {
        return [
            .eccNistP256,
            .eccNistP384,
            .eccNistP521,
            .eccSecgP256k1,
            .rsa2048,
            .rsa3072,
            .rsa4096,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .eccNistP256: return "ECC_NIST_P256"
        case .eccNistP384: return "ECC_NIST_P384"
        case .eccNistP521: return "ECC_NIST_P521"
        case .eccSecgP256k1: return "ECC_SECG_P256K1"
        case .rsa2048: return "RSA_2048"
        case .rsa3072: return "RSA_3072"
        case .rsa4096: return "RSA_4096"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataKeyPairSpec(rawValue: rawValue) ?? DataKeyPairSpec.sdkUnknown(rawValue)
    }
}

public enum DataKeySpec {
    case aes128
    case aes256
    case sdkUnknown(String)
}

extension DataKeySpec : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataKeySpec] {
        return [
            .aes128,
            .aes256,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .aes128: return "AES_128"
        case .aes256: return "AES_256"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataKeySpec(rawValue: rawValue) ?? DataKeySpec.sdkUnknown(rawValue)
    }
}

public struct DecryptInputBodyMiddleware: Middleware {
    public let id: String = "DecryptInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DecryptInput>,
                  next: H) -> Swift.Result<OperationOutput<DecryptOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DecryptInput>
    public typealias MOutput = OperationOutput<DecryptOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DecryptOutputError>
}

extension DecryptInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DecryptInput(ciphertextBlob: \(String(describing: ciphertextBlob)), encryptionAlgorithm: \(String(describing: encryptionAlgorithm)), encryptionContext: \(String(describing: encryptionContext)), grantTokens: \(String(describing: grantTokens)), keyId: \(String(describing: keyId)))"}
}

extension DecryptInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ciphertextBlob = "CiphertextBlob"
        case encryptionAlgorithm = "EncryptionAlgorithm"
        case encryptionContext = "EncryptionContext"
        case grantTokens = "GrantTokens"
        case keyId = "KeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ciphertextBlob = ciphertextBlob {
            try encodeContainer.encode(ciphertextBlob.base64EncodedString(), forKey: .ciphertextBlob)
        }
        if let encryptionAlgorithm = encryptionAlgorithm {
            try encodeContainer.encode(encryptionAlgorithm.rawValue, forKey: .encryptionAlgorithm)
        }
        if let encryptionContext = encryptionContext {
            var encryptionContextContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .encryptionContext)
            for (dictKey0, encryptioncontexttype0) in encryptionContext {
                try encryptionContextContainer.encode(encryptioncontexttype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let grantTokens = grantTokens {
            var grantTokensContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantTokens)
            for granttokenlist0 in grantTokens {
                try grantTokensContainer.encode(granttokenlist0)
            }
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
    }
}

public struct DecryptInputHeadersMiddleware: Middleware {
    public let id: String = "DecryptInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DecryptInput>,
                  next: H) -> Swift.Result<OperationOutput<DecryptOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DecryptInput>
    public typealias MOutput = OperationOutput<DecryptOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DecryptOutputError>
}

public struct DecryptInputQueryItemMiddleware: Middleware {
    public let id: String = "DecryptInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DecryptInput>,
                  next: H) -> Swift.Result<OperationOutput<DecryptOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DecryptInput>
    public typealias MOutput = OperationOutput<DecryptOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DecryptOutputError>
}

public struct DecryptInput: Equatable {
    /// <p>Ciphertext to be decrypted. The blob includes metadata.</p>
    public let ciphertextBlob: Data?
    /// <p>Specifies the encryption algorithm that will be used to decrypt the ciphertext. Specify
    ///       the same algorithm that was used to encrypt the data. If you specify a different algorithm,
    ///       the <code>Decrypt</code> operation fails.</p>
    ///          <p>This parameter is required only when the ciphertext was encrypted under an asymmetric CMK.
    ///       The default value, <code>SYMMETRIC_DEFAULT</code>, represents the only supported algorithm
    ///       that is valid for symmetric CMKs.</p>
    public let encryptionAlgorithm: EncryptionAlgorithmSpec?
    /// <p>Specifies the encryption context to use when decrypting the data.
    ///       An encryption context is valid only for <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations">cryptographic operations</a> with a symmetric CMK. The standard asymmetric encryption algorithms that AWS KMS uses do not support an encryption context.</p>
    ///          <p>An <i>encryption context</i> is a collection of non-secret key-value pairs that represents additional authenticated data. When you use an encryption context to encrypt data, you must specify the same (an exact case-sensitive match) encryption context to decrypt the data. An encryption context is optional when encrypting with a symmetric CMK, but it is highly recommended.</p>
    ///          <p>For more information, see
    ///         <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context">Encryption
    ///         Context</a> in the <i>AWS Key Management Service Developer Guide</i>.</p>
    public let encryptionContext: [String:String]?
    /// <p>A list of grant tokens.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#grant_token">Grant Tokens</a> in the
    ///     <i>AWS Key Management Service Developer Guide</i>.</p>
    public let grantTokens: [String]?
    /// <p>Specifies the customer master key (CMK) that AWS KMS uses to decrypt the ciphertext. Enter a
    ///       key ID of the CMK that was used to encrypt the ciphertext.</p>
    ///          <p>This parameter is required only when the ciphertext was encrypted under an asymmetric CMK.
    ///       If you used a symmetric CMK, AWS KMS can get the CMK from metadata that it adds to the
    ///       symmetric ciphertext blob. However, it is always recommended as a best practice. This practice
    ///       ensures that you use the CMK that you intend.</p>
    ///
    ///          <p>To specify a CMK, use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. When using an alias name, prefix it with <code>"alias/"</code>. To specify a CMK in a different AWS account, you must use the key ARN or alias ARN.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Alias name: <code>alias/ExampleAlias</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Alias ARN: <code>arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>. To get the alias name and alias ARN, use <a>ListAliases</a>.</p>
    public let keyId: String?

    public init (
        ciphertextBlob: Data? = nil,
        encryptionAlgorithm: EncryptionAlgorithmSpec? = nil,
        encryptionContext: [String:String]? = nil,
        grantTokens: [String]? = nil,
        keyId: String? = nil
    )
    {
        self.ciphertextBlob = ciphertextBlob
        self.encryptionAlgorithm = encryptionAlgorithm
        self.encryptionContext = encryptionContext
        self.grantTokens = grantTokens
        self.keyId = keyId
    }
}

struct DecryptInputBody: Equatable {
    public let ciphertextBlob: Data?
    public let encryptionContext: [String:String]?
    public let grantTokens: [String]?
    public let keyId: String?
    public let encryptionAlgorithm: EncryptionAlgorithmSpec?
}

extension DecryptInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ciphertextBlob = "CiphertextBlob"
        case encryptionAlgorithm = "EncryptionAlgorithm"
        case encryptionContext = "EncryptionContext"
        case grantTokens = "GrantTokens"
        case keyId = "KeyId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ciphertextBlobDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .ciphertextBlob)
        ciphertextBlob = ciphertextBlobDecoded
        let encryptionContextContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .encryptionContext)
        var encryptionContextDecoded0: [String:String]? = nil
        if let encryptionContextContainer = encryptionContextContainer {
            encryptionContextDecoded0 = [String:String]()
            for (key0, encryptioncontextvalue0) in encryptionContextContainer {
                if let encryptioncontextvalue0 = encryptioncontextvalue0 {
                    encryptionContextDecoded0?[key0] = encryptioncontextvalue0
                }
            }
        }
        encryptionContext = encryptionContextDecoded0
        let grantTokensContainer = try containerValues.decodeIfPresent([String?].self, forKey: .grantTokens)
        var grantTokensDecoded0:[String]? = nil
        if let grantTokensContainer = grantTokensContainer {
            grantTokensDecoded0 = [String]()
            for string0 in grantTokensContainer {
                if let string0 = string0 {
                    grantTokensDecoded0?.append(string0)
                }
            }
        }
        grantTokens = grantTokensDecoded0
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let encryptionAlgorithmDecoded = try containerValues.decodeIfPresent(EncryptionAlgorithmSpec.self, forKey: .encryptionAlgorithm)
        encryptionAlgorithm = encryptionAlgorithmDecoded
    }
}

extension DecryptOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DecryptOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledException" : self = .disabledException(try DisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectKeyException" : self = .incorrectKeyException(try IncorrectKeyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCiphertextException" : self = .invalidCiphertextException(try InvalidCiphertextException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGrantTokenException" : self = .invalidGrantTokenException(try InvalidGrantTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKeyUsageException" : self = .invalidKeyUsageException(try InvalidKeyUsageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KeyUnavailableException" : self = .keyUnavailableException(try KeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DecryptOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case disabledException(DisabledException)
    case incorrectKeyException(IncorrectKeyException)
    case invalidCiphertextException(InvalidCiphertextException)
    case invalidGrantTokenException(InvalidGrantTokenException)
    case invalidKeyUsageException(InvalidKeyUsageException)
    case keyUnavailableException(KeyUnavailableException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DecryptOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DecryptOutputResponse(encryptionAlgorithm: \(String(describing: encryptionAlgorithm)), keyId: \(String(describing: keyId)), plaintext: \(String(describing: plaintext)))"}
}

extension DecryptOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DecryptOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.encryptionAlgorithm = output.encryptionAlgorithm
            self.keyId = output.keyId
            self.plaintext = output.plaintext
        } else {
            self.encryptionAlgorithm = nil
            self.keyId = nil
            self.plaintext = nil
        }
    }
}

public struct DecryptOutputResponse: Equatable {
    /// <p>The encryption algorithm that was used to decrypt the ciphertext.</p>
    public let encryptionAlgorithm: EncryptionAlgorithmSpec?
    /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN">key ARN</a>) of the CMK that was used to decrypt the ciphertext.</p>
    public let keyId: String?
    /// <p>Decrypted plaintext data. When you use the HTTP API or the AWS CLI, the value is Base64-encoded. Otherwise, it is not Base64-encoded.</p>
    public let plaintext: Data?

    public init (
        encryptionAlgorithm: EncryptionAlgorithmSpec? = nil,
        keyId: String? = nil,
        plaintext: Data? = nil
    )
    {
        self.encryptionAlgorithm = encryptionAlgorithm
        self.keyId = keyId
        self.plaintext = plaintext
    }
}

struct DecryptOutputResponseBody: Equatable {
    public let keyId: String?
    public let plaintext: Data?
    public let encryptionAlgorithm: EncryptionAlgorithmSpec?
}

extension DecryptOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case encryptionAlgorithm = "EncryptionAlgorithm"
        case keyId = "KeyId"
        case plaintext = "Plaintext"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let plaintextDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .plaintext)
        plaintext = plaintextDecoded
        let encryptionAlgorithmDecoded = try containerValues.decodeIfPresent(EncryptionAlgorithmSpec.self, forKey: .encryptionAlgorithm)
        encryptionAlgorithm = encryptionAlgorithmDecoded
    }
}

public struct DeleteAliasInputBodyMiddleware: Middleware {
    public let id: String = "DeleteAliasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAliasInput>
    public typealias MOutput = OperationOutput<DeleteAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAliasOutputError>
}

extension DeleteAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAliasInput(aliasName: \(String(describing: aliasName)))"}
}

extension DeleteAliasInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aliasName = "AliasName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasName = aliasName {
            try encodeContainer.encode(aliasName, forKey: .aliasName)
        }
    }
}

public struct DeleteAliasInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAliasInput>
    public typealias MOutput = OperationOutput<DeleteAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAliasOutputError>
}

public struct DeleteAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAliasInput>
    public typealias MOutput = OperationOutput<DeleteAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAliasOutputError>
}

public struct DeleteAliasInput: Equatable {
    /// <p>The alias to be deleted. The alias name must begin with <code>alias/</code> followed by
    ///       the alias name, such as <code>alias/ExampleAlias</code>.</p>
    public let aliasName: String?

    public init (
        aliasName: String? = nil
    )
    {
        self.aliasName = aliasName
    }
}

struct DeleteAliasInputBody: Equatable {
    public let aliasName: String?
}

extension DeleteAliasInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aliasName = "AliasName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aliasName)
        aliasName = aliasNameDecoded
    }
}

extension DeleteAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAliasOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAliasOutputResponse()"}
}

extension DeleteAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAliasOutputResponse: Equatable {

    public init() {}
}

struct DeleteAliasOutputResponseBody: Equatable {
}

extension DeleteAliasOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteCustomKeyStoreInputBodyMiddleware: Middleware {
    public let id: String = "DeleteCustomKeyStoreInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCustomKeyStoreInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCustomKeyStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCustomKeyStoreInput>
    public typealias MOutput = OperationOutput<DeleteCustomKeyStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCustomKeyStoreOutputError>
}

extension DeleteCustomKeyStoreInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCustomKeyStoreInput(customKeyStoreId: \(String(describing: customKeyStoreId)))"}
}

extension DeleteCustomKeyStoreInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customKeyStoreId = "CustomKeyStoreId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customKeyStoreId = customKeyStoreId {
            try encodeContainer.encode(customKeyStoreId, forKey: .customKeyStoreId)
        }
    }
}

public struct DeleteCustomKeyStoreInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteCustomKeyStoreInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCustomKeyStoreInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCustomKeyStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCustomKeyStoreInput>
    public typealias MOutput = OperationOutput<DeleteCustomKeyStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCustomKeyStoreOutputError>
}

public struct DeleteCustomKeyStoreInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteCustomKeyStoreInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCustomKeyStoreInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCustomKeyStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCustomKeyStoreInput>
    public typealias MOutput = OperationOutput<DeleteCustomKeyStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCustomKeyStoreOutputError>
}

public struct DeleteCustomKeyStoreInput: Equatable {
    /// <p>Enter the ID of the custom key store you want to delete. To find the ID of a custom key store, use the <a>DescribeCustomKeyStores</a> operation.</p>
    public let customKeyStoreId: String?

    public init (
        customKeyStoreId: String? = nil
    )
    {
        self.customKeyStoreId = customKeyStoreId
    }
}

struct DeleteCustomKeyStoreInputBody: Equatable {
    public let customKeyStoreId: String?
}

extension DeleteCustomKeyStoreInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customKeyStoreId = "CustomKeyStoreId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customKeyStoreIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customKeyStoreId)
        customKeyStoreId = customKeyStoreIdDecoded
    }
}

extension DeleteCustomKeyStoreOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCustomKeyStoreOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CustomKeyStoreHasCMKsException" : self = .customKeyStoreHasCMKsException(try CustomKeyStoreHasCMKsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CustomKeyStoreInvalidStateException" : self = .customKeyStoreInvalidStateException(try CustomKeyStoreInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CustomKeyStoreNotFoundException" : self = .customKeyStoreNotFoundException(try CustomKeyStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCustomKeyStoreOutputError: Equatable {
    case customKeyStoreHasCMKsException(CustomKeyStoreHasCMKsException)
    case customKeyStoreInvalidStateException(CustomKeyStoreInvalidStateException)
    case customKeyStoreNotFoundException(CustomKeyStoreNotFoundException)
    case kMSInternalException(KMSInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCustomKeyStoreOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCustomKeyStoreOutputResponse()"}
}

extension DeleteCustomKeyStoreOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCustomKeyStoreOutputResponse: Equatable {

    public init() {}
}

struct DeleteCustomKeyStoreOutputResponseBody: Equatable {
}

extension DeleteCustomKeyStoreOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteImportedKeyMaterialInputBodyMiddleware: Middleware {
    public let id: String = "DeleteImportedKeyMaterialInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteImportedKeyMaterialInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteImportedKeyMaterialOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteImportedKeyMaterialInput>
    public typealias MOutput = OperationOutput<DeleteImportedKeyMaterialOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteImportedKeyMaterialOutputError>
}

extension DeleteImportedKeyMaterialInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteImportedKeyMaterialInput(keyId: \(String(describing: keyId)))"}
}

extension DeleteImportedKeyMaterialInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
    }
}

public struct DeleteImportedKeyMaterialInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteImportedKeyMaterialInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteImportedKeyMaterialInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteImportedKeyMaterialOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteImportedKeyMaterialInput>
    public typealias MOutput = OperationOutput<DeleteImportedKeyMaterialOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteImportedKeyMaterialOutputError>
}

public struct DeleteImportedKeyMaterialInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteImportedKeyMaterialInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteImportedKeyMaterialInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteImportedKeyMaterialOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteImportedKeyMaterialInput>
    public typealias MOutput = OperationOutput<DeleteImportedKeyMaterialOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteImportedKeyMaterialOutputError>
}

public struct DeleteImportedKeyMaterialInput: Equatable {
    /// <p>Identifies the CMK from which you are deleting imported key material. The
    ///         <code>Origin</code> of the CMK must be <code>EXTERNAL</code>.</p>
    ///          <p>Specify the key ID or the Amazon Resource Name (ARN) of the CMK.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
    public let keyId: String?

    public init (
        keyId: String? = nil
    )
    {
        self.keyId = keyId
    }
}

struct DeleteImportedKeyMaterialInputBody: Equatable {
    public let keyId: String?
}

extension DeleteImportedKeyMaterialInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
    }
}

extension DeleteImportedKeyMaterialOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteImportedKeyMaterialOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteImportedKeyMaterialOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case invalidArnException(InvalidArnException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case notFoundException(NotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteImportedKeyMaterialOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteImportedKeyMaterialOutputResponse()"}
}

extension DeleteImportedKeyMaterialOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteImportedKeyMaterialOutputResponse: Equatable {

    public init() {}
}

struct DeleteImportedKeyMaterialOutputResponseBody: Equatable {
}

extension DeleteImportedKeyMaterialOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DependencyTimeoutException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DependencyTimeoutException(message: \(String(describing: message)))"}
}

extension DependencyTimeoutException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DependencyTimeoutExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The system timed out while trying to fulfill the request. The request can be
///       retried.</p>
public struct DependencyTimeoutException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DependencyTimeoutExceptionBody: Equatable {
    public let message: String?
}

extension DependencyTimeoutExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct DescribeCustomKeyStoresInputBodyMiddleware: Middleware {
    public let id: String = "DescribeCustomKeyStoresInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCustomKeyStoresInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCustomKeyStoresOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCustomKeyStoresInput>
    public typealias MOutput = OperationOutput<DescribeCustomKeyStoresOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCustomKeyStoresOutputError>
}

extension DescribeCustomKeyStoresInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCustomKeyStoresInput(customKeyStoreId: \(String(describing: customKeyStoreId)), customKeyStoreName: \(String(describing: customKeyStoreName)), limit: \(String(describing: limit)), marker: \(String(describing: marker)))"}
}

extension DescribeCustomKeyStoresInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customKeyStoreId = "CustomKeyStoreId"
        case customKeyStoreName = "CustomKeyStoreName"
        case limit = "Limit"
        case marker = "Marker"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customKeyStoreId = customKeyStoreId {
            try encodeContainer.encode(customKeyStoreId, forKey: .customKeyStoreId)
        }
        if let customKeyStoreName = customKeyStoreName {
            try encodeContainer.encode(customKeyStoreName, forKey: .customKeyStoreName)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
    }
}

public struct DescribeCustomKeyStoresInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCustomKeyStoresInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCustomKeyStoresInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCustomKeyStoresOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCustomKeyStoresInput>
    public typealias MOutput = OperationOutput<DescribeCustomKeyStoresOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCustomKeyStoresOutputError>
}

public struct DescribeCustomKeyStoresInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCustomKeyStoresInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCustomKeyStoresInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCustomKeyStoresOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCustomKeyStoresInput>
    public typealias MOutput = OperationOutput<DescribeCustomKeyStoresOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCustomKeyStoresOutputError>
}

public struct DescribeCustomKeyStoresInput: Equatable {
    /// <p>Gets only information about the specified custom key store. Enter the key store ID.</p>
    ///          <p>By default, this operation gets information about all custom key stores in the account and
    ///       region. To limit the output to a particular custom key store, you can use either the
    ///         <code>CustomKeyStoreId</code> or <code>CustomKeyStoreName</code> parameter, but not
    ///       both.</p>
    public let customKeyStoreId: String?
    /// <p>Gets only information about the specified custom key store. Enter the friendly name of the
    ///       custom key store.</p>
    ///          <p>By default, this operation gets information about all custom key stores in the account and
    ///       region. To limit the output to a particular custom key store, you can use either the
    ///         <code>CustomKeyStoreId</code> or <code>CustomKeyStoreName</code> parameter, but not
    ///       both.</p>
    public let customKeyStoreName: String?
    /// <p>Use this parameter to specify the maximum number of items to return. When this
    ///     value is present, AWS KMS does not return more than the specified number of items, but it might
    ///     return fewer.</p>
    public let limit: Int?
    /// <p>Use this parameter in a subsequent request after you receive a response with
    ///     truncated results. Set it to the value of <code>NextMarker</code> from the truncated response
    ///     you just received.</p>
    public let marker: String?

    public init (
        customKeyStoreId: String? = nil,
        customKeyStoreName: String? = nil,
        limit: Int? = nil,
        marker: String? = nil
    )
    {
        self.customKeyStoreId = customKeyStoreId
        self.customKeyStoreName = customKeyStoreName
        self.limit = limit
        self.marker = marker
    }
}

struct DescribeCustomKeyStoresInputBody: Equatable {
    public let customKeyStoreId: String?
    public let customKeyStoreName: String?
    public let limit: Int?
    public let marker: String?
}

extension DescribeCustomKeyStoresInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customKeyStoreId = "CustomKeyStoreId"
        case customKeyStoreName = "CustomKeyStoreName"
        case limit = "Limit"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customKeyStoreIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customKeyStoreId)
        customKeyStoreId = customKeyStoreIdDecoded
        let customKeyStoreNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customKeyStoreName)
        customKeyStoreName = customKeyStoreNameDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeCustomKeyStoresOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCustomKeyStoresOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CustomKeyStoreNotFoundException" : self = .customKeyStoreNotFoundException(try CustomKeyStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCustomKeyStoresOutputError: Equatable {
    case customKeyStoreNotFoundException(CustomKeyStoreNotFoundException)
    case kMSInternalException(KMSInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCustomKeyStoresOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCustomKeyStoresOutputResponse(customKeyStores: \(String(describing: customKeyStores)), nextMarker: \(String(describing: nextMarker)), truncated: \(String(describing: truncated)))"}
}

extension DescribeCustomKeyStoresOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeCustomKeyStoresOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.customKeyStores = output.customKeyStores
            self.nextMarker = output.nextMarker
            self.truncated = output.truncated
        } else {
            self.customKeyStores = nil
            self.nextMarker = nil
            self.truncated = false
        }
    }
}

public struct DescribeCustomKeyStoresOutputResponse: Equatable {
    /// <p>Contains metadata about each custom key store.</p>
    public let customKeyStores: [CustomKeyStoresListEntry]?
    /// <p>When <code>Truncated</code> is true, this element is present and contains the
    ///     value to use for the <code>Marker</code> parameter in a subsequent request.</p>
    public let nextMarker: String?
    /// <p>A flag that indicates whether there are more items in the list. When this
    ///     value is true, the list in this response is truncated. To get more items, pass the value of
    ///     the <code>NextMarker</code> element in thisresponse to the <code>Marker</code> parameter in a
    ///     subsequent request.</p>
    public let truncated: Bool

    public init (
        customKeyStores: [CustomKeyStoresListEntry]? = nil,
        nextMarker: String? = nil,
        truncated: Bool = false
    )
    {
        self.customKeyStores = customKeyStores
        self.nextMarker = nextMarker
        self.truncated = truncated
    }
}

struct DescribeCustomKeyStoresOutputResponseBody: Equatable {
    public let customKeyStores: [CustomKeyStoresListEntry]?
    public let nextMarker: String?
    public let truncated: Bool
}

extension DescribeCustomKeyStoresOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customKeyStores = "CustomKeyStores"
        case nextMarker = "NextMarker"
        case truncated = "Truncated"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customKeyStoresContainer = try containerValues.decodeIfPresent([CustomKeyStoresListEntry?].self, forKey: .customKeyStores)
        var customKeyStoresDecoded0:[CustomKeyStoresListEntry]? = nil
        if let customKeyStoresContainer = customKeyStoresContainer {
            customKeyStoresDecoded0 = [CustomKeyStoresListEntry]()
            for structure0 in customKeyStoresContainer {
                if let structure0 = structure0 {
                    customKeyStoresDecoded0?.append(structure0)
                }
            }
        }
        customKeyStores = customKeyStoresDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let truncatedDecoded = try containerValues.decode(Bool.self, forKey: .truncated)
        truncated = truncatedDecoded
    }
}

public struct DescribeKeyInputBodyMiddleware: Middleware {
    public let id: String = "DescribeKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeKeyInput>
    public typealias MOutput = OperationOutput<DescribeKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeKeyOutputError>
}

extension DescribeKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeKeyInput(grantTokens: \(String(describing: grantTokens)), keyId: \(String(describing: keyId)))"}
}

extension DescribeKeyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grantTokens = "GrantTokens"
        case keyId = "KeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantTokens = grantTokens {
            var grantTokensContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantTokens)
            for granttokenlist0 in grantTokens {
                try grantTokensContainer.encode(granttokenlist0)
            }
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
    }
}

public struct DescribeKeyInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeKeyInput>
    public typealias MOutput = OperationOutput<DescribeKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeKeyOutputError>
}

public struct DescribeKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeKeyInput>
    public typealias MOutput = OperationOutput<DescribeKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeKeyOutputError>
}

public struct DescribeKeyInput: Equatable {
    /// <p>A list of grant tokens.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#grant_token">Grant Tokens</a> in the
    ///     <i>AWS Key Management Service Developer Guide</i>.</p>
    public let grantTokens: [String]?
    /// <p>Describes the specified customer master key (CMK). </p>
    ///          <p>If you specify a predefined AWS alias (an AWS alias with no key ID), KMS associates the
    ///       alias with an <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#master_keys">AWS
    ///         managed CMK</a> and returns its <code>KeyId</code> and <code>Arn</code> in the
    ///       response.</p>
    ///          <p>To specify a CMK, use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. When using an alias name, prefix it with <code>"alias/"</code>. To specify a CMK in a different AWS account, you must use the key ARN or alias ARN.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Alias name: <code>alias/ExampleAlias</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Alias ARN: <code>arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>. To get the alias name and alias ARN, use <a>ListAliases</a>.</p>
    public let keyId: String?

    public init (
        grantTokens: [String]? = nil,
        keyId: String? = nil
    )
    {
        self.grantTokens = grantTokens
        self.keyId = keyId
    }
}

struct DescribeKeyInputBody: Equatable {
    public let keyId: String?
    public let grantTokens: [String]?
}

extension DescribeKeyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case grantTokens = "GrantTokens"
        case keyId = "KeyId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let grantTokensContainer = try containerValues.decodeIfPresent([String?].self, forKey: .grantTokens)
        var grantTokensDecoded0:[String]? = nil
        if let grantTokensContainer = grantTokensContainer {
            grantTokensDecoded0 = [String]()
            for string0 in grantTokensContainer {
                if let string0 = string0 {
                    grantTokensDecoded0?.append(string0)
                }
            }
        }
        grantTokens = grantTokensDecoded0
    }
}

extension DescribeKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeKeyOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case invalidArnException(InvalidArnException)
    case kMSInternalException(KMSInternalException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeKeyOutputResponse(keyMetadata: \(String(describing: keyMetadata)))"}
}

extension DescribeKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeKeyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.keyMetadata = output.keyMetadata
        } else {
            self.keyMetadata = nil
        }
    }
}

public struct DescribeKeyOutputResponse: Equatable {
    /// <p>Metadata associated with the key.</p>
    public let keyMetadata: KeyMetadata?

    public init (
        keyMetadata: KeyMetadata? = nil
    )
    {
        self.keyMetadata = keyMetadata
    }
}

struct DescribeKeyOutputResponseBody: Equatable {
    public let keyMetadata: KeyMetadata?
}

extension DescribeKeyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyMetadata = "KeyMetadata"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyMetadataDecoded = try containerValues.decodeIfPresent(KeyMetadata.self, forKey: .keyMetadata)
        keyMetadata = keyMetadataDecoded
    }
}

public struct DisableKeyInputBodyMiddleware: Middleware {
    public let id: String = "DisableKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableKeyInput>
    public typealias MOutput = OperationOutput<DisableKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableKeyOutputError>
}

extension DisableKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableKeyInput(keyId: \(String(describing: keyId)))"}
}

extension DisableKeyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
    }
}

public struct DisableKeyInputHeadersMiddleware: Middleware {
    public let id: String = "DisableKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableKeyInput>
    public typealias MOutput = OperationOutput<DisableKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableKeyOutputError>
}

public struct DisableKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "DisableKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableKeyInput>
    public typealias MOutput = OperationOutput<DisableKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableKeyOutputError>
}

public struct DisableKeyInput: Equatable {
    /// <p>A unique identifier for the customer master key (CMK).</p>
    ///          <p>Specify the key ID or the Amazon Resource Name (ARN) of the CMK.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
    public let keyId: String?

    public init (
        keyId: String? = nil
    )
    {
        self.keyId = keyId
    }
}

struct DisableKeyInputBody: Equatable {
    public let keyId: String?
}

extension DisableKeyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
    }
}

extension DisableKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableKeyOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case invalidArnException(InvalidArnException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableKeyOutputResponse()"}
}

extension DisableKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisableKeyOutputResponse: Equatable {

    public init() {}
}

struct DisableKeyOutputResponseBody: Equatable {
}

extension DisableKeyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisableKeyRotationInputBodyMiddleware: Middleware {
    public let id: String = "DisableKeyRotationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableKeyRotationInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableKeyRotationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableKeyRotationInput>
    public typealias MOutput = OperationOutput<DisableKeyRotationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableKeyRotationOutputError>
}

extension DisableKeyRotationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableKeyRotationInput(keyId: \(String(describing: keyId)))"}
}

extension DisableKeyRotationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
    }
}

public struct DisableKeyRotationInputHeadersMiddleware: Middleware {
    public let id: String = "DisableKeyRotationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableKeyRotationInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableKeyRotationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableKeyRotationInput>
    public typealias MOutput = OperationOutput<DisableKeyRotationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableKeyRotationOutputError>
}

public struct DisableKeyRotationInputQueryItemMiddleware: Middleware {
    public let id: String = "DisableKeyRotationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableKeyRotationInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableKeyRotationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableKeyRotationInput>
    public typealias MOutput = OperationOutput<DisableKeyRotationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableKeyRotationOutputError>
}

public struct DisableKeyRotationInput: Equatable {
    /// <p>Identifies a symmetric customer master key (CMK). You cannot enable or disable automatic
    ///       rotation of <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html#asymmetric-cmks">asymmetric CMKs</a>, CMKs
    ///       with <a href="https://docs.aws.amazon.com/kms/latest/developerguide/importing-keys.html">imported key
    ///         material</a>, or CMKs in a <a href="https://docs.aws.amazon.com/kms/latest/developerguide/custom-key-store-overview.html">custom key store</a>.</p>
    ///          <p>Specify the key ID or the Amazon Resource Name (ARN) of the CMK.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
    public let keyId: String?

    public init (
        keyId: String? = nil
    )
    {
        self.keyId = keyId
    }
}

struct DisableKeyRotationInputBody: Equatable {
    public let keyId: String?
}

extension DisableKeyRotationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
    }
}

extension DisableKeyRotationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableKeyRotationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledException" : self = .disabledException(try DisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableKeyRotationOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case disabledException(DisabledException)
    case invalidArnException(InvalidArnException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case notFoundException(NotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableKeyRotationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableKeyRotationOutputResponse()"}
}

extension DisableKeyRotationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisableKeyRotationOutputResponse: Equatable {

    public init() {}
}

struct DisableKeyRotationOutputResponseBody: Equatable {
}

extension DisableKeyRotationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisabledException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisabledException(message: \(String(describing: message)))"}
}

extension DisabledException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DisabledExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the specified CMK is not enabled.</p>
public struct DisabledException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DisabledExceptionBody: Equatable {
    public let message: String?
}

extension DisabledExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct DisconnectCustomKeyStoreInputBodyMiddleware: Middleware {
    public let id: String = "DisconnectCustomKeyStoreInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisconnectCustomKeyStoreInput>,
                  next: H) -> Swift.Result<OperationOutput<DisconnectCustomKeyStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisconnectCustomKeyStoreInput>
    public typealias MOutput = OperationOutput<DisconnectCustomKeyStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisconnectCustomKeyStoreOutputError>
}

extension DisconnectCustomKeyStoreInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisconnectCustomKeyStoreInput(customKeyStoreId: \(String(describing: customKeyStoreId)))"}
}

extension DisconnectCustomKeyStoreInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customKeyStoreId = "CustomKeyStoreId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customKeyStoreId = customKeyStoreId {
            try encodeContainer.encode(customKeyStoreId, forKey: .customKeyStoreId)
        }
    }
}

public struct DisconnectCustomKeyStoreInputHeadersMiddleware: Middleware {
    public let id: String = "DisconnectCustomKeyStoreInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisconnectCustomKeyStoreInput>,
                  next: H) -> Swift.Result<OperationOutput<DisconnectCustomKeyStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisconnectCustomKeyStoreInput>
    public typealias MOutput = OperationOutput<DisconnectCustomKeyStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisconnectCustomKeyStoreOutputError>
}

public struct DisconnectCustomKeyStoreInputQueryItemMiddleware: Middleware {
    public let id: String = "DisconnectCustomKeyStoreInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisconnectCustomKeyStoreInput>,
                  next: H) -> Swift.Result<OperationOutput<DisconnectCustomKeyStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisconnectCustomKeyStoreInput>
    public typealias MOutput = OperationOutput<DisconnectCustomKeyStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisconnectCustomKeyStoreOutputError>
}

public struct DisconnectCustomKeyStoreInput: Equatable {
    /// <p>Enter the ID of the custom key store you want to disconnect. To find the ID of a custom key store, use the <a>DescribeCustomKeyStores</a> operation.</p>
    public let customKeyStoreId: String?

    public init (
        customKeyStoreId: String? = nil
    )
    {
        self.customKeyStoreId = customKeyStoreId
    }
}

struct DisconnectCustomKeyStoreInputBody: Equatable {
    public let customKeyStoreId: String?
}

extension DisconnectCustomKeyStoreInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customKeyStoreId = "CustomKeyStoreId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customKeyStoreIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customKeyStoreId)
        customKeyStoreId = customKeyStoreIdDecoded
    }
}

extension DisconnectCustomKeyStoreOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisconnectCustomKeyStoreOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CustomKeyStoreInvalidStateException" : self = .customKeyStoreInvalidStateException(try CustomKeyStoreInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CustomKeyStoreNotFoundException" : self = .customKeyStoreNotFoundException(try CustomKeyStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisconnectCustomKeyStoreOutputError: Equatable {
    case customKeyStoreInvalidStateException(CustomKeyStoreInvalidStateException)
    case customKeyStoreNotFoundException(CustomKeyStoreNotFoundException)
    case kMSInternalException(KMSInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisconnectCustomKeyStoreOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisconnectCustomKeyStoreOutputResponse()"}
}

extension DisconnectCustomKeyStoreOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisconnectCustomKeyStoreOutputResponse: Equatable {

    public init() {}
}

struct DisconnectCustomKeyStoreOutputResponseBody: Equatable {
}

extension DisconnectCustomKeyStoreOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct EnableKeyInputBodyMiddleware: Middleware {
    public let id: String = "EnableKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableKeyInput>
    public typealias MOutput = OperationOutput<EnableKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableKeyOutputError>
}

extension EnableKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableKeyInput(keyId: \(String(describing: keyId)))"}
}

extension EnableKeyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
    }
}

public struct EnableKeyInputHeadersMiddleware: Middleware {
    public let id: String = "EnableKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableKeyInput>
    public typealias MOutput = OperationOutput<EnableKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableKeyOutputError>
}

public struct EnableKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "EnableKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableKeyInput>
    public typealias MOutput = OperationOutput<EnableKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableKeyOutputError>
}

public struct EnableKeyInput: Equatable {
    /// <p>A unique identifier for the customer master key (CMK).</p>
    ///          <p>Specify the key ID or the Amazon Resource Name (ARN) of the CMK.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
    public let keyId: String?

    public init (
        keyId: String? = nil
    )
    {
        self.keyId = keyId
    }
}

struct EnableKeyInputBody: Equatable {
    public let keyId: String?
}

extension EnableKeyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
    }
}

extension EnableKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableKeyOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case invalidArnException(InvalidArnException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableKeyOutputResponse()"}
}

extension EnableKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct EnableKeyOutputResponse: Equatable {

    public init() {}
}

struct EnableKeyOutputResponseBody: Equatable {
}

extension EnableKeyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct EnableKeyRotationInputBodyMiddleware: Middleware {
    public let id: String = "EnableKeyRotationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableKeyRotationInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableKeyRotationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableKeyRotationInput>
    public typealias MOutput = OperationOutput<EnableKeyRotationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableKeyRotationOutputError>
}

extension EnableKeyRotationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableKeyRotationInput(keyId: \(String(describing: keyId)))"}
}

extension EnableKeyRotationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
    }
}

public struct EnableKeyRotationInputHeadersMiddleware: Middleware {
    public let id: String = "EnableKeyRotationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableKeyRotationInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableKeyRotationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableKeyRotationInput>
    public typealias MOutput = OperationOutput<EnableKeyRotationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableKeyRotationOutputError>
}

public struct EnableKeyRotationInputQueryItemMiddleware: Middleware {
    public let id: String = "EnableKeyRotationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableKeyRotationInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableKeyRotationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableKeyRotationInput>
    public typealias MOutput = OperationOutput<EnableKeyRotationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableKeyRotationOutputError>
}

public struct EnableKeyRotationInput: Equatable {
    /// <p>Identifies a symmetric customer master key (CMK). You cannot enable automatic rotation of asymmetric CMKs, CMKs with imported key material, or CMKs in a <a href="https://docs.aws.amazon.com/kms/latest/developerguide/custom-key-store-overview.html">custom key store</a>.</p>
    ///
    ///          <p>Specify the key ID or the Amazon Resource Name (ARN) of the CMK.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
    public let keyId: String?

    public init (
        keyId: String? = nil
    )
    {
        self.keyId = keyId
    }
}

struct EnableKeyRotationInputBody: Equatable {
    public let keyId: String?
}

extension EnableKeyRotationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
    }
}

extension EnableKeyRotationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableKeyRotationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledException" : self = .disabledException(try DisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableKeyRotationOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case disabledException(DisabledException)
    case invalidArnException(InvalidArnException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case notFoundException(NotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableKeyRotationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableKeyRotationOutputResponse()"}
}

extension EnableKeyRotationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct EnableKeyRotationOutputResponse: Equatable {

    public init() {}
}

struct EnableKeyRotationOutputResponseBody: Equatable {
}

extension EnableKeyRotationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct EncryptInputBodyMiddleware: Middleware {
    public let id: String = "EncryptInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EncryptInput>,
                  next: H) -> Swift.Result<OperationOutput<EncryptOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EncryptInput>
    public typealias MOutput = OperationOutput<EncryptOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EncryptOutputError>
}

extension EncryptInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EncryptInput(encryptionAlgorithm: \(String(describing: encryptionAlgorithm)), encryptionContext: \(String(describing: encryptionContext)), grantTokens: \(String(describing: grantTokens)), keyId: \(String(describing: keyId)), plaintext: \(String(describing: plaintext)))"}
}

extension EncryptInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionAlgorithm = "EncryptionAlgorithm"
        case encryptionContext = "EncryptionContext"
        case grantTokens = "GrantTokens"
        case keyId = "KeyId"
        case plaintext = "Plaintext"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionAlgorithm = encryptionAlgorithm {
            try encodeContainer.encode(encryptionAlgorithm.rawValue, forKey: .encryptionAlgorithm)
        }
        if let encryptionContext = encryptionContext {
            var encryptionContextContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .encryptionContext)
            for (dictKey0, encryptioncontexttype0) in encryptionContext {
                try encryptionContextContainer.encode(encryptioncontexttype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let grantTokens = grantTokens {
            var grantTokensContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantTokens)
            for granttokenlist0 in grantTokens {
                try grantTokensContainer.encode(granttokenlist0)
            }
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let plaintext = plaintext {
            try encodeContainer.encode(plaintext.base64EncodedString(), forKey: .plaintext)
        }
    }
}

public struct EncryptInputHeadersMiddleware: Middleware {
    public let id: String = "EncryptInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EncryptInput>,
                  next: H) -> Swift.Result<OperationOutput<EncryptOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EncryptInput>
    public typealias MOutput = OperationOutput<EncryptOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EncryptOutputError>
}

public struct EncryptInputQueryItemMiddleware: Middleware {
    public let id: String = "EncryptInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EncryptInput>,
                  next: H) -> Swift.Result<OperationOutput<EncryptOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EncryptInput>
    public typealias MOutput = OperationOutput<EncryptOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EncryptOutputError>
}

public struct EncryptInput: Equatable {
    /// <p>Specifies the encryption algorithm that AWS KMS will use to encrypt the plaintext message.
    ///       The algorithm must be compatible with the CMK that you specify.</p>
    ///          <p>This parameter is required only for asymmetric CMKs. The default value,
    ///         <code>SYMMETRIC_DEFAULT</code>, is the algorithm used for symmetric CMKs. If you are using
    ///       an asymmetric CMK, we recommend RSAES_OAEP_SHA_256.</p>
    public let encryptionAlgorithm: EncryptionAlgorithmSpec?
    /// <p>Specifies the encryption context that will be used to encrypt the data.
    ///       An encryption context is valid only for <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations">cryptographic operations</a> with a symmetric CMK. The standard asymmetric encryption algorithms that AWS KMS uses do not support an encryption context. </p>
    ///          <p>An <i>encryption context</i> is a collection of non-secret key-value pairs that represents additional authenticated data. When you use an encryption context to encrypt data, you must specify the same (an exact case-sensitive match) encryption context to decrypt the data. An encryption context is optional when encrypting with a symmetric CMK, but it is highly recommended.</p>
    ///          <p>For more information, see
    ///         <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context">Encryption
    ///         Context</a> in the <i>AWS Key Management Service Developer Guide</i>.</p>
    public let encryptionContext: [String:String]?
    /// <p>A list of grant tokens.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#grant_token">Grant Tokens</a> in the
    ///     <i>AWS Key Management Service Developer Guide</i>.</p>
    public let grantTokens: [String]?
    /// <p>A unique identifier for the customer master key (CMK).</p>
    ///          <p>To specify a CMK, use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. When using an alias name, prefix it with <code>"alias/"</code>. To specify a CMK in a different AWS account, you must use the key ARN or alias ARN.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Alias name: <code>alias/ExampleAlias</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Alias ARN: <code>arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>. To get the alias name and alias ARN, use <a>ListAliases</a>.</p>
    public let keyId: String?
    /// <p>Data to be encrypted.</p>
    public let plaintext: Data?

    public init (
        encryptionAlgorithm: EncryptionAlgorithmSpec? = nil,
        encryptionContext: [String:String]? = nil,
        grantTokens: [String]? = nil,
        keyId: String? = nil,
        plaintext: Data? = nil
    )
    {
        self.encryptionAlgorithm = encryptionAlgorithm
        self.encryptionContext = encryptionContext
        self.grantTokens = grantTokens
        self.keyId = keyId
        self.plaintext = plaintext
    }
}

struct EncryptInputBody: Equatable {
    public let keyId: String?
    public let plaintext: Data?
    public let encryptionContext: [String:String]?
    public let grantTokens: [String]?
    public let encryptionAlgorithm: EncryptionAlgorithmSpec?
}

extension EncryptInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case encryptionAlgorithm = "EncryptionAlgorithm"
        case encryptionContext = "EncryptionContext"
        case grantTokens = "GrantTokens"
        case keyId = "KeyId"
        case plaintext = "Plaintext"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let plaintextDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .plaintext)
        plaintext = plaintextDecoded
        let encryptionContextContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .encryptionContext)
        var encryptionContextDecoded0: [String:String]? = nil
        if let encryptionContextContainer = encryptionContextContainer {
            encryptionContextDecoded0 = [String:String]()
            for (key0, encryptioncontextvalue0) in encryptionContextContainer {
                if let encryptioncontextvalue0 = encryptioncontextvalue0 {
                    encryptionContextDecoded0?[key0] = encryptioncontextvalue0
                }
            }
        }
        encryptionContext = encryptionContextDecoded0
        let grantTokensContainer = try containerValues.decodeIfPresent([String?].self, forKey: .grantTokens)
        var grantTokensDecoded0:[String]? = nil
        if let grantTokensContainer = grantTokensContainer {
            grantTokensDecoded0 = [String]()
            for string0 in grantTokensContainer {
                if let string0 = string0 {
                    grantTokensDecoded0?.append(string0)
                }
            }
        }
        grantTokens = grantTokensDecoded0
        let encryptionAlgorithmDecoded = try containerValues.decodeIfPresent(EncryptionAlgorithmSpec.self, forKey: .encryptionAlgorithm)
        encryptionAlgorithm = encryptionAlgorithmDecoded
    }
}

extension EncryptOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EncryptOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledException" : self = .disabledException(try DisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGrantTokenException" : self = .invalidGrantTokenException(try InvalidGrantTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKeyUsageException" : self = .invalidKeyUsageException(try InvalidKeyUsageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KeyUnavailableException" : self = .keyUnavailableException(try KeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EncryptOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case disabledException(DisabledException)
    case invalidGrantTokenException(InvalidGrantTokenException)
    case invalidKeyUsageException(InvalidKeyUsageException)
    case keyUnavailableException(KeyUnavailableException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EncryptOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EncryptOutputResponse(ciphertextBlob: \(String(describing: ciphertextBlob)), encryptionAlgorithm: \(String(describing: encryptionAlgorithm)), keyId: \(String(describing: keyId)))"}
}

extension EncryptOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EncryptOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.ciphertextBlob = output.ciphertextBlob
            self.encryptionAlgorithm = output.encryptionAlgorithm
            self.keyId = output.keyId
        } else {
            self.ciphertextBlob = nil
            self.encryptionAlgorithm = nil
            self.keyId = nil
        }
    }
}

public struct EncryptOutputResponse: Equatable {
    /// <p>The encrypted plaintext. When you use the HTTP API or the AWS CLI, the value is Base64-encoded. Otherwise, it is not Base64-encoded.</p>
    public let ciphertextBlob: Data?
    /// <p>The encryption algorithm that was used to encrypt the plaintext.</p>
    public let encryptionAlgorithm: EncryptionAlgorithmSpec?
    /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN">key ARN</a>) of the CMK that was used to encrypt the plaintext.</p>
    public let keyId: String?

    public init (
        ciphertextBlob: Data? = nil,
        encryptionAlgorithm: EncryptionAlgorithmSpec? = nil,
        keyId: String? = nil
    )
    {
        self.ciphertextBlob = ciphertextBlob
        self.encryptionAlgorithm = encryptionAlgorithm
        self.keyId = keyId
    }
}

struct EncryptOutputResponseBody: Equatable {
    public let ciphertextBlob: Data?
    public let keyId: String?
    public let encryptionAlgorithm: EncryptionAlgorithmSpec?
}

extension EncryptOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ciphertextBlob = "CiphertextBlob"
        case encryptionAlgorithm = "EncryptionAlgorithm"
        case keyId = "KeyId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ciphertextBlobDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .ciphertextBlob)
        ciphertextBlob = ciphertextBlobDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let encryptionAlgorithmDecoded = try containerValues.decodeIfPresent(EncryptionAlgorithmSpec.self, forKey: .encryptionAlgorithm)
        encryptionAlgorithm = encryptionAlgorithmDecoded
    }
}

public enum EncryptionAlgorithmSpec {
    case rsaesOaepSha1
    case rsaesOaepSha256
    case symmetricDefault
    case sdkUnknown(String)
}

extension EncryptionAlgorithmSpec : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EncryptionAlgorithmSpec] {
        return [
            .rsaesOaepSha1,
            .rsaesOaepSha256,
            .symmetricDefault,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .rsaesOaepSha1: return "RSAES_OAEP_SHA_1"
        case .rsaesOaepSha256: return "RSAES_OAEP_SHA_256"
        case .symmetricDefault: return "SYMMETRIC_DEFAULT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EncryptionAlgorithmSpec(rawValue: rawValue) ?? EncryptionAlgorithmSpec.sdkUnknown(rawValue)
    }
}

public enum ExpirationModelType {
    case keyMaterialDoesNotExpire
    case keyMaterialExpires
    case sdkUnknown(String)
}

extension ExpirationModelType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExpirationModelType] {
        return [
            .keyMaterialDoesNotExpire,
            .keyMaterialExpires,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .keyMaterialDoesNotExpire: return "KEY_MATERIAL_DOES_NOT_EXPIRE"
        case .keyMaterialExpires: return "KEY_MATERIAL_EXPIRES"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExpirationModelType(rawValue: rawValue) ?? ExpirationModelType.sdkUnknown(rawValue)
    }
}

extension ExpiredImportTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExpiredImportTokenException(message: \(String(describing: message)))"}
}

extension ExpiredImportTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ExpiredImportTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the specified import token is expired. Use <a>GetParametersForImport</a> to get a new import token and public key, use the new
///       public key to encrypt the key material, and then try the request again.</p>
public struct ExpiredImportTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ExpiredImportTokenExceptionBody: Equatable {
    public let message: String?
}

extension ExpiredImportTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct GenerateDataKeyInputBodyMiddleware: Middleware {
    public let id: String = "GenerateDataKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateDataKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateDataKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateDataKeyInput>
    public typealias MOutput = OperationOutput<GenerateDataKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateDataKeyOutputError>
}

extension GenerateDataKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GenerateDataKeyInput(encryptionContext: \(String(describing: encryptionContext)), grantTokens: \(String(describing: grantTokens)), keyId: \(String(describing: keyId)), keySpec: \(String(describing: keySpec)), numberOfBytes: \(String(describing: numberOfBytes)))"}
}

extension GenerateDataKeyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionContext = "EncryptionContext"
        case grantTokens = "GrantTokens"
        case keyId = "KeyId"
        case keySpec = "KeySpec"
        case numberOfBytes = "NumberOfBytes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionContext = encryptionContext {
            var encryptionContextContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .encryptionContext)
            for (dictKey0, encryptioncontexttype0) in encryptionContext {
                try encryptionContextContainer.encode(encryptioncontexttype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let grantTokens = grantTokens {
            var grantTokensContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantTokens)
            for granttokenlist0 in grantTokens {
                try grantTokensContainer.encode(granttokenlist0)
            }
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let keySpec = keySpec {
            try encodeContainer.encode(keySpec.rawValue, forKey: .keySpec)
        }
        if let numberOfBytes = numberOfBytes {
            try encodeContainer.encode(numberOfBytes, forKey: .numberOfBytes)
        }
    }
}

public struct GenerateDataKeyInputHeadersMiddleware: Middleware {
    public let id: String = "GenerateDataKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateDataKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateDataKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateDataKeyInput>
    public typealias MOutput = OperationOutput<GenerateDataKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateDataKeyOutputError>
}

public struct GenerateDataKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "GenerateDataKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateDataKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateDataKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateDataKeyInput>
    public typealias MOutput = OperationOutput<GenerateDataKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateDataKeyOutputError>
}

public struct GenerateDataKeyInput: Equatable {
    /// <p>Specifies the encryption context that will be used when encrypting the data key.</p>
    ///          <p>An <i>encryption context</i> is a collection of non-secret key-value pairs that represents additional authenticated data. When you use an encryption context to encrypt data, you must specify the same (an exact case-sensitive match) encryption context to decrypt the data. An encryption context is optional when encrypting with a symmetric CMK, but it is highly recommended.</p>
    ///          <p>For more information, see
    ///         <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context">Encryption
    ///         Context</a> in the <i>AWS Key Management Service Developer Guide</i>.</p>
    public let encryptionContext: [String:String]?
    /// <p>A list of grant tokens.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#grant_token">Grant Tokens</a> in the
    ///     <i>AWS Key Management Service Developer Guide</i>.</p>
    public let grantTokens: [String]?
    /// <p>Identifies the symmetric CMK that encrypts the data key.</p>
    ///
    ///          <p>To specify a CMK, use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. When using an alias name, prefix it with <code>"alias/"</code>. To specify a CMK in a different AWS account, you must use the key ARN or alias ARN.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Alias name: <code>alias/ExampleAlias</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Alias ARN: <code>arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>. To get the alias name and alias ARN, use <a>ListAliases</a>.</p>
    public let keyId: String?
    /// <p>Specifies the length of the data key. Use <code>AES_128</code> to generate a 128-bit
    ///       symmetric key, or <code>AES_256</code> to generate a 256-bit symmetric key.</p>
    ///          <p>You must specify either the <code>KeySpec</code> or the <code>NumberOfBytes</code>
    ///       parameter (but not both) in every <code>GenerateDataKey</code> request.</p>
    public let keySpec: DataKeySpec?
    /// <p>Specifies the length of the data key in bytes. For example, use the value 64 to generate a
    ///       512-bit data key (64 bytes is 512 bits). For 128-bit (16-byte) and 256-bit (32-byte) data
    ///       keys, use the <code>KeySpec</code> parameter.</p>
    ///          <p>You must specify either the <code>KeySpec</code> or the <code>NumberOfBytes</code>
    ///       parameter (but not both) in every <code>GenerateDataKey</code> request.</p>
    public let numberOfBytes: Int?

    public init (
        encryptionContext: [String:String]? = nil,
        grantTokens: [String]? = nil,
        keyId: String? = nil,
        keySpec: DataKeySpec? = nil,
        numberOfBytes: Int? = nil
    )
    {
        self.encryptionContext = encryptionContext
        self.grantTokens = grantTokens
        self.keyId = keyId
        self.keySpec = keySpec
        self.numberOfBytes = numberOfBytes
    }
}

struct GenerateDataKeyInputBody: Equatable {
    public let keyId: String?
    public let encryptionContext: [String:String]?
    public let numberOfBytes: Int?
    public let keySpec: DataKeySpec?
    public let grantTokens: [String]?
}

extension GenerateDataKeyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case encryptionContext = "EncryptionContext"
        case grantTokens = "GrantTokens"
        case keyId = "KeyId"
        case keySpec = "KeySpec"
        case numberOfBytes = "NumberOfBytes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let encryptionContextContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .encryptionContext)
        var encryptionContextDecoded0: [String:String]? = nil
        if let encryptionContextContainer = encryptionContextContainer {
            encryptionContextDecoded0 = [String:String]()
            for (key0, encryptioncontextvalue0) in encryptionContextContainer {
                if let encryptioncontextvalue0 = encryptioncontextvalue0 {
                    encryptionContextDecoded0?[key0] = encryptioncontextvalue0
                }
            }
        }
        encryptionContext = encryptionContextDecoded0
        let numberOfBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfBytes)
        numberOfBytes = numberOfBytesDecoded
        let keySpecDecoded = try containerValues.decodeIfPresent(DataKeySpec.self, forKey: .keySpec)
        keySpec = keySpecDecoded
        let grantTokensContainer = try containerValues.decodeIfPresent([String?].self, forKey: .grantTokens)
        var grantTokensDecoded0:[String]? = nil
        if let grantTokensContainer = grantTokensContainer {
            grantTokensDecoded0 = [String]()
            for string0 in grantTokensContainer {
                if let string0 = string0 {
                    grantTokensDecoded0?.append(string0)
                }
            }
        }
        grantTokens = grantTokensDecoded0
    }
}

extension GenerateDataKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GenerateDataKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledException" : self = .disabledException(try DisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGrantTokenException" : self = .invalidGrantTokenException(try InvalidGrantTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKeyUsageException" : self = .invalidKeyUsageException(try InvalidKeyUsageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KeyUnavailableException" : self = .keyUnavailableException(try KeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GenerateDataKeyOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case disabledException(DisabledException)
    case invalidGrantTokenException(InvalidGrantTokenException)
    case invalidKeyUsageException(InvalidKeyUsageException)
    case keyUnavailableException(KeyUnavailableException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GenerateDataKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GenerateDataKeyOutputResponse(ciphertextBlob: \(String(describing: ciphertextBlob)), keyId: \(String(describing: keyId)), plaintext: \(String(describing: plaintext)))"}
}

extension GenerateDataKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GenerateDataKeyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.ciphertextBlob = output.ciphertextBlob
            self.keyId = output.keyId
            self.plaintext = output.plaintext
        } else {
            self.ciphertextBlob = nil
            self.keyId = nil
            self.plaintext = nil
        }
    }
}

public struct GenerateDataKeyOutputResponse: Equatable {
    /// <p>The encrypted copy of the data key. When you use the HTTP API or the AWS CLI, the value is Base64-encoded. Otherwise, it is not Base64-encoded.</p>
    public let ciphertextBlob: Data?
    /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN">key ARN</a>) of the CMK that encrypted the data key.</p>
    public let keyId: String?
    /// <p>The plaintext data key. When you use the HTTP API or the AWS CLI, the value is Base64-encoded. Otherwise, it is not Base64-encoded. Use this data key to encrypt your data outside of
    ///       KMS. Then, remove it from memory as soon as possible.</p>
    public let plaintext: Data?

    public init (
        ciphertextBlob: Data? = nil,
        keyId: String? = nil,
        plaintext: Data? = nil
    )
    {
        self.ciphertextBlob = ciphertextBlob
        self.keyId = keyId
        self.plaintext = plaintext
    }
}

struct GenerateDataKeyOutputResponseBody: Equatable {
    public let ciphertextBlob: Data?
    public let plaintext: Data?
    public let keyId: String?
}

extension GenerateDataKeyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ciphertextBlob = "CiphertextBlob"
        case keyId = "KeyId"
        case plaintext = "Plaintext"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ciphertextBlobDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .ciphertextBlob)
        ciphertextBlob = ciphertextBlobDecoded
        let plaintextDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .plaintext)
        plaintext = plaintextDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
    }
}

public struct GenerateDataKeyPairInputBodyMiddleware: Middleware {
    public let id: String = "GenerateDataKeyPairInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateDataKeyPairInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateDataKeyPairOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateDataKeyPairInput>
    public typealias MOutput = OperationOutput<GenerateDataKeyPairOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateDataKeyPairOutputError>
}

extension GenerateDataKeyPairInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GenerateDataKeyPairInput(encryptionContext: \(String(describing: encryptionContext)), grantTokens: \(String(describing: grantTokens)), keyId: \(String(describing: keyId)), keyPairSpec: \(String(describing: keyPairSpec)))"}
}

extension GenerateDataKeyPairInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionContext = "EncryptionContext"
        case grantTokens = "GrantTokens"
        case keyId = "KeyId"
        case keyPairSpec = "KeyPairSpec"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionContext = encryptionContext {
            var encryptionContextContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .encryptionContext)
            for (dictKey0, encryptioncontexttype0) in encryptionContext {
                try encryptionContextContainer.encode(encryptioncontexttype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let grantTokens = grantTokens {
            var grantTokensContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantTokens)
            for granttokenlist0 in grantTokens {
                try grantTokensContainer.encode(granttokenlist0)
            }
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let keyPairSpec = keyPairSpec {
            try encodeContainer.encode(keyPairSpec.rawValue, forKey: .keyPairSpec)
        }
    }
}

public struct GenerateDataKeyPairInputHeadersMiddleware: Middleware {
    public let id: String = "GenerateDataKeyPairInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateDataKeyPairInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateDataKeyPairOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateDataKeyPairInput>
    public typealias MOutput = OperationOutput<GenerateDataKeyPairOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateDataKeyPairOutputError>
}

public struct GenerateDataKeyPairInputQueryItemMiddleware: Middleware {
    public let id: String = "GenerateDataKeyPairInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateDataKeyPairInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateDataKeyPairOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateDataKeyPairInput>
    public typealias MOutput = OperationOutput<GenerateDataKeyPairOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateDataKeyPairOutputError>
}

public struct GenerateDataKeyPairInput: Equatable {
    /// <p>Specifies the encryption context that will be used when encrypting the private key in the
    ///       data key pair.</p>
    ///          <p>An <i>encryption context</i> is a collection of non-secret key-value pairs that represents additional authenticated data. When you use an encryption context to encrypt data, you must specify the same (an exact case-sensitive match) encryption context to decrypt the data. An encryption context is optional when encrypting with a symmetric CMK, but it is highly recommended.</p>
    ///          <p>For more information, see
    ///         <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context">Encryption
    ///         Context</a> in the <i>AWS Key Management Service Developer Guide</i>.</p>
    public let encryptionContext: [String:String]?
    /// <p>A list of grant tokens.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#grant_token">Grant Tokens</a> in the
    ///     <i>AWS Key Management Service Developer Guide</i>.</p>
    public let grantTokens: [String]?
    /// <p>Specifies the symmetric CMK that encrypts the private key in the data key pair. You cannot
    ///       specify an asymmetric CMK or a CMK in a custom key store. To get the type and origin of your
    ///       CMK, use the <a>DescribeKey</a> operation.</p>
    ///          <p>To specify a CMK, use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. When using an alias name, prefix it with <code>"alias/"</code>. To specify a CMK in a different AWS account, you must use the key ARN or alias ARN.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Alias name: <code>alias/ExampleAlias</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Alias ARN: <code>arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>. To get the alias name and alias ARN, use <a>ListAliases</a>.</p>
    public let keyId: String?
    /// <p>Determines the type of data key pair that is generated. </p>
    ///          <p>The AWS KMS rule that restricts the use of asymmetric RSA CMKs to encrypt and decrypt or to sign and verify (but not both), and the rule that permits you to use ECC CMKs only to sign and verify, are not effective outside of AWS KMS.</p>
    public let keyPairSpec: DataKeyPairSpec?

    public init (
        encryptionContext: [String:String]? = nil,
        grantTokens: [String]? = nil,
        keyId: String? = nil,
        keyPairSpec: DataKeyPairSpec? = nil
    )
    {
        self.encryptionContext = encryptionContext
        self.grantTokens = grantTokens
        self.keyId = keyId
        self.keyPairSpec = keyPairSpec
    }
}

struct GenerateDataKeyPairInputBody: Equatable {
    public let encryptionContext: [String:String]?
    public let keyId: String?
    public let keyPairSpec: DataKeyPairSpec?
    public let grantTokens: [String]?
}

extension GenerateDataKeyPairInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case encryptionContext = "EncryptionContext"
        case grantTokens = "GrantTokens"
        case keyId = "KeyId"
        case keyPairSpec = "KeyPairSpec"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionContextContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .encryptionContext)
        var encryptionContextDecoded0: [String:String]? = nil
        if let encryptionContextContainer = encryptionContextContainer {
            encryptionContextDecoded0 = [String:String]()
            for (key0, encryptioncontextvalue0) in encryptionContextContainer {
                if let encryptioncontextvalue0 = encryptioncontextvalue0 {
                    encryptionContextDecoded0?[key0] = encryptioncontextvalue0
                }
            }
        }
        encryptionContext = encryptionContextDecoded0
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let keyPairSpecDecoded = try containerValues.decodeIfPresent(DataKeyPairSpec.self, forKey: .keyPairSpec)
        keyPairSpec = keyPairSpecDecoded
        let grantTokensContainer = try containerValues.decodeIfPresent([String?].self, forKey: .grantTokens)
        var grantTokensDecoded0:[String]? = nil
        if let grantTokensContainer = grantTokensContainer {
            grantTokensDecoded0 = [String]()
            for string0 in grantTokensContainer {
                if let string0 = string0 {
                    grantTokensDecoded0?.append(string0)
                }
            }
        }
        grantTokens = grantTokensDecoded0
    }
}

extension GenerateDataKeyPairOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GenerateDataKeyPairOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledException" : self = .disabledException(try DisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGrantTokenException" : self = .invalidGrantTokenException(try InvalidGrantTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKeyUsageException" : self = .invalidKeyUsageException(try InvalidKeyUsageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KeyUnavailableException" : self = .keyUnavailableException(try KeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GenerateDataKeyPairOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case disabledException(DisabledException)
    case invalidGrantTokenException(InvalidGrantTokenException)
    case invalidKeyUsageException(InvalidKeyUsageException)
    case keyUnavailableException(KeyUnavailableException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case notFoundException(NotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GenerateDataKeyPairOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GenerateDataKeyPairOutputResponse(keyId: \(String(describing: keyId)), keyPairSpec: \(String(describing: keyPairSpec)), privateKeyCiphertextBlob: \(String(describing: privateKeyCiphertextBlob)), privateKeyPlaintext: \(String(describing: privateKeyPlaintext)), publicKey: \(String(describing: publicKey)))"}
}

extension GenerateDataKeyPairOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GenerateDataKeyPairOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.keyId = output.keyId
            self.keyPairSpec = output.keyPairSpec
            self.privateKeyCiphertextBlob = output.privateKeyCiphertextBlob
            self.privateKeyPlaintext = output.privateKeyPlaintext
            self.publicKey = output.publicKey
        } else {
            self.keyId = nil
            self.keyPairSpec = nil
            self.privateKeyCiphertextBlob = nil
            self.privateKeyPlaintext = nil
            self.publicKey = nil
        }
    }
}

public struct GenerateDataKeyPairOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN">key ARN</a>) of the CMK that encrypted the private key.</p>
    public let keyId: String?
    /// <p>The type of data key pair that was generated.</p>
    public let keyPairSpec: DataKeyPairSpec?
    /// <p>The encrypted copy of the private key. When you use the HTTP API or the AWS CLI, the value is Base64-encoded. Otherwise, it is not Base64-encoded.</p>
    public let privateKeyCiphertextBlob: Data?
    /// <p>The plaintext copy of the private key. When you use the HTTP API or the AWS CLI, the value is Base64-encoded. Otherwise, it is not Base64-encoded.</p>
    public let privateKeyPlaintext: Data?
    /// <p>The public key (in plaintext).</p>
    public let publicKey: Data?

    public init (
        keyId: String? = nil,
        keyPairSpec: DataKeyPairSpec? = nil,
        privateKeyCiphertextBlob: Data? = nil,
        privateKeyPlaintext: Data? = nil,
        publicKey: Data? = nil
    )
    {
        self.keyId = keyId
        self.keyPairSpec = keyPairSpec
        self.privateKeyCiphertextBlob = privateKeyCiphertextBlob
        self.privateKeyPlaintext = privateKeyPlaintext
        self.publicKey = publicKey
    }
}

struct GenerateDataKeyPairOutputResponseBody: Equatable {
    public let privateKeyCiphertextBlob: Data?
    public let privateKeyPlaintext: Data?
    public let publicKey: Data?
    public let keyId: String?
    public let keyPairSpec: DataKeyPairSpec?
}

extension GenerateDataKeyPairOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
        case keyPairSpec = "KeyPairSpec"
        case privateKeyCiphertextBlob = "PrivateKeyCiphertextBlob"
        case privateKeyPlaintext = "PrivateKeyPlaintext"
        case publicKey = "PublicKey"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let privateKeyCiphertextBlobDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .privateKeyCiphertextBlob)
        privateKeyCiphertextBlob = privateKeyCiphertextBlobDecoded
        let privateKeyPlaintextDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .privateKeyPlaintext)
        privateKeyPlaintext = privateKeyPlaintextDecoded
        let publicKeyDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .publicKey)
        publicKey = publicKeyDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let keyPairSpecDecoded = try containerValues.decodeIfPresent(DataKeyPairSpec.self, forKey: .keyPairSpec)
        keyPairSpec = keyPairSpecDecoded
    }
}

public struct GenerateDataKeyPairWithoutPlaintextInputBodyMiddleware: Middleware {
    public let id: String = "GenerateDataKeyPairWithoutPlaintextInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateDataKeyPairWithoutPlaintextInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateDataKeyPairWithoutPlaintextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateDataKeyPairWithoutPlaintextInput>
    public typealias MOutput = OperationOutput<GenerateDataKeyPairWithoutPlaintextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateDataKeyPairWithoutPlaintextOutputError>
}

extension GenerateDataKeyPairWithoutPlaintextInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GenerateDataKeyPairWithoutPlaintextInput(encryptionContext: \(String(describing: encryptionContext)), grantTokens: \(String(describing: grantTokens)), keyId: \(String(describing: keyId)), keyPairSpec: \(String(describing: keyPairSpec)))"}
}

extension GenerateDataKeyPairWithoutPlaintextInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionContext = "EncryptionContext"
        case grantTokens = "GrantTokens"
        case keyId = "KeyId"
        case keyPairSpec = "KeyPairSpec"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionContext = encryptionContext {
            var encryptionContextContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .encryptionContext)
            for (dictKey0, encryptioncontexttype0) in encryptionContext {
                try encryptionContextContainer.encode(encryptioncontexttype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let grantTokens = grantTokens {
            var grantTokensContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantTokens)
            for granttokenlist0 in grantTokens {
                try grantTokensContainer.encode(granttokenlist0)
            }
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let keyPairSpec = keyPairSpec {
            try encodeContainer.encode(keyPairSpec.rawValue, forKey: .keyPairSpec)
        }
    }
}

public struct GenerateDataKeyPairWithoutPlaintextInputHeadersMiddleware: Middleware {
    public let id: String = "GenerateDataKeyPairWithoutPlaintextInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateDataKeyPairWithoutPlaintextInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateDataKeyPairWithoutPlaintextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateDataKeyPairWithoutPlaintextInput>
    public typealias MOutput = OperationOutput<GenerateDataKeyPairWithoutPlaintextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateDataKeyPairWithoutPlaintextOutputError>
}

public struct GenerateDataKeyPairWithoutPlaintextInputQueryItemMiddleware: Middleware {
    public let id: String = "GenerateDataKeyPairWithoutPlaintextInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateDataKeyPairWithoutPlaintextInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateDataKeyPairWithoutPlaintextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateDataKeyPairWithoutPlaintextInput>
    public typealias MOutput = OperationOutput<GenerateDataKeyPairWithoutPlaintextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateDataKeyPairWithoutPlaintextOutputError>
}

public struct GenerateDataKeyPairWithoutPlaintextInput: Equatable {
    /// <p>Specifies the encryption context that will be used when encrypting the private key in the
    ///       data key pair.</p>
    ///          <p>An <i>encryption context</i> is a collection of non-secret key-value pairs that represents additional authenticated data. When you use an encryption context to encrypt data, you must specify the same (an exact case-sensitive match) encryption context to decrypt the data. An encryption context is optional when encrypting with a symmetric CMK, but it is highly recommended.</p>
    ///          <p>For more information, see
    ///         <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context">Encryption
    ///         Context</a> in the <i>AWS Key Management Service Developer Guide</i>.</p>
    public let encryptionContext: [String:String]?
    /// <p>A list of grant tokens.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#grant_token">Grant Tokens</a> in the
    ///     <i>AWS Key Management Service Developer Guide</i>.</p>
    public let grantTokens: [String]?
    /// <p>Specifies the CMK that encrypts the private key in the data key pair. You must specify a
    ///       symmetric CMK. You cannot use an asymmetric CMK or a CMK in a custom key store. To get the
    ///       type and origin of your CMK, use the <a>DescribeKey</a> operation. </p>
    ///          <p>To specify a CMK, use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. When using an alias name, prefix it with <code>"alias/"</code>. To specify a CMK in a different AWS account, you must use the key ARN or alias ARN.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Alias name: <code>alias/ExampleAlias</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Alias ARN: <code>arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>. To get the alias name and alias ARN, use <a>ListAliases</a>.</p>
    public let keyId: String?
    /// <p>Determines the type of data key pair that is generated.</p>
    ///          <p>The AWS KMS rule that restricts the use of asymmetric RSA CMKs to encrypt and decrypt or to sign and verify (but not both), and the rule that permits you to use ECC CMKs only to sign and verify, are not effective outside of AWS KMS.</p>
    public let keyPairSpec: DataKeyPairSpec?

    public init (
        encryptionContext: [String:String]? = nil,
        grantTokens: [String]? = nil,
        keyId: String? = nil,
        keyPairSpec: DataKeyPairSpec? = nil
    )
    {
        self.encryptionContext = encryptionContext
        self.grantTokens = grantTokens
        self.keyId = keyId
        self.keyPairSpec = keyPairSpec
    }
}

struct GenerateDataKeyPairWithoutPlaintextInputBody: Equatable {
    public let encryptionContext: [String:String]?
    public let keyId: String?
    public let keyPairSpec: DataKeyPairSpec?
    public let grantTokens: [String]?
}

extension GenerateDataKeyPairWithoutPlaintextInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case encryptionContext = "EncryptionContext"
        case grantTokens = "GrantTokens"
        case keyId = "KeyId"
        case keyPairSpec = "KeyPairSpec"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionContextContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .encryptionContext)
        var encryptionContextDecoded0: [String:String]? = nil
        if let encryptionContextContainer = encryptionContextContainer {
            encryptionContextDecoded0 = [String:String]()
            for (key0, encryptioncontextvalue0) in encryptionContextContainer {
                if let encryptioncontextvalue0 = encryptioncontextvalue0 {
                    encryptionContextDecoded0?[key0] = encryptioncontextvalue0
                }
            }
        }
        encryptionContext = encryptionContextDecoded0
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let keyPairSpecDecoded = try containerValues.decodeIfPresent(DataKeyPairSpec.self, forKey: .keyPairSpec)
        keyPairSpec = keyPairSpecDecoded
        let grantTokensContainer = try containerValues.decodeIfPresent([String?].self, forKey: .grantTokens)
        var grantTokensDecoded0:[String]? = nil
        if let grantTokensContainer = grantTokensContainer {
            grantTokensDecoded0 = [String]()
            for string0 in grantTokensContainer {
                if let string0 = string0 {
                    grantTokensDecoded0?.append(string0)
                }
            }
        }
        grantTokens = grantTokensDecoded0
    }
}

extension GenerateDataKeyPairWithoutPlaintextOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GenerateDataKeyPairWithoutPlaintextOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledException" : self = .disabledException(try DisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGrantTokenException" : self = .invalidGrantTokenException(try InvalidGrantTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKeyUsageException" : self = .invalidKeyUsageException(try InvalidKeyUsageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KeyUnavailableException" : self = .keyUnavailableException(try KeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GenerateDataKeyPairWithoutPlaintextOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case disabledException(DisabledException)
    case invalidGrantTokenException(InvalidGrantTokenException)
    case invalidKeyUsageException(InvalidKeyUsageException)
    case keyUnavailableException(KeyUnavailableException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case notFoundException(NotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GenerateDataKeyPairWithoutPlaintextOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GenerateDataKeyPairWithoutPlaintextOutputResponse(keyId: \(String(describing: keyId)), keyPairSpec: \(String(describing: keyPairSpec)), privateKeyCiphertextBlob: \(String(describing: privateKeyCiphertextBlob)), publicKey: \(String(describing: publicKey)))"}
}

extension GenerateDataKeyPairWithoutPlaintextOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GenerateDataKeyPairWithoutPlaintextOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.keyId = output.keyId
            self.keyPairSpec = output.keyPairSpec
            self.privateKeyCiphertextBlob = output.privateKeyCiphertextBlob
            self.publicKey = output.publicKey
        } else {
            self.keyId = nil
            self.keyPairSpec = nil
            self.privateKeyCiphertextBlob = nil
            self.publicKey = nil
        }
    }
}

public struct GenerateDataKeyPairWithoutPlaintextOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN">key ARN</a>) of the CMK that encrypted the private key.</p>
    public let keyId: String?
    /// <p>The type of data key pair that was generated.</p>
    public let keyPairSpec: DataKeyPairSpec?
    /// <p>The encrypted copy of the private key. When you use the HTTP API or the AWS CLI, the value is Base64-encoded. Otherwise, it is not Base64-encoded.</p>
    public let privateKeyCiphertextBlob: Data?
    /// <p>The public key (in plaintext).</p>
    public let publicKey: Data?

    public init (
        keyId: String? = nil,
        keyPairSpec: DataKeyPairSpec? = nil,
        privateKeyCiphertextBlob: Data? = nil,
        publicKey: Data? = nil
    )
    {
        self.keyId = keyId
        self.keyPairSpec = keyPairSpec
        self.privateKeyCiphertextBlob = privateKeyCiphertextBlob
        self.publicKey = publicKey
    }
}

struct GenerateDataKeyPairWithoutPlaintextOutputResponseBody: Equatable {
    public let privateKeyCiphertextBlob: Data?
    public let publicKey: Data?
    public let keyId: String?
    public let keyPairSpec: DataKeyPairSpec?
}

extension GenerateDataKeyPairWithoutPlaintextOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
        case keyPairSpec = "KeyPairSpec"
        case privateKeyCiphertextBlob = "PrivateKeyCiphertextBlob"
        case publicKey = "PublicKey"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let privateKeyCiphertextBlobDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .privateKeyCiphertextBlob)
        privateKeyCiphertextBlob = privateKeyCiphertextBlobDecoded
        let publicKeyDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .publicKey)
        publicKey = publicKeyDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let keyPairSpecDecoded = try containerValues.decodeIfPresent(DataKeyPairSpec.self, forKey: .keyPairSpec)
        keyPairSpec = keyPairSpecDecoded
    }
}

public struct GenerateDataKeyWithoutPlaintextInputBodyMiddleware: Middleware {
    public let id: String = "GenerateDataKeyWithoutPlaintextInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateDataKeyWithoutPlaintextInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateDataKeyWithoutPlaintextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateDataKeyWithoutPlaintextInput>
    public typealias MOutput = OperationOutput<GenerateDataKeyWithoutPlaintextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateDataKeyWithoutPlaintextOutputError>
}

extension GenerateDataKeyWithoutPlaintextInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GenerateDataKeyWithoutPlaintextInput(encryptionContext: \(String(describing: encryptionContext)), grantTokens: \(String(describing: grantTokens)), keyId: \(String(describing: keyId)), keySpec: \(String(describing: keySpec)), numberOfBytes: \(String(describing: numberOfBytes)))"}
}

extension GenerateDataKeyWithoutPlaintextInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionContext = "EncryptionContext"
        case grantTokens = "GrantTokens"
        case keyId = "KeyId"
        case keySpec = "KeySpec"
        case numberOfBytes = "NumberOfBytes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionContext = encryptionContext {
            var encryptionContextContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .encryptionContext)
            for (dictKey0, encryptioncontexttype0) in encryptionContext {
                try encryptionContextContainer.encode(encryptioncontexttype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let grantTokens = grantTokens {
            var grantTokensContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantTokens)
            for granttokenlist0 in grantTokens {
                try grantTokensContainer.encode(granttokenlist0)
            }
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let keySpec = keySpec {
            try encodeContainer.encode(keySpec.rawValue, forKey: .keySpec)
        }
        if let numberOfBytes = numberOfBytes {
            try encodeContainer.encode(numberOfBytes, forKey: .numberOfBytes)
        }
    }
}

public struct GenerateDataKeyWithoutPlaintextInputHeadersMiddleware: Middleware {
    public let id: String = "GenerateDataKeyWithoutPlaintextInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateDataKeyWithoutPlaintextInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateDataKeyWithoutPlaintextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateDataKeyWithoutPlaintextInput>
    public typealias MOutput = OperationOutput<GenerateDataKeyWithoutPlaintextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateDataKeyWithoutPlaintextOutputError>
}

public struct GenerateDataKeyWithoutPlaintextInputQueryItemMiddleware: Middleware {
    public let id: String = "GenerateDataKeyWithoutPlaintextInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateDataKeyWithoutPlaintextInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateDataKeyWithoutPlaintextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateDataKeyWithoutPlaintextInput>
    public typealias MOutput = OperationOutput<GenerateDataKeyWithoutPlaintextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateDataKeyWithoutPlaintextOutputError>
}

public struct GenerateDataKeyWithoutPlaintextInput: Equatable {
    /// <p>Specifies the encryption context that will be used when encrypting the data key.</p>
    ///          <p>An <i>encryption context</i> is a collection of non-secret key-value pairs that represents additional authenticated data. When you use an encryption context to encrypt data, you must specify the same (an exact case-sensitive match) encryption context to decrypt the data. An encryption context is optional when encrypting with a symmetric CMK, but it is highly recommended.</p>
    ///          <p>For more information, see
    ///         <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context">Encryption
    ///         Context</a> in the <i>AWS Key Management Service Developer Guide</i>.</p>
    public let encryptionContext: [String:String]?
    /// <p>A list of grant tokens.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#grant_token">Grant Tokens</a> in the
    ///     <i>AWS Key Management Service Developer Guide</i>.</p>
    public let grantTokens: [String]?
    /// <p>The identifier of the symmetric customer master key (CMK) that encrypts the data
    ///       key.</p>
    ///          <p>To specify a CMK, use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. When using an alias name, prefix it with <code>"alias/"</code>. To specify a CMK in a different AWS account, you must use the key ARN or alias ARN.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Alias name: <code>alias/ExampleAlias</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Alias ARN: <code>arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>. To get the alias name and alias ARN, use <a>ListAliases</a>.</p>
    public let keyId: String?
    /// <p>The length of the data key. Use <code>AES_128</code> to generate a 128-bit symmetric key,
    ///       or <code>AES_256</code> to generate a 256-bit symmetric key.</p>
    public let keySpec: DataKeySpec?
    /// <p>The length of the data key in bytes. For example, use the value 64 to generate a 512-bit
    ///       data key (64 bytes is 512 bits). For common key lengths (128-bit and 256-bit symmetric keys),
    ///       we recommend that you use the <code>KeySpec</code> field instead of this one.</p>
    public let numberOfBytes: Int?

    public init (
        encryptionContext: [String:String]? = nil,
        grantTokens: [String]? = nil,
        keyId: String? = nil,
        keySpec: DataKeySpec? = nil,
        numberOfBytes: Int? = nil
    )
    {
        self.encryptionContext = encryptionContext
        self.grantTokens = grantTokens
        self.keyId = keyId
        self.keySpec = keySpec
        self.numberOfBytes = numberOfBytes
    }
}

struct GenerateDataKeyWithoutPlaintextInputBody: Equatable {
    public let keyId: String?
    public let encryptionContext: [String:String]?
    public let keySpec: DataKeySpec?
    public let numberOfBytes: Int?
    public let grantTokens: [String]?
}

extension GenerateDataKeyWithoutPlaintextInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case encryptionContext = "EncryptionContext"
        case grantTokens = "GrantTokens"
        case keyId = "KeyId"
        case keySpec = "KeySpec"
        case numberOfBytes = "NumberOfBytes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let encryptionContextContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .encryptionContext)
        var encryptionContextDecoded0: [String:String]? = nil
        if let encryptionContextContainer = encryptionContextContainer {
            encryptionContextDecoded0 = [String:String]()
            for (key0, encryptioncontextvalue0) in encryptionContextContainer {
                if let encryptioncontextvalue0 = encryptioncontextvalue0 {
                    encryptionContextDecoded0?[key0] = encryptioncontextvalue0
                }
            }
        }
        encryptionContext = encryptionContextDecoded0
        let keySpecDecoded = try containerValues.decodeIfPresent(DataKeySpec.self, forKey: .keySpec)
        keySpec = keySpecDecoded
        let numberOfBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfBytes)
        numberOfBytes = numberOfBytesDecoded
        let grantTokensContainer = try containerValues.decodeIfPresent([String?].self, forKey: .grantTokens)
        var grantTokensDecoded0:[String]? = nil
        if let grantTokensContainer = grantTokensContainer {
            grantTokensDecoded0 = [String]()
            for string0 in grantTokensContainer {
                if let string0 = string0 {
                    grantTokensDecoded0?.append(string0)
                }
            }
        }
        grantTokens = grantTokensDecoded0
    }
}

extension GenerateDataKeyWithoutPlaintextOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GenerateDataKeyWithoutPlaintextOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledException" : self = .disabledException(try DisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGrantTokenException" : self = .invalidGrantTokenException(try InvalidGrantTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKeyUsageException" : self = .invalidKeyUsageException(try InvalidKeyUsageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KeyUnavailableException" : self = .keyUnavailableException(try KeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GenerateDataKeyWithoutPlaintextOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case disabledException(DisabledException)
    case invalidGrantTokenException(InvalidGrantTokenException)
    case invalidKeyUsageException(InvalidKeyUsageException)
    case keyUnavailableException(KeyUnavailableException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GenerateDataKeyWithoutPlaintextOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GenerateDataKeyWithoutPlaintextOutputResponse(ciphertextBlob: \(String(describing: ciphertextBlob)), keyId: \(String(describing: keyId)))"}
}

extension GenerateDataKeyWithoutPlaintextOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GenerateDataKeyWithoutPlaintextOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.ciphertextBlob = output.ciphertextBlob
            self.keyId = output.keyId
        } else {
            self.ciphertextBlob = nil
            self.keyId = nil
        }
    }
}

public struct GenerateDataKeyWithoutPlaintextOutputResponse: Equatable {
    /// <p>The encrypted data key. When you use the HTTP API or the AWS CLI, the value is Base64-encoded. Otherwise, it is not Base64-encoded.</p>
    public let ciphertextBlob: Data?
    /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN">key ARN</a>) of the CMK that encrypted the data key.</p>
    public let keyId: String?

    public init (
        ciphertextBlob: Data? = nil,
        keyId: String? = nil
    )
    {
        self.ciphertextBlob = ciphertextBlob
        self.keyId = keyId
    }
}

struct GenerateDataKeyWithoutPlaintextOutputResponseBody: Equatable {
    public let ciphertextBlob: Data?
    public let keyId: String?
}

extension GenerateDataKeyWithoutPlaintextOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ciphertextBlob = "CiphertextBlob"
        case keyId = "KeyId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ciphertextBlobDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .ciphertextBlob)
        ciphertextBlob = ciphertextBlobDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
    }
}

public struct GenerateRandomInputBodyMiddleware: Middleware {
    public let id: String = "GenerateRandomInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateRandomInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateRandomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateRandomInput>
    public typealias MOutput = OperationOutput<GenerateRandomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateRandomOutputError>
}

extension GenerateRandomInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GenerateRandomInput(customKeyStoreId: \(String(describing: customKeyStoreId)), numberOfBytes: \(String(describing: numberOfBytes)))"}
}

extension GenerateRandomInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customKeyStoreId = "CustomKeyStoreId"
        case numberOfBytes = "NumberOfBytes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customKeyStoreId = customKeyStoreId {
            try encodeContainer.encode(customKeyStoreId, forKey: .customKeyStoreId)
        }
        if let numberOfBytes = numberOfBytes {
            try encodeContainer.encode(numberOfBytes, forKey: .numberOfBytes)
        }
    }
}

public struct GenerateRandomInputHeadersMiddleware: Middleware {
    public let id: String = "GenerateRandomInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateRandomInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateRandomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateRandomInput>
    public typealias MOutput = OperationOutput<GenerateRandomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateRandomOutputError>
}

public struct GenerateRandomInputQueryItemMiddleware: Middleware {
    public let id: String = "GenerateRandomInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateRandomInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateRandomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateRandomInput>
    public typealias MOutput = OperationOutput<GenerateRandomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateRandomOutputError>
}

public struct GenerateRandomInput: Equatable {
    /// <p>Generates the random byte string in the AWS CloudHSM cluster that is associated with the
    ///       specified <a href="https://docs.aws.amazon.com/kms/latest/developerguide/custom-key-store-overview.html">custom key store</a>. To find the ID of a custom key store, use the <a>DescribeCustomKeyStores</a> operation.</p>
    public let customKeyStoreId: String?
    /// <p>The length of the byte string.</p>
    public let numberOfBytes: Int?

    public init (
        customKeyStoreId: String? = nil,
        numberOfBytes: Int? = nil
    )
    {
        self.customKeyStoreId = customKeyStoreId
        self.numberOfBytes = numberOfBytes
    }
}

struct GenerateRandomInputBody: Equatable {
    public let numberOfBytes: Int?
    public let customKeyStoreId: String?
}

extension GenerateRandomInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customKeyStoreId = "CustomKeyStoreId"
        case numberOfBytes = "NumberOfBytes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberOfBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfBytes)
        numberOfBytes = numberOfBytesDecoded
        let customKeyStoreIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customKeyStoreId)
        customKeyStoreId = customKeyStoreIdDecoded
    }
}

extension GenerateRandomOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GenerateRandomOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CustomKeyStoreInvalidStateException" : self = .customKeyStoreInvalidStateException(try CustomKeyStoreInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CustomKeyStoreNotFoundException" : self = .customKeyStoreNotFoundException(try CustomKeyStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GenerateRandomOutputError: Equatable {
    case customKeyStoreInvalidStateException(CustomKeyStoreInvalidStateException)
    case customKeyStoreNotFoundException(CustomKeyStoreNotFoundException)
    case dependencyTimeoutException(DependencyTimeoutException)
    case kMSInternalException(KMSInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GenerateRandomOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GenerateRandomOutputResponse(plaintext: \(String(describing: plaintext)))"}
}

extension GenerateRandomOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GenerateRandomOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.plaintext = output.plaintext
        } else {
            self.plaintext = nil
        }
    }
}

public struct GenerateRandomOutputResponse: Equatable {
    /// <p>The random byte string. When you use the HTTP API or the AWS CLI, the value is Base64-encoded. Otherwise, it is not Base64-encoded.</p>
    public let plaintext: Data?

    public init (
        plaintext: Data? = nil
    )
    {
        self.plaintext = plaintext
    }
}

struct GenerateRandomOutputResponseBody: Equatable {
    public let plaintext: Data?
}

extension GenerateRandomOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case plaintext = "Plaintext"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let plaintextDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .plaintext)
        plaintext = plaintextDecoded
    }
}

public struct GetKeyPolicyInputBodyMiddleware: Middleware {
    public let id: String = "GetKeyPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetKeyPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetKeyPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetKeyPolicyInput>
    public typealias MOutput = OperationOutput<GetKeyPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetKeyPolicyOutputError>
}

extension GetKeyPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetKeyPolicyInput(keyId: \(String(describing: keyId)), policyName: \(String(describing: policyName)))"}
}

extension GetKeyPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let policyName = policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
    }
}

public struct GetKeyPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetKeyPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetKeyPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetKeyPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetKeyPolicyInput>
    public typealias MOutput = OperationOutput<GetKeyPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetKeyPolicyOutputError>
}

public struct GetKeyPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetKeyPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetKeyPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetKeyPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetKeyPolicyInput>
    public typealias MOutput = OperationOutput<GetKeyPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetKeyPolicyOutputError>
}

public struct GetKeyPolicyInput: Equatable {
    /// <p>A unique identifier for the customer master key (CMK).</p>
    ///          <p>Specify the key ID or the Amazon Resource Name (ARN) of the CMK.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
    public let keyId: String?
    /// <p>Specifies the name of the key policy. The only valid name is <code>default</code>. To get
    ///       the names of key policies, use <a>ListKeyPolicies</a>.</p>
    public let policyName: String?

    public init (
        keyId: String? = nil,
        policyName: String? = nil
    )
    {
        self.keyId = keyId
        self.policyName = policyName
    }
}

struct GetKeyPolicyInputBody: Equatable {
    public let keyId: String?
    public let policyName: String?
}

extension GetKeyPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
        case policyName = "PolicyName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
    }
}

extension GetKeyPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetKeyPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetKeyPolicyOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case invalidArnException(InvalidArnException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetKeyPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetKeyPolicyOutputResponse(policy: \(String(describing: policy)))"}
}

extension GetKeyPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetKeyPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetKeyPolicyOutputResponse: Equatable {
    /// <p>A key policy document in JSON format.</p>
    public let policy: String?

    public init (
        policy: String? = nil
    )
    {
        self.policy = policy
    }
}

struct GetKeyPolicyOutputResponseBody: Equatable {
    public let policy: String?
}

extension GetKeyPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

public struct GetKeyRotationStatusInputBodyMiddleware: Middleware {
    public let id: String = "GetKeyRotationStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetKeyRotationStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetKeyRotationStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetKeyRotationStatusInput>
    public typealias MOutput = OperationOutput<GetKeyRotationStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetKeyRotationStatusOutputError>
}

extension GetKeyRotationStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetKeyRotationStatusInput(keyId: \(String(describing: keyId)))"}
}

extension GetKeyRotationStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
    }
}

public struct GetKeyRotationStatusInputHeadersMiddleware: Middleware {
    public let id: String = "GetKeyRotationStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetKeyRotationStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetKeyRotationStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetKeyRotationStatusInput>
    public typealias MOutput = OperationOutput<GetKeyRotationStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetKeyRotationStatusOutputError>
}

public struct GetKeyRotationStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "GetKeyRotationStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetKeyRotationStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetKeyRotationStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetKeyRotationStatusInput>
    public typealias MOutput = OperationOutput<GetKeyRotationStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetKeyRotationStatusOutputError>
}

public struct GetKeyRotationStatusInput: Equatable {
    /// <p>A unique identifier for the customer master key (CMK).</p>
    ///          <p>Specify the key ID or the Amazon Resource Name (ARN) of the CMK. To specify a CMK in a
    /// different AWS account, you must use the key ARN.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
    public let keyId: String?

    public init (
        keyId: String? = nil
    )
    {
        self.keyId = keyId
    }
}

struct GetKeyRotationStatusInputBody: Equatable {
    public let keyId: String?
}

extension GetKeyRotationStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
    }
}

extension GetKeyRotationStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetKeyRotationStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetKeyRotationStatusOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case invalidArnException(InvalidArnException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case notFoundException(NotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetKeyRotationStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetKeyRotationStatusOutputResponse(keyRotationEnabled: \(String(describing: keyRotationEnabled)))"}
}

extension GetKeyRotationStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetKeyRotationStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.keyRotationEnabled = output.keyRotationEnabled
        } else {
            self.keyRotationEnabled = false
        }
    }
}

public struct GetKeyRotationStatusOutputResponse: Equatable {
    /// <p>A Boolean value that specifies whether key rotation is enabled.</p>
    public let keyRotationEnabled: Bool

    public init (
        keyRotationEnabled: Bool = false
    )
    {
        self.keyRotationEnabled = keyRotationEnabled
    }
}

struct GetKeyRotationStatusOutputResponseBody: Equatable {
    public let keyRotationEnabled: Bool
}

extension GetKeyRotationStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyRotationEnabled = "KeyRotationEnabled"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyRotationEnabledDecoded = try containerValues.decode(Bool.self, forKey: .keyRotationEnabled)
        keyRotationEnabled = keyRotationEnabledDecoded
    }
}

public struct GetParametersForImportInputBodyMiddleware: Middleware {
    public let id: String = "GetParametersForImportInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetParametersForImportInput>,
                  next: H) -> Swift.Result<OperationOutput<GetParametersForImportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetParametersForImportInput>
    public typealias MOutput = OperationOutput<GetParametersForImportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetParametersForImportOutputError>
}

extension GetParametersForImportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetParametersForImportInput(keyId: \(String(describing: keyId)), wrappingAlgorithm: \(String(describing: wrappingAlgorithm)), wrappingKeySpec: \(String(describing: wrappingKeySpec)))"}
}

extension GetParametersForImportInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
        case wrappingAlgorithm = "WrappingAlgorithm"
        case wrappingKeySpec = "WrappingKeySpec"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let wrappingAlgorithm = wrappingAlgorithm {
            try encodeContainer.encode(wrappingAlgorithm.rawValue, forKey: .wrappingAlgorithm)
        }
        if let wrappingKeySpec = wrappingKeySpec {
            try encodeContainer.encode(wrappingKeySpec.rawValue, forKey: .wrappingKeySpec)
        }
    }
}

public struct GetParametersForImportInputHeadersMiddleware: Middleware {
    public let id: String = "GetParametersForImportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetParametersForImportInput>,
                  next: H) -> Swift.Result<OperationOutput<GetParametersForImportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetParametersForImportInput>
    public typealias MOutput = OperationOutput<GetParametersForImportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetParametersForImportOutputError>
}

public struct GetParametersForImportInputQueryItemMiddleware: Middleware {
    public let id: String = "GetParametersForImportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetParametersForImportInput>,
                  next: H) -> Swift.Result<OperationOutput<GetParametersForImportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetParametersForImportInput>
    public typealias MOutput = OperationOutput<GetParametersForImportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetParametersForImportOutputError>
}

public struct GetParametersForImportInput: Equatable {
    /// <p>The identifier of the symmetric CMK into which you will import key material. The
    ///         <code>Origin</code> of the CMK must be <code>EXTERNAL</code>.</p>
    ///          <p>Specify the key ID or the Amazon Resource Name (ARN) of the CMK.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
    public let keyId: String?
    /// <p>The algorithm you will use to encrypt the key material before importing it with <a>ImportKeyMaterial</a>. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/importing-keys-encrypt-key-material.html">Encrypt the Key Material</a>
    ///       in the <i>AWS Key Management Service Developer Guide</i>.</p>
    public let wrappingAlgorithm: AlgorithmSpec?
    /// <p>The type of wrapping key (public key) to return in the response. Only 2048-bit RSA public
    ///       keys are supported.</p>
    public let wrappingKeySpec: WrappingKeySpec?

    public init (
        keyId: String? = nil,
        wrappingAlgorithm: AlgorithmSpec? = nil,
        wrappingKeySpec: WrappingKeySpec? = nil
    )
    {
        self.keyId = keyId
        self.wrappingAlgorithm = wrappingAlgorithm
        self.wrappingKeySpec = wrappingKeySpec
    }
}

struct GetParametersForImportInputBody: Equatable {
    public let keyId: String?
    public let wrappingAlgorithm: AlgorithmSpec?
    public let wrappingKeySpec: WrappingKeySpec?
}

extension GetParametersForImportInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
        case wrappingAlgorithm = "WrappingAlgorithm"
        case wrappingKeySpec = "WrappingKeySpec"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let wrappingAlgorithmDecoded = try containerValues.decodeIfPresent(AlgorithmSpec.self, forKey: .wrappingAlgorithm)
        wrappingAlgorithm = wrappingAlgorithmDecoded
        let wrappingKeySpecDecoded = try containerValues.decodeIfPresent(WrappingKeySpec.self, forKey: .wrappingKeySpec)
        wrappingKeySpec = wrappingKeySpecDecoded
    }
}

extension GetParametersForImportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetParametersForImportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetParametersForImportOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case invalidArnException(InvalidArnException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case notFoundException(NotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetParametersForImportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetParametersForImportOutputResponse(importToken: \(String(describing: importToken)), keyId: \(String(describing: keyId)), parametersValidTo: \(String(describing: parametersValidTo)), publicKey: \(String(describing: publicKey)))"}
}

extension GetParametersForImportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetParametersForImportOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.importToken = output.importToken
            self.keyId = output.keyId
            self.parametersValidTo = output.parametersValidTo
            self.publicKey = output.publicKey
        } else {
            self.importToken = nil
            self.keyId = nil
            self.parametersValidTo = nil
            self.publicKey = nil
        }
    }
}

public struct GetParametersForImportOutputResponse: Equatable {
    /// <p>The import token to send in a subsequent <a>ImportKeyMaterial</a>
    ///       request.</p>
    public let importToken: Data?
    /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN">key ARN</a>) of the CMK to use in a subsequent <a>ImportKeyMaterial</a>
    ///       request. This is the same CMK specified in the <code>GetParametersForImport</code>
    ///       request.</p>
    public let keyId: String?
    /// <p>The time at which the import token and public key are no longer valid. After this time,
    ///       you cannot use them to make an <a>ImportKeyMaterial</a> request and you must send
    ///       another <code>GetParametersForImport</code> request to get new ones.</p>
    public let parametersValidTo: Date?
    /// <p>The public key to use to encrypt the key material before importing it with <a>ImportKeyMaterial</a>.</p>
    public let publicKey: Data?

    public init (
        importToken: Data? = nil,
        keyId: String? = nil,
        parametersValidTo: Date? = nil,
        publicKey: Data? = nil
    )
    {
        self.importToken = importToken
        self.keyId = keyId
        self.parametersValidTo = parametersValidTo
        self.publicKey = publicKey
    }
}

struct GetParametersForImportOutputResponseBody: Equatable {
    public let keyId: String?
    public let importToken: Data?
    public let publicKey: Data?
    public let parametersValidTo: Date?
}

extension GetParametersForImportOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case importToken = "ImportToken"
        case keyId = "KeyId"
        case parametersValidTo = "ParametersValidTo"
        case publicKey = "PublicKey"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let importTokenDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .importToken)
        importToken = importTokenDecoded
        let publicKeyDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .publicKey)
        publicKey = publicKeyDecoded
        let parametersValidToDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .parametersValidTo)
        parametersValidTo = parametersValidToDecoded
    }
}

public struct GetPublicKeyInputBodyMiddleware: Middleware {
    public let id: String = "GetPublicKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPublicKeyInput>
    public typealias MOutput = OperationOutput<GetPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPublicKeyOutputError>
}

extension GetPublicKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPublicKeyInput(grantTokens: \(String(describing: grantTokens)), keyId: \(String(describing: keyId)))"}
}

extension GetPublicKeyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grantTokens = "GrantTokens"
        case keyId = "KeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantTokens = grantTokens {
            var grantTokensContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantTokens)
            for granttokenlist0 in grantTokens {
                try grantTokensContainer.encode(granttokenlist0)
            }
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
    }
}

public struct GetPublicKeyInputHeadersMiddleware: Middleware {
    public let id: String = "GetPublicKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPublicKeyInput>
    public typealias MOutput = OperationOutput<GetPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPublicKeyOutputError>
}

public struct GetPublicKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPublicKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPublicKeyInput>
    public typealias MOutput = OperationOutput<GetPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPublicKeyOutputError>
}

public struct GetPublicKeyInput: Equatable {
    /// <p>A list of grant tokens.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#grant_token">Grant Tokens</a> in the
    ///     <i>AWS Key Management Service Developer Guide</i>.</p>
    public let grantTokens: [String]?
    /// <p>Identifies the asymmetric CMK that includes the public key.</p>
    ///
    ///          <p>To specify a CMK, use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. When using an alias name, prefix it with <code>"alias/"</code>. To specify a CMK in a different AWS account, you must use the key ARN or alias ARN.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Alias name: <code>alias/ExampleAlias</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Alias ARN: <code>arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>. To get the alias name and alias ARN, use <a>ListAliases</a>.</p>
    public let keyId: String?

    public init (
        grantTokens: [String]? = nil,
        keyId: String? = nil
    )
    {
        self.grantTokens = grantTokens
        self.keyId = keyId
    }
}

struct GetPublicKeyInputBody: Equatable {
    public let keyId: String?
    public let grantTokens: [String]?
}

extension GetPublicKeyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case grantTokens = "GrantTokens"
        case keyId = "KeyId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let grantTokensContainer = try containerValues.decodeIfPresent([String?].self, forKey: .grantTokens)
        var grantTokensDecoded0:[String]? = nil
        if let grantTokensContainer = grantTokensContainer {
            grantTokensDecoded0 = [String]()
            for string0 in grantTokensContainer {
                if let string0 = string0 {
                    grantTokensDecoded0?.append(string0)
                }
            }
        }
        grantTokens = grantTokensDecoded0
    }
}

extension GetPublicKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPublicKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledException" : self = .disabledException(try DisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGrantTokenException" : self = .invalidGrantTokenException(try InvalidGrantTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKeyUsageException" : self = .invalidKeyUsageException(try InvalidKeyUsageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KeyUnavailableException" : self = .keyUnavailableException(try KeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPublicKeyOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case disabledException(DisabledException)
    case invalidArnException(InvalidArnException)
    case invalidGrantTokenException(InvalidGrantTokenException)
    case invalidKeyUsageException(InvalidKeyUsageException)
    case keyUnavailableException(KeyUnavailableException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case notFoundException(NotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPublicKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPublicKeyOutputResponse(customerMasterKeySpec: \(String(describing: customerMasterKeySpec)), encryptionAlgorithms: \(String(describing: encryptionAlgorithms)), keyId: \(String(describing: keyId)), keyUsage: \(String(describing: keyUsage)), publicKey: \(String(describing: publicKey)), signingAlgorithms: \(String(describing: signingAlgorithms)))"}
}

extension GetPublicKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetPublicKeyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.customerMasterKeySpec = output.customerMasterKeySpec
            self.encryptionAlgorithms = output.encryptionAlgorithms
            self.keyId = output.keyId
            self.keyUsage = output.keyUsage
            self.publicKey = output.publicKey
            self.signingAlgorithms = output.signingAlgorithms
        } else {
            self.customerMasterKeySpec = nil
            self.encryptionAlgorithms = nil
            self.keyId = nil
            self.keyUsage = nil
            self.publicKey = nil
            self.signingAlgorithms = nil
        }
    }
}

public struct GetPublicKeyOutputResponse: Equatable {
    /// <p>The type of the of the public key that was downloaded.</p>
    public let customerMasterKeySpec: CustomerMasterKeySpec?
    /// <p>The encryption algorithms that AWS KMS supports for this key. </p>
    ///          <p>This information is critical. If a public key encrypts data outside of AWS KMS by using an
    ///       unsupported encryption algorithm, the ciphertext cannot be decrypted. </p>
    ///          <p>This field appears in the response only when the <code>KeyUsage</code> of the public key
    ///       is <code>ENCRYPT_DECRYPT</code>.</p>
    public let encryptionAlgorithms: [EncryptionAlgorithmSpec]?
    /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN">key ARN</a>) of the asymmetric CMK from which the public key was downloaded.</p>
    public let keyId: String?
    /// <p>The permitted use of the public key. Valid values are <code>ENCRYPT_DECRYPT</code> or
    ///         <code>SIGN_VERIFY</code>. </p>
    ///          <p>This information is critical. If a public key with <code>SIGN_VERIFY</code> key usage
    ///       encrypts data outside of AWS KMS, the ciphertext cannot be decrypted. </p>
    public let keyUsage: KeyUsageType?
    /// <p>The exported public key. </p>
    ///          <p>The value is a DER-encoded X.509 public key, also known as
    ///         <code>SubjectPublicKeyInfo</code> (SPKI), as defined in <a href="https://tools.ietf.org/html/rfc5280">RFC 5280</a>. When you use the HTTP API or the AWS CLI, the value is Base64-encoded. Otherwise, it is not Base64-encoded.</p>
    ///          <p></p>
    public let publicKey: Data?
    /// <p>The signing algorithms that AWS KMS supports for this key.</p>
    ///          <p>This field appears in the response only when the <code>KeyUsage</code> of the public key
    ///       is <code>SIGN_VERIFY</code>.</p>
    public let signingAlgorithms: [SigningAlgorithmSpec]?

    public init (
        customerMasterKeySpec: CustomerMasterKeySpec? = nil,
        encryptionAlgorithms: [EncryptionAlgorithmSpec]? = nil,
        keyId: String? = nil,
        keyUsage: KeyUsageType? = nil,
        publicKey: Data? = nil,
        signingAlgorithms: [SigningAlgorithmSpec]? = nil
    )
    {
        self.customerMasterKeySpec = customerMasterKeySpec
        self.encryptionAlgorithms = encryptionAlgorithms
        self.keyId = keyId
        self.keyUsage = keyUsage
        self.publicKey = publicKey
        self.signingAlgorithms = signingAlgorithms
    }
}

struct GetPublicKeyOutputResponseBody: Equatable {
    public let keyId: String?
    public let publicKey: Data?
    public let customerMasterKeySpec: CustomerMasterKeySpec?
    public let keyUsage: KeyUsageType?
    public let encryptionAlgorithms: [EncryptionAlgorithmSpec]?
    public let signingAlgorithms: [SigningAlgorithmSpec]?
}

extension GetPublicKeyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customerMasterKeySpec = "CustomerMasterKeySpec"
        case encryptionAlgorithms = "EncryptionAlgorithms"
        case keyId = "KeyId"
        case keyUsage = "KeyUsage"
        case publicKey = "PublicKey"
        case signingAlgorithms = "SigningAlgorithms"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let publicKeyDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .publicKey)
        publicKey = publicKeyDecoded
        let customerMasterKeySpecDecoded = try containerValues.decodeIfPresent(CustomerMasterKeySpec.self, forKey: .customerMasterKeySpec)
        customerMasterKeySpec = customerMasterKeySpecDecoded
        let keyUsageDecoded = try containerValues.decodeIfPresent(KeyUsageType.self, forKey: .keyUsage)
        keyUsage = keyUsageDecoded
        let encryptionAlgorithmsContainer = try containerValues.decodeIfPresent([EncryptionAlgorithmSpec?].self, forKey: .encryptionAlgorithms)
        var encryptionAlgorithmsDecoded0:[EncryptionAlgorithmSpec]? = nil
        if let encryptionAlgorithmsContainer = encryptionAlgorithmsContainer {
            encryptionAlgorithmsDecoded0 = [EncryptionAlgorithmSpec]()
            for string0 in encryptionAlgorithmsContainer {
                if let string0 = string0 {
                    encryptionAlgorithmsDecoded0?.append(string0)
                }
            }
        }
        encryptionAlgorithms = encryptionAlgorithmsDecoded0
        let signingAlgorithmsContainer = try containerValues.decodeIfPresent([SigningAlgorithmSpec?].self, forKey: .signingAlgorithms)
        var signingAlgorithmsDecoded0:[SigningAlgorithmSpec]? = nil
        if let signingAlgorithmsContainer = signingAlgorithmsContainer {
            signingAlgorithmsDecoded0 = [SigningAlgorithmSpec]()
            for string0 in signingAlgorithmsContainer {
                if let string0 = string0 {
                    signingAlgorithmsDecoded0?.append(string0)
                }
            }
        }
        signingAlgorithms = signingAlgorithmsDecoded0
    }
}

extension GrantConstraints: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionContextEquals = "EncryptionContextEquals"
        case encryptionContextSubset = "EncryptionContextSubset"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionContextEquals = encryptionContextEquals {
            var encryptionContextEqualsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .encryptionContextEquals)
            for (dictKey0, encryptioncontexttype0) in encryptionContextEquals {
                try encryptionContextEqualsContainer.encode(encryptioncontexttype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let encryptionContextSubset = encryptionContextSubset {
            var encryptionContextSubsetContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .encryptionContextSubset)
            for (dictKey0, encryptioncontexttype0) in encryptionContextSubset {
                try encryptionContextSubsetContainer.encode(encryptioncontexttype0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionContextSubsetContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .encryptionContextSubset)
        var encryptionContextSubsetDecoded0: [String:String]? = nil
        if let encryptionContextSubsetContainer = encryptionContextSubsetContainer {
            encryptionContextSubsetDecoded0 = [String:String]()
            for (key0, encryptioncontextvalue0) in encryptionContextSubsetContainer {
                if let encryptioncontextvalue0 = encryptioncontextvalue0 {
                    encryptionContextSubsetDecoded0?[key0] = encryptioncontextvalue0
                }
            }
        }
        encryptionContextSubset = encryptionContextSubsetDecoded0
        let encryptionContextEqualsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .encryptionContextEquals)
        var encryptionContextEqualsDecoded0: [String:String]? = nil
        if let encryptionContextEqualsContainer = encryptionContextEqualsContainer {
            encryptionContextEqualsDecoded0 = [String:String]()
            for (key0, encryptioncontextvalue0) in encryptionContextEqualsContainer {
                if let encryptioncontextvalue0 = encryptioncontextvalue0 {
                    encryptionContextEqualsDecoded0?[key0] = encryptioncontextvalue0
                }
            }
        }
        encryptionContextEquals = encryptionContextEqualsDecoded0
    }
}

extension GrantConstraints: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GrantConstraints(encryptionContextEquals: \(String(describing: encryptionContextEquals)), encryptionContextSubset: \(String(describing: encryptionContextSubset)))"}
}

/// <p>Use this structure to allow <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations">cryptographic operations</a> in the grant only when the operation request
///       includes the specified <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context">encryption context</a>. </p>
///          <p>AWS KMS applies the grant constraints only to cryptographic operations that support an
///       encryption context, that is, all cryptographic operations with a <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symm-asymm-concepts.html#symmetric-cmks">symmetric CMK</a>. Grant
///       constraints are not applied to operations that do not support an encryption context, such as
///       cryptographic operations with asymmetric CMKs and management operations, such as <a>DescribeKey</a> or <a>RetireGrant</a>.</p>
///          <important>
///             <p>In a cryptographic operation, the encryption context in the decryption operation must be
///         an exact, case-sensitive match for the keys and values in the encryption context of the
///         encryption operation. Only the order of the pairs can vary.</p>
///             <p>However, in a grant constraint, the key in each key-value pair is not case sensitive,
///         but the value is case sensitive.</p>
///             <p>To avoid confusion, do not use multiple encryption context pairs that differ only by
///         case. To require a fully case-sensitive encryption context, use the
///           <code>kms:EncryptionContext:</code> and <code>kms:EncryptionContextKeys</code> conditions
///         in an IAM or key policy. For details, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/policy-conditions.html#conditions-kms-encryption-context">kms:EncryptionContext:</a> in the <i>
///                   <i>AWS Key Management Service Developer Guide</i>
///                </i>.</p>
///          </important>
public struct GrantConstraints: Equatable {
    /// <p>A list of key-value pairs that must match the encryption context in the <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations">cryptographic operation</a> request. The grant allows the operation only when the encryption context in the
    ///       request is the same as the encryption context specified in this constraint.</p>
    public let encryptionContextEquals: [String:String]?
    /// <p>A list of key-value pairs that must be included in the encryption context of the
    ///       <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations">cryptographic operation</a> request. The grant allows the cryptographic operation only when the
    ///       encryption context in the request includes the key-value pairs specified in this constraint,
    ///       although it can include additional key-value pairs.</p>
    public let encryptionContextSubset: [String:String]?

    public init (
        encryptionContextEquals: [String:String]? = nil,
        encryptionContextSubset: [String:String]? = nil
    )
    {
        self.encryptionContextEquals = encryptionContextEquals
        self.encryptionContextSubset = encryptionContextSubset
    }
}

extension GrantListEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case constraints = "Constraints"
        case creationDate = "CreationDate"
        case grantId = "GrantId"
        case granteePrincipal = "GranteePrincipal"
        case issuingAccount = "IssuingAccount"
        case keyId = "KeyId"
        case name = "Name"
        case operations = "Operations"
        case retiringPrincipal = "RetiringPrincipal"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let constraints = constraints {
            try encodeContainer.encode(constraints, forKey: .constraints)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let grantId = grantId {
            try encodeContainer.encode(grantId, forKey: .grantId)
        }
        if let granteePrincipal = granteePrincipal {
            try encodeContainer.encode(granteePrincipal, forKey: .granteePrincipal)
        }
        if let issuingAccount = issuingAccount {
            try encodeContainer.encode(issuingAccount, forKey: .issuingAccount)
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let operations = operations {
            var operationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operations)
            for grantoperationlist0 in operations {
                try operationsContainer.encode(grantoperationlist0.rawValue)
            }
        }
        if let retiringPrincipal = retiringPrincipal {
            try encodeContainer.encode(retiringPrincipal, forKey: .retiringPrincipal)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let grantIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grantId)
        grantId = grantIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let granteePrincipalDecoded = try containerValues.decodeIfPresent(String.self, forKey: .granteePrincipal)
        granteePrincipal = granteePrincipalDecoded
        let retiringPrincipalDecoded = try containerValues.decodeIfPresent(String.self, forKey: .retiringPrincipal)
        retiringPrincipal = retiringPrincipalDecoded
        let issuingAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .issuingAccount)
        issuingAccount = issuingAccountDecoded
        let operationsContainer = try containerValues.decodeIfPresent([GrantOperation?].self, forKey: .operations)
        var operationsDecoded0:[GrantOperation]? = nil
        if let operationsContainer = operationsContainer {
            operationsDecoded0 = [GrantOperation]()
            for string0 in operationsContainer {
                if let string0 = string0 {
                    operationsDecoded0?.append(string0)
                }
            }
        }
        operations = operationsDecoded0
        let constraintsDecoded = try containerValues.decodeIfPresent(GrantConstraints.self, forKey: .constraints)
        constraints = constraintsDecoded
    }
}

extension GrantListEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GrantListEntry(constraints: \(String(describing: constraints)), creationDate: \(String(describing: creationDate)), grantId: \(String(describing: grantId)), granteePrincipal: \(String(describing: granteePrincipal)), issuingAccount: \(String(describing: issuingAccount)), keyId: \(String(describing: keyId)), name: \(String(describing: name)), operations: \(String(describing: operations)), retiringPrincipal: \(String(describing: retiringPrincipal)))"}
}

/// <p>Contains information about a grant.</p>
public struct GrantListEntry: Equatable {
    /// <p>A list of key-value pairs that must be present in the encryption context of certain
    ///       subsequent operations that the grant allows.</p>
    public let constraints: GrantConstraints?
    /// <p>The date and time when the grant was created.</p>
    public let creationDate: Date?
    /// <p>The unique identifier for the grant.</p>
    public let grantId: String?
    /// <p>The identity that gets the permissions in the grant.</p>
    ///          <p>The <code>GranteePrincipal</code> field in the <code>ListGrants</code> response usually contains the
    ///         user or role designated as the grantee principal in the grant. However, when the grantee
    ///         principal in the grant is an AWS service, the <code>GranteePrincipal</code> field contains
    ///         the <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_principal.html#principal-services">service
    ///           principal</a>, which might represent several different grantee principals.</p>
    public let granteePrincipal: String?
    /// <p>The AWS account under which the grant was issued.</p>
    public let issuingAccount: String?
    /// <p>The unique identifier for the customer master key (CMK) to which the grant applies.</p>
    public let keyId: String?
    /// <p>The friendly name that identifies the grant. If a name was provided in the <a>CreateGrant</a> request, that name is returned. Otherwise this value is null.</p>
    public let name: String?
    /// <p>The list of operations permitted by the grant.</p>
    public let operations: [GrantOperation]?
    /// <p>The principal that can retire the grant.</p>
    public let retiringPrincipal: String?

    public init (
        constraints: GrantConstraints? = nil,
        creationDate: Date? = nil,
        grantId: String? = nil,
        granteePrincipal: String? = nil,
        issuingAccount: String? = nil,
        keyId: String? = nil,
        name: String? = nil,
        operations: [GrantOperation]? = nil,
        retiringPrincipal: String? = nil
    )
    {
        self.constraints = constraints
        self.creationDate = creationDate
        self.grantId = grantId
        self.granteePrincipal = granteePrincipal
        self.issuingAccount = issuingAccount
        self.keyId = keyId
        self.name = name
        self.operations = operations
        self.retiringPrincipal = retiringPrincipal
    }
}

public enum GrantOperation {
    case creategrant
    case decrypt
    case describekey
    case encrypt
    case generatedatakey
    case generatedatakeypair
    case generatedatakeypairwithoutplaintext
    case generatedatakeywithoutplaintext
    case getpublickey
    case reencryptfrom
    case reencryptto
    case retiregrant
    case sign
    case verify
    case sdkUnknown(String)
}

extension GrantOperation : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [GrantOperation] {
        return [
            .creategrant,
            .decrypt,
            .describekey,
            .encrypt,
            .generatedatakey,
            .generatedatakeypair,
            .generatedatakeypairwithoutplaintext,
            .generatedatakeywithoutplaintext,
            .getpublickey,
            .reencryptfrom,
            .reencryptto,
            .retiregrant,
            .sign,
            .verify,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .creategrant: return "CreateGrant"
        case .decrypt: return "Decrypt"
        case .describekey: return "DescribeKey"
        case .encrypt: return "Encrypt"
        case .generatedatakey: return "GenerateDataKey"
        case .generatedatakeypair: return "GenerateDataKeyPair"
        case .generatedatakeypairwithoutplaintext: return "GenerateDataKeyPairWithoutPlaintext"
        case .generatedatakeywithoutplaintext: return "GenerateDataKeyWithoutPlaintext"
        case .getpublickey: return "GetPublicKey"
        case .reencryptfrom: return "ReEncryptFrom"
        case .reencryptto: return "ReEncryptTo"
        case .retiregrant: return "RetireGrant"
        case .sign: return "Sign"
        case .verify: return "Verify"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = GrantOperation(rawValue: rawValue) ?? GrantOperation.sdkUnknown(rawValue)
    }
}

public struct ImportKeyMaterialInputBodyMiddleware: Middleware {
    public let id: String = "ImportKeyMaterialInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportKeyMaterialInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportKeyMaterialOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportKeyMaterialInput>
    public typealias MOutput = OperationOutput<ImportKeyMaterialOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportKeyMaterialOutputError>
}

extension ImportKeyMaterialInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportKeyMaterialInput(encryptedKeyMaterial: \(String(describing: encryptedKeyMaterial)), expirationModel: \(String(describing: expirationModel)), importToken: \(String(describing: importToken)), keyId: \(String(describing: keyId)), validTo: \(String(describing: validTo)))"}
}

extension ImportKeyMaterialInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptedKeyMaterial = "EncryptedKeyMaterial"
        case expirationModel = "ExpirationModel"
        case importToken = "ImportToken"
        case keyId = "KeyId"
        case validTo = "ValidTo"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptedKeyMaterial = encryptedKeyMaterial {
            try encodeContainer.encode(encryptedKeyMaterial.base64EncodedString(), forKey: .encryptedKeyMaterial)
        }
        if let expirationModel = expirationModel {
            try encodeContainer.encode(expirationModel.rawValue, forKey: .expirationModel)
        }
        if let importToken = importToken {
            try encodeContainer.encode(importToken.base64EncodedString(), forKey: .importToken)
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let validTo = validTo {
            try encodeContainer.encode(validTo.timeIntervalSince1970, forKey: .validTo)
        }
    }
}

public struct ImportKeyMaterialInputHeadersMiddleware: Middleware {
    public let id: String = "ImportKeyMaterialInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportKeyMaterialInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportKeyMaterialOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportKeyMaterialInput>
    public typealias MOutput = OperationOutput<ImportKeyMaterialOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportKeyMaterialOutputError>
}

public struct ImportKeyMaterialInputQueryItemMiddleware: Middleware {
    public let id: String = "ImportKeyMaterialInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportKeyMaterialInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportKeyMaterialOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportKeyMaterialInput>
    public typealias MOutput = OperationOutput<ImportKeyMaterialOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportKeyMaterialOutputError>
}

public struct ImportKeyMaterialInput: Equatable {
    /// <p>The encrypted key material to import. The key material must be encrypted with the public
    ///       wrapping key that <a>GetParametersForImport</a> returned, using the wrapping
    ///       algorithm that you specified in the same <code>GetParametersForImport</code> request.</p>
    public let encryptedKeyMaterial: Data?
    /// <p>Specifies whether the key material expires. The default is
    ///         <code>KEY_MATERIAL_EXPIRES</code>, in which case you must include the <code>ValidTo</code>
    ///       parameter. When this parameter is set to <code>KEY_MATERIAL_DOES_NOT_EXPIRE</code>, you must
    ///       omit the <code>ValidTo</code> parameter.</p>
    public let expirationModel: ExpirationModelType?
    /// <p>The import token that you received in the response to a previous <a>GetParametersForImport</a> request. It must be from the same response that contained
    ///       the public key that you used to encrypt the key material.</p>
    public let importToken: Data?
    /// <p>The identifier of the symmetric CMK that receives the imported key material. The CMK's
    ///         <code>Origin</code> must be <code>EXTERNAL</code>. This must be the same CMK specified in
    ///       the <code>KeyID</code> parameter of the corresponding <a>GetParametersForImport</a>
    ///       request.</p>
    ///          <p>Specify the key ID or the Amazon Resource Name (ARN) of the CMK.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
    public let keyId: String?
    /// <p>The time at which the imported key material expires. When the key material expires, AWS KMS
    ///       deletes the key material and the CMK becomes unusable. You must omit this parameter when the
    ///         <code>ExpirationModel</code> parameter is set to <code>KEY_MATERIAL_DOES_NOT_EXPIRE</code>.
    ///       Otherwise it is required.</p>
    public let validTo: Date?

    public init (
        encryptedKeyMaterial: Data? = nil,
        expirationModel: ExpirationModelType? = nil,
        importToken: Data? = nil,
        keyId: String? = nil,
        validTo: Date? = nil
    )
    {
        self.encryptedKeyMaterial = encryptedKeyMaterial
        self.expirationModel = expirationModel
        self.importToken = importToken
        self.keyId = keyId
        self.validTo = validTo
    }
}

struct ImportKeyMaterialInputBody: Equatable {
    public let keyId: String?
    public let importToken: Data?
    public let encryptedKeyMaterial: Data?
    public let validTo: Date?
    public let expirationModel: ExpirationModelType?
}

extension ImportKeyMaterialInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case encryptedKeyMaterial = "EncryptedKeyMaterial"
        case expirationModel = "ExpirationModel"
        case importToken = "ImportToken"
        case keyId = "KeyId"
        case validTo = "ValidTo"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let importTokenDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .importToken)
        importToken = importTokenDecoded
        let encryptedKeyMaterialDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .encryptedKeyMaterial)
        encryptedKeyMaterial = encryptedKeyMaterialDecoded
        let validToDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .validTo)
        validTo = validToDecoded
        let expirationModelDecoded = try containerValues.decodeIfPresent(ExpirationModelType.self, forKey: .expirationModel)
        expirationModel = expirationModelDecoded
    }
}

extension ImportKeyMaterialOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportKeyMaterialOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ExpiredImportTokenException" : self = .expiredImportTokenException(try ExpiredImportTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectKeyMaterialException" : self = .incorrectKeyMaterialException(try IncorrectKeyMaterialException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCiphertextException" : self = .invalidCiphertextException(try InvalidCiphertextException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidImportTokenException" : self = .invalidImportTokenException(try InvalidImportTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportKeyMaterialOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case expiredImportTokenException(ExpiredImportTokenException)
    case incorrectKeyMaterialException(IncorrectKeyMaterialException)
    case invalidArnException(InvalidArnException)
    case invalidCiphertextException(InvalidCiphertextException)
    case invalidImportTokenException(InvalidImportTokenException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case notFoundException(NotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportKeyMaterialOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportKeyMaterialOutputResponse()"}
}

extension ImportKeyMaterialOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ImportKeyMaterialOutputResponse: Equatable {

    public init() {}
}

struct ImportKeyMaterialOutputResponseBody: Equatable {
}

extension ImportKeyMaterialOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension IncorrectKeyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IncorrectKeyException(message: \(String(describing: message)))"}
}

extension IncorrectKeyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IncorrectKeyExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the specified CMK cannot decrypt the data. The
///         <code>KeyId</code> in a <a>Decrypt</a> request and the <code>SourceKeyId</code>
///       in a <a>ReEncrypt</a> request must identify the same CMK that was used to encrypt
///       the ciphertext.</p>
public struct IncorrectKeyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IncorrectKeyExceptionBody: Equatable {
    public let message: String?
}

extension IncorrectKeyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IncorrectKeyMaterialException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IncorrectKeyMaterialException(message: \(String(describing: message)))"}
}

extension IncorrectKeyMaterialException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IncorrectKeyMaterialExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the key material in the request is, expired, invalid, or
///       is not the same key material that was previously imported into this customer master key
///       (CMK).</p>
public struct IncorrectKeyMaterialException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IncorrectKeyMaterialExceptionBody: Equatable {
    public let message: String?
}

extension IncorrectKeyMaterialExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IncorrectTrustAnchorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IncorrectTrustAnchorException(message: \(String(describing: message)))"}
}

extension IncorrectTrustAnchorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IncorrectTrustAnchorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the trust anchor certificate in the request is not the
///       trust anchor certificate for the specified AWS CloudHSM cluster.</p>
///          <p>When you <a href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/initialize-cluster.html#sign-csr">initialize the cluster</a>, you create the trust anchor certificate and save it in the
///         <code>customerCA.crt</code> file.</p>
public struct IncorrectTrustAnchorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IncorrectTrustAnchorExceptionBody: Equatable {
    public let message: String?
}

extension IncorrectTrustAnchorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAliasNameException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidAliasNameException(message: \(String(describing: message)))"}
}

extension InvalidAliasNameException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidAliasNameExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the specified alias name is not valid.</p>
public struct InvalidAliasNameException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAliasNameExceptionBody: Equatable {
    public let message: String?
}

extension InvalidAliasNameExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidArnException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidArnException(message: \(String(describing: message)))"}
}

extension InvalidArnException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidArnExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because a specified ARN, or an ARN in a key policy, is not
///       valid.</p>
public struct InvalidArnException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArnExceptionBody: Equatable {
    public let message: String?
}

extension InvalidArnExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCiphertextException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidCiphertextException(message: \(String(describing: message)))"}
}

extension InvalidCiphertextException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidCiphertextExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>From the <a>Decrypt</a> or <a>ReEncrypt</a> operation, the request
///       was rejected because the specified ciphertext, or additional authenticated data incorporated
///       into the ciphertext, such as the encryption context, is corrupted, missing, or otherwise
///       invalid.</p>
///          <p>From the <a>ImportKeyMaterial</a> operation, the request was rejected because
///       AWS KMS could not decrypt the encrypted (wrapped) key material. </p>
public struct InvalidCiphertextException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidCiphertextExceptionBody: Equatable {
    public let message: String?
}

extension InvalidCiphertextExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidGrantIdException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidGrantIdException(message: \(String(describing: message)))"}
}

extension InvalidGrantIdException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidGrantIdExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the specified <code>GrantId</code> is not valid.</p>
public struct InvalidGrantIdException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidGrantIdExceptionBody: Equatable {
    public let message: String?
}

extension InvalidGrantIdExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidGrantTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidGrantTokenException(message: \(String(describing: message)))"}
}

extension InvalidGrantTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidGrantTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the specified grant token is not valid.</p>
public struct InvalidGrantTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidGrantTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidGrantTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidImportTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidImportTokenException(message: \(String(describing: message)))"}
}

extension InvalidImportTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidImportTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the provided import token is invalid or is associated
///       with a different customer master key (CMK).</p>
public struct InvalidImportTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidImportTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidImportTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidKeyUsageException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidKeyUsageException(message: \(String(describing: message)))"}
}

extension InvalidKeyUsageException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidKeyUsageExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected for one of the following reasons: </p>
///          <ul>
///             <li>
///                <p>The <code>KeyUsage</code> value of the CMK is incompatible with the API
///           operation.</p>
///             </li>
///             <li>
///                <p>The encryption algorithm or signing algorithm specified for the operation is
///           incompatible with the type of key material in the CMK
///           <code>(CustomerMasterKeySpec</code>).</p>
///             </li>
///          </ul>
///          <p>For encrypting, decrypting, re-encrypting, and generating data keys, the
///         <code>KeyUsage</code> must be <code>ENCRYPT_DECRYPT</code>. For signing and verifying, the
///         <code>KeyUsage</code> must be <code>SIGN_VERIFY</code>. To find the <code>KeyUsage</code> of
///       a CMK, use the <a>DescribeKey</a> operation.</p>
///          <p>To find the encryption or signing algorithms supported for a particular CMK, use the <a>DescribeKey</a> operation.</p>
public struct InvalidKeyUsageException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidKeyUsageExceptionBody: Equatable {
    public let message: String?
}

extension InvalidKeyUsageExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidMarkerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidMarkerException(message: \(String(describing: message)))"}
}

extension InvalidMarkerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidMarkerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the marker that specifies where pagination should next
///       begin is not valid.</p>
public struct InvalidMarkerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidMarkerExceptionBody: Equatable {
    public let message: String?
}

extension InvalidMarkerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSInternalException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KMSInternalException(message: \(String(describing: message)))"}
}

extension KMSInternalException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: KMSInternalExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because an internal exception occurred. The request can be
///       retried.</p>
public struct KMSInternalException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KMSInternalExceptionBody: Equatable {
    public let message: String?
}

extension KMSInternalExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSInvalidSignatureException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KMSInvalidSignatureException(message: \(String(describing: message)))"}
}

extension KMSInvalidSignatureException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: KMSInvalidSignatureExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the signature verification failed. Signature
///       verification fails when it cannot confirm that signature was produced by signing the specified
///       message with the specified CMK and signing algorithm.</p>
public struct KMSInvalidSignatureException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KMSInvalidSignatureExceptionBody: Equatable {
    public let message: String?
}

extension KMSInvalidSignatureExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSInvalidStateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KMSInvalidStateException(message: \(String(describing: message)))"}
}

extension KMSInvalidStateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: KMSInvalidStateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the state of the specified resource is not valid for this
///       request.</p>
///          <p>For more information about how key state affects the use of a CMK, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html">How Key State Affects Use of a
///         Customer Master Key</a> in the <i>
///                <i>AWS Key Management Service Developer Guide</i>
///             </i>.</p>
public struct KMSInvalidStateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KMSInvalidStateExceptionBody: Equatable {
    public let message: String?
}

extension KMSInvalidStateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KeyListEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyArn = "KeyArn"
        case keyId = "KeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyArn = keyArn {
            try encodeContainer.encode(keyArn, forKey: .keyArn)
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let keyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyArn)
        keyArn = keyArnDecoded
    }
}

extension KeyListEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KeyListEntry(keyArn: \(String(describing: keyArn)), keyId: \(String(describing: keyId)))"}
}

/// <p>Contains information about each entry in the key list.</p>
public struct KeyListEntry: Equatable {
    /// <p>ARN of the key.</p>
    public let keyArn: String?
    /// <p>Unique identifier of the key.</p>
    public let keyId: String?

    public init (
        keyArn: String? = nil,
        keyId: String? = nil
    )
    {
        self.keyArn = keyArn
        self.keyId = keyId
    }
}

public enum KeyManagerType {
    case aws
    case customer
    case sdkUnknown(String)
}

extension KeyManagerType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [KeyManagerType] {
        return [
            .aws,
            .customer,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .aws: return "AWS"
        case .customer: return "CUSTOMER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = KeyManagerType(rawValue: rawValue) ?? KeyManagerType.sdkUnknown(rawValue)
    }
}

extension KeyMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aWSAccountId = "AWSAccountId"
        case arn = "Arn"
        case cloudHsmClusterId = "CloudHsmClusterId"
        case creationDate = "CreationDate"
        case customKeyStoreId = "CustomKeyStoreId"
        case customerMasterKeySpec = "CustomerMasterKeySpec"
        case deletionDate = "DeletionDate"
        case description = "Description"
        case enabled = "Enabled"
        case encryptionAlgorithms = "EncryptionAlgorithms"
        case expirationModel = "ExpirationModel"
        case keyId = "KeyId"
        case keyManager = "KeyManager"
        case keyState = "KeyState"
        case keyUsage = "KeyUsage"
        case origin = "Origin"
        case signingAlgorithms = "SigningAlgorithms"
        case validTo = "ValidTo"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aWSAccountId = aWSAccountId {
            try encodeContainer.encode(aWSAccountId, forKey: .aWSAccountId)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let cloudHsmClusterId = cloudHsmClusterId {
            try encodeContainer.encode(cloudHsmClusterId, forKey: .cloudHsmClusterId)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let customKeyStoreId = customKeyStoreId {
            try encodeContainer.encode(customKeyStoreId, forKey: .customKeyStoreId)
        }
        if let customerMasterKeySpec = customerMasterKeySpec {
            try encodeContainer.encode(customerMasterKeySpec.rawValue, forKey: .customerMasterKeySpec)
        }
        if let deletionDate = deletionDate {
            try encodeContainer.encode(deletionDate.timeIntervalSince1970, forKey: .deletionDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let encryptionAlgorithms = encryptionAlgorithms {
            var encryptionAlgorithmsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .encryptionAlgorithms)
            for encryptionalgorithmspeclist0 in encryptionAlgorithms {
                try encryptionAlgorithmsContainer.encode(encryptionalgorithmspeclist0.rawValue)
            }
        }
        if let expirationModel = expirationModel {
            try encodeContainer.encode(expirationModel.rawValue, forKey: .expirationModel)
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let keyManager = keyManager {
            try encodeContainer.encode(keyManager.rawValue, forKey: .keyManager)
        }
        if let keyState = keyState {
            try encodeContainer.encode(keyState.rawValue, forKey: .keyState)
        }
        if let keyUsage = keyUsage {
            try encodeContainer.encode(keyUsage.rawValue, forKey: .keyUsage)
        }
        if let origin = origin {
            try encodeContainer.encode(origin.rawValue, forKey: .origin)
        }
        if let signingAlgorithms = signingAlgorithms {
            var signingAlgorithmsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .signingAlgorithms)
            for signingalgorithmspeclist0 in signingAlgorithms {
                try signingAlgorithmsContainer.encode(signingalgorithmspeclist0.rawValue)
            }
        }
        if let validTo = validTo {
            try encodeContainer.encode(validTo.timeIntervalSince1970, forKey: .validTo)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aWSAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aWSAccountId)
        aWSAccountId = aWSAccountIdDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let keyUsageDecoded = try containerValues.decodeIfPresent(KeyUsageType.self, forKey: .keyUsage)
        keyUsage = keyUsageDecoded
        let keyStateDecoded = try containerValues.decodeIfPresent(KeyState.self, forKey: .keyState)
        keyState = keyStateDecoded
        let deletionDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .deletionDate)
        deletionDate = deletionDateDecoded
        let validToDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .validTo)
        validTo = validToDecoded
        let originDecoded = try containerValues.decodeIfPresent(OriginType.self, forKey: .origin)
        origin = originDecoded
        let customKeyStoreIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customKeyStoreId)
        customKeyStoreId = customKeyStoreIdDecoded
        let cloudHsmClusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudHsmClusterId)
        cloudHsmClusterId = cloudHsmClusterIdDecoded
        let expirationModelDecoded = try containerValues.decodeIfPresent(ExpirationModelType.self, forKey: .expirationModel)
        expirationModel = expirationModelDecoded
        let keyManagerDecoded = try containerValues.decodeIfPresent(KeyManagerType.self, forKey: .keyManager)
        keyManager = keyManagerDecoded
        let customerMasterKeySpecDecoded = try containerValues.decodeIfPresent(CustomerMasterKeySpec.self, forKey: .customerMasterKeySpec)
        customerMasterKeySpec = customerMasterKeySpecDecoded
        let encryptionAlgorithmsContainer = try containerValues.decodeIfPresent([EncryptionAlgorithmSpec?].self, forKey: .encryptionAlgorithms)
        var encryptionAlgorithmsDecoded0:[EncryptionAlgorithmSpec]? = nil
        if let encryptionAlgorithmsContainer = encryptionAlgorithmsContainer {
            encryptionAlgorithmsDecoded0 = [EncryptionAlgorithmSpec]()
            for string0 in encryptionAlgorithmsContainer {
                if let string0 = string0 {
                    encryptionAlgorithmsDecoded0?.append(string0)
                }
            }
        }
        encryptionAlgorithms = encryptionAlgorithmsDecoded0
        let signingAlgorithmsContainer = try containerValues.decodeIfPresent([SigningAlgorithmSpec?].self, forKey: .signingAlgorithms)
        var signingAlgorithmsDecoded0:[SigningAlgorithmSpec]? = nil
        if let signingAlgorithmsContainer = signingAlgorithmsContainer {
            signingAlgorithmsDecoded0 = [SigningAlgorithmSpec]()
            for string0 in signingAlgorithmsContainer {
                if let string0 = string0 {
                    signingAlgorithmsDecoded0?.append(string0)
                }
            }
        }
        signingAlgorithms = signingAlgorithmsDecoded0
    }
}

extension KeyMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KeyMetadata(aWSAccountId: \(String(describing: aWSAccountId)), arn: \(String(describing: arn)), cloudHsmClusterId: \(String(describing: cloudHsmClusterId)), creationDate: \(String(describing: creationDate)), customKeyStoreId: \(String(describing: customKeyStoreId)), customerMasterKeySpec: \(String(describing: customerMasterKeySpec)), deletionDate: \(String(describing: deletionDate)), description: \(String(describing: description)), enabled: \(String(describing: enabled)), encryptionAlgorithms: \(String(describing: encryptionAlgorithms)), expirationModel: \(String(describing: expirationModel)), keyId: \(String(describing: keyId)), keyManager: \(String(describing: keyManager)), keyState: \(String(describing: keyState)), keyUsage: \(String(describing: keyUsage)), origin: \(String(describing: origin)), signingAlgorithms: \(String(describing: signingAlgorithms)), validTo: \(String(describing: validTo)))"}
}

/// <p>Contains metadata about a customer master key (CMK).</p>
///          <p>This data type is used as a response element for the <a>CreateKey</a> and <a>DescribeKey</a> operations.</p>
public struct KeyMetadata: Equatable {
    /// <p>The twelve-digit account ID of the AWS account that owns the CMK.</p>
    public let aWSAccountId: String?
    /// <p>The Amazon Resource Name (ARN) of the CMK. For examples, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kms">AWS Key Management Service
    ///         (AWS KMS)</a> in the Example ARNs section of the <i>AWS General
    ///         Reference</i>.</p>
    public let arn: String?
    /// <p>The cluster ID of the AWS CloudHSM cluster that contains the key material for the CMK. When you
    ///       create a CMK in a <a href="https://docs.aws.amazon.com/kms/latest/developerguide/custom-key-store-overview.html">custom key store</a>, AWS KMS creates the key material for the CMK in the
    ///       associated AWS CloudHSM cluster. This value is present only when the CMK is created in a custom key
    ///       store.</p>
    public let cloudHsmClusterId: String?
    /// <p>The date and time when the CMK was created.</p>
    public let creationDate: Date?
    /// <p>A unique identifier for the <a href="https://docs.aws.amazon.com/kms/latest/developerguide/custom-key-store-overview.html">custom key store</a> that contains the CMK. This value is present
    ///       only when the CMK is created in a custom key store.</p>
    public let customKeyStoreId: String?
    /// <p>Describes the type of key material in the CMK.</p>
    public let customerMasterKeySpec: CustomerMasterKeySpec?
    /// <p>The date and time after which AWS KMS deletes the CMK. This value is present only when
    ///         <code>KeyState</code> is <code>PendingDeletion</code>.</p>
    public let deletionDate: Date?
    /// <p>The description of the CMK.</p>
    public let description: String?
    /// <p>Specifies whether the CMK is enabled. When <code>KeyState</code> is <code>Enabled</code>
    ///       this value is true, otherwise it is false.</p>
    public let enabled: Bool
    /// <p>The encryption algorithms that the CMK supports. You cannot use the CMK with other
    ///       encryption algorithms within AWS KMS.</p>
    ///          <p>This field appears only when the <code>KeyUsage</code> of the CMK is
    ///         <code>ENCRYPT_DECRYPT</code>.</p>
    public let encryptionAlgorithms: [EncryptionAlgorithmSpec]?
    /// <p>Specifies whether the CMK's key material expires. This value is present only when
    ///         <code>Origin</code> is <code>EXTERNAL</code>, otherwise this value is omitted.</p>
    public let expirationModel: ExpirationModelType?
    /// <p>The globally unique identifier for the CMK.</p>
    public let keyId: String?
    /// <p>The manager of the CMK. CMKs in your AWS account are either customer managed or AWS
    ///       managed. For more information about the difference, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#master_keys">Customer Master Keys</a> in the
    ///       <i>AWS Key Management Service Developer Guide</i>.</p>
    public let keyManager: KeyManagerType?
    /// <p>The current status of the CMK.</p>
    ///          <p>For more information about how key state affects the use of a CMK, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html">Key state: Effect on your CMK</a> in the <i>AWS Key Management Service Developer Guide</i>.</p>
    public let keyState: KeyState?
    /// <p>The <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations">cryptographic operations</a> for which you can use the CMK.</p>
    public let keyUsage: KeyUsageType?
    /// <p>The source of the CMK's key material. When this value is <code>AWS_KMS</code>, AWS KMS
    ///       created the key material. When this value is <code>EXTERNAL</code>, the key material was
    ///       imported from your existing key management infrastructure or the CMK lacks key material. When
    ///       this value is <code>AWS_CLOUDHSM</code>, the key material was created in the AWS CloudHSM cluster
    ///       associated with a custom key store.</p>
    public let origin: OriginType?
    /// <p>The signing algorithms that the CMK supports. You cannot use the CMK with other
    ///       signing algorithms within AWS KMS.</p>
    ///          <p>This field appears only when the <code>KeyUsage</code> of the CMK is
    ///         <code>SIGN_VERIFY</code>.</p>
    public let signingAlgorithms: [SigningAlgorithmSpec]?
    /// <p>The time at which the imported key material expires. When the key material expires, AWS KMS
    ///       deletes the key material and the CMK becomes unusable. This value is present only for CMKs
    ///       whose <code>Origin</code> is <code>EXTERNAL</code> and whose <code>ExpirationModel</code> is
    ///         <code>KEY_MATERIAL_EXPIRES</code>, otherwise this value is omitted.</p>
    public let validTo: Date?

    public init (
        aWSAccountId: String? = nil,
        arn: String? = nil,
        cloudHsmClusterId: String? = nil,
        creationDate: Date? = nil,
        customKeyStoreId: String? = nil,
        customerMasterKeySpec: CustomerMasterKeySpec? = nil,
        deletionDate: Date? = nil,
        description: String? = nil,
        enabled: Bool = false,
        encryptionAlgorithms: [EncryptionAlgorithmSpec]? = nil,
        expirationModel: ExpirationModelType? = nil,
        keyId: String? = nil,
        keyManager: KeyManagerType? = nil,
        keyState: KeyState? = nil,
        keyUsage: KeyUsageType? = nil,
        origin: OriginType? = nil,
        signingAlgorithms: [SigningAlgorithmSpec]? = nil,
        validTo: Date? = nil
    )
    {
        self.aWSAccountId = aWSAccountId
        self.arn = arn
        self.cloudHsmClusterId = cloudHsmClusterId
        self.creationDate = creationDate
        self.customKeyStoreId = customKeyStoreId
        self.customerMasterKeySpec = customerMasterKeySpec
        self.deletionDate = deletionDate
        self.description = description
        self.enabled = enabled
        self.encryptionAlgorithms = encryptionAlgorithms
        self.expirationModel = expirationModel
        self.keyId = keyId
        self.keyManager = keyManager
        self.keyState = keyState
        self.keyUsage = keyUsage
        self.origin = origin
        self.signingAlgorithms = signingAlgorithms
        self.validTo = validTo
    }
}

public enum KeyState {
    case disabled
    case enabled
    case pendingdeletion
    case pendingimport
    case unavailable
    case sdkUnknown(String)
}

extension KeyState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [KeyState] {
        return [
            .disabled,
            .enabled,
            .pendingdeletion,
            .pendingimport,
            .unavailable,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "Disabled"
        case .enabled: return "Enabled"
        case .pendingdeletion: return "PendingDeletion"
        case .pendingimport: return "PendingImport"
        case .unavailable: return "Unavailable"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = KeyState(rawValue: rawValue) ?? KeyState.sdkUnknown(rawValue)
    }
}

extension KeyUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KeyUnavailableException(message: \(String(describing: message)))"}
}

extension KeyUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: KeyUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the specified CMK was not available. You can retry the
///       request.</p>
public struct KeyUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KeyUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension KeyUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum KeyUsageType {
    case encryptDecrypt
    case signVerify
    case sdkUnknown(String)
}

extension KeyUsageType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [KeyUsageType] {
        return [
            .encryptDecrypt,
            .signVerify,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .encryptDecrypt: return "ENCRYPT_DECRYPT"
        case .signVerify: return "SIGN_VERIFY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = KeyUsageType(rawValue: rawValue) ?? KeyUsageType.sdkUnknown(rawValue)
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because a quota was exceeded. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/limits.html">Quotas</a> in the
///       <i>AWS Key Management Service Developer Guide</i>.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListAliasesInputBodyMiddleware: Middleware {
    public let id: String = "ListAliasesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAliasesInput>
    public typealias MOutput = OperationOutput<ListAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAliasesOutputError>
}

extension ListAliasesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAliasesInput(keyId: \(String(describing: keyId)), limit: \(String(describing: limit)), marker: \(String(describing: marker)))"}
}

extension ListAliasesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
        case limit = "Limit"
        case marker = "Marker"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
    }
}

public struct ListAliasesInputHeadersMiddleware: Middleware {
    public let id: String = "ListAliasesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAliasesInput>
    public typealias MOutput = OperationOutput<ListAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAliasesOutputError>
}

public struct ListAliasesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAliasesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAliasesInput>
    public typealias MOutput = OperationOutput<ListAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAliasesOutputError>
}

public struct ListAliasesInput: Equatable {
    /// <p>Lists only aliases that are associated with the specified CMK. Enter a CMK in your AWS
    ///       account. </p>
    ///          <p>This parameter is optional. If you omit it, <code>ListAliases</code> returns all aliases
    ///       in the account and Region.</p>
    ///
    ///          <p>Specify the key ID or the Amazon Resource Name (ARN) of the CMK.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
    public let keyId: String?
    /// <p>Use this parameter to specify the maximum number of items to return. When this
    ///     value is present, AWS KMS does not return more than the specified number of items, but it might
    ///     return fewer.</p>
    ///          <p>This value is optional. If you include a value, it must be between 1
    ///     and 100, inclusive. If you do not include a value, it defaults to 50.</p>
    public let limit: Int?
    /// <p>Use this parameter in a subsequent request after you receive a response with
    ///     truncated results. Set it to the value of <code>NextMarker</code> from the truncated response
    ///     you just received.</p>
    public let marker: String?

    public init (
        keyId: String? = nil,
        limit: Int? = nil,
        marker: String? = nil
    )
    {
        self.keyId = keyId
        self.limit = limit
        self.marker = marker
    }
}

struct ListAliasesInputBody: Equatable {
    public let keyId: String?
    public let limit: Int?
    public let marker: String?
}

extension ListAliasesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
        case limit = "Limit"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListAliasesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAliasesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMarkerException" : self = .invalidMarkerException(try InvalidMarkerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAliasesOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case invalidArnException(InvalidArnException)
    case invalidMarkerException(InvalidMarkerException)
    case kMSInternalException(KMSInternalException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAliasesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAliasesOutputResponse(aliases: \(String(describing: aliases)), nextMarker: \(String(describing: nextMarker)), truncated: \(String(describing: truncated)))"}
}

extension ListAliasesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAliasesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.aliases = output.aliases
            self.nextMarker = output.nextMarker
            self.truncated = output.truncated
        } else {
            self.aliases = nil
            self.nextMarker = nil
            self.truncated = false
        }
    }
}

public struct ListAliasesOutputResponse: Equatable {
    /// <p>A list of aliases.</p>
    public let aliases: [AliasListEntry]?
    /// <p>When <code>Truncated</code> is true, this element is present and contains the
    ///     value to use for the <code>Marker</code> parameter in a subsequent request.</p>
    public let nextMarker: String?
    /// <p>A flag that indicates whether there are more items in the list. When this
    ///     value is true, the list in this response is truncated. To get more items, pass the value of
    ///     the <code>NextMarker</code> element in thisresponse to the <code>Marker</code> parameter in a
    ///     subsequent request.</p>
    public let truncated: Bool

    public init (
        aliases: [AliasListEntry]? = nil,
        nextMarker: String? = nil,
        truncated: Bool = false
    )
    {
        self.aliases = aliases
        self.nextMarker = nextMarker
        self.truncated = truncated
    }
}

struct ListAliasesOutputResponseBody: Equatable {
    public let aliases: [AliasListEntry]?
    public let nextMarker: String?
    public let truncated: Bool
}

extension ListAliasesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aliases = "Aliases"
        case nextMarker = "NextMarker"
        case truncated = "Truncated"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasesContainer = try containerValues.decodeIfPresent([AliasListEntry?].self, forKey: .aliases)
        var aliasesDecoded0:[AliasListEntry]? = nil
        if let aliasesContainer = aliasesContainer {
            aliasesDecoded0 = [AliasListEntry]()
            for structure0 in aliasesContainer {
                if let structure0 = structure0 {
                    aliasesDecoded0?.append(structure0)
                }
            }
        }
        aliases = aliasesDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let truncatedDecoded = try containerValues.decode(Bool.self, forKey: .truncated)
        truncated = truncatedDecoded
    }
}

public struct ListGrantsInputBodyMiddleware: Middleware {
    public let id: String = "ListGrantsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGrantsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGrantsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGrantsInput>
    public typealias MOutput = OperationOutput<ListGrantsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGrantsOutputError>
}

extension ListGrantsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGrantsInput(grantId: \(String(describing: grantId)), granteePrincipal: \(String(describing: granteePrincipal)), keyId: \(String(describing: keyId)), limit: \(String(describing: limit)), marker: \(String(describing: marker)))"}
}

extension ListGrantsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grantId = "GrantId"
        case granteePrincipal = "GranteePrincipal"
        case keyId = "KeyId"
        case limit = "Limit"
        case marker = "Marker"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantId = grantId {
            try encodeContainer.encode(grantId, forKey: .grantId)
        }
        if let granteePrincipal = granteePrincipal {
            try encodeContainer.encode(granteePrincipal, forKey: .granteePrincipal)
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
    }
}

public struct ListGrantsInputHeadersMiddleware: Middleware {
    public let id: String = "ListGrantsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGrantsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGrantsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGrantsInput>
    public typealias MOutput = OperationOutput<ListGrantsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGrantsOutputError>
}

public struct ListGrantsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListGrantsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGrantsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGrantsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGrantsInput>
    public typealias MOutput = OperationOutput<ListGrantsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGrantsOutputError>
}

public struct ListGrantsInput: Equatable {
    /// <p>Returns only the grant with the specified grant ID. The grant ID uniquely identifies the
    ///       grant. </p>
    public let grantId: String?
    /// <p>Returns only grants where the specified principal is the grantee principal for the
    ///       grant.</p>
    public let granteePrincipal: String?
    /// <p>Returns only grants for the specified customer master key (CMK). This parameter is
    ///       required.</p>
    ///          <p>Specify the key ID or the Amazon Resource Name (ARN) of the CMK. To specify a CMK in a
    /// different AWS account, you must use the key ARN.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
    public let keyId: String?
    /// <p>Use this parameter to specify the maximum number of items to return. When this
    ///     value is present, AWS KMS does not return more than the specified number of items, but it might
    ///     return fewer.</p>
    ///          <p>This value is optional. If you include a value, it must be between 1
    ///     and 100, inclusive. If you do not include a value, it defaults to 50.</p>
    public let limit: Int?
    /// <p>Use this parameter in a subsequent request after you receive a response with
    ///     truncated results. Set it to the value of <code>NextMarker</code> from the truncated response
    ///     you just received.</p>
    public let marker: String?

    public init (
        grantId: String? = nil,
        granteePrincipal: String? = nil,
        keyId: String? = nil,
        limit: Int? = nil,
        marker: String? = nil
    )
    {
        self.grantId = grantId
        self.granteePrincipal = granteePrincipal
        self.keyId = keyId
        self.limit = limit
        self.marker = marker
    }
}

struct ListGrantsInputBody: Equatable {
    public let limit: Int?
    public let marker: String?
    public let keyId: String?
    public let grantId: String?
    public let granteePrincipal: String?
}

extension ListGrantsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case grantId = "GrantId"
        case granteePrincipal = "GranteePrincipal"
        case keyId = "KeyId"
        case limit = "Limit"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let grantIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grantId)
        grantId = grantIdDecoded
        let granteePrincipalDecoded = try containerValues.decodeIfPresent(String.self, forKey: .granteePrincipal)
        granteePrincipal = granteePrincipalDecoded
    }
}

extension ListGrantsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGrantsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGrantIdException" : self = .invalidGrantIdException(try InvalidGrantIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMarkerException" : self = .invalidMarkerException(try InvalidMarkerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGrantsOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case invalidArnException(InvalidArnException)
    case invalidGrantIdException(InvalidGrantIdException)
    case invalidMarkerException(InvalidMarkerException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGrantsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGrantsOutputResponse(grants: \(String(describing: grants)), nextMarker: \(String(describing: nextMarker)), truncated: \(String(describing: truncated)))"}
}

extension ListGrantsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListGrantsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.grants = output.grants
            self.nextMarker = output.nextMarker
            self.truncated = output.truncated
        } else {
            self.grants = nil
            self.nextMarker = nil
            self.truncated = false
        }
    }
}

public struct ListGrantsOutputResponse: Equatable {
    /// <p>A list of grants.</p>
    public let grants: [GrantListEntry]?
    /// <p>When <code>Truncated</code> is true, this element is present and contains the
    ///     value to use for the <code>Marker</code> parameter in a subsequent request.</p>
    public let nextMarker: String?
    /// <p>A flag that indicates whether there are more items in the list. When this
    ///     value is true, the list in this response is truncated. To get more items, pass the value of
    ///     the <code>NextMarker</code> element in thisresponse to the <code>Marker</code> parameter in a
    ///     subsequent request.</p>
    public let truncated: Bool

    public init (
        grants: [GrantListEntry]? = nil,
        nextMarker: String? = nil,
        truncated: Bool = false
    )
    {
        self.grants = grants
        self.nextMarker = nextMarker
        self.truncated = truncated
    }
}

struct ListGrantsOutputResponseBody: Equatable {
    public let grants: [GrantListEntry]?
    public let nextMarker: String?
    public let truncated: Bool
}

extension ListGrantsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case grants = "Grants"
        case nextMarker = "NextMarker"
        case truncated = "Truncated"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantsContainer = try containerValues.decodeIfPresent([GrantListEntry?].self, forKey: .grants)
        var grantsDecoded0:[GrantListEntry]? = nil
        if let grantsContainer = grantsContainer {
            grantsDecoded0 = [GrantListEntry]()
            for structure0 in grantsContainer {
                if let structure0 = structure0 {
                    grantsDecoded0?.append(structure0)
                }
            }
        }
        grants = grantsDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let truncatedDecoded = try containerValues.decode(Bool.self, forKey: .truncated)
        truncated = truncatedDecoded
    }
}

public struct ListKeyPoliciesInputBodyMiddleware: Middleware {
    public let id: String = "ListKeyPoliciesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListKeyPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListKeyPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListKeyPoliciesInput>
    public typealias MOutput = OperationOutput<ListKeyPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListKeyPoliciesOutputError>
}

extension ListKeyPoliciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListKeyPoliciesInput(keyId: \(String(describing: keyId)), limit: \(String(describing: limit)), marker: \(String(describing: marker)))"}
}

extension ListKeyPoliciesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
        case limit = "Limit"
        case marker = "Marker"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
    }
}

public struct ListKeyPoliciesInputHeadersMiddleware: Middleware {
    public let id: String = "ListKeyPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListKeyPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListKeyPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListKeyPoliciesInput>
    public typealias MOutput = OperationOutput<ListKeyPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListKeyPoliciesOutputError>
}

public struct ListKeyPoliciesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListKeyPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListKeyPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListKeyPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListKeyPoliciesInput>
    public typealias MOutput = OperationOutput<ListKeyPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListKeyPoliciesOutputError>
}

public struct ListKeyPoliciesInput: Equatable {
    /// <p>A unique identifier for the customer master key (CMK).</p>
    ///          <p>Specify the key ID or the Amazon Resource Name (ARN) of the CMK.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
    public let keyId: String?
    /// <p>Use this parameter to specify the maximum number of items to return. When this
    ///     value is present, AWS KMS does not return more than the specified number of items, but it might
    ///     return fewer.</p>
    ///          <p>This value is optional. If you include a value, it must be between
    ///     1 and 1000, inclusive. If you do not include a value, it defaults to 100.</p>
    ///          <p>Only one policy can be attached to a key.</p>
    public let limit: Int?
    /// <p>Use this parameter in a subsequent request after you receive a response with
    ///     truncated results. Set it to the value of <code>NextMarker</code> from the truncated response
    ///     you just received.</p>
    public let marker: String?

    public init (
        keyId: String? = nil,
        limit: Int? = nil,
        marker: String? = nil
    )
    {
        self.keyId = keyId
        self.limit = limit
        self.marker = marker
    }
}

struct ListKeyPoliciesInputBody: Equatable {
    public let keyId: String?
    public let limit: Int?
    public let marker: String?
}

extension ListKeyPoliciesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
        case limit = "Limit"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListKeyPoliciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListKeyPoliciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListKeyPoliciesOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case invalidArnException(InvalidArnException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListKeyPoliciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListKeyPoliciesOutputResponse(nextMarker: \(String(describing: nextMarker)), policyNames: \(String(describing: policyNames)), truncated: \(String(describing: truncated)))"}
}

extension ListKeyPoliciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListKeyPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextMarker = output.nextMarker
            self.policyNames = output.policyNames
            self.truncated = output.truncated
        } else {
            self.nextMarker = nil
            self.policyNames = nil
            self.truncated = false
        }
    }
}

public struct ListKeyPoliciesOutputResponse: Equatable {
    /// <p>When <code>Truncated</code> is true, this element is present and contains the
    ///     value to use for the <code>Marker</code> parameter in a subsequent request.</p>
    public let nextMarker: String?
    /// <p>A list of key policy names. The only valid value is <code>default</code>.</p>
    public let policyNames: [String]?
    /// <p>A flag that indicates whether there are more items in the list. When this
    ///     value is true, the list in this response is truncated. To get more items, pass the value of
    ///     the <code>NextMarker</code> element in thisresponse to the <code>Marker</code> parameter in a
    ///     subsequent request.</p>
    public let truncated: Bool

    public init (
        nextMarker: String? = nil,
        policyNames: [String]? = nil,
        truncated: Bool = false
    )
    {
        self.nextMarker = nextMarker
        self.policyNames = policyNames
        self.truncated = truncated
    }
}

struct ListKeyPoliciesOutputResponseBody: Equatable {
    public let policyNames: [String]?
    public let nextMarker: String?
    public let truncated: Bool
}

extension ListKeyPoliciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextMarker = "NextMarker"
        case policyNames = "PolicyNames"
        case truncated = "Truncated"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .policyNames)
        var policyNamesDecoded0:[String]? = nil
        if let policyNamesContainer = policyNamesContainer {
            policyNamesDecoded0 = [String]()
            for string0 in policyNamesContainer {
                if let string0 = string0 {
                    policyNamesDecoded0?.append(string0)
                }
            }
        }
        policyNames = policyNamesDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let truncatedDecoded = try containerValues.decode(Bool.self, forKey: .truncated)
        truncated = truncatedDecoded
    }
}

public struct ListKeysInputBodyMiddleware: Middleware {
    public let id: String = "ListKeysInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListKeysInput>
    public typealias MOutput = OperationOutput<ListKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListKeysOutputError>
}

extension ListKeysInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListKeysInput(limit: \(String(describing: limit)), marker: \(String(describing: marker)))"}
}

extension ListKeysInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case marker = "Marker"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
    }
}

public struct ListKeysInputHeadersMiddleware: Middleware {
    public let id: String = "ListKeysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListKeysInput>
    public typealias MOutput = OperationOutput<ListKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListKeysOutputError>
}

public struct ListKeysInputQueryItemMiddleware: Middleware {
    public let id: String = "ListKeysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListKeysInput>
    public typealias MOutput = OperationOutput<ListKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListKeysOutputError>
}

public struct ListKeysInput: Equatable {
    /// <p>Use this parameter to specify the maximum number of items to return. When this
    ///     value is present, AWS KMS does not return more than the specified number of items, but it might
    ///     return fewer.</p>
    ///          <p>This value is optional. If you include a value, it must be between
    ///     1 and 1000, inclusive. If you do not include a value, it defaults to 100.</p>
    public let limit: Int?
    /// <p>Use this parameter in a subsequent request after you receive a response with
    ///     truncated results. Set it to the value of <code>NextMarker</code> from the truncated response
    ///     you just received.</p>
    public let marker: String?

    public init (
        limit: Int? = nil,
        marker: String? = nil
    )
    {
        self.limit = limit
        self.marker = marker
    }
}

struct ListKeysInputBody: Equatable {
    public let limit: Int?
    public let marker: String?
}

extension ListKeysInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListKeysOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListKeysOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMarkerException" : self = .invalidMarkerException(try InvalidMarkerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListKeysOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case invalidMarkerException(InvalidMarkerException)
    case kMSInternalException(KMSInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListKeysOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListKeysOutputResponse(keys: \(String(describing: keys)), nextMarker: \(String(describing: nextMarker)), truncated: \(String(describing: truncated)))"}
}

extension ListKeysOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListKeysOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.keys = output.keys
            self.nextMarker = output.nextMarker
            self.truncated = output.truncated
        } else {
            self.keys = nil
            self.nextMarker = nil
            self.truncated = false
        }
    }
}

public struct ListKeysOutputResponse: Equatable {
    /// <p>A list of customer master keys (CMKs).</p>
    public let keys: [KeyListEntry]?
    /// <p>When <code>Truncated</code> is true, this element is present and contains the
    ///     value to use for the <code>Marker</code> parameter in a subsequent request.</p>
    public let nextMarker: String?
    /// <p>A flag that indicates whether there are more items in the list. When this
    ///     value is true, the list in this response is truncated. To get more items, pass the value of
    ///     the <code>NextMarker</code> element in thisresponse to the <code>Marker</code> parameter in a
    ///     subsequent request.</p>
    public let truncated: Bool

    public init (
        keys: [KeyListEntry]? = nil,
        nextMarker: String? = nil,
        truncated: Bool = false
    )
    {
        self.keys = keys
        self.nextMarker = nextMarker
        self.truncated = truncated
    }
}

struct ListKeysOutputResponseBody: Equatable {
    public let keys: [KeyListEntry]?
    public let nextMarker: String?
    public let truncated: Bool
}

extension ListKeysOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keys = "Keys"
        case nextMarker = "NextMarker"
        case truncated = "Truncated"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keysContainer = try containerValues.decodeIfPresent([KeyListEntry?].self, forKey: .keys)
        var keysDecoded0:[KeyListEntry]? = nil
        if let keysContainer = keysContainer {
            keysDecoded0 = [KeyListEntry]()
            for structure0 in keysContainer {
                if let structure0 = structure0 {
                    keysDecoded0?.append(structure0)
                }
            }
        }
        keys = keysDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let truncatedDecoded = try containerValues.decode(Bool.self, forKey: .truncated)
        truncated = truncatedDecoded
    }
}

public struct ListResourceTagsInputBodyMiddleware: Middleware {
    public let id: String = "ListResourceTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourceTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourceTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourceTagsInput>
    public typealias MOutput = OperationOutput<ListResourceTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourceTagsOutputError>
}

extension ListResourceTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourceTagsInput(keyId: \(String(describing: keyId)), limit: \(String(describing: limit)), marker: \(String(describing: marker)))"}
}

extension ListResourceTagsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
        case limit = "Limit"
        case marker = "Marker"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
    }
}

public struct ListResourceTagsInputHeadersMiddleware: Middleware {
    public let id: String = "ListResourceTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourceTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourceTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourceTagsInput>
    public typealias MOutput = OperationOutput<ListResourceTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourceTagsOutputError>
}

public struct ListResourceTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListResourceTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourceTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourceTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourceTagsInput>
    public typealias MOutput = OperationOutput<ListResourceTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourceTagsOutputError>
}

public struct ListResourceTagsInput: Equatable {
    /// <p>A unique identifier for the customer master key (CMK).</p>
    ///          <p>Specify the key ID or the Amazon Resource Name (ARN) of the CMK.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
    public let keyId: String?
    /// <p>Use this parameter to specify the maximum number of items to return. When this
    ///     value is present, AWS KMS does not return more than the specified number of items, but it might
    ///     return fewer.</p>
    ///          <p>This value is optional. If you include a value, it must be between 1 and 50, inclusive. If
    ///       you do not include a value, it defaults to 50.</p>
    public let limit: Int?
    /// <p>Use this parameter in a subsequent request after you receive a response with
    ///     truncated results. Set it to the value of <code>NextMarker</code> from the truncated response
    ///     you just received.</p>
    ///          <p>Do not attempt to construct this value. Use only the value of <code>NextMarker</code> from
    ///       the truncated response you just received.</p>
    public let marker: String?

    public init (
        keyId: String? = nil,
        limit: Int? = nil,
        marker: String? = nil
    )
    {
        self.keyId = keyId
        self.limit = limit
        self.marker = marker
    }
}

struct ListResourceTagsInputBody: Equatable {
    public let keyId: String?
    public let limit: Int?
    public let marker: String?
}

extension ListResourceTagsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
        case limit = "Limit"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListResourceTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourceTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMarkerException" : self = .invalidMarkerException(try InvalidMarkerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourceTagsOutputError: Equatable {
    case invalidArnException(InvalidArnException)
    case invalidMarkerException(InvalidMarkerException)
    case kMSInternalException(KMSInternalException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourceTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourceTagsOutputResponse(nextMarker: \(String(describing: nextMarker)), tags: \(String(describing: tags)), truncated: \(String(describing: truncated)))"}
}

extension ListResourceTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListResourceTagsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextMarker = output.nextMarker
            self.tags = output.tags
            self.truncated = output.truncated
        } else {
            self.nextMarker = nil
            self.tags = nil
            self.truncated = false
        }
    }
}

public struct ListResourceTagsOutputResponse: Equatable {
    /// <p>When <code>Truncated</code> is true, this element is present and contains the
    ///     value to use for the <code>Marker</code> parameter in a subsequent request.</p>
    ///          <p>Do not assume or infer any information from this value.</p>
    public let nextMarker: String?
    /// <p>A list of tags. Each tag consists of a tag key and a tag value.</p>
    public let tags: [Tag]?
    /// <p>A flag that indicates whether there are more items in the list. When this
    ///     value is true, the list in this response is truncated. To get more items, pass the value of
    ///     the <code>NextMarker</code> element in thisresponse to the <code>Marker</code> parameter in a
    ///     subsequent request.</p>
    public let truncated: Bool

    public init (
        nextMarker: String? = nil,
        tags: [Tag]? = nil,
        truncated: Bool = false
    )
    {
        self.nextMarker = nextMarker
        self.tags = tags
        self.truncated = truncated
    }
}

struct ListResourceTagsOutputResponseBody: Equatable {
    public let tags: [Tag]?
    public let nextMarker: String?
    public let truncated: Bool
}

extension ListResourceTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextMarker = "NextMarker"
        case tags = "Tags"
        case truncated = "Truncated"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let truncatedDecoded = try containerValues.decode(Bool.self, forKey: .truncated)
        truncated = truncatedDecoded
    }
}

public struct ListRetirableGrantsInputBodyMiddleware: Middleware {
    public let id: String = "ListRetirableGrantsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRetirableGrantsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRetirableGrantsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRetirableGrantsInput>
    public typealias MOutput = OperationOutput<ListRetirableGrantsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRetirableGrantsOutputError>
}

extension ListRetirableGrantsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRetirableGrantsInput(limit: \(String(describing: limit)), marker: \(String(describing: marker)), retiringPrincipal: \(String(describing: retiringPrincipal)))"}
}

extension ListRetirableGrantsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case marker = "Marker"
        case retiringPrincipal = "RetiringPrincipal"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let retiringPrincipal = retiringPrincipal {
            try encodeContainer.encode(retiringPrincipal, forKey: .retiringPrincipal)
        }
    }
}

public struct ListRetirableGrantsInputHeadersMiddleware: Middleware {
    public let id: String = "ListRetirableGrantsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRetirableGrantsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRetirableGrantsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRetirableGrantsInput>
    public typealias MOutput = OperationOutput<ListRetirableGrantsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRetirableGrantsOutputError>
}

public struct ListRetirableGrantsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRetirableGrantsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRetirableGrantsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRetirableGrantsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRetirableGrantsInput>
    public typealias MOutput = OperationOutput<ListRetirableGrantsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRetirableGrantsOutputError>
}

public struct ListRetirableGrantsInput: Equatable {
    /// <p>Use this parameter to specify the maximum number of items to return. When this
    ///     value is present, AWS KMS does not return more than the specified number of items, but it might
    ///     return fewer.</p>
    ///          <p>This value is optional. If you include a value, it must be between 1
    ///     and 100, inclusive. If you do not include a value, it defaults to 50.</p>
    public let limit: Int?
    /// <p>Use this parameter in a subsequent request after you receive a response with
    ///     truncated results. Set it to the value of <code>NextMarker</code> from the truncated response
    ///     you just received.</p>
    public let marker: String?
    /// <p>The retiring principal for which to list grants. Enter a principal in your AWS
    ///       account.</p>
    ///          <p>To specify the retiring principal, use the <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Name (ARN)</a> of an AWS
    ///       principal. Valid AWS principals include AWS accounts (root), IAM users, federated users, and
    ///       assumed role users. For examples of the ARN syntax for specifying a principal, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-iam">AWS
    ///         Identity and Access Management (IAM)</a> in the Example ARNs section of the
    ///         <i>Amazon Web Services General Reference</i>.</p>
    public let retiringPrincipal: String?

    public init (
        limit: Int? = nil,
        marker: String? = nil,
        retiringPrincipal: String? = nil
    )
    {
        self.limit = limit
        self.marker = marker
        self.retiringPrincipal = retiringPrincipal
    }
}

struct ListRetirableGrantsInputBody: Equatable {
    public let limit: Int?
    public let marker: String?
    public let retiringPrincipal: String?
}

extension ListRetirableGrantsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case marker = "Marker"
        case retiringPrincipal = "RetiringPrincipal"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let retiringPrincipalDecoded = try containerValues.decodeIfPresent(String.self, forKey: .retiringPrincipal)
        retiringPrincipal = retiringPrincipalDecoded
    }
}

extension ListRetirableGrantsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRetirableGrantsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMarkerException" : self = .invalidMarkerException(try InvalidMarkerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRetirableGrantsOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case invalidArnException(InvalidArnException)
    case invalidMarkerException(InvalidMarkerException)
    case kMSInternalException(KMSInternalException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRetirableGrantsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRetirableGrantsOutputResponse(grants: \(String(describing: grants)), nextMarker: \(String(describing: nextMarker)), truncated: \(String(describing: truncated)))"}
}

extension ListRetirableGrantsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRetirableGrantsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.grants = output.grants
            self.nextMarker = output.nextMarker
            self.truncated = output.truncated
        } else {
            self.grants = nil
            self.nextMarker = nil
            self.truncated = false
        }
    }
}

public struct ListRetirableGrantsOutputResponse: Equatable {
    /// <p>A list of grants.</p>
    public let grants: [GrantListEntry]?
    /// <p>When <code>Truncated</code> is true, this element is present and contains the
    ///     value to use for the <code>Marker</code> parameter in a subsequent request.</p>
    public let nextMarker: String?
    /// <p>A flag that indicates whether there are more items in the list. When this
    ///     value is true, the list in this response is truncated. To get more items, pass the value of
    ///     the <code>NextMarker</code> element in thisresponse to the <code>Marker</code> parameter in a
    ///     subsequent request.</p>
    public let truncated: Bool

    public init (
        grants: [GrantListEntry]? = nil,
        nextMarker: String? = nil,
        truncated: Bool = false
    )
    {
        self.grants = grants
        self.nextMarker = nextMarker
        self.truncated = truncated
    }
}

struct ListRetirableGrantsOutputResponseBody: Equatable {
    public let grants: [GrantListEntry]?
    public let nextMarker: String?
    public let truncated: Bool
}

extension ListRetirableGrantsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case grants = "Grants"
        case nextMarker = "NextMarker"
        case truncated = "Truncated"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantsContainer = try containerValues.decodeIfPresent([GrantListEntry?].self, forKey: .grants)
        var grantsDecoded0:[GrantListEntry]? = nil
        if let grantsContainer = grantsContainer {
            grantsDecoded0 = [GrantListEntry]()
            for structure0 in grantsContainer {
                if let structure0 = structure0 {
                    grantsDecoded0?.append(structure0)
                }
            }
        }
        grants = grantsDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let truncatedDecoded = try containerValues.decode(Bool.self, forKey: .truncated)
        truncated = truncatedDecoded
    }
}

extension MalformedPolicyDocumentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MalformedPolicyDocumentException(message: \(String(describing: message)))"}
}

extension MalformedPolicyDocumentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MalformedPolicyDocumentExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the specified policy is not syntactically or semantically
///       correct.</p>
public struct MalformedPolicyDocumentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MalformedPolicyDocumentExceptionBody: Equatable {
    public let message: String?
}

extension MalformedPolicyDocumentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum MessageType {
    case digest
    case raw
    case sdkUnknown(String)
}

extension MessageType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MessageType] {
        return [
            .digest,
            .raw,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .digest: return "DIGEST"
        case .raw: return "RAW"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MessageType(rawValue: rawValue) ?? MessageType.sdkUnknown(rawValue)
    }
}

extension NotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFoundException(message: \(String(describing: message)))"}
}

extension NotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the specified entity or resource could not be
///       found.</p>
public struct NotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Equatable {
    public let message: String?
}

extension NotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum OriginType {
    case awsCloudhsm
    case awsKms
    case external
    case sdkUnknown(String)
}

extension OriginType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OriginType] {
        return [
            .awsCloudhsm,
            .awsKms,
            .external,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .awsCloudhsm: return "AWS_CLOUDHSM"
        case .awsKms: return "AWS_KMS"
        case .external: return "EXTERNAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OriginType(rawValue: rawValue) ?? OriginType.sdkUnknown(rawValue)
    }
}

public struct PutKeyPolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutKeyPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutKeyPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutKeyPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutKeyPolicyInput>
    public typealias MOutput = OperationOutput<PutKeyPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutKeyPolicyOutputError>
}

extension PutKeyPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutKeyPolicyInput(bypassPolicyLockoutSafetyCheck: \(String(describing: bypassPolicyLockoutSafetyCheck)), keyId: \(String(describing: keyId)), policy: \(String(describing: policy)), policyName: \(String(describing: policyName)))"}
}

extension PutKeyPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bypassPolicyLockoutSafetyCheck = "BypassPolicyLockoutSafetyCheck"
        case keyId = "KeyId"
        case policy = "Policy"
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if bypassPolicyLockoutSafetyCheck != false {
            try encodeContainer.encode(bypassPolicyLockoutSafetyCheck, forKey: .bypassPolicyLockoutSafetyCheck)
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let policyName = policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
    }
}

public struct PutKeyPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutKeyPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutKeyPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutKeyPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutKeyPolicyInput>
    public typealias MOutput = OperationOutput<PutKeyPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutKeyPolicyOutputError>
}

public struct PutKeyPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutKeyPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutKeyPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutKeyPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutKeyPolicyInput>
    public typealias MOutput = OperationOutput<PutKeyPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutKeyPolicyOutputError>
}

public struct PutKeyPolicyInput: Equatable {
    /// <p>A flag to indicate whether to bypass the key policy lockout safety check.</p>
    ///          <important>
    ///             <p>Setting this value to true increases the risk that the CMK becomes unmanageable. Do not
    ///         set this value to true indiscriminately.</p>
    ///             <p>For more information, refer to the scenario in the <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html#key-policy-default-allow-root-enable-iam">Default Key Policy</a> section in the <i>AWS Key Management Service Developer Guide</i>.</p>
    ///          </important>
    ///          <p>Use this parameter only when you intend to prevent the principal that is making the
    ///       request from making a subsequent <code>PutKeyPolicy</code> request on the CMK.</p>
    ///          <p>The default value is false.</p>
    public let bypassPolicyLockoutSafetyCheck: Bool
    /// <p>A unique identifier for the customer master key (CMK).</p>
    ///          <p>Specify the key ID or the Amazon Resource Name (ARN) of the CMK.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
    public let keyId: String?
    /// <p>The key policy to attach to the CMK.</p>
    ///          <p>The key policy must meet the following criteria:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If you don't set <code>BypassPolicyLockoutSafetyCheck</code> to true, the key policy
    ///           must allow the principal that is making the <code>PutKeyPolicy</code> request to make a
    ///           subsequent <code>PutKeyPolicy</code> request on the CMK. This reduces the risk that the
    ///           CMK becomes unmanageable. For more information, refer to the scenario in the <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html#key-policy-default-allow-root-enable-iam">Default Key Policy</a> section of the <i>AWS Key Management Service Developer Guide</i>.</p>
    ///             </li>
    ///             <li>
    ///                <p>Each statement in the key policy must contain one or more principals. The principals
    ///           in the key policy must exist and be visible to AWS KMS. When you create a new AWS principal
    ///           (for example, an IAM user or role), you might need to enforce a delay before including the
    ///           new principal in a key policy because the new principal might not be immediately visible
    ///           to AWS KMS. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/troubleshoot_general.html#troubleshoot_general_eventual-consistency">Changes that I make are not always immediately visible</a> in the <i>AWS
    ///             Identity and Access Management User Guide</i>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The key policy cannot exceed 32 kilobytes (32768 bytes). For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/resource-limits.html">Resource Quotas</a> in the <i>AWS Key Management Service Developer Guide</i>.</p>
    public let policy: String?
    /// <p>The name of the key policy. The only valid value is <code>default</code>.</p>
    public let policyName: String?

    public init (
        bypassPolicyLockoutSafetyCheck: Bool = false,
        keyId: String? = nil,
        policy: String? = nil,
        policyName: String? = nil
    )
    {
        self.bypassPolicyLockoutSafetyCheck = bypassPolicyLockoutSafetyCheck
        self.keyId = keyId
        self.policy = policy
        self.policyName = policyName
    }
}

struct PutKeyPolicyInputBody: Equatable {
    public let keyId: String?
    public let policyName: String?
    public let policy: String?
    public let bypassPolicyLockoutSafetyCheck: Bool
}

extension PutKeyPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bypassPolicyLockoutSafetyCheck = "BypassPolicyLockoutSafetyCheck"
        case keyId = "KeyId"
        case policy = "Policy"
        case policyName = "PolicyName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
        let bypassPolicyLockoutSafetyCheckDecoded = try containerValues.decode(Bool.self, forKey: .bypassPolicyLockoutSafetyCheck)
        bypassPolicyLockoutSafetyCheck = bypassPolicyLockoutSafetyCheckDecoded
    }
}

extension PutKeyPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutKeyPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocumentException" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutKeyPolicyOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case invalidArnException(InvalidArnException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case limitExceededException(LimitExceededException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case notFoundException(NotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutKeyPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutKeyPolicyOutputResponse()"}
}

extension PutKeyPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutKeyPolicyOutputResponse: Equatable {

    public init() {}
}

struct PutKeyPolicyOutputResponseBody: Equatable {
}

extension PutKeyPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct ReEncryptInputBodyMiddleware: Middleware {
    public let id: String = "ReEncryptInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReEncryptInput>,
                  next: H) -> Swift.Result<OperationOutput<ReEncryptOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReEncryptInput>
    public typealias MOutput = OperationOutput<ReEncryptOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReEncryptOutputError>
}

extension ReEncryptInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReEncryptInput(ciphertextBlob: \(String(describing: ciphertextBlob)), destinationEncryptionAlgorithm: \(String(describing: destinationEncryptionAlgorithm)), destinationEncryptionContext: \(String(describing: destinationEncryptionContext)), destinationKeyId: \(String(describing: destinationKeyId)), grantTokens: \(String(describing: grantTokens)), sourceEncryptionAlgorithm: \(String(describing: sourceEncryptionAlgorithm)), sourceEncryptionContext: \(String(describing: sourceEncryptionContext)), sourceKeyId: \(String(describing: sourceKeyId)))"}
}

extension ReEncryptInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ciphertextBlob = "CiphertextBlob"
        case destinationEncryptionAlgorithm = "DestinationEncryptionAlgorithm"
        case destinationEncryptionContext = "DestinationEncryptionContext"
        case destinationKeyId = "DestinationKeyId"
        case grantTokens = "GrantTokens"
        case sourceEncryptionAlgorithm = "SourceEncryptionAlgorithm"
        case sourceEncryptionContext = "SourceEncryptionContext"
        case sourceKeyId = "SourceKeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ciphertextBlob = ciphertextBlob {
            try encodeContainer.encode(ciphertextBlob.base64EncodedString(), forKey: .ciphertextBlob)
        }
        if let destinationEncryptionAlgorithm = destinationEncryptionAlgorithm {
            try encodeContainer.encode(destinationEncryptionAlgorithm.rawValue, forKey: .destinationEncryptionAlgorithm)
        }
        if let destinationEncryptionContext = destinationEncryptionContext {
            var destinationEncryptionContextContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .destinationEncryptionContext)
            for (dictKey0, encryptioncontexttype0) in destinationEncryptionContext {
                try destinationEncryptionContextContainer.encode(encryptioncontexttype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let destinationKeyId = destinationKeyId {
            try encodeContainer.encode(destinationKeyId, forKey: .destinationKeyId)
        }
        if let grantTokens = grantTokens {
            var grantTokensContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantTokens)
            for granttokenlist0 in grantTokens {
                try grantTokensContainer.encode(granttokenlist0)
            }
        }
        if let sourceEncryptionAlgorithm = sourceEncryptionAlgorithm {
            try encodeContainer.encode(sourceEncryptionAlgorithm.rawValue, forKey: .sourceEncryptionAlgorithm)
        }
        if let sourceEncryptionContext = sourceEncryptionContext {
            var sourceEncryptionContextContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .sourceEncryptionContext)
            for (dictKey0, encryptioncontexttype0) in sourceEncryptionContext {
                try sourceEncryptionContextContainer.encode(encryptioncontexttype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let sourceKeyId = sourceKeyId {
            try encodeContainer.encode(sourceKeyId, forKey: .sourceKeyId)
        }
    }
}

public struct ReEncryptInputHeadersMiddleware: Middleware {
    public let id: String = "ReEncryptInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReEncryptInput>,
                  next: H) -> Swift.Result<OperationOutput<ReEncryptOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReEncryptInput>
    public typealias MOutput = OperationOutput<ReEncryptOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReEncryptOutputError>
}

public struct ReEncryptInputQueryItemMiddleware: Middleware {
    public let id: String = "ReEncryptInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReEncryptInput>,
                  next: H) -> Swift.Result<OperationOutput<ReEncryptOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReEncryptInput>
    public typealias MOutput = OperationOutput<ReEncryptOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReEncryptOutputError>
}

public struct ReEncryptInput: Equatable {
    /// <p>Ciphertext of the data to reencrypt.</p>
    public let ciphertextBlob: Data?
    /// <p>Specifies the encryption algorithm that AWS KMS will use to reecrypt the data after it has
    ///       decrypted it. The default value, <code>SYMMETRIC_DEFAULT</code>, represents the encryption
    ///       algorithm used for symmetric CMKs.</p>
    ///          <p>This parameter is required only when the destination CMK is an asymmetric CMK.</p>
    public let destinationEncryptionAlgorithm: EncryptionAlgorithmSpec?
    /// <p>Specifies that encryption context to use when the reencrypting the data.</p>
    ///          <p>A destination encryption context is valid only when the destination CMK is a symmetric
    ///       CMK. The standard ciphertext format for asymmetric CMKs does not include fields for
    ///       metadata.</p>
    ///          <p>An <i>encryption context</i> is a collection of non-secret key-value pairs that represents additional authenticated data. When you use an encryption context to encrypt data, you must specify the same (an exact case-sensitive match) encryption context to decrypt the data. An encryption context is optional when encrypting with a symmetric CMK, but it is highly recommended.</p>
    ///          <p>For more information, see
    ///         <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context">Encryption
    ///         Context</a> in the <i>AWS Key Management Service Developer Guide</i>.</p>
    public let destinationEncryptionContext: [String:String]?
    /// <p>A unique identifier for the CMK that is used to reencrypt the data. Specify a symmetric or
    ///       asymmetric CMK with a <code>KeyUsage</code> value of <code>ENCRYPT_DECRYPT</code>. To find the
    ///         <code>KeyUsage</code> value of a CMK, use the <a>DescribeKey</a>
    ///       operation.</p>
    ///          <p>To specify a CMK, use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. When using an alias name, prefix it with <code>"alias/"</code>. To specify a CMK in a different AWS account, you must use the key ARN or alias ARN.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Alias name: <code>alias/ExampleAlias</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Alias ARN: <code>arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>. To get the alias name and alias ARN, use <a>ListAliases</a>.</p>
    public let destinationKeyId: String?
    /// <p>A list of grant tokens.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#grant_token">Grant Tokens</a> in the
    ///     <i>AWS Key Management Service Developer Guide</i>.</p>
    public let grantTokens: [String]?
    /// <p>Specifies the encryption algorithm that AWS KMS will use to decrypt the ciphertext before it
    ///       is reencrypted. The default value, <code>SYMMETRIC_DEFAULT</code>, represents the algorithm
    ///       used for symmetric CMKs.</p>
    ///          <p>Specify the same algorithm that was used to encrypt the ciphertext. If you specify a
    ///       different algorithm, the decrypt attempt fails.</p>
    ///          <p>This parameter is required only when the ciphertext was encrypted under an asymmetric
    ///       CMK.</p>
    public let sourceEncryptionAlgorithm: EncryptionAlgorithmSpec?
    /// <p>Specifies the encryption context to use to decrypt the ciphertext. Enter the same
    ///       encryption context that was used to encrypt the ciphertext.</p>
    ///          <p>An <i>encryption context</i> is a collection of non-secret key-value pairs that represents additional authenticated data. When you use an encryption context to encrypt data, you must specify the same (an exact case-sensitive match) encryption context to decrypt the data. An encryption context is optional when encrypting with a symmetric CMK, but it is highly recommended.</p>
    ///          <p>For more information, see
    ///         <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context">Encryption
    ///         Context</a> in the <i>AWS Key Management Service Developer Guide</i>.</p>
    public let sourceEncryptionContext: [String:String]?
    /// <p>Specifies the customer master key (CMK) that
    ///     AWS KMS will use to decrypt the ciphertext before it is re-encrypted. Enter a key ID of the CMK
    ///     that was used to encrypt the ciphertext.</p>
    ///          <p>This parameter is required only when the ciphertext was encrypted under an asymmetric CMK.
    ///       If you used a symmetric CMK, AWS KMS can get the CMK from metadata that it adds to the
    ///       symmetric ciphertext blob. However, it is always recommended as a best practice. This practice
    ///       ensures that you use the CMK that you intend.</p>
    ///
    ///          <p>To specify a CMK, use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. When using an alias name, prefix it with <code>"alias/"</code>. To specify a CMK in a different AWS account, you must use the key ARN or alias ARN.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Alias name: <code>alias/ExampleAlias</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Alias ARN: <code>arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>. To get the alias name and alias ARN, use <a>ListAliases</a>.</p>
    public let sourceKeyId: String?

    public init (
        ciphertextBlob: Data? = nil,
        destinationEncryptionAlgorithm: EncryptionAlgorithmSpec? = nil,
        destinationEncryptionContext: [String:String]? = nil,
        destinationKeyId: String? = nil,
        grantTokens: [String]? = nil,
        sourceEncryptionAlgorithm: EncryptionAlgorithmSpec? = nil,
        sourceEncryptionContext: [String:String]? = nil,
        sourceKeyId: String? = nil
    )
    {
        self.ciphertextBlob = ciphertextBlob
        self.destinationEncryptionAlgorithm = destinationEncryptionAlgorithm
        self.destinationEncryptionContext = destinationEncryptionContext
        self.destinationKeyId = destinationKeyId
        self.grantTokens = grantTokens
        self.sourceEncryptionAlgorithm = sourceEncryptionAlgorithm
        self.sourceEncryptionContext = sourceEncryptionContext
        self.sourceKeyId = sourceKeyId
    }
}

struct ReEncryptInputBody: Equatable {
    public let ciphertextBlob: Data?
    public let sourceEncryptionContext: [String:String]?
    public let sourceKeyId: String?
    public let destinationKeyId: String?
    public let destinationEncryptionContext: [String:String]?
    public let sourceEncryptionAlgorithm: EncryptionAlgorithmSpec?
    public let destinationEncryptionAlgorithm: EncryptionAlgorithmSpec?
    public let grantTokens: [String]?
}

extension ReEncryptInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ciphertextBlob = "CiphertextBlob"
        case destinationEncryptionAlgorithm = "DestinationEncryptionAlgorithm"
        case destinationEncryptionContext = "DestinationEncryptionContext"
        case destinationKeyId = "DestinationKeyId"
        case grantTokens = "GrantTokens"
        case sourceEncryptionAlgorithm = "SourceEncryptionAlgorithm"
        case sourceEncryptionContext = "SourceEncryptionContext"
        case sourceKeyId = "SourceKeyId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ciphertextBlobDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .ciphertextBlob)
        ciphertextBlob = ciphertextBlobDecoded
        let sourceEncryptionContextContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .sourceEncryptionContext)
        var sourceEncryptionContextDecoded0: [String:String]? = nil
        if let sourceEncryptionContextContainer = sourceEncryptionContextContainer {
            sourceEncryptionContextDecoded0 = [String:String]()
            for (key0, encryptioncontextvalue0) in sourceEncryptionContextContainer {
                if let encryptioncontextvalue0 = encryptioncontextvalue0 {
                    sourceEncryptionContextDecoded0?[key0] = encryptioncontextvalue0
                }
            }
        }
        sourceEncryptionContext = sourceEncryptionContextDecoded0
        let sourceKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceKeyId)
        sourceKeyId = sourceKeyIdDecoded
        let destinationKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationKeyId)
        destinationKeyId = destinationKeyIdDecoded
        let destinationEncryptionContextContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .destinationEncryptionContext)
        var destinationEncryptionContextDecoded0: [String:String]? = nil
        if let destinationEncryptionContextContainer = destinationEncryptionContextContainer {
            destinationEncryptionContextDecoded0 = [String:String]()
            for (key0, encryptioncontextvalue0) in destinationEncryptionContextContainer {
                if let encryptioncontextvalue0 = encryptioncontextvalue0 {
                    destinationEncryptionContextDecoded0?[key0] = encryptioncontextvalue0
                }
            }
        }
        destinationEncryptionContext = destinationEncryptionContextDecoded0
        let sourceEncryptionAlgorithmDecoded = try containerValues.decodeIfPresent(EncryptionAlgorithmSpec.self, forKey: .sourceEncryptionAlgorithm)
        sourceEncryptionAlgorithm = sourceEncryptionAlgorithmDecoded
        let destinationEncryptionAlgorithmDecoded = try containerValues.decodeIfPresent(EncryptionAlgorithmSpec.self, forKey: .destinationEncryptionAlgorithm)
        destinationEncryptionAlgorithm = destinationEncryptionAlgorithmDecoded
        let grantTokensContainer = try containerValues.decodeIfPresent([String?].self, forKey: .grantTokens)
        var grantTokensDecoded0:[String]? = nil
        if let grantTokensContainer = grantTokensContainer {
            grantTokensDecoded0 = [String]()
            for string0 in grantTokensContainer {
                if let string0 = string0 {
                    grantTokensDecoded0?.append(string0)
                }
            }
        }
        grantTokens = grantTokensDecoded0
    }
}

extension ReEncryptOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ReEncryptOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledException" : self = .disabledException(try DisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectKeyException" : self = .incorrectKeyException(try IncorrectKeyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCiphertextException" : self = .invalidCiphertextException(try InvalidCiphertextException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGrantTokenException" : self = .invalidGrantTokenException(try InvalidGrantTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKeyUsageException" : self = .invalidKeyUsageException(try InvalidKeyUsageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KeyUnavailableException" : self = .keyUnavailableException(try KeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ReEncryptOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case disabledException(DisabledException)
    case incorrectKeyException(IncorrectKeyException)
    case invalidCiphertextException(InvalidCiphertextException)
    case invalidGrantTokenException(InvalidGrantTokenException)
    case invalidKeyUsageException(InvalidKeyUsageException)
    case keyUnavailableException(KeyUnavailableException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ReEncryptOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReEncryptOutputResponse(ciphertextBlob: \(String(describing: ciphertextBlob)), destinationEncryptionAlgorithm: \(String(describing: destinationEncryptionAlgorithm)), keyId: \(String(describing: keyId)), sourceEncryptionAlgorithm: \(String(describing: sourceEncryptionAlgorithm)), sourceKeyId: \(String(describing: sourceKeyId)))"}
}

extension ReEncryptOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ReEncryptOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.ciphertextBlob = output.ciphertextBlob
            self.destinationEncryptionAlgorithm = output.destinationEncryptionAlgorithm
            self.keyId = output.keyId
            self.sourceEncryptionAlgorithm = output.sourceEncryptionAlgorithm
            self.sourceKeyId = output.sourceKeyId
        } else {
            self.ciphertextBlob = nil
            self.destinationEncryptionAlgorithm = nil
            self.keyId = nil
            self.sourceEncryptionAlgorithm = nil
            self.sourceKeyId = nil
        }
    }
}

public struct ReEncryptOutputResponse: Equatable {
    /// <p>The reencrypted data. When you use the HTTP API or the AWS CLI, the value is Base64-encoded. Otherwise, it is not Base64-encoded.</p>
    public let ciphertextBlob: Data?
    /// <p>The encryption algorithm that was used to reencrypt the data.</p>
    public let destinationEncryptionAlgorithm: EncryptionAlgorithmSpec?
    /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN">key ARN</a>) of the CMK that was used to reencrypt the data.</p>
    public let keyId: String?
    /// <p>The encryption algorithm that was used to decrypt the ciphertext before it was
    ///       reencrypted.</p>
    public let sourceEncryptionAlgorithm: EncryptionAlgorithmSpec?
    /// <p>Unique identifier of the CMK used to originally encrypt the data.</p>
    public let sourceKeyId: String?

    public init (
        ciphertextBlob: Data? = nil,
        destinationEncryptionAlgorithm: EncryptionAlgorithmSpec? = nil,
        keyId: String? = nil,
        sourceEncryptionAlgorithm: EncryptionAlgorithmSpec? = nil,
        sourceKeyId: String? = nil
    )
    {
        self.ciphertextBlob = ciphertextBlob
        self.destinationEncryptionAlgorithm = destinationEncryptionAlgorithm
        self.keyId = keyId
        self.sourceEncryptionAlgorithm = sourceEncryptionAlgorithm
        self.sourceKeyId = sourceKeyId
    }
}

struct ReEncryptOutputResponseBody: Equatable {
    public let ciphertextBlob: Data?
    public let sourceKeyId: String?
    public let keyId: String?
    public let sourceEncryptionAlgorithm: EncryptionAlgorithmSpec?
    public let destinationEncryptionAlgorithm: EncryptionAlgorithmSpec?
}

extension ReEncryptOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ciphertextBlob = "CiphertextBlob"
        case destinationEncryptionAlgorithm = "DestinationEncryptionAlgorithm"
        case keyId = "KeyId"
        case sourceEncryptionAlgorithm = "SourceEncryptionAlgorithm"
        case sourceKeyId = "SourceKeyId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ciphertextBlobDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .ciphertextBlob)
        ciphertextBlob = ciphertextBlobDecoded
        let sourceKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceKeyId)
        sourceKeyId = sourceKeyIdDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let sourceEncryptionAlgorithmDecoded = try containerValues.decodeIfPresent(EncryptionAlgorithmSpec.self, forKey: .sourceEncryptionAlgorithm)
        sourceEncryptionAlgorithm = sourceEncryptionAlgorithmDecoded
        let destinationEncryptionAlgorithmDecoded = try containerValues.decodeIfPresent(EncryptionAlgorithmSpec.self, forKey: .destinationEncryptionAlgorithm)
        destinationEncryptionAlgorithm = destinationEncryptionAlgorithmDecoded
    }
}

public struct RetireGrantInputBodyMiddleware: Middleware {
    public let id: String = "RetireGrantInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RetireGrantInput>,
                  next: H) -> Swift.Result<OperationOutput<RetireGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RetireGrantInput>
    public typealias MOutput = OperationOutput<RetireGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RetireGrantOutputError>
}

extension RetireGrantInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RetireGrantInput(grantId: \(String(describing: grantId)), grantToken: \(String(describing: grantToken)), keyId: \(String(describing: keyId)))"}
}

extension RetireGrantInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grantId = "GrantId"
        case grantToken = "GrantToken"
        case keyId = "KeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantId = grantId {
            try encodeContainer.encode(grantId, forKey: .grantId)
        }
        if let grantToken = grantToken {
            try encodeContainer.encode(grantToken, forKey: .grantToken)
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
    }
}

public struct RetireGrantInputHeadersMiddleware: Middleware {
    public let id: String = "RetireGrantInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RetireGrantInput>,
                  next: H) -> Swift.Result<OperationOutput<RetireGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RetireGrantInput>
    public typealias MOutput = OperationOutput<RetireGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RetireGrantOutputError>
}

public struct RetireGrantInputQueryItemMiddleware: Middleware {
    public let id: String = "RetireGrantInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RetireGrantInput>,
                  next: H) -> Swift.Result<OperationOutput<RetireGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RetireGrantInput>
    public typealias MOutput = OperationOutput<RetireGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RetireGrantOutputError>
}

public struct RetireGrantInput: Equatable {
    /// <p>Unique identifier of the grant to retire. The grant ID is returned in the response to a
    ///         <code>CreateGrant</code> operation.</p>
    ///          <ul>
    ///             <li>
    ///                <p>Grant ID Example -
    ///           0123456789012345678901234567890123456789012345678901234567890123</p>
    ///             </li>
    ///          </ul>
    public let grantId: String?
    /// <p>Token that identifies the grant to be retired.</p>
    public let grantToken: String?
    /// <p>The Amazon Resource Name (ARN) of the CMK associated with the grant. </p>
    ///          <p>For example: <code>arn:aws:kms:us-east-2:444455556666:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///          </p>
    public let keyId: String?

    public init (
        grantId: String? = nil,
        grantToken: String? = nil,
        keyId: String? = nil
    )
    {
        self.grantId = grantId
        self.grantToken = grantToken
        self.keyId = keyId
    }
}

struct RetireGrantInputBody: Equatable {
    public let grantToken: String?
    public let keyId: String?
    public let grantId: String?
}

extension RetireGrantInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case grantId = "GrantId"
        case grantToken = "GrantToken"
        case keyId = "KeyId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grantToken)
        grantToken = grantTokenDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let grantIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grantId)
        grantId = grantIdDecoded
    }
}

extension RetireGrantOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RetireGrantOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGrantIdException" : self = .invalidGrantIdException(try InvalidGrantIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGrantTokenException" : self = .invalidGrantTokenException(try InvalidGrantTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RetireGrantOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case invalidArnException(InvalidArnException)
    case invalidGrantIdException(InvalidGrantIdException)
    case invalidGrantTokenException(InvalidGrantTokenException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RetireGrantOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RetireGrantOutputResponse()"}
}

extension RetireGrantOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RetireGrantOutputResponse: Equatable {

    public init() {}
}

struct RetireGrantOutputResponseBody: Equatable {
}

extension RetireGrantOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct RevokeGrantInputBodyMiddleware: Middleware {
    public let id: String = "RevokeGrantInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeGrantInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeGrantInput>
    public typealias MOutput = OperationOutput<RevokeGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeGrantOutputError>
}

extension RevokeGrantInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevokeGrantInput(grantId: \(String(describing: grantId)), keyId: \(String(describing: keyId)))"}
}

extension RevokeGrantInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grantId = "GrantId"
        case keyId = "KeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantId = grantId {
            try encodeContainer.encode(grantId, forKey: .grantId)
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
    }
}

public struct RevokeGrantInputHeadersMiddleware: Middleware {
    public let id: String = "RevokeGrantInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeGrantInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeGrantInput>
    public typealias MOutput = OperationOutput<RevokeGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeGrantOutputError>
}

public struct RevokeGrantInputQueryItemMiddleware: Middleware {
    public let id: String = "RevokeGrantInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeGrantInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeGrantInput>
    public typealias MOutput = OperationOutput<RevokeGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeGrantOutputError>
}

public struct RevokeGrantInput: Equatable {
    /// <p>Identifier of the grant to be revoked.</p>
    public let grantId: String?
    /// <p>A unique identifier for the customer master key associated with the grant.</p>
    ///
    ///          <p>Specify the key ID or the Amazon Resource Name (ARN) of the CMK. To specify a CMK in a
    /// different AWS account, you must use the key ARN.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
    public let keyId: String?

    public init (
        grantId: String? = nil,
        keyId: String? = nil
    )
    {
        self.grantId = grantId
        self.keyId = keyId
    }
}

struct RevokeGrantInputBody: Equatable {
    public let keyId: String?
    public let grantId: String?
}

extension RevokeGrantInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case grantId = "GrantId"
        case keyId = "KeyId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let grantIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grantId)
        grantId = grantIdDecoded
    }
}

extension RevokeGrantOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RevokeGrantOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGrantIdException" : self = .invalidGrantIdException(try InvalidGrantIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RevokeGrantOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case invalidArnException(InvalidArnException)
    case invalidGrantIdException(InvalidGrantIdException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RevokeGrantOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevokeGrantOutputResponse()"}
}

extension RevokeGrantOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RevokeGrantOutputResponse: Equatable {

    public init() {}
}

struct RevokeGrantOutputResponseBody: Equatable {
}

extension RevokeGrantOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct ScheduleKeyDeletionInputBodyMiddleware: Middleware {
    public let id: String = "ScheduleKeyDeletionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ScheduleKeyDeletionInput>,
                  next: H) -> Swift.Result<OperationOutput<ScheduleKeyDeletionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ScheduleKeyDeletionInput>
    public typealias MOutput = OperationOutput<ScheduleKeyDeletionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ScheduleKeyDeletionOutputError>
}

extension ScheduleKeyDeletionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScheduleKeyDeletionInput(keyId: \(String(describing: keyId)), pendingWindowInDays: \(String(describing: pendingWindowInDays)))"}
}

extension ScheduleKeyDeletionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
        case pendingWindowInDays = "PendingWindowInDays"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let pendingWindowInDays = pendingWindowInDays {
            try encodeContainer.encode(pendingWindowInDays, forKey: .pendingWindowInDays)
        }
    }
}

public struct ScheduleKeyDeletionInputHeadersMiddleware: Middleware {
    public let id: String = "ScheduleKeyDeletionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ScheduleKeyDeletionInput>,
                  next: H) -> Swift.Result<OperationOutput<ScheduleKeyDeletionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ScheduleKeyDeletionInput>
    public typealias MOutput = OperationOutput<ScheduleKeyDeletionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ScheduleKeyDeletionOutputError>
}

public struct ScheduleKeyDeletionInputQueryItemMiddleware: Middleware {
    public let id: String = "ScheduleKeyDeletionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ScheduleKeyDeletionInput>,
                  next: H) -> Swift.Result<OperationOutput<ScheduleKeyDeletionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ScheduleKeyDeletionInput>
    public typealias MOutput = OperationOutput<ScheduleKeyDeletionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ScheduleKeyDeletionOutputError>
}

public struct ScheduleKeyDeletionInput: Equatable {
    /// <p>The unique identifier of the customer master key (CMK) to delete.</p>
    ///
    ///          <p>Specify the key ID or the Amazon Resource Name (ARN) of the CMK.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
    public let keyId: String?
    /// <p>The waiting period, specified in number of days. After the waiting period ends, AWS KMS
    ///       deletes the customer master key (CMK).</p>
    ///          <p>This value is optional. If you include a value, it must be between 7 and 30, inclusive. If
    ///       you do not include a value, it defaults to 30.</p>
    public let pendingWindowInDays: Int?

    public init (
        keyId: String? = nil,
        pendingWindowInDays: Int? = nil
    )
    {
        self.keyId = keyId
        self.pendingWindowInDays = pendingWindowInDays
    }
}

struct ScheduleKeyDeletionInputBody: Equatable {
    public let keyId: String?
    public let pendingWindowInDays: Int?
}

extension ScheduleKeyDeletionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
        case pendingWindowInDays = "PendingWindowInDays"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let pendingWindowInDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .pendingWindowInDays)
        pendingWindowInDays = pendingWindowInDaysDecoded
    }
}

extension ScheduleKeyDeletionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ScheduleKeyDeletionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ScheduleKeyDeletionOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case invalidArnException(InvalidArnException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ScheduleKeyDeletionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScheduleKeyDeletionOutputResponse(deletionDate: \(String(describing: deletionDate)), keyId: \(String(describing: keyId)))"}
}

extension ScheduleKeyDeletionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ScheduleKeyDeletionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deletionDate = output.deletionDate
            self.keyId = output.keyId
        } else {
            self.deletionDate = nil
            self.keyId = nil
        }
    }
}

public struct ScheduleKeyDeletionOutputResponse: Equatable {
    /// <p>The date and time after which AWS KMS deletes the customer master key (CMK).</p>
    public let deletionDate: Date?
    /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN">key ARN</a>) of the CMK whose deletion is scheduled.</p>
    public let keyId: String?

    public init (
        deletionDate: Date? = nil,
        keyId: String? = nil
    )
    {
        self.deletionDate = deletionDate
        self.keyId = keyId
    }
}

struct ScheduleKeyDeletionOutputResponseBody: Equatable {
    public let keyId: String?
    public let deletionDate: Date?
}

extension ScheduleKeyDeletionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deletionDate = "DeletionDate"
        case keyId = "KeyId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let deletionDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .deletionDate)
        deletionDate = deletionDateDecoded
    }
}

public struct SignInputBodyMiddleware: Middleware {
    public let id: String = "SignInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SignInput>,
                  next: H) -> Swift.Result<OperationOutput<SignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SignInput>
    public typealias MOutput = OperationOutput<SignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SignOutputError>
}

extension SignInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SignInput(grantTokens: \(String(describing: grantTokens)), keyId: \(String(describing: keyId)), message: \(String(describing: message)), messageType: \(String(describing: messageType)), signingAlgorithm: \(String(describing: signingAlgorithm)))"}
}

extension SignInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grantTokens = "GrantTokens"
        case keyId = "KeyId"
        case message = "Message"
        case messageType = "MessageType"
        case signingAlgorithm = "SigningAlgorithm"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantTokens = grantTokens {
            var grantTokensContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantTokens)
            for granttokenlist0 in grantTokens {
                try grantTokensContainer.encode(granttokenlist0)
            }
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let message = message {
            try encodeContainer.encode(message.base64EncodedString(), forKey: .message)
        }
        if let messageType = messageType {
            try encodeContainer.encode(messageType.rawValue, forKey: .messageType)
        }
        if let signingAlgorithm = signingAlgorithm {
            try encodeContainer.encode(signingAlgorithm.rawValue, forKey: .signingAlgorithm)
        }
    }
}

public struct SignInputHeadersMiddleware: Middleware {
    public let id: String = "SignInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SignInput>,
                  next: H) -> Swift.Result<OperationOutput<SignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SignInput>
    public typealias MOutput = OperationOutput<SignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SignOutputError>
}

public struct SignInputQueryItemMiddleware: Middleware {
    public let id: String = "SignInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SignInput>,
                  next: H) -> Swift.Result<OperationOutput<SignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SignInput>
    public typealias MOutput = OperationOutput<SignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SignOutputError>
}

public struct SignInput: Equatable {
    /// <p>A list of grant tokens.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#grant_token">Grant Tokens</a> in the
    ///     <i>AWS Key Management Service Developer Guide</i>.</p>
    public let grantTokens: [String]?
    /// <p>Identifies an asymmetric CMK. AWS KMS uses the private key in the asymmetric CMK to sign the
    ///       message. The <code>KeyUsage</code> type of the CMK must be <code>SIGN_VERIFY</code>. To find
    ///       the <code>KeyUsage</code> of a CMK, use the <a>DescribeKey</a> operation.</p>
    ///
    ///          <p>To specify a CMK, use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. When using an alias name, prefix it with <code>"alias/"</code>. To specify a CMK in a different AWS account, you must use the key ARN or alias ARN.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Alias name: <code>alias/ExampleAlias</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Alias ARN: <code>arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>. To get the alias name and alias ARN, use <a>ListAliases</a>.</p>
    public let keyId: String?
    /// <p>Specifies the message or message digest to sign. Messages can be 0-4096 bytes. To sign a
    ///       larger message, provide the message digest.</p>
    ///          <p>If you provide a message, AWS KMS generates a hash digest of the message and then signs
    ///       it.</p>
    public let message: Data?
    /// <p>Tells AWS KMS whether the value of the <code>Message</code> parameter is a message or
    ///       message digest. The default value, RAW, indicates a message. To indicate a message digest,
    ///       enter <code>DIGEST</code>.</p>
    public let messageType: MessageType?
    /// <p>Specifies the signing algorithm to use when signing the message. </p>
    ///          <p>Choose an algorithm that is compatible with the type and size of the specified asymmetric
    ///       CMK.</p>
    public let signingAlgorithm: SigningAlgorithmSpec?

    public init (
        grantTokens: [String]? = nil,
        keyId: String? = nil,
        message: Data? = nil,
        messageType: MessageType? = nil,
        signingAlgorithm: SigningAlgorithmSpec? = nil
    )
    {
        self.grantTokens = grantTokens
        self.keyId = keyId
        self.message = message
        self.messageType = messageType
        self.signingAlgorithm = signingAlgorithm
    }
}

struct SignInputBody: Equatable {
    public let keyId: String?
    public let message: Data?
    public let messageType: MessageType?
    public let grantTokens: [String]?
    public let signingAlgorithm: SigningAlgorithmSpec?
}

extension SignInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case grantTokens = "GrantTokens"
        case keyId = "KeyId"
        case message = "Message"
        case messageType = "MessageType"
        case signingAlgorithm = "SigningAlgorithm"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .message)
        message = messageDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let grantTokensContainer = try containerValues.decodeIfPresent([String?].self, forKey: .grantTokens)
        var grantTokensDecoded0:[String]? = nil
        if let grantTokensContainer = grantTokensContainer {
            grantTokensDecoded0 = [String]()
            for string0 in grantTokensContainer {
                if let string0 = string0 {
                    grantTokensDecoded0?.append(string0)
                }
            }
        }
        grantTokens = grantTokensDecoded0
        let signingAlgorithmDecoded = try containerValues.decodeIfPresent(SigningAlgorithmSpec.self, forKey: .signingAlgorithm)
        signingAlgorithm = signingAlgorithmDecoded
    }
}

extension SignOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SignOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledException" : self = .disabledException(try DisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGrantTokenException" : self = .invalidGrantTokenException(try InvalidGrantTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKeyUsageException" : self = .invalidKeyUsageException(try InvalidKeyUsageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KeyUnavailableException" : self = .keyUnavailableException(try KeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SignOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case disabledException(DisabledException)
    case invalidGrantTokenException(InvalidGrantTokenException)
    case invalidKeyUsageException(InvalidKeyUsageException)
    case keyUnavailableException(KeyUnavailableException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SignOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SignOutputResponse(keyId: \(String(describing: keyId)), signature: \(String(describing: signature)), signingAlgorithm: \(String(describing: signingAlgorithm)))"}
}

extension SignOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SignOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.keyId = output.keyId
            self.signature = output.signature
            self.signingAlgorithm = output.signingAlgorithm
        } else {
            self.keyId = nil
            self.signature = nil
            self.signingAlgorithm = nil
        }
    }
}

public struct SignOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN">key ARN</a>) of the asymmetric CMK that was used to sign the
    ///       message.</p>
    public let keyId: String?
    /// <p>The cryptographic signature that was generated for the message. </p>
    ///          <ul>
    ///             <li>
    ///                <p>When used with the supported RSA signing algorithms, the encoding of this value is
    ///           defined by <a href="https://tools.ietf.org/html/rfc8017">PKCS #1 in RFC
    ///           8017</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>When used with the <code>ECDSA_SHA_256</code>, <code>ECDSA_SHA_384</code>, or
    ///             <code>ECDSA_SHA_512</code> signing algorithms, this value is a DER-encoded object as
    ///           defined by ANS X9.62–2005 and <a href="https://tools.ietf.org/html/rfc3279#section-2.2.3">RFC 3279 Section 2.2.3</a>.
    ///           This is the most commonly used signature format and is appropriate for most uses.
    ///           </p>
    ///             </li>
    ///          </ul>
    ///          <p>When you use the HTTP API or the AWS CLI, the value is Base64-encoded. Otherwise, it is not Base64-encoded.</p>
    public let signature: Data?
    /// <p>The signing algorithm that was used to sign the message.</p>
    public let signingAlgorithm: SigningAlgorithmSpec?

    public init (
        keyId: String? = nil,
        signature: Data? = nil,
        signingAlgorithm: SigningAlgorithmSpec? = nil
    )
    {
        self.keyId = keyId
        self.signature = signature
        self.signingAlgorithm = signingAlgorithm
    }
}

struct SignOutputResponseBody: Equatable {
    public let keyId: String?
    public let signature: Data?
    public let signingAlgorithm: SigningAlgorithmSpec?
}

extension SignOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
        case signature = "Signature"
        case signingAlgorithm = "SigningAlgorithm"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let signatureDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .signature)
        signature = signatureDecoded
        let signingAlgorithmDecoded = try containerValues.decodeIfPresent(SigningAlgorithmSpec.self, forKey: .signingAlgorithm)
        signingAlgorithm = signingAlgorithmDecoded
    }
}

public enum SigningAlgorithmSpec {
    case ecdsaSha256
    case ecdsaSha384
    case ecdsaSha512
    case rsassaPkcs1V15Sha256
    case rsassaPkcs1V15Sha384
    case rsassaPkcs1V15Sha512
    case rsassaPssSha256
    case rsassaPssSha384
    case rsassaPssSha512
    case sdkUnknown(String)
}

extension SigningAlgorithmSpec : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SigningAlgorithmSpec] {
        return [
            .ecdsaSha256,
            .ecdsaSha384,
            .ecdsaSha512,
            .rsassaPkcs1V15Sha256,
            .rsassaPkcs1V15Sha384,
            .rsassaPkcs1V15Sha512,
            .rsassaPssSha256,
            .rsassaPssSha384,
            .rsassaPssSha512,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ecdsaSha256: return "ECDSA_SHA_256"
        case .ecdsaSha384: return "ECDSA_SHA_384"
        case .ecdsaSha512: return "ECDSA_SHA_512"
        case .rsassaPkcs1V15Sha256: return "RSASSA_PKCS1_V1_5_SHA_256"
        case .rsassaPkcs1V15Sha384: return "RSASSA_PKCS1_V1_5_SHA_384"
        case .rsassaPkcs1V15Sha512: return "RSASSA_PKCS1_V1_5_SHA_512"
        case .rsassaPssSha256: return "RSASSA_PSS_SHA_256"
        case .rsassaPssSha384: return "RSASSA_PSS_SHA_384"
        case .rsassaPssSha512: return "RSASSA_PSS_SHA_512"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SigningAlgorithmSpec(rawValue: rawValue) ?? SigningAlgorithmSpec.sdkUnknown(rawValue)
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tagKey = "TagKey"
        case tagValue = "TagValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKey = tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
        if let tagValue = tagValue {
            try encodeContainer.encode(tagValue, forKey: .tagValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let tagValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tagValue)
        tagValue = tagValueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(tagKey: \(String(describing: tagKey)), tagValue: \(String(describing: tagValue)))"}
}

/// <p>A key-value pair. A tag consists of a tag key and a tag value. Tag keys and tag values are
///       both required, but tag values can be empty (null) strings.</p>
///          <p>For information about the rules that apply to tag keys and tag values, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/allocation-tag-restrictions.html">User-Defined Tag Restrictions</a> in the <i>AWS Billing and Cost Management User
///         Guide</i>.</p>
public struct Tag: Equatable {
    /// <p>The key of the tag.</p>
    public let tagKey: String?
    /// <p>The value of the tag.</p>
    public let tagValue: String?

    public init (
        tagKey: String? = nil,
        tagValue: String? = nil
    )
    {
        self.tagKey = tagKey
        self.tagValue = tagValue
    }
}

extension TagException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagException(message: \(String(describing: message)))"}
}

extension TagException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TagExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because one or more tags are not valid.</p>
public struct TagException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TagExceptionBody: Equatable {
    public let message: String?
}

extension TagExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(keyId: \(String(describing: keyId)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>Identifies a customer managed CMK in the account and Region.</p>
    ///          <p>Specify the key ID or the Amazon Resource Name (ARN) of the CMK.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
    public let keyId: String?
    /// <p>One or more tags. </p>
    ///          <p>Each tag consists of a tag key and a tag value. The tag value can be an empty (null)
    ///       string. </p>
    ///          <p>You cannot have more than one tag on a CMK with the same tag key. If you specify an
    ///       existing tag key with a different tag value, AWS KMS replaces the current tag value with the
    ///       specified one.</p>
    public let tags: [Tag]?

    public init (
        keyId: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.keyId = keyId
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let keyId: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagException" : self = .tagException(try TagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case invalidArnException(InvalidArnException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tagException(TagException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UnsupportedOperationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedOperationException(message: \(String(describing: message)))"}
}

extension UnsupportedOperationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedOperationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because a specified parameter is not supported or a specified
///       resource is not valid for this operation.</p>
public struct UnsupportedOperationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOperationExceptionBody: Equatable {
    public let message: String?
}

extension UnsupportedOperationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(keyId: \(String(describing: keyId)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>Identifies the CMK from which you are removing tags.</p>
    ///
    ///          <p>Specify the key ID or the Amazon Resource Name (ARN) of the CMK.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
    public let keyId: String?
    /// <p>One or more tag keys. Specify only the tag keys, not the tag values.</p>
    public let tagKeys: [String]?

    public init (
        keyId: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.keyId = keyId
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let keyId: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagException" : self = .tagException(try TagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case invalidArnException(InvalidArnException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case notFoundException(NotFoundException)
    case tagException(TagException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateAliasInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAliasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAliasInput>
    public typealias MOutput = OperationOutput<UpdateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAliasOutputError>
}

extension UpdateAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAliasInput(aliasName: \(String(describing: aliasName)), targetKeyId: \(String(describing: targetKeyId)))"}
}

extension UpdateAliasInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aliasName = "AliasName"
        case targetKeyId = "TargetKeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasName = aliasName {
            try encodeContainer.encode(aliasName, forKey: .aliasName)
        }
        if let targetKeyId = targetKeyId {
            try encodeContainer.encode(targetKeyId, forKey: .targetKeyId)
        }
    }
}

public struct UpdateAliasInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAliasInput>
    public typealias MOutput = OperationOutput<UpdateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAliasOutputError>
}

public struct UpdateAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAliasInput>
    public typealias MOutput = OperationOutput<UpdateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAliasOutputError>
}

public struct UpdateAliasInput: Equatable {
    /// <p>Identifies the alias that is changing its CMK. This value must begin with
    ///         <code>alias/</code> followed by the alias name, such as <code>alias/ExampleAlias</code>. You
    ///       cannot use UpdateAlias to change the alias name.</p>
    public let aliasName: String?
    /// <p>Identifies the <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#customer-cmk">customer managed CMK</a> to associate with the alias. You don't have permission
    ///       to associate an alias with an <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-managed-cmk">AWS managed CMK</a>.</p>
    ///          <p>The CMK must be in the same AWS account and Region as the alias. Also, the new target CMK
    ///       must be the same type as the current target CMK (both symmetric or both asymmetric) and they
    ///       must have the same key usage. </p>
    ///          <p>Specify the key ID or the Amazon Resource Name (ARN) of the CMK.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
    ///          <p>To verify that the alias
    ///       is mapped to the correct CMK, use <a>ListAliases</a>.</p>
    public let targetKeyId: String?

    public init (
        aliasName: String? = nil,
        targetKeyId: String? = nil
    )
    {
        self.aliasName = aliasName
        self.targetKeyId = targetKeyId
    }
}

struct UpdateAliasInputBody: Equatable {
    public let aliasName: String?
    public let targetKeyId: String?
}

extension UpdateAliasInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aliasName = "AliasName"
        case targetKeyId = "TargetKeyId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aliasName)
        aliasName = aliasNameDecoded
        let targetKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetKeyId)
        targetKeyId = targetKeyIdDecoded
    }
}

extension UpdateAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAliasOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAliasOutputResponse()"}
}

extension UpdateAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateAliasOutputResponse: Equatable {

    public init() {}
}

struct UpdateAliasOutputResponseBody: Equatable {
}

extension UpdateAliasOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateCustomKeyStoreInputBodyMiddleware: Middleware {
    public let id: String = "UpdateCustomKeyStoreInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCustomKeyStoreInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCustomKeyStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCustomKeyStoreInput>
    public typealias MOutput = OperationOutput<UpdateCustomKeyStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCustomKeyStoreOutputError>
}

extension UpdateCustomKeyStoreInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCustomKeyStoreInput(cloudHsmClusterId: \(String(describing: cloudHsmClusterId)), customKeyStoreId: \(String(describing: customKeyStoreId)), keyStorePassword: \(String(describing: keyStorePassword)), newCustomKeyStoreName: \(String(describing: newCustomKeyStoreName)))"}
}

extension UpdateCustomKeyStoreInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudHsmClusterId = "CloudHsmClusterId"
        case customKeyStoreId = "CustomKeyStoreId"
        case keyStorePassword = "KeyStorePassword"
        case newCustomKeyStoreName = "NewCustomKeyStoreName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudHsmClusterId = cloudHsmClusterId {
            try encodeContainer.encode(cloudHsmClusterId, forKey: .cloudHsmClusterId)
        }
        if let customKeyStoreId = customKeyStoreId {
            try encodeContainer.encode(customKeyStoreId, forKey: .customKeyStoreId)
        }
        if let keyStorePassword = keyStorePassword {
            try encodeContainer.encode(keyStorePassword, forKey: .keyStorePassword)
        }
        if let newCustomKeyStoreName = newCustomKeyStoreName {
            try encodeContainer.encode(newCustomKeyStoreName, forKey: .newCustomKeyStoreName)
        }
    }
}

public struct UpdateCustomKeyStoreInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateCustomKeyStoreInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCustomKeyStoreInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCustomKeyStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCustomKeyStoreInput>
    public typealias MOutput = OperationOutput<UpdateCustomKeyStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCustomKeyStoreOutputError>
}

public struct UpdateCustomKeyStoreInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateCustomKeyStoreInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCustomKeyStoreInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCustomKeyStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCustomKeyStoreInput>
    public typealias MOutput = OperationOutput<UpdateCustomKeyStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCustomKeyStoreOutputError>
}

public struct UpdateCustomKeyStoreInput: Equatable {
    /// <p>Associates the custom key store with a related AWS CloudHSM cluster. </p>
    ///          <p>Enter the cluster ID of the cluster that you used to create the custom key store or a
    ///       cluster that shares a backup history and has the same cluster certificate as the original
    ///       cluster. You cannot use this parameter to associate a custom key store with an unrelated
    ///       cluster. In addition, the replacement cluster must <a href="https://docs.aws.amazon.com/kms/latest/developerguide/create-keystore.html#before-keystore">fulfill the requirements</a> for
    ///       a cluster associated with a custom key store. To view the cluster certificate of a cluster,
    ///       use the <a href="https://docs.aws.amazon.com/cloudhsm/latest/APIReference/API_DescribeClusters.html">DescribeClusters</a> operation.</p>
    public let cloudHsmClusterId: String?
    /// <p>Identifies the custom key store that you want to update. Enter the ID of the custom key
    ///       store. To find the ID of a custom key store, use the <a>DescribeCustomKeyStores</a> operation.</p>
    public let customKeyStoreId: String?
    /// <p>Enter the current password of the <code>kmsuser</code> crypto user (CU) in the AWS CloudHSM
    ///       cluster that is associated with the custom key store.</p>
    ///          <p>This parameter tells AWS KMS the current password of the <code>kmsuser</code> crypto user
    ///       (CU). It does not set or change the password of any users in the AWS CloudHSM cluster.</p>
    public let keyStorePassword: String?
    /// <p>Changes the friendly name of the custom key store to the value that you specify. The
    ///       custom key store name must be unique in the AWS account.</p>
    public let newCustomKeyStoreName: String?

    public init (
        cloudHsmClusterId: String? = nil,
        customKeyStoreId: String? = nil,
        keyStorePassword: String? = nil,
        newCustomKeyStoreName: String? = nil
    )
    {
        self.cloudHsmClusterId = cloudHsmClusterId
        self.customKeyStoreId = customKeyStoreId
        self.keyStorePassword = keyStorePassword
        self.newCustomKeyStoreName = newCustomKeyStoreName
    }
}

struct UpdateCustomKeyStoreInputBody: Equatable {
    public let customKeyStoreId: String?
    public let newCustomKeyStoreName: String?
    public let keyStorePassword: String?
    public let cloudHsmClusterId: String?
}

extension UpdateCustomKeyStoreInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cloudHsmClusterId = "CloudHsmClusterId"
        case customKeyStoreId = "CustomKeyStoreId"
        case keyStorePassword = "KeyStorePassword"
        case newCustomKeyStoreName = "NewCustomKeyStoreName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customKeyStoreIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customKeyStoreId)
        customKeyStoreId = customKeyStoreIdDecoded
        let newCustomKeyStoreNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .newCustomKeyStoreName)
        newCustomKeyStoreName = newCustomKeyStoreNameDecoded
        let keyStorePasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyStorePassword)
        keyStorePassword = keyStorePasswordDecoded
        let cloudHsmClusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudHsmClusterId)
        cloudHsmClusterId = cloudHsmClusterIdDecoded
    }
}

extension UpdateCustomKeyStoreOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCustomKeyStoreOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudHsmClusterInvalidConfigurationException" : self = .cloudHsmClusterInvalidConfigurationException(try CloudHsmClusterInvalidConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmClusterNotActiveException" : self = .cloudHsmClusterNotActiveException(try CloudHsmClusterNotActiveException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmClusterNotFoundException" : self = .cloudHsmClusterNotFoundException(try CloudHsmClusterNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmClusterNotRelatedException" : self = .cloudHsmClusterNotRelatedException(try CloudHsmClusterNotRelatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CustomKeyStoreInvalidStateException" : self = .customKeyStoreInvalidStateException(try CustomKeyStoreInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CustomKeyStoreNameInUseException" : self = .customKeyStoreNameInUseException(try CustomKeyStoreNameInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CustomKeyStoreNotFoundException" : self = .customKeyStoreNotFoundException(try CustomKeyStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCustomKeyStoreOutputError: Equatable {
    case cloudHsmClusterInvalidConfigurationException(CloudHsmClusterInvalidConfigurationException)
    case cloudHsmClusterNotActiveException(CloudHsmClusterNotActiveException)
    case cloudHsmClusterNotFoundException(CloudHsmClusterNotFoundException)
    case cloudHsmClusterNotRelatedException(CloudHsmClusterNotRelatedException)
    case customKeyStoreInvalidStateException(CustomKeyStoreInvalidStateException)
    case customKeyStoreNameInUseException(CustomKeyStoreNameInUseException)
    case customKeyStoreNotFoundException(CustomKeyStoreNotFoundException)
    case kMSInternalException(KMSInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCustomKeyStoreOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCustomKeyStoreOutputResponse()"}
}

extension UpdateCustomKeyStoreOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateCustomKeyStoreOutputResponse: Equatable {

    public init() {}
}

struct UpdateCustomKeyStoreOutputResponseBody: Equatable {
}

extension UpdateCustomKeyStoreOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateKeyDescriptionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateKeyDescriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateKeyDescriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateKeyDescriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateKeyDescriptionInput>
    public typealias MOutput = OperationOutput<UpdateKeyDescriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateKeyDescriptionOutputError>
}

extension UpdateKeyDescriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateKeyDescriptionInput(description: \(String(describing: description)), keyId: \(String(describing: keyId)))"}
}

extension UpdateKeyDescriptionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case keyId = "KeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
    }
}

public struct UpdateKeyDescriptionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateKeyDescriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateKeyDescriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateKeyDescriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateKeyDescriptionInput>
    public typealias MOutput = OperationOutput<UpdateKeyDescriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateKeyDescriptionOutputError>
}

public struct UpdateKeyDescriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateKeyDescriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateKeyDescriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateKeyDescriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateKeyDescriptionInput>
    public typealias MOutput = OperationOutput<UpdateKeyDescriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateKeyDescriptionOutputError>
}

public struct UpdateKeyDescriptionInput: Equatable {
    /// <p>New description for the CMK.</p>
    public let description: String?
    /// <p>A unique identifier for the customer master key (CMK).</p>
    ///          <p>Specify the key ID or the Amazon Resource Name (ARN) of the CMK.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
    public let keyId: String?

    public init (
        description: String? = nil,
        keyId: String? = nil
    )
    {
        self.description = description
        self.keyId = keyId
    }
}

struct UpdateKeyDescriptionInputBody: Equatable {
    public let keyId: String?
    public let description: String?
}

extension UpdateKeyDescriptionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case keyId = "KeyId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateKeyDescriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateKeyDescriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateKeyDescriptionOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case invalidArnException(InvalidArnException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateKeyDescriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateKeyDescriptionOutputResponse()"}
}

extension UpdateKeyDescriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateKeyDescriptionOutputResponse: Equatable {

    public init() {}
}

struct UpdateKeyDescriptionOutputResponseBody: Equatable {
}

extension UpdateKeyDescriptionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct VerifyInputBodyMiddleware: Middleware {
    public let id: String = "VerifyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<VerifyInput>,
                  next: H) -> Swift.Result<OperationOutput<VerifyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<VerifyInput>
    public typealias MOutput = OperationOutput<VerifyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<VerifyOutputError>
}

extension VerifyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VerifyInput(grantTokens: \(String(describing: grantTokens)), keyId: \(String(describing: keyId)), message: \(String(describing: message)), messageType: \(String(describing: messageType)), signature: \(String(describing: signature)), signingAlgorithm: \(String(describing: signingAlgorithm)))"}
}

extension VerifyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grantTokens = "GrantTokens"
        case keyId = "KeyId"
        case message = "Message"
        case messageType = "MessageType"
        case signature = "Signature"
        case signingAlgorithm = "SigningAlgorithm"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantTokens = grantTokens {
            var grantTokensContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantTokens)
            for granttokenlist0 in grantTokens {
                try grantTokensContainer.encode(granttokenlist0)
            }
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let message = message {
            try encodeContainer.encode(message.base64EncodedString(), forKey: .message)
        }
        if let messageType = messageType {
            try encodeContainer.encode(messageType.rawValue, forKey: .messageType)
        }
        if let signature = signature {
            try encodeContainer.encode(signature.base64EncodedString(), forKey: .signature)
        }
        if let signingAlgorithm = signingAlgorithm {
            try encodeContainer.encode(signingAlgorithm.rawValue, forKey: .signingAlgorithm)
        }
    }
}

public struct VerifyInputHeadersMiddleware: Middleware {
    public let id: String = "VerifyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<VerifyInput>,
                  next: H) -> Swift.Result<OperationOutput<VerifyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<VerifyInput>
    public typealias MOutput = OperationOutput<VerifyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<VerifyOutputError>
}

public struct VerifyInputQueryItemMiddleware: Middleware {
    public let id: String = "VerifyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<VerifyInput>,
                  next: H) -> Swift.Result<OperationOutput<VerifyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<VerifyInput>
    public typealias MOutput = OperationOutput<VerifyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<VerifyOutputError>
}

public struct VerifyInput: Equatable {
    /// <p>A list of grant tokens.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#grant_token">Grant Tokens</a> in the
    ///     <i>AWS Key Management Service Developer Guide</i>.</p>
    public let grantTokens: [String]?
    /// <p>Identifies the asymmetric CMK that will be used to verify the signature. This must be the
    ///       same CMK that was used to generate the signature. If you specify a different CMK, the
    ///       signature verification fails.</p>
    ///
    ///          <p>To specify a CMK, use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. When using an alias name, prefix it with <code>"alias/"</code>. To specify a CMK in a different AWS account, you must use the key ARN or alias ARN.</p>
    ///          <p>For example:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Alias name: <code>alias/ExampleAlias</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Alias ARN: <code>arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the key ID and key ARN for a CMK, use <a>ListKeys</a> or <a>DescribeKey</a>. To get the alias name and alias ARN, use <a>ListAliases</a>.</p>
    public let keyId: String?
    /// <p>Specifies the message that was signed. You can submit a raw message of up to 4096 bytes,
    ///       or a hash digest of the message. If you submit a digest, use the <code>MessageType</code>
    ///       parameter with a value of <code>DIGEST</code>.</p>
    ///          <p>If the message specified here is different from the message that was signed, the signature
    ///       verification fails. A message and its hash digest are considered to be the same
    ///       message.</p>
    public let message: Data?
    /// <p>Tells AWS KMS whether the value of the <code>Message</code> parameter is a message or
    ///       message digest. The default value, RAW, indicates a message. To indicate a message digest,
    ///       enter <code>DIGEST</code>.</p>
    ///          <important>
    ///             <p>Use the <code>DIGEST</code> value only when the value of the <code>Message</code>
    ///         parameter is a message digest. If you use the <code>DIGEST</code> value with a raw message,
    ///         the security of the verification operation can be compromised.</p>
    ///          </important>
    public let messageType: MessageType?
    /// <p>The signature that the <code>Sign</code> operation generated.</p>
    public let signature: Data?
    /// <p>The signing algorithm that was used to sign the message. If you submit a different
    ///       algorithm, the signature verification fails.</p>
    public let signingAlgorithm: SigningAlgorithmSpec?

    public init (
        grantTokens: [String]? = nil,
        keyId: String? = nil,
        message: Data? = nil,
        messageType: MessageType? = nil,
        signature: Data? = nil,
        signingAlgorithm: SigningAlgorithmSpec? = nil
    )
    {
        self.grantTokens = grantTokens
        self.keyId = keyId
        self.message = message
        self.messageType = messageType
        self.signature = signature
        self.signingAlgorithm = signingAlgorithm
    }
}

struct VerifyInputBody: Equatable {
    public let keyId: String?
    public let message: Data?
    public let messageType: MessageType?
    public let signature: Data?
    public let signingAlgorithm: SigningAlgorithmSpec?
    public let grantTokens: [String]?
}

extension VerifyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case grantTokens = "GrantTokens"
        case keyId = "KeyId"
        case message = "Message"
        case messageType = "MessageType"
        case signature = "Signature"
        case signingAlgorithm = "SigningAlgorithm"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .message)
        message = messageDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let signatureDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .signature)
        signature = signatureDecoded
        let signingAlgorithmDecoded = try containerValues.decodeIfPresent(SigningAlgorithmSpec.self, forKey: .signingAlgorithm)
        signingAlgorithm = signingAlgorithmDecoded
        let grantTokensContainer = try containerValues.decodeIfPresent([String?].self, forKey: .grantTokens)
        var grantTokensDecoded0:[String]? = nil
        if let grantTokensContainer = grantTokensContainer {
            grantTokensDecoded0 = [String]()
            for string0 in grantTokensContainer {
                if let string0 = string0 {
                    grantTokensDecoded0?.append(string0)
                }
            }
        }
        grantTokens = grantTokensDecoded0
    }
}

extension VerifyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension VerifyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyTimeoutException" : self = .dependencyTimeoutException(try DependencyTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledException" : self = .disabledException(try DisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGrantTokenException" : self = .invalidGrantTokenException(try InvalidGrantTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKeyUsageException" : self = .invalidKeyUsageException(try InvalidKeyUsageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KeyUnavailableException" : self = .keyUnavailableException(try KeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInternalException" : self = .kMSInternalException(try KMSInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidSignatureException" : self = .kMSInvalidSignatureException(try KMSInvalidSignatureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum VerifyOutputError: Equatable {
    case dependencyTimeoutException(DependencyTimeoutException)
    case disabledException(DisabledException)
    case invalidGrantTokenException(InvalidGrantTokenException)
    case invalidKeyUsageException(InvalidKeyUsageException)
    case keyUnavailableException(KeyUnavailableException)
    case kMSInternalException(KMSInternalException)
    case kMSInvalidSignatureException(KMSInvalidSignatureException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension VerifyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VerifyOutputResponse(keyId: \(String(describing: keyId)), signatureValid: \(String(describing: signatureValid)), signingAlgorithm: \(String(describing: signingAlgorithm)))"}
}

extension VerifyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: VerifyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.keyId = output.keyId
            self.signatureValid = output.signatureValid
            self.signingAlgorithm = output.signingAlgorithm
        } else {
            self.keyId = nil
            self.signatureValid = false
            self.signingAlgorithm = nil
        }
    }
}

public struct VerifyOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN">key ARN</a>) of the asymmetric CMK that was used to verify the signature.</p>
    public let keyId: String?
    /// <p>A Boolean value that indicates whether the signature was verified. A value of
    ///         <code>True</code> indicates that the <code>Signature</code> was produced by signing the
    ///         <code>Message</code> with the specified <code>KeyID</code> and
    ///         <code>SigningAlgorithm.</code> If the signature is not verified, the <code>Verify</code>
    ///       operation fails with a <code>KMSInvalidSignatureException</code> exception. </p>
    public let signatureValid: Bool
    /// <p>The signing algorithm that was used to verify the signature.</p>
    public let signingAlgorithm: SigningAlgorithmSpec?

    public init (
        keyId: String? = nil,
        signatureValid: Bool = false,
        signingAlgorithm: SigningAlgorithmSpec? = nil
    )
    {
        self.keyId = keyId
        self.signatureValid = signatureValid
        self.signingAlgorithm = signingAlgorithm
    }
}

struct VerifyOutputResponseBody: Equatable {
    public let keyId: String?
    public let signatureValid: Bool
    public let signingAlgorithm: SigningAlgorithmSpec?
}

extension VerifyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
        case signatureValid = "SignatureValid"
        case signingAlgorithm = "SigningAlgorithm"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let signatureValidDecoded = try containerValues.decode(Bool.self, forKey: .signatureValid)
        signatureValid = signatureValidDecoded
        let signingAlgorithmDecoded = try containerValues.decodeIfPresent(SigningAlgorithmSpec.self, forKey: .signingAlgorithm)
        signingAlgorithm = signingAlgorithmDecoded
    }
}

public enum WrappingKeySpec {
    case rsa2048
    case sdkUnknown(String)
}

extension WrappingKeySpec : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WrappingKeySpec] {
        return [
            .rsa2048,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .rsa2048: return "RSA_2048"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WrappingKeySpec(rawValue: rawValue) ?? WrappingKeySpec.sdkUnknown(rawValue)
    }
}
