// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AcceptGrantInputBodyMiddleware: Middleware {
    public let id: String = "AcceptGrantInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptGrantInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptGrantInput>
    public typealias MOutput = OperationOutput<AcceptGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptGrantOutputError>
}

extension AcceptGrantInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptGrantInput(grantArn: \(String(describing: grantArn)))"}
}

extension AcceptGrantInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grantArn = "GrantArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantArn = grantArn {
            try encodeContainer.encode(grantArn, forKey: .grantArn)
        }
    }
}

public struct AcceptGrantInputHeadersMiddleware: Middleware {
    public let id: String = "AcceptGrantInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptGrantInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptGrantInput>
    public typealias MOutput = OperationOutput<AcceptGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptGrantOutputError>
}

public struct AcceptGrantInputQueryItemMiddleware: Middleware {
    public let id: String = "AcceptGrantInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptGrantInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptGrantInput>
    public typealias MOutput = OperationOutput<AcceptGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptGrantOutputError>
}

public struct AcceptGrantInput: Equatable {
    /// <p>Amazon Resource Name (ARN) of the grant.</p>
    public let grantArn: String?

    public init (
        grantArn: String? = nil
    )
    {
        self.grantArn = grantArn
    }
}

struct AcceptGrantInputBody: Equatable {
    public let grantArn: String?
}

extension AcceptGrantInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case grantArn = "GrantArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
    }
}

extension AcceptGrantOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptGrantOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcceptGrantOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptGrantOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptGrantOutputResponse(grantArn: \(String(describing: grantArn)), status: \(String(describing: status)), version: \(String(describing: version)))"}
}

extension AcceptGrantOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AcceptGrantOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.grantArn = output.grantArn
            self.status = output.status
            self.version = output.version
        } else {
            self.grantArn = nil
            self.status = nil
            self.version = nil
        }
    }
}

public struct AcceptGrantOutputResponse: Equatable {
    /// <p>Grant ARN.</p>
    public let grantArn: String?
    /// <p>Grant status.</p>
    public let status: GrantStatus?
    /// <p>Grant version.</p>
    public let version: String?

    public init (
        grantArn: String? = nil,
        status: GrantStatus? = nil,
        version: String? = nil
    )
    {
        self.grantArn = grantArn
        self.status = status
        self.version = version
    }
}

struct AcceptGrantOutputResponseBody: Equatable {
    public let grantArn: String?
    public let status: GrantStatus?
    public let version: String?
}

extension AcceptGrantOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case grantArn = "GrantArn"
        case status = "Status"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GrantStatus.self, forKey: .status)
        status = statusDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Access to resource denied.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum AllowedOperation {
    case checkoutBorrowLicense
    case checkoutLicense
    case checkInLicense
    case createGrant
    case createToken
    case extendConsumptionLicense
    case listPurchasedLicenses
    case sdkUnknown(String)
}

extension AllowedOperation : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AllowedOperation] {
        return [
            .checkoutBorrowLicense,
            .checkoutLicense,
            .checkInLicense,
            .createGrant,
            .createToken,
            .extendConsumptionLicense,
            .listPurchasedLicenses,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .checkoutBorrowLicense: return "CheckoutBorrowLicense"
        case .checkoutLicense: return "CheckoutLicense"
        case .checkInLicense: return "CheckInLicense"
        case .createGrant: return "CreateGrant"
        case .createToken: return "CreateToken"
        case .extendConsumptionLicense: return "ExtendConsumptionLicense"
        case .listPurchasedLicenses: return "ListPurchasedLicenses"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AllowedOperation(rawValue: rawValue) ?? AllowedOperation.sdkUnknown(rawValue)
    }
}

extension AuthorizationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthorizationException(message: \(String(describing: message)))"}
}

extension AuthorizationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AuthorizationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The AWS user account does not have permission to perform the action. Check the IAM
///          policy associated with this account.</p>
public struct AuthorizationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AuthorizationExceptionBody: Equatable {
    public let message: String?
}

extension AuthorizationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AutomatedDiscoveryInformation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lastRunTime = "LastRunTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastRunTime = lastRunTime {
            try encodeContainer.encode(lastRunTime.timeIntervalSince1970, forKey: .lastRunTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastRunTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastRunTime)
        lastRunTime = lastRunTimeDecoded
    }
}

extension AutomatedDiscoveryInformation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AutomatedDiscoveryInformation(lastRunTime: \(String(describing: lastRunTime)))"}
}

/// <p>Describes automated discovery.</p>
public struct AutomatedDiscoveryInformation: Equatable {
    /// <p>Time that automated discovery last ran.</p>
    public let lastRunTime: Date?

    public init (
        lastRunTime: Date? = nil
    )
    {
        self.lastRunTime = lastRunTime
    }
}

extension BorrowConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowEarlyCheckIn = "AllowEarlyCheckIn"
        case maxTimeToLiveInMinutes = "MaxTimeToLiveInMinutes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowEarlyCheckIn = allowEarlyCheckIn {
            try encodeContainer.encode(allowEarlyCheckIn, forKey: .allowEarlyCheckIn)
        }
        if let maxTimeToLiveInMinutes = maxTimeToLiveInMinutes {
            try encodeContainer.encode(maxTimeToLiveInMinutes, forKey: .maxTimeToLiveInMinutes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowEarlyCheckInDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowEarlyCheckIn)
        allowEarlyCheckIn = allowEarlyCheckInDecoded
        let maxTimeToLiveInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxTimeToLiveInMinutes)
        maxTimeToLiveInMinutes = maxTimeToLiveInMinutesDecoded
    }
}

extension BorrowConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BorrowConfiguration(allowEarlyCheckIn: \(String(describing: allowEarlyCheckIn)), maxTimeToLiveInMinutes: \(String(describing: maxTimeToLiveInMinutes)))"}
}

/// <p>Details about a borrow configuration.</p>
public struct BorrowConfiguration: Equatable {
    /// <p>Indicates whether early check-ins are allowed.</p>
    public let allowEarlyCheckIn: Bool?
    /// <p>Maximum time for the borrow configuration, in minutes.</p>
    public let maxTimeToLiveInMinutes: Int?

    public init (
        allowEarlyCheckIn: Bool? = nil,
        maxTimeToLiveInMinutes: Int? = nil
    )
    {
        self.allowEarlyCheckIn = allowEarlyCheckIn
        self.maxTimeToLiveInMinutes = maxTimeToLiveInMinutes
    }
}

public struct CheckInLicenseInputBodyMiddleware: Middleware {
    public let id: String = "CheckInLicenseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CheckInLicenseInput>,
                  next: H) -> Swift.Result<OperationOutput<CheckInLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CheckInLicenseInput>
    public typealias MOutput = OperationOutput<CheckInLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CheckInLicenseOutputError>
}

extension CheckInLicenseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CheckInLicenseInput(beneficiary: \(String(describing: beneficiary)), licenseConsumptionToken: \(String(describing: licenseConsumptionToken)))"}
}

extension CheckInLicenseInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case beneficiary = "Beneficiary"
        case licenseConsumptionToken = "LicenseConsumptionToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beneficiary = beneficiary {
            try encodeContainer.encode(beneficiary, forKey: .beneficiary)
        }
        if let licenseConsumptionToken = licenseConsumptionToken {
            try encodeContainer.encode(licenseConsumptionToken, forKey: .licenseConsumptionToken)
        }
    }
}

public struct CheckInLicenseInputHeadersMiddleware: Middleware {
    public let id: String = "CheckInLicenseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CheckInLicenseInput>,
                  next: H) -> Swift.Result<OperationOutput<CheckInLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CheckInLicenseInput>
    public typealias MOutput = OperationOutput<CheckInLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CheckInLicenseOutputError>
}

public struct CheckInLicenseInputQueryItemMiddleware: Middleware {
    public let id: String = "CheckInLicenseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CheckInLicenseInput>,
                  next: H) -> Swift.Result<OperationOutput<CheckInLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CheckInLicenseInput>
    public typealias MOutput = OperationOutput<CheckInLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CheckInLicenseOutputError>
}

public struct CheckInLicenseInput: Equatable {
    /// <p>License beneficiary.</p>
    public let beneficiary: String?
    /// <p>License consumption token.</p>
    public let licenseConsumptionToken: String?

    public init (
        beneficiary: String? = nil,
        licenseConsumptionToken: String? = nil
    )
    {
        self.beneficiary = beneficiary
        self.licenseConsumptionToken = licenseConsumptionToken
    }
}

struct CheckInLicenseInputBody: Equatable {
    public let licenseConsumptionToken: String?
    public let beneficiary: String?
}

extension CheckInLicenseInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case beneficiary = "Beneficiary"
        case licenseConsumptionToken = "LicenseConsumptionToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConsumptionTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseConsumptionToken)
        licenseConsumptionToken = licenseConsumptionTokenDecoded
        let beneficiaryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .beneficiary)
        beneficiary = beneficiaryDecoded
    }
}

extension CheckInLicenseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CheckInLicenseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CheckInLicenseOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case conflictException(ConflictException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CheckInLicenseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CheckInLicenseOutputResponse()"}
}

extension CheckInLicenseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CheckInLicenseOutputResponse: Equatable {

    public init() {}
}

struct CheckInLicenseOutputResponseBody: Equatable {
}

extension CheckInLicenseOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CheckoutBorrowLicenseInputBodyMiddleware: Middleware {
    public let id: String = "CheckoutBorrowLicenseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CheckoutBorrowLicenseInput>,
                  next: H) -> Swift.Result<OperationOutput<CheckoutBorrowLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CheckoutBorrowLicenseInput>
    public typealias MOutput = OperationOutput<CheckoutBorrowLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CheckoutBorrowLicenseOutputError>
}

extension CheckoutBorrowLicenseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CheckoutBorrowLicenseInput(checkoutMetadata: \(String(describing: checkoutMetadata)), clientToken: \(String(describing: clientToken)), digitalSignatureMethod: \(String(describing: digitalSignatureMethod)), entitlements: \(String(describing: entitlements)), licenseArn: \(String(describing: licenseArn)), nodeId: \(String(describing: nodeId)))"}
}

extension CheckoutBorrowLicenseInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case checkoutMetadata = "CheckoutMetadata"
        case clientToken = "ClientToken"
        case digitalSignatureMethod = "DigitalSignatureMethod"
        case entitlements = "Entitlements"
        case licenseArn = "LicenseArn"
        case nodeId = "NodeId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkoutMetadata = checkoutMetadata {
            var checkoutMetadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .checkoutMetadata)
            for metadatalist0 in checkoutMetadata {
                try checkoutMetadataContainer.encode(metadatalist0)
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let digitalSignatureMethod = digitalSignatureMethod {
            try encodeContainer.encode(digitalSignatureMethod.rawValue, forKey: .digitalSignatureMethod)
        }
        if let entitlements = entitlements {
            var entitlementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entitlements)
            for entitlementdatalist0 in entitlements {
                try entitlementsContainer.encode(entitlementdatalist0)
            }
        }
        if let licenseArn = licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let nodeId = nodeId {
            try encodeContainer.encode(nodeId, forKey: .nodeId)
        }
    }
}

public struct CheckoutBorrowLicenseInputHeadersMiddleware: Middleware {
    public let id: String = "CheckoutBorrowLicenseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CheckoutBorrowLicenseInput>,
                  next: H) -> Swift.Result<OperationOutput<CheckoutBorrowLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CheckoutBorrowLicenseInput>
    public typealias MOutput = OperationOutput<CheckoutBorrowLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CheckoutBorrowLicenseOutputError>
}

public struct CheckoutBorrowLicenseInputQueryItemMiddleware: Middleware {
    public let id: String = "CheckoutBorrowLicenseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CheckoutBorrowLicenseInput>,
                  next: H) -> Swift.Result<OperationOutput<CheckoutBorrowLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CheckoutBorrowLicenseInput>
    public typealias MOutput = OperationOutput<CheckoutBorrowLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CheckoutBorrowLicenseOutputError>
}

public struct CheckoutBorrowLicenseInput: Equatable {
    /// <p>Information about constraints.</p>
    public let checkoutMetadata: [Metadata]?
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: String?
    /// <p>Digital signature method. The possible value is JSON Web Signature (JWS) algorithm PS384.
    ///          For more information, see <a href="https://tools.ietf.org/html/rfc7518#section-3.5">RFC 7518 Digital Signature with RSASSA-PSS</a>.</p>
    public let digitalSignatureMethod: DigitalSignatureMethod?
    /// <p>License entitlements. Partial checkouts are not supported.</p>
    public let entitlements: [EntitlementData]?
    /// <p>Amazon Resource Name (ARN) of the license. The license must use the borrow consumption configuration.</p>
    public let licenseArn: String?
    /// <p>Node ID.</p>
    public let nodeId: String?

    public init (
        checkoutMetadata: [Metadata]? = nil,
        clientToken: String? = nil,
        digitalSignatureMethod: DigitalSignatureMethod? = nil,
        entitlements: [EntitlementData]? = nil,
        licenseArn: String? = nil,
        nodeId: String? = nil
    )
    {
        self.checkoutMetadata = checkoutMetadata
        self.clientToken = clientToken
        self.digitalSignatureMethod = digitalSignatureMethod
        self.entitlements = entitlements
        self.licenseArn = licenseArn
        self.nodeId = nodeId
    }
}

struct CheckoutBorrowLicenseInputBody: Equatable {
    public let licenseArn: String?
    public let entitlements: [EntitlementData]?
    public let digitalSignatureMethod: DigitalSignatureMethod?
    public let nodeId: String?
    public let checkoutMetadata: [Metadata]?
    public let clientToken: String?
}

extension CheckoutBorrowLicenseInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case checkoutMetadata = "CheckoutMetadata"
        case clientToken = "ClientToken"
        case digitalSignatureMethod = "DigitalSignatureMethod"
        case entitlements = "Entitlements"
        case licenseArn = "LicenseArn"
        case nodeId = "NodeId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let entitlementsContainer = try containerValues.decodeIfPresent([EntitlementData?].self, forKey: .entitlements)
        var entitlementsDecoded0:[EntitlementData]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [EntitlementData]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let digitalSignatureMethodDecoded = try containerValues.decodeIfPresent(DigitalSignatureMethod.self, forKey: .digitalSignatureMethod)
        digitalSignatureMethod = digitalSignatureMethodDecoded
        let nodeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeId)
        nodeId = nodeIdDecoded
        let checkoutMetadataContainer = try containerValues.decodeIfPresent([Metadata?].self, forKey: .checkoutMetadata)
        var checkoutMetadataDecoded0:[Metadata]? = nil
        if let checkoutMetadataContainer = checkoutMetadataContainer {
            checkoutMetadataDecoded0 = [Metadata]()
            for structure0 in checkoutMetadataContainer {
                if let structure0 = structure0 {
                    checkoutMetadataDecoded0?.append(structure0)
                }
            }
        }
        checkoutMetadata = checkoutMetadataDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CheckoutBorrowLicenseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CheckoutBorrowLicenseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntitlementNotAllowedException" : self = .entitlementNotAllowedException(try EntitlementNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoEntitlementsAllowedException" : self = .noEntitlementsAllowedException(try NoEntitlementsAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RedirectException" : self = .redirectException(try RedirectException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedDigitalSignatureMethodException" : self = .unsupportedDigitalSignatureMethodException(try UnsupportedDigitalSignatureMethodException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CheckoutBorrowLicenseOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case entitlementNotAllowedException(EntitlementNotAllowedException)
    case noEntitlementsAllowedException(NoEntitlementsAllowedException)
    case rateLimitExceededException(RateLimitExceededException)
    case redirectException(RedirectException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalException(ServerInternalException)
    case unsupportedDigitalSignatureMethodException(UnsupportedDigitalSignatureMethodException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CheckoutBorrowLicenseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CheckoutBorrowLicenseOutputResponse(checkoutMetadata: \(String(describing: checkoutMetadata)), entitlementsAllowed: \(String(describing: entitlementsAllowed)), expiration: \(String(describing: expiration)), issuedAt: \(String(describing: issuedAt)), licenseArn: \(String(describing: licenseArn)), licenseConsumptionToken: \(String(describing: licenseConsumptionToken)), nodeId: \(String(describing: nodeId)), signedToken: \(String(describing: signedToken)))"}
}

extension CheckoutBorrowLicenseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CheckoutBorrowLicenseOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.checkoutMetadata = output.checkoutMetadata
            self.entitlementsAllowed = output.entitlementsAllowed
            self.expiration = output.expiration
            self.issuedAt = output.issuedAt
            self.licenseArn = output.licenseArn
            self.licenseConsumptionToken = output.licenseConsumptionToken
            self.nodeId = output.nodeId
            self.signedToken = output.signedToken
        } else {
            self.checkoutMetadata = nil
            self.entitlementsAllowed = nil
            self.expiration = nil
            self.issuedAt = nil
            self.licenseArn = nil
            self.licenseConsumptionToken = nil
            self.nodeId = nil
            self.signedToken = nil
        }
    }
}

public struct CheckoutBorrowLicenseOutputResponse: Equatable {
    /// <p>Information about constraints.</p>
    public let checkoutMetadata: [Metadata]?
    /// <p>Allowed license entitlements.</p>
    public let entitlementsAllowed: [EntitlementData]?
    /// <p>Date and time at which the license checkout expires.</p>
    public let expiration: String?
    /// <p>Date and time at which the license checkout is issued.</p>
    public let issuedAt: String?
    /// <p>Amazon Resource Name (ARN) of the license.</p>
    public let licenseArn: String?
    /// <p>License consumption token.</p>
    public let licenseConsumptionToken: String?
    /// <p>Node ID.</p>
    public let nodeId: String?
    /// <p>Signed token.</p>
    public let signedToken: String?

    public init (
        checkoutMetadata: [Metadata]? = nil,
        entitlementsAllowed: [EntitlementData]? = nil,
        expiration: String? = nil,
        issuedAt: String? = nil,
        licenseArn: String? = nil,
        licenseConsumptionToken: String? = nil,
        nodeId: String? = nil,
        signedToken: String? = nil
    )
    {
        self.checkoutMetadata = checkoutMetadata
        self.entitlementsAllowed = entitlementsAllowed
        self.expiration = expiration
        self.issuedAt = issuedAt
        self.licenseArn = licenseArn
        self.licenseConsumptionToken = licenseConsumptionToken
        self.nodeId = nodeId
        self.signedToken = signedToken
    }
}

struct CheckoutBorrowLicenseOutputResponseBody: Equatable {
    public let licenseArn: String?
    public let licenseConsumptionToken: String?
    public let entitlementsAllowed: [EntitlementData]?
    public let nodeId: String?
    public let signedToken: String?
    public let issuedAt: String?
    public let expiration: String?
    public let checkoutMetadata: [Metadata]?
}

extension CheckoutBorrowLicenseOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case checkoutMetadata = "CheckoutMetadata"
        case entitlementsAllowed = "EntitlementsAllowed"
        case expiration = "Expiration"
        case issuedAt = "IssuedAt"
        case licenseArn = "LicenseArn"
        case licenseConsumptionToken = "LicenseConsumptionToken"
        case nodeId = "NodeId"
        case signedToken = "SignedToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let licenseConsumptionTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseConsumptionToken)
        licenseConsumptionToken = licenseConsumptionTokenDecoded
        let entitlementsAllowedContainer = try containerValues.decodeIfPresent([EntitlementData?].self, forKey: .entitlementsAllowed)
        var entitlementsAllowedDecoded0:[EntitlementData]? = nil
        if let entitlementsAllowedContainer = entitlementsAllowedContainer {
            entitlementsAllowedDecoded0 = [EntitlementData]()
            for structure0 in entitlementsAllowedContainer {
                if let structure0 = structure0 {
                    entitlementsAllowedDecoded0?.append(structure0)
                }
            }
        }
        entitlementsAllowed = entitlementsAllowedDecoded0
        let nodeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeId)
        nodeId = nodeIdDecoded
        let signedTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signedToken)
        signedToken = signedTokenDecoded
        let issuedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .issuedAt)
        issuedAt = issuedAtDecoded
        let expirationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expiration)
        expiration = expirationDecoded
        let checkoutMetadataContainer = try containerValues.decodeIfPresent([Metadata?].self, forKey: .checkoutMetadata)
        var checkoutMetadataDecoded0:[Metadata]? = nil
        if let checkoutMetadataContainer = checkoutMetadataContainer {
            checkoutMetadataDecoded0 = [Metadata]()
            for structure0 in checkoutMetadataContainer {
                if let structure0 = structure0 {
                    checkoutMetadataDecoded0?.append(structure0)
                }
            }
        }
        checkoutMetadata = checkoutMetadataDecoded0
    }
}

public struct CheckoutLicenseInputBodyMiddleware: Middleware {
    public let id: String = "CheckoutLicenseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CheckoutLicenseInput>,
                  next: H) -> Swift.Result<OperationOutput<CheckoutLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CheckoutLicenseInput>
    public typealias MOutput = OperationOutput<CheckoutLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CheckoutLicenseOutputError>
}

extension CheckoutLicenseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CheckoutLicenseInput(beneficiary: \(String(describing: beneficiary)), checkoutType: \(String(describing: checkoutType)), clientToken: \(String(describing: clientToken)), entitlements: \(String(describing: entitlements)), keyFingerprint: \(String(describing: keyFingerprint)), nodeId: \(String(describing: nodeId)), productSKU: \(String(describing: productSKU)))"}
}

extension CheckoutLicenseInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case beneficiary = "Beneficiary"
        case checkoutType = "CheckoutType"
        case clientToken = "ClientToken"
        case entitlements = "Entitlements"
        case keyFingerprint = "KeyFingerprint"
        case nodeId = "NodeId"
        case productSKU = "ProductSKU"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beneficiary = beneficiary {
            try encodeContainer.encode(beneficiary, forKey: .beneficiary)
        }
        if let checkoutType = checkoutType {
            try encodeContainer.encode(checkoutType.rawValue, forKey: .checkoutType)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let entitlements = entitlements {
            var entitlementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entitlements)
            for entitlementdatalist0 in entitlements {
                try entitlementsContainer.encode(entitlementdatalist0)
            }
        }
        if let keyFingerprint = keyFingerprint {
            try encodeContainer.encode(keyFingerprint, forKey: .keyFingerprint)
        }
        if let nodeId = nodeId {
            try encodeContainer.encode(nodeId, forKey: .nodeId)
        }
        if let productSKU = productSKU {
            try encodeContainer.encode(productSKU, forKey: .productSKU)
        }
    }
}

public struct CheckoutLicenseInputHeadersMiddleware: Middleware {
    public let id: String = "CheckoutLicenseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CheckoutLicenseInput>,
                  next: H) -> Swift.Result<OperationOutput<CheckoutLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CheckoutLicenseInput>
    public typealias MOutput = OperationOutput<CheckoutLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CheckoutLicenseOutputError>
}

public struct CheckoutLicenseInputQueryItemMiddleware: Middleware {
    public let id: String = "CheckoutLicenseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CheckoutLicenseInput>,
                  next: H) -> Swift.Result<OperationOutput<CheckoutLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CheckoutLicenseInput>
    public typealias MOutput = OperationOutput<CheckoutLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CheckoutLicenseOutputError>
}

public struct CheckoutLicenseInput: Equatable {
    /// <p>License beneficiary.</p>
    public let beneficiary: String?
    /// <p>Checkout type.</p>
    public let checkoutType: CheckoutType?
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: String?
    /// <p>License entitlements.</p>
    public let entitlements: [EntitlementData]?
    /// <p>Key fingerprint identifying the license.</p>
    public let keyFingerprint: String?
    /// <p>Node ID.</p>
    public let nodeId: String?
    /// <p>Product SKU.</p>
    public let productSKU: String?

    public init (
        beneficiary: String? = nil,
        checkoutType: CheckoutType? = nil,
        clientToken: String? = nil,
        entitlements: [EntitlementData]? = nil,
        keyFingerprint: String? = nil,
        nodeId: String? = nil,
        productSKU: String? = nil
    )
    {
        self.beneficiary = beneficiary
        self.checkoutType = checkoutType
        self.clientToken = clientToken
        self.entitlements = entitlements
        self.keyFingerprint = keyFingerprint
        self.nodeId = nodeId
        self.productSKU = productSKU
    }
}

struct CheckoutLicenseInputBody: Equatable {
    public let productSKU: String?
    public let checkoutType: CheckoutType?
    public let keyFingerprint: String?
    public let entitlements: [EntitlementData]?
    public let clientToken: String?
    public let beneficiary: String?
    public let nodeId: String?
}

extension CheckoutLicenseInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case beneficiary = "Beneficiary"
        case checkoutType = "CheckoutType"
        case clientToken = "ClientToken"
        case entitlements = "Entitlements"
        case keyFingerprint = "KeyFingerprint"
        case nodeId = "NodeId"
        case productSKU = "ProductSKU"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productSKUDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productSKU)
        productSKU = productSKUDecoded
        let checkoutTypeDecoded = try containerValues.decodeIfPresent(CheckoutType.self, forKey: .checkoutType)
        checkoutType = checkoutTypeDecoded
        let keyFingerprintDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyFingerprint)
        keyFingerprint = keyFingerprintDecoded
        let entitlementsContainer = try containerValues.decodeIfPresent([EntitlementData?].self, forKey: .entitlements)
        var entitlementsDecoded0:[EntitlementData]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [EntitlementData]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let beneficiaryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .beneficiary)
        beneficiary = beneficiaryDecoded
        let nodeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeId)
        nodeId = nodeIdDecoded
    }
}

extension CheckoutLicenseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CheckoutLicenseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoEntitlementsAllowedException" : self = .noEntitlementsAllowedException(try NoEntitlementsAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RedirectException" : self = .redirectException(try RedirectException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedDigitalSignatureMethodException" : self = .unsupportedDigitalSignatureMethodException(try UnsupportedDigitalSignatureMethodException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CheckoutLicenseOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case noEntitlementsAllowedException(NoEntitlementsAllowedException)
    case rateLimitExceededException(RateLimitExceededException)
    case redirectException(RedirectException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalException(ServerInternalException)
    case unsupportedDigitalSignatureMethodException(UnsupportedDigitalSignatureMethodException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CheckoutLicenseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CheckoutLicenseOutputResponse(checkoutType: \(String(describing: checkoutType)), entitlementsAllowed: \(String(describing: entitlementsAllowed)), expiration: \(String(describing: expiration)), issuedAt: \(String(describing: issuedAt)), licenseConsumptionToken: \(String(describing: licenseConsumptionToken)), nodeId: \(String(describing: nodeId)), signedToken: \(String(describing: signedToken)))"}
}

extension CheckoutLicenseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CheckoutLicenseOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.checkoutType = output.checkoutType
            self.entitlementsAllowed = output.entitlementsAllowed
            self.expiration = output.expiration
            self.issuedAt = output.issuedAt
            self.licenseConsumptionToken = output.licenseConsumptionToken
            self.nodeId = output.nodeId
            self.signedToken = output.signedToken
        } else {
            self.checkoutType = nil
            self.entitlementsAllowed = nil
            self.expiration = nil
            self.issuedAt = nil
            self.licenseConsumptionToken = nil
            self.nodeId = nil
            self.signedToken = nil
        }
    }
}

public struct CheckoutLicenseOutputResponse: Equatable {
    /// <p>Checkout type.</p>
    public let checkoutType: CheckoutType?
    /// <p>Allowed license entitlements.</p>
    public let entitlementsAllowed: [EntitlementData]?
    /// <p>Date and time at which the license checkout expires.</p>
    public let expiration: String?
    /// <p>Date and time at which the license checkout is issued.</p>
    public let issuedAt: String?
    /// <p>License consumption token.</p>
    public let licenseConsumptionToken: String?
    /// <p>Node ID.</p>
    public let nodeId: String?
    /// <p>Signed token.</p>
    public let signedToken: String?

    public init (
        checkoutType: CheckoutType? = nil,
        entitlementsAllowed: [EntitlementData]? = nil,
        expiration: String? = nil,
        issuedAt: String? = nil,
        licenseConsumptionToken: String? = nil,
        nodeId: String? = nil,
        signedToken: String? = nil
    )
    {
        self.checkoutType = checkoutType
        self.entitlementsAllowed = entitlementsAllowed
        self.expiration = expiration
        self.issuedAt = issuedAt
        self.licenseConsumptionToken = licenseConsumptionToken
        self.nodeId = nodeId
        self.signedToken = signedToken
    }
}

struct CheckoutLicenseOutputResponseBody: Equatable {
    public let checkoutType: CheckoutType?
    public let licenseConsumptionToken: String?
    public let entitlementsAllowed: [EntitlementData]?
    public let signedToken: String?
    public let nodeId: String?
    public let issuedAt: String?
    public let expiration: String?
}

extension CheckoutLicenseOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case checkoutType = "CheckoutType"
        case entitlementsAllowed = "EntitlementsAllowed"
        case expiration = "Expiration"
        case issuedAt = "IssuedAt"
        case licenseConsumptionToken = "LicenseConsumptionToken"
        case nodeId = "NodeId"
        case signedToken = "SignedToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkoutTypeDecoded = try containerValues.decodeIfPresent(CheckoutType.self, forKey: .checkoutType)
        checkoutType = checkoutTypeDecoded
        let licenseConsumptionTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseConsumptionToken)
        licenseConsumptionToken = licenseConsumptionTokenDecoded
        let entitlementsAllowedContainer = try containerValues.decodeIfPresent([EntitlementData?].self, forKey: .entitlementsAllowed)
        var entitlementsAllowedDecoded0:[EntitlementData]? = nil
        if let entitlementsAllowedContainer = entitlementsAllowedContainer {
            entitlementsAllowedDecoded0 = [EntitlementData]()
            for structure0 in entitlementsAllowedContainer {
                if let structure0 = structure0 {
                    entitlementsAllowedDecoded0?.append(structure0)
                }
            }
        }
        entitlementsAllowed = entitlementsAllowedDecoded0
        let signedTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signedToken)
        signedToken = signedTokenDecoded
        let nodeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeId)
        nodeId = nodeIdDecoded
        let issuedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .issuedAt)
        issuedAt = issuedAtDecoded
        let expirationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expiration)
        expiration = expirationDecoded
    }
}

public enum CheckoutType {
    case provisional
    case sdkUnknown(String)
}

extension CheckoutType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CheckoutType] {
        return [
            .provisional,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .provisional: return "PROVISIONAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CheckoutType(rawValue: rawValue) ?? CheckoutType.sdkUnknown(rawValue)
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There was a conflict processing the request. Try your request again.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConsumedLicenseSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case consumedLicenses = "ConsumedLicenses"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumedLicenses = consumedLicenses {
            try encodeContainer.encode(consumedLicenses, forKey: .consumedLicenses)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let consumedLicensesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .consumedLicenses)
        consumedLicenses = consumedLicensesDecoded
    }
}

extension ConsumedLicenseSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConsumedLicenseSummary(consumedLicenses: \(String(describing: consumedLicenses)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>Details about license consumption.</p>
public struct ConsumedLicenseSummary: Equatable {
    /// <p>Number of licenses consumed by the resource.</p>
    public let consumedLicenses: Int?
    /// <p>Resource type of the resource consuming a license.</p>
    public let resourceType: ResourceType?

    public init (
        consumedLicenses: Int? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.consumedLicenses = consumedLicenses
        self.resourceType = resourceType
    }
}

extension ConsumptionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case borrowConfiguration = "BorrowConfiguration"
        case provisionalConfiguration = "ProvisionalConfiguration"
        case renewType = "RenewType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let borrowConfiguration = borrowConfiguration {
            try encodeContainer.encode(borrowConfiguration, forKey: .borrowConfiguration)
        }
        if let provisionalConfiguration = provisionalConfiguration {
            try encodeContainer.encode(provisionalConfiguration, forKey: .provisionalConfiguration)
        }
        if let renewType = renewType {
            try encodeContainer.encode(renewType.rawValue, forKey: .renewType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let renewTypeDecoded = try containerValues.decodeIfPresent(RenewType.self, forKey: .renewType)
        renewType = renewTypeDecoded
        let provisionalConfigurationDecoded = try containerValues.decodeIfPresent(ProvisionalConfiguration.self, forKey: .provisionalConfiguration)
        provisionalConfiguration = provisionalConfigurationDecoded
        let borrowConfigurationDecoded = try containerValues.decodeIfPresent(BorrowConfiguration.self, forKey: .borrowConfiguration)
        borrowConfiguration = borrowConfigurationDecoded
    }
}

extension ConsumptionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConsumptionConfiguration(borrowConfiguration: \(String(describing: borrowConfiguration)), provisionalConfiguration: \(String(describing: provisionalConfiguration)), renewType: \(String(describing: renewType)))"}
}

/// <p>Details about a consumption configuration.</p>
public struct ConsumptionConfiguration: Equatable {
    /// <p>Details about a borrow configuration.</p>
    public let borrowConfiguration: BorrowConfiguration?
    /// <p>Details about a provisional configuration.</p>
    public let provisionalConfiguration: ProvisionalConfiguration?
    /// <p>Renewal frequency.</p>
    public let renewType: RenewType?

    public init (
        borrowConfiguration: BorrowConfiguration? = nil,
        provisionalConfiguration: ProvisionalConfiguration? = nil,
        renewType: RenewType? = nil
    )
    {
        self.borrowConfiguration = borrowConfiguration
        self.provisionalConfiguration = provisionalConfiguration
        self.renewType = renewType
    }
}

public struct CreateGrantInputBodyMiddleware: Middleware {
    public let id: String = "CreateGrantInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGrantInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGrantInput>
    public typealias MOutput = OperationOutput<CreateGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGrantOutputError>
}

extension CreateGrantInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGrantInput(allowedOperations: \(String(describing: allowedOperations)), clientToken: \(String(describing: clientToken)), grantName: \(String(describing: grantName)), homeRegion: \(String(describing: homeRegion)), licenseArn: \(String(describing: licenseArn)), principals: \(String(describing: principals)))"}
}

extension CreateGrantInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedOperations = "AllowedOperations"
        case clientToken = "ClientToken"
        case grantName = "GrantName"
        case homeRegion = "HomeRegion"
        case licenseArn = "LicenseArn"
        case principals = "Principals"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedOperations = allowedOperations {
            var allowedOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedOperations)
            for allowedoperationlist0 in allowedOperations {
                try allowedOperationsContainer.encode(allowedoperationlist0.rawValue)
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let grantName = grantName {
            try encodeContainer.encode(grantName, forKey: .grantName)
        }
        if let homeRegion = homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let licenseArn = licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for principalarnlist0 in principals {
                try principalsContainer.encode(principalarnlist0)
            }
        }
    }
}

public struct CreateGrantInputHeadersMiddleware: Middleware {
    public let id: String = "CreateGrantInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGrantInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGrantInput>
    public typealias MOutput = OperationOutput<CreateGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGrantOutputError>
}

public struct CreateGrantInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateGrantInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGrantInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGrantInput>
    public typealias MOutput = OperationOutput<CreateGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGrantOutputError>
}

public struct CreateGrantInput: Equatable {
    /// <p>Allowed operations for the grant.</p>
    public let allowedOperations: [AllowedOperation]?
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: String?
    /// <p>Grant name.</p>
    public let grantName: String?
    /// <p>Home Region of the grant.</p>
    public let homeRegion: String?
    /// <p>Amazon Resource Name (ARN) of the license.</p>
    public let licenseArn: String?
    /// <p>The grant principals.</p>
    public let principals: [String]?

    public init (
        allowedOperations: [AllowedOperation]? = nil,
        clientToken: String? = nil,
        grantName: String? = nil,
        homeRegion: String? = nil,
        licenseArn: String? = nil,
        principals: [String]? = nil
    )
    {
        self.allowedOperations = allowedOperations
        self.clientToken = clientToken
        self.grantName = grantName
        self.homeRegion = homeRegion
        self.licenseArn = licenseArn
        self.principals = principals
    }
}

struct CreateGrantInputBody: Equatable {
    public let clientToken: String?
    public let grantName: String?
    public let licenseArn: String?
    public let principals: [String]?
    public let homeRegion: String?
    public let allowedOperations: [AllowedOperation]?
}

extension CreateGrantInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allowedOperations = "AllowedOperations"
        case clientToken = "ClientToken"
        case grantName = "GrantName"
        case homeRegion = "HomeRegion"
        case licenseArn = "LicenseArn"
        case principals = "Principals"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let grantNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grantName)
        grantName = grantNameDecoded
        let licenseArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let principalsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .principals)
        var principalsDecoded0:[String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let homeRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let allowedOperationsContainer = try containerValues.decodeIfPresent([AllowedOperation?].self, forKey: .allowedOperations)
        var allowedOperationsDecoded0:[AllowedOperation]? = nil
        if let allowedOperationsContainer = allowedOperationsContainer {
            allowedOperationsDecoded0 = [AllowedOperation]()
            for string0 in allowedOperationsContainer {
                if let string0 = string0 {
                    allowedOperationsDecoded0?.append(string0)
                }
            }
        }
        allowedOperations = allowedOperationsDecoded0
    }
}

extension CreateGrantOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGrantOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGrantOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGrantOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGrantOutputResponse(grantArn: \(String(describing: grantArn)), status: \(String(describing: status)), version: \(String(describing: version)))"}
}

extension CreateGrantOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateGrantOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.grantArn = output.grantArn
            self.status = output.status
            self.version = output.version
        } else {
            self.grantArn = nil
            self.status = nil
            self.version = nil
        }
    }
}

public struct CreateGrantOutputResponse: Equatable {
    /// <p>Grant ARN.</p>
    public let grantArn: String?
    /// <p>Grant status.</p>
    public let status: GrantStatus?
    /// <p>Grant version.</p>
    public let version: String?

    public init (
        grantArn: String? = nil,
        status: GrantStatus? = nil,
        version: String? = nil
    )
    {
        self.grantArn = grantArn
        self.status = status
        self.version = version
    }
}

struct CreateGrantOutputResponseBody: Equatable {
    public let grantArn: String?
    public let status: GrantStatus?
    public let version: String?
}

extension CreateGrantOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case grantArn = "GrantArn"
        case status = "Status"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GrantStatus.self, forKey: .status)
        status = statusDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

public struct CreateGrantVersionInputBodyMiddleware: Middleware {
    public let id: String = "CreateGrantVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGrantVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGrantVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGrantVersionInput>
    public typealias MOutput = OperationOutput<CreateGrantVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGrantVersionOutputError>
}

extension CreateGrantVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGrantVersionInput(allowedOperations: \(String(describing: allowedOperations)), clientToken: \(String(describing: clientToken)), grantArn: \(String(describing: grantArn)), grantName: \(String(describing: grantName)), sourceVersion: \(String(describing: sourceVersion)), status: \(String(describing: status)))"}
}

extension CreateGrantVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedOperations = "AllowedOperations"
        case clientToken = "ClientToken"
        case grantArn = "GrantArn"
        case grantName = "GrantName"
        case sourceVersion = "SourceVersion"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedOperations = allowedOperations {
            var allowedOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedOperations)
            for allowedoperationlist0 in allowedOperations {
                try allowedOperationsContainer.encode(allowedoperationlist0.rawValue)
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let grantArn = grantArn {
            try encodeContainer.encode(grantArn, forKey: .grantArn)
        }
        if let grantName = grantName {
            try encodeContainer.encode(grantName, forKey: .grantName)
        }
        if let sourceVersion = sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct CreateGrantVersionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateGrantVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGrantVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGrantVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGrantVersionInput>
    public typealias MOutput = OperationOutput<CreateGrantVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGrantVersionOutputError>
}

public struct CreateGrantVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateGrantVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGrantVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGrantVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGrantVersionInput>
    public typealias MOutput = OperationOutput<CreateGrantVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGrantVersionOutputError>
}

public struct CreateGrantVersionInput: Equatable {
    /// <p>Allowed operations for the grant.</p>
    public let allowedOperations: [AllowedOperation]?
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: String?
    /// <p>Amazon Resource Name (ARN) of the grant.</p>
    public let grantArn: String?
    /// <p>Grant name.</p>
    public let grantName: String?
    /// <p>Current version of the grant.</p>
    public let sourceVersion: String?
    /// <p>Grant status.</p>
    public let status: GrantStatus?

    public init (
        allowedOperations: [AllowedOperation]? = nil,
        clientToken: String? = nil,
        grantArn: String? = nil,
        grantName: String? = nil,
        sourceVersion: String? = nil,
        status: GrantStatus? = nil
    )
    {
        self.allowedOperations = allowedOperations
        self.clientToken = clientToken
        self.grantArn = grantArn
        self.grantName = grantName
        self.sourceVersion = sourceVersion
        self.status = status
    }
}

struct CreateGrantVersionInputBody: Equatable {
    public let clientToken: String?
    public let grantArn: String?
    public let grantName: String?
    public let allowedOperations: [AllowedOperation]?
    public let status: GrantStatus?
    public let sourceVersion: String?
}

extension CreateGrantVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allowedOperations = "AllowedOperations"
        case clientToken = "ClientToken"
        case grantArn = "GrantArn"
        case grantName = "GrantName"
        case sourceVersion = "SourceVersion"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let grantArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
        let grantNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grantName)
        grantName = grantNameDecoded
        let allowedOperationsContainer = try containerValues.decodeIfPresent([AllowedOperation?].self, forKey: .allowedOperations)
        var allowedOperationsDecoded0:[AllowedOperation]? = nil
        if let allowedOperationsContainer = allowedOperationsContainer {
            allowedOperationsDecoded0 = [AllowedOperation]()
            for string0 in allowedOperationsContainer {
                if let string0 = string0 {
                    allowedOperationsDecoded0?.append(string0)
                }
            }
        }
        allowedOperations = allowedOperationsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(GrantStatus.self, forKey: .status)
        status = statusDecoded
        let sourceVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
    }
}

extension CreateGrantVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGrantVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGrantVersionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGrantVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGrantVersionOutputResponse(grantArn: \(String(describing: grantArn)), status: \(String(describing: status)), version: \(String(describing: version)))"}
}

extension CreateGrantVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateGrantVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.grantArn = output.grantArn
            self.status = output.status
            self.version = output.version
        } else {
            self.grantArn = nil
            self.status = nil
            self.version = nil
        }
    }
}

public struct CreateGrantVersionOutputResponse: Equatable {
    /// <p>Grant ARN.</p>
    public let grantArn: String?
    /// <p>Grant status.</p>
    public let status: GrantStatus?
    /// <p>New version of the grant.</p>
    public let version: String?

    public init (
        grantArn: String? = nil,
        status: GrantStatus? = nil,
        version: String? = nil
    )
    {
        self.grantArn = grantArn
        self.status = status
        self.version = version
    }
}

struct CreateGrantVersionOutputResponseBody: Equatable {
    public let grantArn: String?
    public let status: GrantStatus?
    public let version: String?
}

extension CreateGrantVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case grantArn = "GrantArn"
        case status = "Status"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GrantStatus.self, forKey: .status)
        status = statusDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

public struct CreateLicenseConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "CreateLicenseConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLicenseConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLicenseConfigurationInput>
    public typealias MOutput = OperationOutput<CreateLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLicenseConfigurationOutputError>
}

extension CreateLicenseConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLicenseConfigurationInput(description: \(String(describing: description)), disassociateWhenNotFound: \(String(describing: disassociateWhenNotFound)), licenseCount: \(String(describing: licenseCount)), licenseCountHardLimit: \(String(describing: licenseCountHardLimit)), licenseCountingType: \(String(describing: licenseCountingType)), licenseRules: \(String(describing: licenseRules)), name: \(String(describing: name)), productInformationList: \(String(describing: productInformationList)), tags: \(String(describing: tags)))"}
}

extension CreateLicenseConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case disassociateWhenNotFound = "DisassociateWhenNotFound"
        case licenseCount = "LicenseCount"
        case licenseCountHardLimit = "LicenseCountHardLimit"
        case licenseCountingType = "LicenseCountingType"
        case licenseRules = "LicenseRules"
        case name = "Name"
        case productInformationList = "ProductInformationList"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disassociateWhenNotFound = disassociateWhenNotFound {
            try encodeContainer.encode(disassociateWhenNotFound, forKey: .disassociateWhenNotFound)
        }
        if let licenseCount = licenseCount {
            try encodeContainer.encode(licenseCount, forKey: .licenseCount)
        }
        if let licenseCountHardLimit = licenseCountHardLimit {
            try encodeContainer.encode(licenseCountHardLimit, forKey: .licenseCountHardLimit)
        }
        if let licenseCountingType = licenseCountingType {
            try encodeContainer.encode(licenseCountingType.rawValue, forKey: .licenseCountingType)
        }
        if let licenseRules = licenseRules {
            var licenseRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseRules)
            for stringlist0 in licenseRules {
                try licenseRulesContainer.encode(stringlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let productInformationList = productInformationList {
            var productInformationListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productInformationList)
            for productinformationlist0 in productInformationList {
                try productInformationListContainer.encode(productinformationlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateLicenseConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateLicenseConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLicenseConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLicenseConfigurationInput>
    public typealias MOutput = OperationOutput<CreateLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLicenseConfigurationOutputError>
}

public struct CreateLicenseConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateLicenseConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLicenseConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLicenseConfigurationInput>
    public typealias MOutput = OperationOutput<CreateLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLicenseConfigurationOutputError>
}

public struct CreateLicenseConfigurationInput: Equatable {
    /// <p>Description of the license configuration.</p>
    public let description: String?
    /// <p>When true, disassociates a resource when software is uninstalled.</p>
    public let disassociateWhenNotFound: Bool?
    /// <p>Number of licenses managed by the license configuration.</p>
    public let licenseCount: Int?
    /// <p>Indicates whether hard or soft license enforcement is used. Exceeding a hard limit
    ///          blocks the launch of new instances.</p>
    public let licenseCountHardLimit: Bool?
    /// <p>Dimension used to track the license inventory.</p>
    public let licenseCountingType: LicenseCountingType?
    /// <p>License rules. The syntax is #name=value (for example, #allowedTenancy=EC2-DedicatedHost). The available rules
    ///          vary by dimension, as follows.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Cores</code> dimension: <code>allowedTenancy</code> |
    ///                <code>licenseAffinityToHost</code> |
    ///                <code>maximumCores</code> | <code>minimumCores</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Instances</code> dimension: <code>allowedTenancy</code> |
    ///                <code>maximumCores</code> | <code>minimumCores</code> |
    ///                <code>maximumSockets</code> | <code>minimumSockets</code> |
    ///                <code>maximumVcpus</code> | <code>minimumVcpus</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Sockets</code> dimension: <code>allowedTenancy</code> |
    ///                <code>licenseAffinityToHost</code> |
    ///                <code>maximumSockets</code> | <code>minimumSockets</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>vCPUs</code> dimension: <code>allowedTenancy</code> |
    ///                <code>honorVcpuOptimization</code> |
    ///                <code>maximumVcpus</code> | <code>minimumVcpus</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>The unit for <code>licenseAffinityToHost</code> is days and the range is 1 to 180. The possible
    ///          values for <code>allowedTenancy</code> are <code>EC2-Default</code>, <code>EC2-DedicatedHost</code>, and
    ///          <code>EC2-DedicatedInstance</code>. The possible values for <code>honorVcpuOptimization</code> are
    ///          <code>True</code> and <code>False</code>.</p>
    public let licenseRules: [String]?
    /// <p>Name of the license configuration.</p>
    public let name: String?
    /// <p>Product information.</p>
    public let productInformationList: [ProductInformation]?
    /// <p>Tags to add to the license configuration.</p>
    public let tags: [Tag]?

    public init (
        description: String? = nil,
        disassociateWhenNotFound: Bool? = nil,
        licenseCount: Int? = nil,
        licenseCountHardLimit: Bool? = nil,
        licenseCountingType: LicenseCountingType? = nil,
        licenseRules: [String]? = nil,
        name: String? = nil,
        productInformationList: [ProductInformation]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.description = description
        self.disassociateWhenNotFound = disassociateWhenNotFound
        self.licenseCount = licenseCount
        self.licenseCountHardLimit = licenseCountHardLimit
        self.licenseCountingType = licenseCountingType
        self.licenseRules = licenseRules
        self.name = name
        self.productInformationList = productInformationList
        self.tags = tags
    }
}

struct CreateLicenseConfigurationInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let licenseCountingType: LicenseCountingType?
    public let licenseCount: Int?
    public let licenseCountHardLimit: Bool?
    public let licenseRules: [String]?
    public let tags: [Tag]?
    public let disassociateWhenNotFound: Bool?
    public let productInformationList: [ProductInformation]?
}

extension CreateLicenseConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case disassociateWhenNotFound = "DisassociateWhenNotFound"
        case licenseCount = "LicenseCount"
        case licenseCountHardLimit = "LicenseCountHardLimit"
        case licenseCountingType = "LicenseCountingType"
        case licenseRules = "LicenseRules"
        case name = "Name"
        case productInformationList = "ProductInformationList"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let licenseCountingTypeDecoded = try containerValues.decodeIfPresent(LicenseCountingType.self, forKey: .licenseCountingType)
        licenseCountingType = licenseCountingTypeDecoded
        let licenseCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .licenseCount)
        licenseCount = licenseCountDecoded
        let licenseCountHardLimitDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .licenseCountHardLimit)
        licenseCountHardLimit = licenseCountHardLimitDecoded
        let licenseRulesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .licenseRules)
        var licenseRulesDecoded0:[String]? = nil
        if let licenseRulesContainer = licenseRulesContainer {
            licenseRulesDecoded0 = [String]()
            for string0 in licenseRulesContainer {
                if let string0 = string0 {
                    licenseRulesDecoded0?.append(string0)
                }
            }
        }
        licenseRules = licenseRulesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let disassociateWhenNotFoundDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .disassociateWhenNotFound)
        disassociateWhenNotFound = disassociateWhenNotFoundDecoded
        let productInformationListContainer = try containerValues.decodeIfPresent([ProductInformation?].self, forKey: .productInformationList)
        var productInformationListDecoded0:[ProductInformation]? = nil
        if let productInformationListContainer = productInformationListContainer {
            productInformationListDecoded0 = [ProductInformation]()
            for structure0 in productInformationListContainer {
                if let structure0 = structure0 {
                    productInformationListDecoded0?.append(structure0)
                }
            }
        }
        productInformationList = productInformationListDecoded0
    }
}

extension CreateLicenseConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLicenseConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLicenseConfigurationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLicenseConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLicenseConfigurationOutputResponse(licenseConfigurationArn: \(String(describing: licenseConfigurationArn)))"}
}

extension CreateLicenseConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateLicenseConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.licenseConfigurationArn = output.licenseConfigurationArn
        } else {
            self.licenseConfigurationArn = nil
        }
    }
}

public struct CreateLicenseConfigurationOutputResponse: Equatable {
    /// <p>Amazon Resource Name (ARN) of the license configuration.</p>
    public let licenseConfigurationArn: String?

    public init (
        licenseConfigurationArn: String? = nil
    )
    {
        self.licenseConfigurationArn = licenseConfigurationArn
    }
}

struct CreateLicenseConfigurationOutputResponseBody: Equatable {
    public let licenseConfigurationArn: String?
}

extension CreateLicenseConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseConfigurationArn)
        licenseConfigurationArn = licenseConfigurationArnDecoded
    }
}

public struct CreateLicenseInputBodyMiddleware: Middleware {
    public let id: String = "CreateLicenseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLicenseInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLicenseInput>
    public typealias MOutput = OperationOutput<CreateLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLicenseOutputError>
}

extension CreateLicenseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLicenseInput(beneficiary: \(String(describing: beneficiary)), clientToken: \(String(describing: clientToken)), consumptionConfiguration: \(String(describing: consumptionConfiguration)), entitlements: \(String(describing: entitlements)), homeRegion: \(String(describing: homeRegion)), issuer: \(String(describing: issuer)), licenseMetadata: \(String(describing: licenseMetadata)), licenseName: \(String(describing: licenseName)), productName: \(String(describing: productName)), productSKU: \(String(describing: productSKU)), validity: \(String(describing: validity)))"}
}

extension CreateLicenseInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case beneficiary = "Beneficiary"
        case clientToken = "ClientToken"
        case consumptionConfiguration = "ConsumptionConfiguration"
        case entitlements = "Entitlements"
        case homeRegion = "HomeRegion"
        case issuer = "Issuer"
        case licenseMetadata = "LicenseMetadata"
        case licenseName = "LicenseName"
        case productName = "ProductName"
        case productSKU = "ProductSKU"
        case validity = "Validity"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beneficiary = beneficiary {
            try encodeContainer.encode(beneficiary, forKey: .beneficiary)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let consumptionConfiguration = consumptionConfiguration {
            try encodeContainer.encode(consumptionConfiguration, forKey: .consumptionConfiguration)
        }
        if let entitlements = entitlements {
            var entitlementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entitlements)
            for entitlementlist0 in entitlements {
                try entitlementsContainer.encode(entitlementlist0)
            }
        }
        if let homeRegion = homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let issuer = issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
        if let licenseMetadata = licenseMetadata {
            var licenseMetadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseMetadata)
            for metadatalist0 in licenseMetadata {
                try licenseMetadataContainer.encode(metadatalist0)
            }
        }
        if let licenseName = licenseName {
            try encodeContainer.encode(licenseName, forKey: .licenseName)
        }
        if let productName = productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let productSKU = productSKU {
            try encodeContainer.encode(productSKU, forKey: .productSKU)
        }
        if let validity = validity {
            try encodeContainer.encode(validity, forKey: .validity)
        }
    }
}

public struct CreateLicenseInputHeadersMiddleware: Middleware {
    public let id: String = "CreateLicenseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLicenseInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLicenseInput>
    public typealias MOutput = OperationOutput<CreateLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLicenseOutputError>
}

public struct CreateLicenseInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateLicenseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLicenseInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLicenseInput>
    public typealias MOutput = OperationOutput<CreateLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLicenseOutputError>
}

public struct CreateLicenseInput: Equatable {
    /// <p>License beneficiary.</p>
    public let beneficiary: String?
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: String?
    /// <p>Configuration for consumption of the license. Choose a provisional configuration for workloads
    ///           running with continuous connectivity. Choose a borrow configuration for workloads with offline
    ///           usage.</p>
    public let consumptionConfiguration: ConsumptionConfiguration?
    /// <p>License entitlements.</p>
    public let entitlements: [Entitlement]?
    /// <p>Home Region for the license.</p>
    public let homeRegion: String?
    /// <p>License issuer.</p>
    public let issuer: Issuer?
    /// <p>Information about the license.</p>
    public let licenseMetadata: [Metadata]?
    /// <p>License name.</p>
    public let licenseName: String?
    /// <p>Product name.</p>
    public let productName: String?
    /// <p>Product SKU.</p>
    public let productSKU: String?
    /// <p>Date and time range during which the license is valid, in ISO8601-UTC format.</p>
    public let validity: DatetimeRange?

    public init (
        beneficiary: String? = nil,
        clientToken: String? = nil,
        consumptionConfiguration: ConsumptionConfiguration? = nil,
        entitlements: [Entitlement]? = nil,
        homeRegion: String? = nil,
        issuer: Issuer? = nil,
        licenseMetadata: [Metadata]? = nil,
        licenseName: String? = nil,
        productName: String? = nil,
        productSKU: String? = nil,
        validity: DatetimeRange? = nil
    )
    {
        self.beneficiary = beneficiary
        self.clientToken = clientToken
        self.consumptionConfiguration = consumptionConfiguration
        self.entitlements = entitlements
        self.homeRegion = homeRegion
        self.issuer = issuer
        self.licenseMetadata = licenseMetadata
        self.licenseName = licenseName
        self.productName = productName
        self.productSKU = productSKU
        self.validity = validity
    }
}

struct CreateLicenseInputBody: Equatable {
    public let licenseName: String?
    public let productName: String?
    public let productSKU: String?
    public let issuer: Issuer?
    public let homeRegion: String?
    public let validity: DatetimeRange?
    public let entitlements: [Entitlement]?
    public let beneficiary: String?
    public let consumptionConfiguration: ConsumptionConfiguration?
    public let licenseMetadata: [Metadata]?
    public let clientToken: String?
}

extension CreateLicenseInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case beneficiary = "Beneficiary"
        case clientToken = "ClientToken"
        case consumptionConfiguration = "ConsumptionConfiguration"
        case entitlements = "Entitlements"
        case homeRegion = "HomeRegion"
        case issuer = "Issuer"
        case licenseMetadata = "LicenseMetadata"
        case licenseName = "LicenseName"
        case productName = "ProductName"
        case productSKU = "ProductSKU"
        case validity = "Validity"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseName)
        licenseName = licenseNameDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productName)
        productName = productNameDecoded
        let productSKUDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productSKU)
        productSKU = productSKUDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(Issuer.self, forKey: .issuer)
        issuer = issuerDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let validityDecoded = try containerValues.decodeIfPresent(DatetimeRange.self, forKey: .validity)
        validity = validityDecoded
        let entitlementsContainer = try containerValues.decodeIfPresent([Entitlement?].self, forKey: .entitlements)
        var entitlementsDecoded0:[Entitlement]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [Entitlement]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let beneficiaryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .beneficiary)
        beneficiary = beneficiaryDecoded
        let consumptionConfigurationDecoded = try containerValues.decodeIfPresent(ConsumptionConfiguration.self, forKey: .consumptionConfiguration)
        consumptionConfiguration = consumptionConfigurationDecoded
        let licenseMetadataContainer = try containerValues.decodeIfPresent([Metadata?].self, forKey: .licenseMetadata)
        var licenseMetadataDecoded0:[Metadata]? = nil
        if let licenseMetadataContainer = licenseMetadataContainer {
            licenseMetadataDecoded0 = [Metadata]()
            for structure0 in licenseMetadataContainer {
                if let structure0 = structure0 {
                    licenseMetadataDecoded0?.append(structure0)
                }
            }
        }
        licenseMetadata = licenseMetadataDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public struct CreateLicenseManagerReportGeneratorInputBodyMiddleware: Middleware {
    public let id: String = "CreateLicenseManagerReportGeneratorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLicenseManagerReportGeneratorInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLicenseManagerReportGeneratorInput>
    public typealias MOutput = OperationOutput<CreateLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLicenseManagerReportGeneratorOutputError>
}

extension CreateLicenseManagerReportGeneratorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLicenseManagerReportGeneratorInput(clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), reportContext: \(String(describing: reportContext)), reportFrequency: \(String(describing: reportFrequency)), reportGeneratorName: \(String(describing: reportGeneratorName)), tags: \(String(describing: tags)), type: \(String(describing: type)))"}
}

extension CreateLicenseManagerReportGeneratorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case reportContext = "ReportContext"
        case reportFrequency = "ReportFrequency"
        case reportGeneratorName = "ReportGeneratorName"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let reportContext = reportContext {
            try encodeContainer.encode(reportContext, forKey: .reportContext)
        }
        if let reportFrequency = reportFrequency {
            try encodeContainer.encode(reportFrequency, forKey: .reportFrequency)
        }
        if let reportGeneratorName = reportGeneratorName {
            try encodeContainer.encode(reportGeneratorName, forKey: .reportGeneratorName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            var typeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .type)
            for reporttypelist0 in type {
                try typeContainer.encode(reporttypelist0.rawValue)
            }
        }
    }
}

public struct CreateLicenseManagerReportGeneratorInputHeadersMiddleware: Middleware {
    public let id: String = "CreateLicenseManagerReportGeneratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLicenseManagerReportGeneratorInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLicenseManagerReportGeneratorInput>
    public typealias MOutput = OperationOutput<CreateLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLicenseManagerReportGeneratorOutputError>
}

public struct CreateLicenseManagerReportGeneratorInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateLicenseManagerReportGeneratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLicenseManagerReportGeneratorInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLicenseManagerReportGeneratorInput>
    public typealias MOutput = OperationOutput<CreateLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLicenseManagerReportGeneratorOutputError>
}

public struct CreateLicenseManagerReportGeneratorInput: Equatable {
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: String?
    /// <p>Description of the report generator.</p>
    public let description: String?
    /// <p>Defines the type of license configuration the report generator tracks.</p>
    public let reportContext: ReportContext?
    /// <p>Frequency by which reports are generated.  Reports can be generated daily, monthly, or weekly.</p>
    public let reportFrequency: ReportFrequency?
    /// <p>Name of the report generator.</p>
    public let reportGeneratorName: String?
    /// <p>Tags to add to the report generator.</p>
    public let tags: [Tag]?
    /// <p>Type of reports to generate. The following report types an be generated:</p>
    ///          <ul>
    ///             <li>
    ///                <p>License configuration report - Reports on the number and details of consumed licenses for a license configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>Resource report - Reports on the tracked licenses and resource consumption for a license configuration.</p>
    ///             </li>
    ///          </ul>
    public let type: [ReportType]?

    public init (
        clientToken: String? = nil,
        description: String? = nil,
        reportContext: ReportContext? = nil,
        reportFrequency: ReportFrequency? = nil,
        reportGeneratorName: String? = nil,
        tags: [Tag]? = nil,
        type: [ReportType]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.reportContext = reportContext
        self.reportFrequency = reportFrequency
        self.reportGeneratorName = reportGeneratorName
        self.tags = tags
        self.type = type
    }
}

struct CreateLicenseManagerReportGeneratorInputBody: Equatable {
    public let reportGeneratorName: String?
    public let type: [ReportType]?
    public let reportContext: ReportContext?
    public let reportFrequency: ReportFrequency?
    public let clientToken: String?
    public let description: String?
    public let tags: [Tag]?
}

extension CreateLicenseManagerReportGeneratorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case reportContext = "ReportContext"
        case reportFrequency = "ReportFrequency"
        case reportGeneratorName = "ReportGeneratorName"
        case tags = "Tags"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportGeneratorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportGeneratorName)
        reportGeneratorName = reportGeneratorNameDecoded
        let typeContainer = try containerValues.decodeIfPresent([ReportType?].self, forKey: .type)
        var typeDecoded0:[ReportType]? = nil
        if let typeContainer = typeContainer {
            typeDecoded0 = [ReportType]()
            for string0 in typeContainer {
                if let string0 = string0 {
                    typeDecoded0?.append(string0)
                }
            }
        }
        type = typeDecoded0
        let reportContextDecoded = try containerValues.decodeIfPresent(ReportContext.self, forKey: .reportContext)
        reportContext = reportContextDecoded
        let reportFrequencyDecoded = try containerValues.decodeIfPresent(ReportFrequency.self, forKey: .reportFrequency)
        reportFrequency = reportFrequencyDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLicenseManagerReportGeneratorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLicenseManagerReportGeneratorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLicenseManagerReportGeneratorOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLicenseManagerReportGeneratorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLicenseManagerReportGeneratorOutputResponse(licenseManagerReportGeneratorArn: \(String(describing: licenseManagerReportGeneratorArn)))"}
}

extension CreateLicenseManagerReportGeneratorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateLicenseManagerReportGeneratorOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.licenseManagerReportGeneratorArn = output.licenseManagerReportGeneratorArn
        } else {
            self.licenseManagerReportGeneratorArn = nil
        }
    }
}

public struct CreateLicenseManagerReportGeneratorOutputResponse: Equatable {
    /// <p>The Amazon Resource Number (ARN) of the new report generator.</p>
    public let licenseManagerReportGeneratorArn: String?

    public init (
        licenseManagerReportGeneratorArn: String? = nil
    )
    {
        self.licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArn
    }
}

struct CreateLicenseManagerReportGeneratorOutputResponseBody: Equatable {
    public let licenseManagerReportGeneratorArn: String?
}

extension CreateLicenseManagerReportGeneratorOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case licenseManagerReportGeneratorArn = "LicenseManagerReportGeneratorArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseManagerReportGeneratorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseManagerReportGeneratorArn)
        licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArnDecoded
    }
}

extension CreateLicenseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLicenseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RedirectException" : self = .redirectException(try RedirectException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLicenseOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case redirectException(RedirectException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLicenseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLicenseOutputResponse(licenseArn: \(String(describing: licenseArn)), status: \(String(describing: status)), version: \(String(describing: version)))"}
}

extension CreateLicenseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateLicenseOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.licenseArn = output.licenseArn
            self.status = output.status
            self.version = output.version
        } else {
            self.licenseArn = nil
            self.status = nil
            self.version = nil
        }
    }
}

public struct CreateLicenseOutputResponse: Equatable {
    /// <p>Amazon Resource Name (ARN) of the license.</p>
    public let licenseArn: String?
    /// <p>License status.</p>
    public let status: LicenseStatus?
    /// <p>License version.</p>
    public let version: String?

    public init (
        licenseArn: String? = nil,
        status: LicenseStatus? = nil,
        version: String? = nil
    )
    {
        self.licenseArn = licenseArn
        self.status = status
        self.version = version
    }
}

struct CreateLicenseOutputResponseBody: Equatable {
    public let licenseArn: String?
    public let status: LicenseStatus?
    public let version: String?
}

extension CreateLicenseOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case licenseArn = "LicenseArn"
        case status = "Status"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseStatus.self, forKey: .status)
        status = statusDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

public struct CreateLicenseVersionInputBodyMiddleware: Middleware {
    public let id: String = "CreateLicenseVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLicenseVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLicenseVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLicenseVersionInput>
    public typealias MOutput = OperationOutput<CreateLicenseVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLicenseVersionOutputError>
}

extension CreateLicenseVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLicenseVersionInput(clientToken: \(String(describing: clientToken)), consumptionConfiguration: \(String(describing: consumptionConfiguration)), entitlements: \(String(describing: entitlements)), homeRegion: \(String(describing: homeRegion)), issuer: \(String(describing: issuer)), licenseArn: \(String(describing: licenseArn)), licenseMetadata: \(String(describing: licenseMetadata)), licenseName: \(String(describing: licenseName)), productName: \(String(describing: productName)), sourceVersion: \(String(describing: sourceVersion)), status: \(String(describing: status)), validity: \(String(describing: validity)))"}
}

extension CreateLicenseVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case consumptionConfiguration = "ConsumptionConfiguration"
        case entitlements = "Entitlements"
        case homeRegion = "HomeRegion"
        case issuer = "Issuer"
        case licenseArn = "LicenseArn"
        case licenseMetadata = "LicenseMetadata"
        case licenseName = "LicenseName"
        case productName = "ProductName"
        case sourceVersion = "SourceVersion"
        case status = "Status"
        case validity = "Validity"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let consumptionConfiguration = consumptionConfiguration {
            try encodeContainer.encode(consumptionConfiguration, forKey: .consumptionConfiguration)
        }
        if let entitlements = entitlements {
            var entitlementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entitlements)
            for entitlementlist0 in entitlements {
                try entitlementsContainer.encode(entitlementlist0)
            }
        }
        if let homeRegion = homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let issuer = issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
        if let licenseArn = licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let licenseMetadata = licenseMetadata {
            var licenseMetadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseMetadata)
            for metadatalist0 in licenseMetadata {
                try licenseMetadataContainer.encode(metadatalist0)
            }
        }
        if let licenseName = licenseName {
            try encodeContainer.encode(licenseName, forKey: .licenseName)
        }
        if let productName = productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let sourceVersion = sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let validity = validity {
            try encodeContainer.encode(validity, forKey: .validity)
        }
    }
}

public struct CreateLicenseVersionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateLicenseVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLicenseVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLicenseVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLicenseVersionInput>
    public typealias MOutput = OperationOutput<CreateLicenseVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLicenseVersionOutputError>
}

public struct CreateLicenseVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateLicenseVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLicenseVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLicenseVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLicenseVersionInput>
    public typealias MOutput = OperationOutput<CreateLicenseVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLicenseVersionOutputError>
}

public struct CreateLicenseVersionInput: Equatable {
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: String?
    /// <p>Configuration for consumption of the license. Choose a provisional configuration for workloads
    ///          running with continuous connectivity. Choose a borrow configuration for workloads with offline
    ///          usage.</p>
    public let consumptionConfiguration: ConsumptionConfiguration?
    /// <p>License entitlements.</p>
    public let entitlements: [Entitlement]?
    /// <p>Home Region of the license.</p>
    public let homeRegion: String?
    /// <p>License issuer.</p>
    public let issuer: Issuer?
    /// <p>Amazon Resource Name (ARN) of the license.</p>
    public let licenseArn: String?
    /// <p>Information about the license.</p>
    public let licenseMetadata: [Metadata]?
    /// <p>License name.</p>
    public let licenseName: String?
    /// <p>Product name.</p>
    public let productName: String?
    /// <p>Current version of the license.</p>
    public let sourceVersion: String?
    /// <p>License status.</p>
    public let status: LicenseStatus?
    /// <p>Date and time range during which the license is valid, in ISO8601-UTC format.</p>
    public let validity: DatetimeRange?

    public init (
        clientToken: String? = nil,
        consumptionConfiguration: ConsumptionConfiguration? = nil,
        entitlements: [Entitlement]? = nil,
        homeRegion: String? = nil,
        issuer: Issuer? = nil,
        licenseArn: String? = nil,
        licenseMetadata: [Metadata]? = nil,
        licenseName: String? = nil,
        productName: String? = nil,
        sourceVersion: String? = nil,
        status: LicenseStatus? = nil,
        validity: DatetimeRange? = nil
    )
    {
        self.clientToken = clientToken
        self.consumptionConfiguration = consumptionConfiguration
        self.entitlements = entitlements
        self.homeRegion = homeRegion
        self.issuer = issuer
        self.licenseArn = licenseArn
        self.licenseMetadata = licenseMetadata
        self.licenseName = licenseName
        self.productName = productName
        self.sourceVersion = sourceVersion
        self.status = status
        self.validity = validity
    }
}

struct CreateLicenseVersionInputBody: Equatable {
    public let licenseArn: String?
    public let licenseName: String?
    public let productName: String?
    public let issuer: Issuer?
    public let homeRegion: String?
    public let validity: DatetimeRange?
    public let licenseMetadata: [Metadata]?
    public let entitlements: [Entitlement]?
    public let consumptionConfiguration: ConsumptionConfiguration?
    public let status: LicenseStatus?
    public let clientToken: String?
    public let sourceVersion: String?
}

extension CreateLicenseVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case consumptionConfiguration = "ConsumptionConfiguration"
        case entitlements = "Entitlements"
        case homeRegion = "HomeRegion"
        case issuer = "Issuer"
        case licenseArn = "LicenseArn"
        case licenseMetadata = "LicenseMetadata"
        case licenseName = "LicenseName"
        case productName = "ProductName"
        case sourceVersion = "SourceVersion"
        case status = "Status"
        case validity = "Validity"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let licenseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseName)
        licenseName = licenseNameDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productName)
        productName = productNameDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(Issuer.self, forKey: .issuer)
        issuer = issuerDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let validityDecoded = try containerValues.decodeIfPresent(DatetimeRange.self, forKey: .validity)
        validity = validityDecoded
        let licenseMetadataContainer = try containerValues.decodeIfPresent([Metadata?].self, forKey: .licenseMetadata)
        var licenseMetadataDecoded0:[Metadata]? = nil
        if let licenseMetadataContainer = licenseMetadataContainer {
            licenseMetadataDecoded0 = [Metadata]()
            for structure0 in licenseMetadataContainer {
                if let structure0 = structure0 {
                    licenseMetadataDecoded0?.append(structure0)
                }
            }
        }
        licenseMetadata = licenseMetadataDecoded0
        let entitlementsContainer = try containerValues.decodeIfPresent([Entitlement?].self, forKey: .entitlements)
        var entitlementsDecoded0:[Entitlement]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [Entitlement]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let consumptionConfigurationDecoded = try containerValues.decodeIfPresent(ConsumptionConfiguration.self, forKey: .consumptionConfiguration)
        consumptionConfiguration = consumptionConfigurationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseStatus.self, forKey: .status)
        status = statusDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let sourceVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
    }
}

extension CreateLicenseVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLicenseVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RedirectException" : self = .redirectException(try RedirectException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLicenseVersionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case conflictException(ConflictException)
    case rateLimitExceededException(RateLimitExceededException)
    case redirectException(RedirectException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLicenseVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLicenseVersionOutputResponse(licenseArn: \(String(describing: licenseArn)), status: \(String(describing: status)), version: \(String(describing: version)))"}
}

extension CreateLicenseVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateLicenseVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.licenseArn = output.licenseArn
            self.status = output.status
            self.version = output.version
        } else {
            self.licenseArn = nil
            self.status = nil
            self.version = nil
        }
    }
}

public struct CreateLicenseVersionOutputResponse: Equatable {
    /// <p>License ARN.</p>
    public let licenseArn: String?
    /// <p>License status.</p>
    public let status: LicenseStatus?
    /// <p>New version of the license.</p>
    public let version: String?

    public init (
        licenseArn: String? = nil,
        status: LicenseStatus? = nil,
        version: String? = nil
    )
    {
        self.licenseArn = licenseArn
        self.status = status
        self.version = version
    }
}

struct CreateLicenseVersionOutputResponseBody: Equatable {
    public let licenseArn: String?
    public let version: String?
    public let status: LicenseStatus?
}

extension CreateLicenseVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case licenseArn = "LicenseArn"
        case status = "Status"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct CreateTokenInputBodyMiddleware: Middleware {
    public let id: String = "CreateTokenInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTokenInput>
    public typealias MOutput = OperationOutput<CreateTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTokenOutputError>
}

extension CreateTokenInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTokenInput(clientToken: \(String(describing: clientToken)), expirationInDays: \(String(describing: expirationInDays)), licenseArn: \(String(describing: licenseArn)), roleArns: \(String(describing: roleArns)), tokenProperties: \(String(describing: tokenProperties)))"}
}

extension CreateTokenInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case expirationInDays = "ExpirationInDays"
        case licenseArn = "LicenseArn"
        case roleArns = "RoleArns"
        case tokenProperties = "TokenProperties"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let expirationInDays = expirationInDays {
            try encodeContainer.encode(expirationInDays, forKey: .expirationInDays)
        }
        if let licenseArn = licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let roleArns = roleArns {
            var roleArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roleArns)
            for arnlist0 in roleArns {
                try roleArnsContainer.encode(arnlist0)
            }
        }
        if let tokenProperties = tokenProperties {
            var tokenPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tokenProperties)
            for maxsize3stringlist0 in tokenProperties {
                try tokenPropertiesContainer.encode(maxsize3stringlist0)
            }
        }
    }
}

public struct CreateTokenInputHeadersMiddleware: Middleware {
    public let id: String = "CreateTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTokenInput>
    public typealias MOutput = OperationOutput<CreateTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTokenOutputError>
}

public struct CreateTokenInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTokenInput>
    public typealias MOutput = OperationOutput<CreateTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTokenOutputError>
}

public struct CreateTokenInput: Equatable {
    /// <p>Idempotency token, valid for 10 minutes.</p>
    public let clientToken: String?
    /// <p>Token expiration, in days, counted from token creation. The default is 365 days.</p>
    public let expirationInDays: Int?
    /// <p>Amazon Resource Name (ARN) of the license. The ARN is mapped to the aud claim of the
    ///           JWT token.</p>
    public let licenseArn: String?
    /// <p>Amazon Resource Name (ARN) of the IAM roles to embed in the token.
    ///          License Manager does not check whether the roles are in use.</p>
    public let roleArns: [String]?
    /// <p>Data specified by the caller to be included in the JWT token. The data is mapped
    ///           to the amr claim of the JWT token.</p>
    public let tokenProperties: [String]?

    public init (
        clientToken: String? = nil,
        expirationInDays: Int? = nil,
        licenseArn: String? = nil,
        roleArns: [String]? = nil,
        tokenProperties: [String]? = nil
    )
    {
        self.clientToken = clientToken
        self.expirationInDays = expirationInDays
        self.licenseArn = licenseArn
        self.roleArns = roleArns
        self.tokenProperties = tokenProperties
    }
}

struct CreateTokenInputBody: Equatable {
    public let licenseArn: String?
    public let roleArns: [String]?
    public let expirationInDays: Int?
    public let tokenProperties: [String]?
    public let clientToken: String?
}

extension CreateTokenInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case expirationInDays = "ExpirationInDays"
        case licenseArn = "LicenseArn"
        case roleArns = "RoleArns"
        case tokenProperties = "TokenProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let roleArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .roleArns)
        var roleArnsDecoded0:[String]? = nil
        if let roleArnsContainer = roleArnsContainer {
            roleArnsDecoded0 = [String]()
            for string0 in roleArnsContainer {
                if let string0 = string0 {
                    roleArnsDecoded0?.append(string0)
                }
            }
        }
        roleArns = roleArnsDecoded0
        let expirationInDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .expirationInDays)
        expirationInDays = expirationInDaysDecoded
        let tokenPropertiesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tokenProperties)
        var tokenPropertiesDecoded0:[String]? = nil
        if let tokenPropertiesContainer = tokenPropertiesContainer {
            tokenPropertiesDecoded0 = [String]()
            for string0 in tokenPropertiesContainer {
                if let string0 = string0 {
                    tokenPropertiesDecoded0?.append(string0)
                }
            }
        }
        tokenProperties = tokenPropertiesDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateTokenOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTokenOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RedirectException" : self = .redirectException(try RedirectException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTokenOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case rateLimitExceededException(RateLimitExceededException)
    case redirectException(RedirectException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTokenOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTokenOutputResponse(token: \(String(describing: token)), tokenId: \(String(describing: tokenId)), tokenType: \(String(describing: tokenType)))"}
}

extension CreateTokenOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateTokenOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.token = output.token
            self.tokenId = output.tokenId
            self.tokenType = output.tokenType
        } else {
            self.token = nil
            self.tokenId = nil
            self.tokenType = nil
        }
    }
}

public struct CreateTokenOutputResponse: Equatable {
    /// <p>Refresh token, encoded as a JWT token.</p>
    public let token: String?
    /// <p>Token ID.</p>
    public let tokenId: String?
    /// <p>Token type.</p>
    public let tokenType: TokenType?

    public init (
        token: String? = nil,
        tokenId: String? = nil,
        tokenType: TokenType? = nil
    )
    {
        self.token = token
        self.tokenId = tokenId
        self.tokenType = tokenType
    }
}

struct CreateTokenOutputResponseBody: Equatable {
    public let tokenId: String?
    public let tokenType: TokenType?
    public let token: String?
}

extension CreateTokenOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case token = "Token"
        case tokenId = "TokenId"
        case tokenType = "TokenType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tokenId)
        tokenId = tokenIdDecoded
        let tokenTypeDecoded = try containerValues.decodeIfPresent(TokenType.self, forKey: .tokenType)
        tokenType = tokenTypeDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .token)
        token = tokenDecoded
    }
}

extension DatetimeRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case begin = "Begin"
        case end = "End"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let begin = begin {
            try encodeContainer.encode(begin, forKey: .begin)
        }
        if let end = end {
            try encodeContainer.encode(end, forKey: .end)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let beginDecoded = try containerValues.decodeIfPresent(String.self, forKey: .begin)
        begin = beginDecoded
        let endDecoded = try containerValues.decodeIfPresent(String.self, forKey: .end)
        end = endDecoded
    }
}

extension DatetimeRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatetimeRange(begin: \(String(describing: begin)), end: \(String(describing: end)))"}
}

/// <p>Describes a time range, in ISO8601-UTC format.</p>
public struct DatetimeRange: Equatable {
    /// <p>Start of the time range.</p>
    public let begin: String?
    /// <p>End of the time range.</p>
    public let end: String?

    public init (
        begin: String? = nil,
        end: String? = nil
    )
    {
        self.begin = begin
        self.end = end
    }
}

public struct DeleteGrantInputBodyMiddleware: Middleware {
    public let id: String = "DeleteGrantInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGrantInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGrantInput>
    public typealias MOutput = OperationOutput<DeleteGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGrantOutputError>
}

extension DeleteGrantInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGrantInput(grantArn: \(String(describing: grantArn)), version: \(String(describing: version)))"}
}

extension DeleteGrantInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grantArn = "GrantArn"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantArn = grantArn {
            try encodeContainer.encode(grantArn, forKey: .grantArn)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

public struct DeleteGrantInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteGrantInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGrantInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGrantInput>
    public typealias MOutput = OperationOutput<DeleteGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGrantOutputError>
}

public struct DeleteGrantInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteGrantInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGrantInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGrantInput>
    public typealias MOutput = OperationOutput<DeleteGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGrantOutputError>
}

public struct DeleteGrantInput: Equatable {
    /// <p>Amazon Resource Name (ARN) of the grant.</p>
    public let grantArn: String?
    /// <p>Current version of the grant.</p>
    public let version: String?

    public init (
        grantArn: String? = nil,
        version: String? = nil
    )
    {
        self.grantArn = grantArn
        self.version = version
    }
}

struct DeleteGrantInputBody: Equatable {
    public let grantArn: String?
    public let version: String?
}

extension DeleteGrantInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case grantArn = "GrantArn"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension DeleteGrantOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGrantOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGrantOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGrantOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGrantOutputResponse(grantArn: \(String(describing: grantArn)), status: \(String(describing: status)), version: \(String(describing: version)))"}
}

extension DeleteGrantOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteGrantOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.grantArn = output.grantArn
            self.status = output.status
            self.version = output.version
        } else {
            self.grantArn = nil
            self.status = nil
            self.version = nil
        }
    }
}

public struct DeleteGrantOutputResponse: Equatable {
    /// <p>Grant ARN.</p>
    public let grantArn: String?
    /// <p>Grant status.</p>
    public let status: GrantStatus?
    /// <p>Grant version.</p>
    public let version: String?

    public init (
        grantArn: String? = nil,
        status: GrantStatus? = nil,
        version: String? = nil
    )
    {
        self.grantArn = grantArn
        self.status = status
        self.version = version
    }
}

struct DeleteGrantOutputResponseBody: Equatable {
    public let grantArn: String?
    public let status: GrantStatus?
    public let version: String?
}

extension DeleteGrantOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case grantArn = "GrantArn"
        case status = "Status"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GrantStatus.self, forKey: .status)
        status = statusDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

public struct DeleteLicenseConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteLicenseConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLicenseConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLicenseConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLicenseConfigurationOutputError>
}

extension DeleteLicenseConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLicenseConfigurationInput(licenseConfigurationArn: \(String(describing: licenseConfigurationArn)))"}
}

extension DeleteLicenseConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseConfigurationArn = licenseConfigurationArn {
            try encodeContainer.encode(licenseConfigurationArn, forKey: .licenseConfigurationArn)
        }
    }
}

public struct DeleteLicenseConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteLicenseConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLicenseConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLicenseConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLicenseConfigurationOutputError>
}

public struct DeleteLicenseConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteLicenseConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLicenseConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLicenseConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLicenseConfigurationOutputError>
}

public struct DeleteLicenseConfigurationInput: Equatable {
    /// <p>ID of the license configuration.</p>
    public let licenseConfigurationArn: String?

    public init (
        licenseConfigurationArn: String? = nil
    )
    {
        self.licenseConfigurationArn = licenseConfigurationArn
    }
}

struct DeleteLicenseConfigurationInputBody: Equatable {
    public let licenseConfigurationArn: String?
}

extension DeleteLicenseConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseConfigurationArn)
        licenseConfigurationArn = licenseConfigurationArnDecoded
    }
}

extension DeleteLicenseConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLicenseConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLicenseConfigurationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLicenseConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLicenseConfigurationOutputResponse()"}
}

extension DeleteLicenseConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLicenseConfigurationOutputResponse: Equatable {

    public init() {}
}

struct DeleteLicenseConfigurationOutputResponseBody: Equatable {
}

extension DeleteLicenseConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteLicenseInputBodyMiddleware: Middleware {
    public let id: String = "DeleteLicenseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLicenseInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLicenseInput>
    public typealias MOutput = OperationOutput<DeleteLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLicenseOutputError>
}

extension DeleteLicenseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLicenseInput(licenseArn: \(String(describing: licenseArn)), sourceVersion: \(String(describing: sourceVersion)))"}
}

extension DeleteLicenseInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case licenseArn = "LicenseArn"
        case sourceVersion = "SourceVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseArn = licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let sourceVersion = sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
    }
}

public struct DeleteLicenseInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteLicenseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLicenseInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLicenseInput>
    public typealias MOutput = OperationOutput<DeleteLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLicenseOutputError>
}

public struct DeleteLicenseInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteLicenseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLicenseInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLicenseInput>
    public typealias MOutput = OperationOutput<DeleteLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLicenseOutputError>
}

public struct DeleteLicenseInput: Equatable {
    /// <p>Amazon Resource Name (ARN) of the license.</p>
    public let licenseArn: String?
    /// <p>Current version of the license.</p>
    public let sourceVersion: String?

    public init (
        licenseArn: String? = nil,
        sourceVersion: String? = nil
    )
    {
        self.licenseArn = licenseArn
        self.sourceVersion = sourceVersion
    }
}

struct DeleteLicenseInputBody: Equatable {
    public let licenseArn: String?
    public let sourceVersion: String?
}

extension DeleteLicenseInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case licenseArn = "LicenseArn"
        case sourceVersion = "SourceVersion"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let sourceVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
    }
}

public struct DeleteLicenseManagerReportGeneratorInputBodyMiddleware: Middleware {
    public let id: String = "DeleteLicenseManagerReportGeneratorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLicenseManagerReportGeneratorInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLicenseManagerReportGeneratorInput>
    public typealias MOutput = OperationOutput<DeleteLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLicenseManagerReportGeneratorOutputError>
}

extension DeleteLicenseManagerReportGeneratorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLicenseManagerReportGeneratorInput(licenseManagerReportGeneratorArn: \(String(describing: licenseManagerReportGeneratorArn)))"}
}

extension DeleteLicenseManagerReportGeneratorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case licenseManagerReportGeneratorArn = "LicenseManagerReportGeneratorArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArn {
            try encodeContainer.encode(licenseManagerReportGeneratorArn, forKey: .licenseManagerReportGeneratorArn)
        }
    }
}

public struct DeleteLicenseManagerReportGeneratorInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteLicenseManagerReportGeneratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLicenseManagerReportGeneratorInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLicenseManagerReportGeneratorInput>
    public typealias MOutput = OperationOutput<DeleteLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLicenseManagerReportGeneratorOutputError>
}

public struct DeleteLicenseManagerReportGeneratorInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteLicenseManagerReportGeneratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLicenseManagerReportGeneratorInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLicenseManagerReportGeneratorInput>
    public typealias MOutput = OperationOutput<DeleteLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLicenseManagerReportGeneratorOutputError>
}

public struct DeleteLicenseManagerReportGeneratorInput: Equatable {
    /// <p>Amazon Resource Number (ARN) of the report generator that will be deleted.</p>
    public let licenseManagerReportGeneratorArn: String?

    public init (
        licenseManagerReportGeneratorArn: String? = nil
    )
    {
        self.licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArn
    }
}

struct DeleteLicenseManagerReportGeneratorInputBody: Equatable {
    public let licenseManagerReportGeneratorArn: String?
}

extension DeleteLicenseManagerReportGeneratorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case licenseManagerReportGeneratorArn = "LicenseManagerReportGeneratorArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseManagerReportGeneratorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseManagerReportGeneratorArn)
        licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArnDecoded
    }
}

extension DeleteLicenseManagerReportGeneratorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLicenseManagerReportGeneratorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLicenseManagerReportGeneratorOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLicenseManagerReportGeneratorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLicenseManagerReportGeneratorOutputResponse()"}
}

extension DeleteLicenseManagerReportGeneratorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLicenseManagerReportGeneratorOutputResponse: Equatable {

    public init() {}
}

struct DeleteLicenseManagerReportGeneratorOutputResponseBody: Equatable {
}

extension DeleteLicenseManagerReportGeneratorOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteLicenseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLicenseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RedirectException" : self = .redirectException(try RedirectException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLicenseOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case conflictException(ConflictException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case redirectException(RedirectException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLicenseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLicenseOutputResponse(deletionDate: \(String(describing: deletionDate)), status: \(String(describing: status)))"}
}

extension DeleteLicenseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteLicenseOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deletionDate = output.deletionDate
            self.status = output.status
        } else {
            self.deletionDate = nil
            self.status = nil
        }
    }
}

public struct DeleteLicenseOutputResponse: Equatable {
    /// <p>Date on which the license is deleted.</p>
    public let deletionDate: String?
    /// <p>License status.</p>
    public let status: LicenseDeletionStatus?

    public init (
        deletionDate: String? = nil,
        status: LicenseDeletionStatus? = nil
    )
    {
        self.deletionDate = deletionDate
        self.status = status
    }
}

struct DeleteLicenseOutputResponseBody: Equatable {
    public let status: LicenseDeletionStatus?
    public let deletionDate: String?
}

extension DeleteLicenseOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deletionDate = "DeletionDate"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(LicenseDeletionStatus.self, forKey: .status)
        status = statusDecoded
        let deletionDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deletionDate)
        deletionDate = deletionDateDecoded
    }
}

public struct DeleteTokenInputBodyMiddleware: Middleware {
    public let id: String = "DeleteTokenInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTokenInput>
    public typealias MOutput = OperationOutput<DeleteTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTokenOutputError>
}

extension DeleteTokenInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTokenInput(tokenId: \(String(describing: tokenId)))"}
}

extension DeleteTokenInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tokenId = "TokenId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tokenId = tokenId {
            try encodeContainer.encode(tokenId, forKey: .tokenId)
        }
    }
}

public struct DeleteTokenInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTokenInput>
    public typealias MOutput = OperationOutput<DeleteTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTokenOutputError>
}

public struct DeleteTokenInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTokenInput>
    public typealias MOutput = OperationOutput<DeleteTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTokenOutputError>
}

public struct DeleteTokenInput: Equatable {
    /// <p>Token ID.</p>
    public let tokenId: String?

    public init (
        tokenId: String? = nil
    )
    {
        self.tokenId = tokenId
    }
}

struct DeleteTokenInputBody: Equatable {
    public let tokenId: String?
}

extension DeleteTokenInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tokenId = "TokenId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tokenId)
        tokenId = tokenIdDecoded
    }
}

extension DeleteTokenOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTokenOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RedirectException" : self = .redirectException(try RedirectException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTokenOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case rateLimitExceededException(RateLimitExceededException)
    case redirectException(RedirectException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTokenOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTokenOutputResponse()"}
}

extension DeleteTokenOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTokenOutputResponse: Equatable {

    public init() {}
}

struct DeleteTokenOutputResponseBody: Equatable {
}

extension DeleteTokenOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum DigitalSignatureMethod {
    case jwtPs384
    case sdkUnknown(String)
}

extension DigitalSignatureMethod : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DigitalSignatureMethod] {
        return [
            .jwtPs384,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .jwtPs384: return "JWT_PS384"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DigitalSignatureMethod(rawValue: rawValue) ?? DigitalSignatureMethod.sdkUnknown(rawValue)
    }
}

extension Entitlement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowCheckIn = "AllowCheckIn"
        case maxCount = "MaxCount"
        case name = "Name"
        case overage = "Overage"
        case unit = "Unit"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowCheckIn = allowCheckIn {
            try encodeContainer.encode(allowCheckIn, forKey: .allowCheckIn)
        }
        if let maxCount = maxCount {
            try encodeContainer.encode(maxCount, forKey: .maxCount)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overage = overage {
            try encodeContainer.encode(overage, forKey: .overage)
        }
        if let unit = unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let maxCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxCount)
        maxCount = maxCountDecoded
        let overageDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .overage)
        overage = overageDecoded
        let unitDecoded = try containerValues.decodeIfPresent(EntitlementUnit.self, forKey: .unit)
        unit = unitDecoded
        let allowCheckInDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowCheckIn)
        allowCheckIn = allowCheckInDecoded
    }
}

extension Entitlement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Entitlement(allowCheckIn: \(String(describing: allowCheckIn)), maxCount: \(String(describing: maxCount)), name: \(String(describing: name)), overage: \(String(describing: overage)), unit: \(String(describing: unit)), value: \(String(describing: value)))"}
}

/// <p>Describes a resource entitled for use with a license.</p>
public struct Entitlement: Equatable {
    /// <p>Indicates whether check-ins are allowed.</p>
    public let allowCheckIn: Bool?
    /// <p>Maximum entitlement count. Use if the unit is not None.</p>
    public let maxCount: Int?
    /// <p>Entitlement name.</p>
    public let name: String?
    /// <p>Indicates whether overages are allowed.</p>
    public let overage: Bool?
    /// <p>Entitlement unit.</p>
    public let unit: EntitlementUnit?
    /// <p>Entitlement resource. Use only if the unit is None.</p>
    public let value: String?

    public init (
        allowCheckIn: Bool? = nil,
        maxCount: Int? = nil,
        name: String? = nil,
        overage: Bool? = nil,
        unit: EntitlementUnit? = nil,
        value: String? = nil
    )
    {
        self.allowCheckIn = allowCheckIn
        self.maxCount = maxCount
        self.name = name
        self.overage = overage
        self.unit = unit
        self.value = value
    }
}

extension EntitlementData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case unit = "Unit"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let unit = unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let unitDecoded = try containerValues.decodeIfPresent(EntitlementDataUnit.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension EntitlementData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntitlementData(name: \(String(describing: name)), unit: \(String(describing: unit)), value: \(String(describing: value)))"}
}

/// <p>Data associated with an entitlement resource.</p>
public struct EntitlementData: Equatable {
    /// <p>Entitlement data name.</p>
    public let name: String?
    /// <p>Entitlement data unit.</p>
    public let unit: EntitlementDataUnit?
    /// <p>Entitlement data value.</p>
    public let value: String?

    public init (
        name: String? = nil,
        unit: EntitlementDataUnit? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.unit = unit
        self.value = value
    }
}

public enum EntitlementDataUnit {
    case bits
    case bitsPerSecond
    case bytes
    case bytesPerSecond
    case count
    case countPerSecond
    case gigabits
    case gigabitsPerSecond
    case gigabytes
    case gigabytesPerSecond
    case kilobits
    case kilobitsPerSecond
    case kilobytes
    case kilobytesPerSecond
    case megabits
    case megabitsPerSecond
    case megabytes
    case megabytesPerSecond
    case microseconds
    case milliseconds
    case `none`
    case percent
    case seconds
    case terabits
    case terabitsPerSecond
    case terabytes
    case terabytesPerSecond
    case sdkUnknown(String)
}

extension EntitlementDataUnit : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EntitlementDataUnit] {
        return [
            .bits,
            .bitsPerSecond,
            .bytes,
            .bytesPerSecond,
            .count,
            .countPerSecond,
            .gigabits,
            .gigabitsPerSecond,
            .gigabytes,
            .gigabytesPerSecond,
            .kilobits,
            .kilobitsPerSecond,
            .kilobytes,
            .kilobytesPerSecond,
            .megabits,
            .megabitsPerSecond,
            .megabytes,
            .megabytesPerSecond,
            .microseconds,
            .milliseconds,
            .none,
            .percent,
            .seconds,
            .terabits,
            .terabitsPerSecond,
            .terabytes,
            .terabytesPerSecond,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bits: return "Bits"
        case .bitsPerSecond: return "Bits/Second"
        case .bytes: return "Bytes"
        case .bytesPerSecond: return "Bytes/Second"
        case .count: return "Count"
        case .countPerSecond: return "Count/Second"
        case .gigabits: return "Gigabits"
        case .gigabitsPerSecond: return "Gigabits/Second"
        case .gigabytes: return "Gigabytes"
        case .gigabytesPerSecond: return "Gigabytes/Second"
        case .kilobits: return "Kilobits"
        case .kilobitsPerSecond: return "Kilobits/Second"
        case .kilobytes: return "Kilobytes"
        case .kilobytesPerSecond: return "Kilobytes/Second"
        case .megabits: return "Megabits"
        case .megabitsPerSecond: return "Megabits/Second"
        case .megabytes: return "Megabytes"
        case .megabytesPerSecond: return "Megabytes/Second"
        case .microseconds: return "Microseconds"
        case .milliseconds: return "Milliseconds"
        case .none: return "None"
        case .percent: return "Percent"
        case .seconds: return "Seconds"
        case .terabits: return "Terabits"
        case .terabitsPerSecond: return "Terabits/Second"
        case .terabytes: return "Terabytes"
        case .terabytesPerSecond: return "Terabytes/Second"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EntitlementDataUnit(rawValue: rawValue) ?? EntitlementDataUnit.sdkUnknown(rawValue)
    }
}

extension EntitlementNotAllowedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntitlementNotAllowedException(message: \(String(describing: message)))"}
}

extension EntitlementNotAllowedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EntitlementNotAllowedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The entitlement is not allowed.</p>
public struct EntitlementNotAllowedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EntitlementNotAllowedExceptionBody: Equatable {
    public let message: String?
}

extension EntitlementNotAllowedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum EntitlementUnit {
    case bits
    case bitsPerSecond
    case bytes
    case bytesPerSecond
    case count
    case countPerSecond
    case gigabits
    case gigabitsPerSecond
    case gigabytes
    case gigabytesPerSecond
    case kilobits
    case kilobitsPerSecond
    case kilobytes
    case kilobytesPerSecond
    case megabits
    case megabitsPerSecond
    case megabytes
    case megabytesPerSecond
    case microseconds
    case milliseconds
    case `none`
    case percent
    case seconds
    case terabits
    case terabitsPerSecond
    case terabytes
    case terabytesPerSecond
    case sdkUnknown(String)
}

extension EntitlementUnit : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EntitlementUnit] {
        return [
            .bits,
            .bitsPerSecond,
            .bytes,
            .bytesPerSecond,
            .count,
            .countPerSecond,
            .gigabits,
            .gigabitsPerSecond,
            .gigabytes,
            .gigabytesPerSecond,
            .kilobits,
            .kilobitsPerSecond,
            .kilobytes,
            .kilobytesPerSecond,
            .megabits,
            .megabitsPerSecond,
            .megabytes,
            .megabytesPerSecond,
            .microseconds,
            .milliseconds,
            .none,
            .percent,
            .seconds,
            .terabits,
            .terabitsPerSecond,
            .terabytes,
            .terabytesPerSecond,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bits: return "Bits"
        case .bitsPerSecond: return "Bits/Second"
        case .bytes: return "Bytes"
        case .bytesPerSecond: return "Bytes/Second"
        case .count: return "Count"
        case .countPerSecond: return "Count/Second"
        case .gigabits: return "Gigabits"
        case .gigabitsPerSecond: return "Gigabits/Second"
        case .gigabytes: return "Gigabytes"
        case .gigabytesPerSecond: return "Gigabytes/Second"
        case .kilobits: return "Kilobits"
        case .kilobitsPerSecond: return "Kilobits/Second"
        case .kilobytes: return "Kilobytes"
        case .kilobytesPerSecond: return "Kilobytes/Second"
        case .megabits: return "Megabits"
        case .megabitsPerSecond: return "Megabits/Second"
        case .megabytes: return "Megabytes"
        case .megabytesPerSecond: return "Megabytes/Second"
        case .microseconds: return "Microseconds"
        case .milliseconds: return "Milliseconds"
        case .none: return "None"
        case .percent: return "Percent"
        case .seconds: return "Seconds"
        case .terabits: return "Terabits"
        case .terabitsPerSecond: return "Terabits/Second"
        case .terabytes: return "Terabytes"
        case .terabytesPerSecond: return "Terabytes/Second"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EntitlementUnit(rawValue: rawValue) ?? EntitlementUnit.sdkUnknown(rawValue)
    }
}

extension EntitlementUsage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case consumedValue = "ConsumedValue"
        case maxCount = "MaxCount"
        case name = "Name"
        case unit = "Unit"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumedValue = consumedValue {
            try encodeContainer.encode(consumedValue, forKey: .consumedValue)
        }
        if let maxCount = maxCount {
            try encodeContainer.encode(maxCount, forKey: .maxCount)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let unit = unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let consumedValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .consumedValue)
        consumedValue = consumedValueDecoded
        let maxCountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxCount)
        maxCount = maxCountDecoded
        let unitDecoded = try containerValues.decodeIfPresent(EntitlementDataUnit.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension EntitlementUsage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntitlementUsage(consumedValue: \(String(describing: consumedValue)), maxCount: \(String(describing: maxCount)), name: \(String(describing: name)), unit: \(String(describing: unit)))"}
}

/// <p>Usage associated with an entitlement resource.</p>
public struct EntitlementUsage: Equatable {
    /// <p>Resource usage consumed.</p>
    public let consumedValue: String?
    /// <p>Maximum entitlement usage count.</p>
    public let maxCount: String?
    /// <p>Entitlement usage name.</p>
    public let name: String?
    /// <p>Entitlement usage unit.</p>
    public let unit: EntitlementDataUnit?

    public init (
        consumedValue: String? = nil,
        maxCount: String? = nil,
        name: String? = nil,
        unit: EntitlementDataUnit? = nil
    )
    {
        self.consumedValue = consumedValue
        self.maxCount = maxCount
        self.name = name
        self.unit = unit
    }
}

public struct ExtendLicenseConsumptionInputBodyMiddleware: Middleware {
    public let id: String = "ExtendLicenseConsumptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExtendLicenseConsumptionInput>,
                  next: H) -> Swift.Result<OperationOutput<ExtendLicenseConsumptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExtendLicenseConsumptionInput>
    public typealias MOutput = OperationOutput<ExtendLicenseConsumptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExtendLicenseConsumptionOutputError>
}

extension ExtendLicenseConsumptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExtendLicenseConsumptionInput(dryRun: \(String(describing: dryRun)), licenseConsumptionToken: \(String(describing: licenseConsumptionToken)))"}
}

extension ExtendLicenseConsumptionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case licenseConsumptionToken = "LicenseConsumptionToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let licenseConsumptionToken = licenseConsumptionToken {
            try encodeContainer.encode(licenseConsumptionToken, forKey: .licenseConsumptionToken)
        }
    }
}

public struct ExtendLicenseConsumptionInputHeadersMiddleware: Middleware {
    public let id: String = "ExtendLicenseConsumptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExtendLicenseConsumptionInput>,
                  next: H) -> Swift.Result<OperationOutput<ExtendLicenseConsumptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExtendLicenseConsumptionInput>
    public typealias MOutput = OperationOutput<ExtendLicenseConsumptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExtendLicenseConsumptionOutputError>
}

public struct ExtendLicenseConsumptionInputQueryItemMiddleware: Middleware {
    public let id: String = "ExtendLicenseConsumptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExtendLicenseConsumptionInput>,
                  next: H) -> Swift.Result<OperationOutput<ExtendLicenseConsumptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExtendLicenseConsumptionInput>
    public typealias MOutput = OperationOutput<ExtendLicenseConsumptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExtendLicenseConsumptionOutputError>
}

public struct ExtendLicenseConsumptionInput: Equatable {
    /// <p>Checks whether you have the required permissions for the action, without actually making the request. Provides an error response if you do not have the required permissions.</p>
    public let dryRun: Bool
    /// <p>License consumption token.</p>
    public let licenseConsumptionToken: String?

    public init (
        dryRun: Bool = false,
        licenseConsumptionToken: String? = nil
    )
    {
        self.dryRun = dryRun
        self.licenseConsumptionToken = licenseConsumptionToken
    }
}

struct ExtendLicenseConsumptionInputBody: Equatable {
    public let licenseConsumptionToken: String?
    public let dryRun: Bool
}

extension ExtendLicenseConsumptionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case licenseConsumptionToken = "LicenseConsumptionToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConsumptionTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseConsumptionToken)
        licenseConsumptionToken = licenseConsumptionTokenDecoded
        let dryRunDecoded = try containerValues.decode(Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension ExtendLicenseConsumptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExtendLicenseConsumptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExtendLicenseConsumptionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExtendLicenseConsumptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExtendLicenseConsumptionOutputResponse(expiration: \(String(describing: expiration)), licenseConsumptionToken: \(String(describing: licenseConsumptionToken)))"}
}

extension ExtendLicenseConsumptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ExtendLicenseConsumptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.expiration = output.expiration
            self.licenseConsumptionToken = output.licenseConsumptionToken
        } else {
            self.expiration = nil
            self.licenseConsumptionToken = nil
        }
    }
}

public struct ExtendLicenseConsumptionOutputResponse: Equatable {
    /// <p>Date and time at which the license consumption expires.</p>
    public let expiration: String?
    /// <p>License consumption token.</p>
    public let licenseConsumptionToken: String?

    public init (
        expiration: String? = nil,
        licenseConsumptionToken: String? = nil
    )
    {
        self.expiration = expiration
        self.licenseConsumptionToken = licenseConsumptionToken
    }
}

struct ExtendLicenseConsumptionOutputResponseBody: Equatable {
    public let licenseConsumptionToken: String?
    public let expiration: String?
}

extension ExtendLicenseConsumptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case expiration = "Expiration"
        case licenseConsumptionToken = "LicenseConsumptionToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConsumptionTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseConsumptionToken)
        licenseConsumptionToken = licenseConsumptionTokenDecoded
        let expirationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expiration)
        expiration = expirationDecoded
    }
}

extension FailedDependencyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FailedDependencyException(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension FailedDependencyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: FailedDependencyExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A dependency required to run the API is missing.</p>
public struct FailedDependencyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var errorCode: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct FailedDependencyExceptionBody: Equatable {
    public let message: String?
    public let errorCode: String?
}

extension FailedDependencyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
    }
}

extension Filter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension Filter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Filter(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>A filter name and value pair that is used to return more specific results from a
///          describe operation. Filters can be used to match a set of resources by specific criteria,
///          such as tags, attributes, or IDs.</p>
public struct Filter: Equatable {
    /// <p>Name of the filter. Filter names are case-sensitive.</p>
    public let name: String?
    /// <p>Filter values. Filter values are case-sensitive.</p>
    public let values: [String]?

    public init (
        name: String? = nil,
        values: [String]? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

extension FilterLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FilterLimitExceededException(message: \(String(describing: message)))"}
}

extension FilterLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: FilterLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request uses too many filters or too many filter values.</p>
public struct FilterLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct FilterLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension FilterLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct GetAccessTokenInputBodyMiddleware: Middleware {
    public let id: String = "GetAccessTokenInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccessTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccessTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccessTokenInput>
    public typealias MOutput = OperationOutput<GetAccessTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccessTokenOutputError>
}

extension GetAccessTokenInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccessTokenInput(token: \(String(describing: token)), tokenProperties: \(String(describing: tokenProperties)))"}
}

extension GetAccessTokenInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case token = "Token"
        case tokenProperties = "TokenProperties"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let token = token {
            try encodeContainer.encode(token, forKey: .token)
        }
        if let tokenProperties = tokenProperties {
            var tokenPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tokenProperties)
            for maxsize3stringlist0 in tokenProperties {
                try tokenPropertiesContainer.encode(maxsize3stringlist0)
            }
        }
    }
}

public struct GetAccessTokenInputHeadersMiddleware: Middleware {
    public let id: String = "GetAccessTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccessTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccessTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccessTokenInput>
    public typealias MOutput = OperationOutput<GetAccessTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccessTokenOutputError>
}

public struct GetAccessTokenInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAccessTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccessTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccessTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccessTokenInput>
    public typealias MOutput = OperationOutput<GetAccessTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccessTokenOutputError>
}

public struct GetAccessTokenInput: Equatable {
    /// <p>Refresh token, encoded as a JWT token.</p>
    public let token: String?
    /// <p>Token properties to validate against those present in the JWT token.</p>
    public let tokenProperties: [String]?

    public init (
        token: String? = nil,
        tokenProperties: [String]? = nil
    )
    {
        self.token = token
        self.tokenProperties = tokenProperties
    }
}

struct GetAccessTokenInputBody: Equatable {
    public let token: String?
    public let tokenProperties: [String]?
}

extension GetAccessTokenInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case token = "Token"
        case tokenProperties = "TokenProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .token)
        token = tokenDecoded
        let tokenPropertiesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tokenProperties)
        var tokenPropertiesDecoded0:[String]? = nil
        if let tokenPropertiesContainer = tokenPropertiesContainer {
            tokenPropertiesDecoded0 = [String]()
            for string0 in tokenPropertiesContainer {
                if let string0 = string0 {
                    tokenPropertiesDecoded0?.append(string0)
                }
            }
        }
        tokenProperties = tokenPropertiesDecoded0
    }
}

extension GetAccessTokenOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccessTokenOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccessTokenOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccessTokenOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccessTokenOutputResponse(accessToken: \(String(describing: accessToken)))"}
}

extension GetAccessTokenOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAccessTokenOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accessToken = output.accessToken
        } else {
            self.accessToken = nil
        }
    }
}

public struct GetAccessTokenOutputResponse: Equatable {
    /// <p>Temporary access token.</p>
    public let accessToken: String?

    public init (
        accessToken: String? = nil
    )
    {
        self.accessToken = accessToken
    }
}

struct GetAccessTokenOutputResponseBody: Equatable {
    public let accessToken: String?
}

extension GetAccessTokenOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
    }
}

public struct GetGrantInputBodyMiddleware: Middleware {
    public let id: String = "GetGrantInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGrantInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGrantInput>
    public typealias MOutput = OperationOutput<GetGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGrantOutputError>
}

extension GetGrantInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGrantInput(grantArn: \(String(describing: grantArn)), version: \(String(describing: version)))"}
}

extension GetGrantInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grantArn = "GrantArn"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantArn = grantArn {
            try encodeContainer.encode(grantArn, forKey: .grantArn)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

public struct GetGrantInputHeadersMiddleware: Middleware {
    public let id: String = "GetGrantInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGrantInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGrantInput>
    public typealias MOutput = OperationOutput<GetGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGrantOutputError>
}

public struct GetGrantInputQueryItemMiddleware: Middleware {
    public let id: String = "GetGrantInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGrantInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGrantInput>
    public typealias MOutput = OperationOutput<GetGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGrantOutputError>
}

public struct GetGrantInput: Equatable {
    /// <p>Amazon Resource Name (ARN) of the grant.</p>
    public let grantArn: String?
    /// <p>Grant version.</p>
    public let version: String?

    public init (
        grantArn: String? = nil,
        version: String? = nil
    )
    {
        self.grantArn = grantArn
        self.version = version
    }
}

struct GetGrantInputBody: Equatable {
    public let grantArn: String?
    public let version: String?
}

extension GetGrantInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case grantArn = "GrantArn"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension GetGrantOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGrantOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetGrantOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGrantOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGrantOutputResponse(grant: \(String(describing: grant)))"}
}

extension GetGrantOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetGrantOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.grant = output.grant
        } else {
            self.grant = nil
        }
    }
}

public struct GetGrantOutputResponse: Equatable {
    /// <p>Grant details.</p>
    public let grant: Grant?

    public init (
        grant: Grant? = nil
    )
    {
        self.grant = grant
    }
}

struct GetGrantOutputResponseBody: Equatable {
    public let grant: Grant?
}

extension GetGrantOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case grant = "Grant"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantDecoded = try containerValues.decodeIfPresent(Grant.self, forKey: .grant)
        grant = grantDecoded
    }
}

public struct GetLicenseConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "GetLicenseConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLicenseConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLicenseConfigurationInput>
    public typealias MOutput = OperationOutput<GetLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLicenseConfigurationOutputError>
}

extension GetLicenseConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLicenseConfigurationInput(licenseConfigurationArn: \(String(describing: licenseConfigurationArn)))"}
}

extension GetLicenseConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseConfigurationArn = licenseConfigurationArn {
            try encodeContainer.encode(licenseConfigurationArn, forKey: .licenseConfigurationArn)
        }
    }
}

public struct GetLicenseConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetLicenseConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLicenseConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLicenseConfigurationInput>
    public typealias MOutput = OperationOutput<GetLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLicenseConfigurationOutputError>
}

public struct GetLicenseConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLicenseConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLicenseConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLicenseConfigurationInput>
    public typealias MOutput = OperationOutput<GetLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLicenseConfigurationOutputError>
}

public struct GetLicenseConfigurationInput: Equatable {
    /// <p>Amazon Resource Name (ARN) of the license configuration.</p>
    public let licenseConfigurationArn: String?

    public init (
        licenseConfigurationArn: String? = nil
    )
    {
        self.licenseConfigurationArn = licenseConfigurationArn
    }
}

struct GetLicenseConfigurationInputBody: Equatable {
    public let licenseConfigurationArn: String?
}

extension GetLicenseConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseConfigurationArn)
        licenseConfigurationArn = licenseConfigurationArnDecoded
    }
}

extension GetLicenseConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLicenseConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLicenseConfigurationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLicenseConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLicenseConfigurationOutputResponse(automatedDiscoveryInformation: \(String(describing: automatedDiscoveryInformation)), consumedLicenseSummaryList: \(String(describing: consumedLicenseSummaryList)), consumedLicenses: \(String(describing: consumedLicenses)), description: \(String(describing: description)), disassociateWhenNotFound: \(String(describing: disassociateWhenNotFound)), licenseConfigurationArn: \(String(describing: licenseConfigurationArn)), licenseConfigurationId: \(String(describing: licenseConfigurationId)), licenseCount: \(String(describing: licenseCount)), licenseCountHardLimit: \(String(describing: licenseCountHardLimit)), licenseCountingType: \(String(describing: licenseCountingType)), licenseRules: \(String(describing: licenseRules)), managedResourceSummaryList: \(String(describing: managedResourceSummaryList)), name: \(String(describing: name)), ownerAccountId: \(String(describing: ownerAccountId)), productInformationList: \(String(describing: productInformationList)), status: \(String(describing: status)), tags: \(String(describing: tags)))"}
}

extension GetLicenseConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetLicenseConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.automatedDiscoveryInformation = output.automatedDiscoveryInformation
            self.consumedLicenseSummaryList = output.consumedLicenseSummaryList
            self.consumedLicenses = output.consumedLicenses
            self.description = output.description
            self.disassociateWhenNotFound = output.disassociateWhenNotFound
            self.licenseConfigurationArn = output.licenseConfigurationArn
            self.licenseConfigurationId = output.licenseConfigurationId
            self.licenseCount = output.licenseCount
            self.licenseCountHardLimit = output.licenseCountHardLimit
            self.licenseCountingType = output.licenseCountingType
            self.licenseRules = output.licenseRules
            self.managedResourceSummaryList = output.managedResourceSummaryList
            self.name = output.name
            self.ownerAccountId = output.ownerAccountId
            self.productInformationList = output.productInformationList
            self.status = output.status
            self.tags = output.tags
        } else {
            self.automatedDiscoveryInformation = nil
            self.consumedLicenseSummaryList = nil
            self.consumedLicenses = nil
            self.description = nil
            self.disassociateWhenNotFound = nil
            self.licenseConfigurationArn = nil
            self.licenseConfigurationId = nil
            self.licenseCount = nil
            self.licenseCountHardLimit = nil
            self.licenseCountingType = nil
            self.licenseRules = nil
            self.managedResourceSummaryList = nil
            self.name = nil
            self.ownerAccountId = nil
            self.productInformationList = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct GetLicenseConfigurationOutputResponse: Equatable {
    /// <p>Automated discovery information.</p>
    public let automatedDiscoveryInformation: AutomatedDiscoveryInformation?
    /// <p>Summaries of the licenses consumed by resources.</p>
    public let consumedLicenseSummaryList: [ConsumedLicenseSummary]?
    /// <p>Number of licenses assigned to resources.</p>
    public let consumedLicenses: Int?
    /// <p>Description of the license configuration.</p>
    public let description: String?
    /// <p>When true, disassociates a resource when software is uninstalled.</p>
    public let disassociateWhenNotFound: Bool?
    /// <p>Amazon Resource Name (ARN) of the license configuration.</p>
    public let licenseConfigurationArn: String?
    /// <p>Unique ID for the license configuration.</p>
    public let licenseConfigurationId: String?
    /// <p>Number of available licenses.</p>
    public let licenseCount: Int?
    /// <p>Sets the number of available licenses as a hard limit.</p>
    public let licenseCountHardLimit: Bool?
    /// <p>Dimension on which the licenses are counted.</p>
    public let licenseCountingType: LicenseCountingType?
    /// <p>License rules.</p>
    public let licenseRules: [String]?
    /// <p>Summaries of the managed resources.</p>
    public let managedResourceSummaryList: [ManagedResourceSummary]?
    /// <p>Name of the license configuration.</p>
    public let name: String?
    /// <p>Account ID of the owner of the license configuration.</p>
    public let ownerAccountId: String?
    /// <p>Product information.</p>
    public let productInformationList: [ProductInformation]?
    /// <p>License configuration status.</p>
    public let status: String?
    /// <p>Tags for the license configuration.</p>
    public let tags: [Tag]?

    public init (
        automatedDiscoveryInformation: AutomatedDiscoveryInformation? = nil,
        consumedLicenseSummaryList: [ConsumedLicenseSummary]? = nil,
        consumedLicenses: Int? = nil,
        description: String? = nil,
        disassociateWhenNotFound: Bool? = nil,
        licenseConfigurationArn: String? = nil,
        licenseConfigurationId: String? = nil,
        licenseCount: Int? = nil,
        licenseCountHardLimit: Bool? = nil,
        licenseCountingType: LicenseCountingType? = nil,
        licenseRules: [String]? = nil,
        managedResourceSummaryList: [ManagedResourceSummary]? = nil,
        name: String? = nil,
        ownerAccountId: String? = nil,
        productInformationList: [ProductInformation]? = nil,
        status: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.automatedDiscoveryInformation = automatedDiscoveryInformation
        self.consumedLicenseSummaryList = consumedLicenseSummaryList
        self.consumedLicenses = consumedLicenses
        self.description = description
        self.disassociateWhenNotFound = disassociateWhenNotFound
        self.licenseConfigurationArn = licenseConfigurationArn
        self.licenseConfigurationId = licenseConfigurationId
        self.licenseCount = licenseCount
        self.licenseCountHardLimit = licenseCountHardLimit
        self.licenseCountingType = licenseCountingType
        self.licenseRules = licenseRules
        self.managedResourceSummaryList = managedResourceSummaryList
        self.name = name
        self.ownerAccountId = ownerAccountId
        self.productInformationList = productInformationList
        self.status = status
        self.tags = tags
    }
}

struct GetLicenseConfigurationOutputResponseBody: Equatable {
    public let licenseConfigurationId: String?
    public let licenseConfigurationArn: String?
    public let name: String?
    public let description: String?
    public let licenseCountingType: LicenseCountingType?
    public let licenseRules: [String]?
    public let licenseCount: Int?
    public let licenseCountHardLimit: Bool?
    public let consumedLicenses: Int?
    public let status: String?
    public let ownerAccountId: String?
    public let consumedLicenseSummaryList: [ConsumedLicenseSummary]?
    public let managedResourceSummaryList: [ManagedResourceSummary]?
    public let tags: [Tag]?
    public let productInformationList: [ProductInformation]?
    public let automatedDiscoveryInformation: AutomatedDiscoveryInformation?
    public let disassociateWhenNotFound: Bool?
}

extension GetLicenseConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case automatedDiscoveryInformation = "AutomatedDiscoveryInformation"
        case consumedLicenseSummaryList = "ConsumedLicenseSummaryList"
        case consumedLicenses = "ConsumedLicenses"
        case description = "Description"
        case disassociateWhenNotFound = "DisassociateWhenNotFound"
        case licenseConfigurationArn = "LicenseConfigurationArn"
        case licenseConfigurationId = "LicenseConfigurationId"
        case licenseCount = "LicenseCount"
        case licenseCountHardLimit = "LicenseCountHardLimit"
        case licenseCountingType = "LicenseCountingType"
        case licenseRules = "LicenseRules"
        case managedResourceSummaryList = "ManagedResourceSummaryList"
        case name = "Name"
        case ownerAccountId = "OwnerAccountId"
        case productInformationList = "ProductInformationList"
        case status = "Status"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseConfigurationId)
        licenseConfigurationId = licenseConfigurationIdDecoded
        let licenseConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseConfigurationArn)
        licenseConfigurationArn = licenseConfigurationArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let licenseCountingTypeDecoded = try containerValues.decodeIfPresent(LicenseCountingType.self, forKey: .licenseCountingType)
        licenseCountingType = licenseCountingTypeDecoded
        let licenseRulesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .licenseRules)
        var licenseRulesDecoded0:[String]? = nil
        if let licenseRulesContainer = licenseRulesContainer {
            licenseRulesDecoded0 = [String]()
            for string0 in licenseRulesContainer {
                if let string0 = string0 {
                    licenseRulesDecoded0?.append(string0)
                }
            }
        }
        licenseRules = licenseRulesDecoded0
        let licenseCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .licenseCount)
        licenseCount = licenseCountDecoded
        let licenseCountHardLimitDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .licenseCountHardLimit)
        licenseCountHardLimit = licenseCountHardLimitDecoded
        let consumedLicensesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .consumedLicenses)
        consumedLicenses = consumedLicensesDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let consumedLicenseSummaryListContainer = try containerValues.decodeIfPresent([ConsumedLicenseSummary?].self, forKey: .consumedLicenseSummaryList)
        var consumedLicenseSummaryListDecoded0:[ConsumedLicenseSummary]? = nil
        if let consumedLicenseSummaryListContainer = consumedLicenseSummaryListContainer {
            consumedLicenseSummaryListDecoded0 = [ConsumedLicenseSummary]()
            for structure0 in consumedLicenseSummaryListContainer {
                if let structure0 = structure0 {
                    consumedLicenseSummaryListDecoded0?.append(structure0)
                }
            }
        }
        consumedLicenseSummaryList = consumedLicenseSummaryListDecoded0
        let managedResourceSummaryListContainer = try containerValues.decodeIfPresent([ManagedResourceSummary?].self, forKey: .managedResourceSummaryList)
        var managedResourceSummaryListDecoded0:[ManagedResourceSummary]? = nil
        if let managedResourceSummaryListContainer = managedResourceSummaryListContainer {
            managedResourceSummaryListDecoded0 = [ManagedResourceSummary]()
            for structure0 in managedResourceSummaryListContainer {
                if let structure0 = structure0 {
                    managedResourceSummaryListDecoded0?.append(structure0)
                }
            }
        }
        managedResourceSummaryList = managedResourceSummaryListDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let productInformationListContainer = try containerValues.decodeIfPresent([ProductInformation?].self, forKey: .productInformationList)
        var productInformationListDecoded0:[ProductInformation]? = nil
        if let productInformationListContainer = productInformationListContainer {
            productInformationListDecoded0 = [ProductInformation]()
            for structure0 in productInformationListContainer {
                if let structure0 = structure0 {
                    productInformationListDecoded0?.append(structure0)
                }
            }
        }
        productInformationList = productInformationListDecoded0
        let automatedDiscoveryInformationDecoded = try containerValues.decodeIfPresent(AutomatedDiscoveryInformation.self, forKey: .automatedDiscoveryInformation)
        automatedDiscoveryInformation = automatedDiscoveryInformationDecoded
        let disassociateWhenNotFoundDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .disassociateWhenNotFound)
        disassociateWhenNotFound = disassociateWhenNotFoundDecoded
    }
}

public struct GetLicenseInputBodyMiddleware: Middleware {
    public let id: String = "GetLicenseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLicenseInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLicenseInput>
    public typealias MOutput = OperationOutput<GetLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLicenseOutputError>
}

extension GetLicenseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLicenseInput(licenseArn: \(String(describing: licenseArn)), version: \(String(describing: version)))"}
}

extension GetLicenseInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case licenseArn = "LicenseArn"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseArn = licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

public struct GetLicenseInputHeadersMiddleware: Middleware {
    public let id: String = "GetLicenseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLicenseInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLicenseInput>
    public typealias MOutput = OperationOutput<GetLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLicenseOutputError>
}

public struct GetLicenseInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLicenseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLicenseInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLicenseInput>
    public typealias MOutput = OperationOutput<GetLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLicenseOutputError>
}

public struct GetLicenseInput: Equatable {
    /// <p>Amazon Resource Name (ARN) of the license.</p>
    public let licenseArn: String?
    /// <p>License version.</p>
    public let version: String?

    public init (
        licenseArn: String? = nil,
        version: String? = nil
    )
    {
        self.licenseArn = licenseArn
        self.version = version
    }
}

struct GetLicenseInputBody: Equatable {
    public let licenseArn: String?
    public let version: String?
}

extension GetLicenseInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case licenseArn = "LicenseArn"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

public struct GetLicenseManagerReportGeneratorInputBodyMiddleware: Middleware {
    public let id: String = "GetLicenseManagerReportGeneratorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLicenseManagerReportGeneratorInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLicenseManagerReportGeneratorInput>
    public typealias MOutput = OperationOutput<GetLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLicenseManagerReportGeneratorOutputError>
}

extension GetLicenseManagerReportGeneratorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLicenseManagerReportGeneratorInput(licenseManagerReportGeneratorArn: \(String(describing: licenseManagerReportGeneratorArn)))"}
}

extension GetLicenseManagerReportGeneratorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case licenseManagerReportGeneratorArn = "LicenseManagerReportGeneratorArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArn {
            try encodeContainer.encode(licenseManagerReportGeneratorArn, forKey: .licenseManagerReportGeneratorArn)
        }
    }
}

public struct GetLicenseManagerReportGeneratorInputHeadersMiddleware: Middleware {
    public let id: String = "GetLicenseManagerReportGeneratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLicenseManagerReportGeneratorInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLicenseManagerReportGeneratorInput>
    public typealias MOutput = OperationOutput<GetLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLicenseManagerReportGeneratorOutputError>
}

public struct GetLicenseManagerReportGeneratorInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLicenseManagerReportGeneratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLicenseManagerReportGeneratorInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLicenseManagerReportGeneratorInput>
    public typealias MOutput = OperationOutput<GetLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLicenseManagerReportGeneratorOutputError>
}

public struct GetLicenseManagerReportGeneratorInput: Equatable {
    /// <p>mazon Resource Number (ARN) of the report generator to retrieve information on.</p>
    public let licenseManagerReportGeneratorArn: String?

    public init (
        licenseManagerReportGeneratorArn: String? = nil
    )
    {
        self.licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArn
    }
}

struct GetLicenseManagerReportGeneratorInputBody: Equatable {
    public let licenseManagerReportGeneratorArn: String?
}

extension GetLicenseManagerReportGeneratorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case licenseManagerReportGeneratorArn = "LicenseManagerReportGeneratorArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseManagerReportGeneratorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseManagerReportGeneratorArn)
        licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArnDecoded
    }
}

extension GetLicenseManagerReportGeneratorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLicenseManagerReportGeneratorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLicenseManagerReportGeneratorOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLicenseManagerReportGeneratorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLicenseManagerReportGeneratorOutputResponse(reportGenerator: \(String(describing: reportGenerator)))"}
}

extension GetLicenseManagerReportGeneratorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetLicenseManagerReportGeneratorOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.reportGenerator = output.reportGenerator
        } else {
            self.reportGenerator = nil
        }
    }
}

public struct GetLicenseManagerReportGeneratorOutputResponse: Equatable {
    /// <p>A report generator that creates periodic reports on your license configurations.</p>
    public let reportGenerator: ReportGenerator?

    public init (
        reportGenerator: ReportGenerator? = nil
    )
    {
        self.reportGenerator = reportGenerator
    }
}

struct GetLicenseManagerReportGeneratorOutputResponseBody: Equatable {
    public let reportGenerator: ReportGenerator?
}

extension GetLicenseManagerReportGeneratorOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case reportGenerator = "ReportGenerator"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportGeneratorDecoded = try containerValues.decodeIfPresent(ReportGenerator.self, forKey: .reportGenerator)
        reportGenerator = reportGeneratorDecoded
    }
}

extension GetLicenseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLicenseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLicenseOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLicenseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLicenseOutputResponse(license: \(String(describing: license)))"}
}

extension GetLicenseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetLicenseOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.license = output.license
        } else {
            self.license = nil
        }
    }
}

public struct GetLicenseOutputResponse: Equatable {
    /// <p>License details.</p>
    public let license: License?

    public init (
        license: License? = nil
    )
    {
        self.license = license
    }
}

struct GetLicenseOutputResponseBody: Equatable {
    public let license: License?
}

extension GetLicenseOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case license = "License"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseDecoded = try containerValues.decodeIfPresent(License.self, forKey: .license)
        license = licenseDecoded
    }
}

public struct GetLicenseUsageInputBodyMiddleware: Middleware {
    public let id: String = "GetLicenseUsageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLicenseUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLicenseUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLicenseUsageInput>
    public typealias MOutput = OperationOutput<GetLicenseUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLicenseUsageOutputError>
}

extension GetLicenseUsageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLicenseUsageInput(licenseArn: \(String(describing: licenseArn)))"}
}

extension GetLicenseUsageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case licenseArn = "LicenseArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseArn = licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
    }
}

public struct GetLicenseUsageInputHeadersMiddleware: Middleware {
    public let id: String = "GetLicenseUsageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLicenseUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLicenseUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLicenseUsageInput>
    public typealias MOutput = OperationOutput<GetLicenseUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLicenseUsageOutputError>
}

public struct GetLicenseUsageInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLicenseUsageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLicenseUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLicenseUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLicenseUsageInput>
    public typealias MOutput = OperationOutput<GetLicenseUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLicenseUsageOutputError>
}

public struct GetLicenseUsageInput: Equatable {
    /// <p>Amazon Resource Name (ARN) of the license.</p>
    public let licenseArn: String?

    public init (
        licenseArn: String? = nil
    )
    {
        self.licenseArn = licenseArn
    }
}

struct GetLicenseUsageInputBody: Equatable {
    public let licenseArn: String?
}

extension GetLicenseUsageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case licenseArn = "LicenseArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
    }
}

extension GetLicenseUsageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLicenseUsageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLicenseUsageOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLicenseUsageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLicenseUsageOutputResponse(licenseUsage: \(String(describing: licenseUsage)))"}
}

extension GetLicenseUsageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetLicenseUsageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.licenseUsage = output.licenseUsage
        } else {
            self.licenseUsage = nil
        }
    }
}

public struct GetLicenseUsageOutputResponse: Equatable {
    /// <p>License usage details.</p>
    public let licenseUsage: LicenseUsage?

    public init (
        licenseUsage: LicenseUsage? = nil
    )
    {
        self.licenseUsage = licenseUsage
    }
}

struct GetLicenseUsageOutputResponseBody: Equatable {
    public let licenseUsage: LicenseUsage?
}

extension GetLicenseUsageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case licenseUsage = "LicenseUsage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseUsageDecoded = try containerValues.decodeIfPresent(LicenseUsage.self, forKey: .licenseUsage)
        licenseUsage = licenseUsageDecoded
    }
}

extension GetServiceSettingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetServiceSettingsInput()"}
}

extension GetServiceSettingsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetServiceSettingsInputHeadersMiddleware: Middleware {
    public let id: String = "GetServiceSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceSettingsInput>
    public typealias MOutput = OperationOutput<GetServiceSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceSettingsOutputError>
}

public struct GetServiceSettingsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetServiceSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceSettingsInput>
    public typealias MOutput = OperationOutput<GetServiceSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceSettingsOutputError>
}

public struct GetServiceSettingsInput: Equatable {

    public init() {}
}

struct GetServiceSettingsInputBody: Equatable {
}

extension GetServiceSettingsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetServiceSettingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceSettingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServiceSettingsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceSettingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetServiceSettingsOutputResponse(enableCrossAccountsDiscovery: \(String(describing: enableCrossAccountsDiscovery)), licenseManagerResourceShareArn: \(String(describing: licenseManagerResourceShareArn)), organizationConfiguration: \(String(describing: organizationConfiguration)), s3BucketArn: \(String(describing: s3BucketArn)), snsTopicArn: \(String(describing: snsTopicArn)))"}
}

extension GetServiceSettingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetServiceSettingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.enableCrossAccountsDiscovery = output.enableCrossAccountsDiscovery
            self.licenseManagerResourceShareArn = output.licenseManagerResourceShareArn
            self.organizationConfiguration = output.organizationConfiguration
            self.s3BucketArn = output.s3BucketArn
            self.snsTopicArn = output.snsTopicArn
        } else {
            self.enableCrossAccountsDiscovery = nil
            self.licenseManagerResourceShareArn = nil
            self.organizationConfiguration = nil
            self.s3BucketArn = nil
            self.snsTopicArn = nil
        }
    }
}

public struct GetServiceSettingsOutputResponse: Equatable {
    /// <p>Indicates whether cross-account discovery is enabled.</p>
    public let enableCrossAccountsDiscovery: Bool?
    /// <p>Amazon Resource Name (ARN) of the AWS resource share. The License Manager management account
    ///          provides member accounts with access to this share.</p>
    public let licenseManagerResourceShareArn: String?
    /// <p>Indicates whether AWS Organizations is integrated with License Manager for
    ///          cross-account discovery.</p>
    public let organizationConfiguration: OrganizationConfiguration?
    /// <p>Regional S3 bucket path for storing reports, license trail event data, discovery data,
    ///          and so on.</p>
    public let s3BucketArn: String?
    /// <p>SNS topic configured to receive notifications from License Manager.</p>
    public let snsTopicArn: String?

    public init (
        enableCrossAccountsDiscovery: Bool? = nil,
        licenseManagerResourceShareArn: String? = nil,
        organizationConfiguration: OrganizationConfiguration? = nil,
        s3BucketArn: String? = nil,
        snsTopicArn: String? = nil
    )
    {
        self.enableCrossAccountsDiscovery = enableCrossAccountsDiscovery
        self.licenseManagerResourceShareArn = licenseManagerResourceShareArn
        self.organizationConfiguration = organizationConfiguration
        self.s3BucketArn = s3BucketArn
        self.snsTopicArn = snsTopicArn
    }
}

struct GetServiceSettingsOutputResponseBody: Equatable {
    public let s3BucketArn: String?
    public let snsTopicArn: String?
    public let organizationConfiguration: OrganizationConfiguration?
    public let enableCrossAccountsDiscovery: Bool?
    public let licenseManagerResourceShareArn: String?
}

extension GetServiceSettingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case enableCrossAccountsDiscovery = "EnableCrossAccountsDiscovery"
        case licenseManagerResourceShareArn = "LicenseManagerResourceShareArn"
        case organizationConfiguration = "OrganizationConfiguration"
        case s3BucketArn = "S3BucketArn"
        case snsTopicArn = "SnsTopicArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketArn)
        s3BucketArn = s3BucketArnDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let organizationConfigurationDecoded = try containerValues.decodeIfPresent(OrganizationConfiguration.self, forKey: .organizationConfiguration)
        organizationConfiguration = organizationConfigurationDecoded
        let enableCrossAccountsDiscoveryDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableCrossAccountsDiscovery)
        enableCrossAccountsDiscovery = enableCrossAccountsDiscoveryDecoded
        let licenseManagerResourceShareArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseManagerResourceShareArn)
        licenseManagerResourceShareArn = licenseManagerResourceShareArnDecoded
    }
}

extension Grant: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grantArn = "GrantArn"
        case grantName = "GrantName"
        case grantStatus = "GrantStatus"
        case grantedOperations = "GrantedOperations"
        case granteePrincipalArn = "GranteePrincipalArn"
        case homeRegion = "HomeRegion"
        case licenseArn = "LicenseArn"
        case parentArn = "ParentArn"
        case statusReason = "StatusReason"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantArn = grantArn {
            try encodeContainer.encode(grantArn, forKey: .grantArn)
        }
        if let grantName = grantName {
            try encodeContainer.encode(grantName, forKey: .grantName)
        }
        if let grantStatus = grantStatus {
            try encodeContainer.encode(grantStatus.rawValue, forKey: .grantStatus)
        }
        if let grantedOperations = grantedOperations {
            var grantedOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantedOperations)
            for allowedoperationlist0 in grantedOperations {
                try grantedOperationsContainer.encode(allowedoperationlist0.rawValue)
            }
        }
        if let granteePrincipalArn = granteePrincipalArn {
            try encodeContainer.encode(granteePrincipalArn, forKey: .granteePrincipalArn)
        }
        if let homeRegion = homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let licenseArn = licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let parentArn = parentArn {
            try encodeContainer.encode(parentArn, forKey: .parentArn)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
        let grantNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grantName)
        grantName = grantNameDecoded
        let parentArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentArn)
        parentArn = parentArnDecoded
        let licenseArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let granteePrincipalArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .granteePrincipalArn)
        granteePrincipalArn = granteePrincipalArnDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let grantStatusDecoded = try containerValues.decodeIfPresent(GrantStatus.self, forKey: .grantStatus)
        grantStatus = grantStatusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let grantedOperationsContainer = try containerValues.decodeIfPresent([AllowedOperation?].self, forKey: .grantedOperations)
        var grantedOperationsDecoded0:[AllowedOperation]? = nil
        if let grantedOperationsContainer = grantedOperationsContainer {
            grantedOperationsDecoded0 = [AllowedOperation]()
            for string0 in grantedOperationsContainer {
                if let string0 = string0 {
                    grantedOperationsDecoded0?.append(string0)
                }
            }
        }
        grantedOperations = grantedOperationsDecoded0
    }
}

extension Grant: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Grant(grantArn: \(String(describing: grantArn)), grantName: \(String(describing: grantName)), grantStatus: \(String(describing: grantStatus)), grantedOperations: \(String(describing: grantedOperations)), granteePrincipalArn: \(String(describing: granteePrincipalArn)), homeRegion: \(String(describing: homeRegion)), licenseArn: \(String(describing: licenseArn)), parentArn: \(String(describing: parentArn)), statusReason: \(String(describing: statusReason)), version: \(String(describing: version)))"}
}

/// <p>Describes a grant.</p>
public struct Grant: Equatable {
    /// <p>Amazon Resource Name (ARN) of the grant.</p>
    public let grantArn: String?
    /// <p>Grant name.</p>
    public let grantName: String?
    /// <p>Grant status.</p>
    public let grantStatus: GrantStatus?
    /// <p>Granted operations.</p>
    public let grantedOperations: [AllowedOperation]?
    /// <p>The grantee principal ARN.</p>
    public let granteePrincipalArn: String?
    /// <p>Home Region of the grant.</p>
    public let homeRegion: String?
    /// <p>License ARN.</p>
    public let licenseArn: String?
    /// <p>Parent ARN.</p>
    public let parentArn: String?
    /// <p>Grant status reason.</p>
    public let statusReason: String?
    /// <p>Grant version.</p>
    public let version: String?

    public init (
        grantArn: String? = nil,
        grantName: String? = nil,
        grantStatus: GrantStatus? = nil,
        grantedOperations: [AllowedOperation]? = nil,
        granteePrincipalArn: String? = nil,
        homeRegion: String? = nil,
        licenseArn: String? = nil,
        parentArn: String? = nil,
        statusReason: String? = nil,
        version: String? = nil
    )
    {
        self.grantArn = grantArn
        self.grantName = grantName
        self.grantStatus = grantStatus
        self.grantedOperations = grantedOperations
        self.granteePrincipalArn = granteePrincipalArn
        self.homeRegion = homeRegion
        self.licenseArn = licenseArn
        self.parentArn = parentArn
        self.statusReason = statusReason
        self.version = version
    }
}

public enum GrantStatus {
    case active
    case deleted
    case disabled
    case failedWorkflow
    case pendingAccept
    case pendingDelete
    case pendingWorkflow
    case rejected
    case sdkUnknown(String)
}

extension GrantStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [GrantStatus] {
        return [
            .active,
            .deleted,
            .disabled,
            .failedWorkflow,
            .pendingAccept,
            .pendingDelete,
            .pendingWorkflow,
            .rejected,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .deleted: return "DELETED"
        case .disabled: return "DISABLED"
        case .failedWorkflow: return "FAILED_WORKFLOW"
        case .pendingAccept: return "PENDING_ACCEPT"
        case .pendingDelete: return "PENDING_DELETE"
        case .pendingWorkflow: return "PENDING_WORKFLOW"
        case .rejected: return "REJECTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = GrantStatus(rawValue: rawValue) ?? GrantStatus.sdkUnknown(rawValue)
    }
}

extension GrantedLicense: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case beneficiary = "Beneficiary"
        case consumptionConfiguration = "ConsumptionConfiguration"
        case createTime = "CreateTime"
        case entitlements = "Entitlements"
        case homeRegion = "HomeRegion"
        case issuer = "Issuer"
        case licenseArn = "LicenseArn"
        case licenseMetadata = "LicenseMetadata"
        case licenseName = "LicenseName"
        case productName = "ProductName"
        case productSKU = "ProductSKU"
        case receivedMetadata = "ReceivedMetadata"
        case status = "Status"
        case validity = "Validity"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beneficiary = beneficiary {
            try encodeContainer.encode(beneficiary, forKey: .beneficiary)
        }
        if let consumptionConfiguration = consumptionConfiguration {
            try encodeContainer.encode(consumptionConfiguration, forKey: .consumptionConfiguration)
        }
        if let createTime = createTime {
            try encodeContainer.encode(createTime, forKey: .createTime)
        }
        if let entitlements = entitlements {
            var entitlementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entitlements)
            for entitlementlist0 in entitlements {
                try entitlementsContainer.encode(entitlementlist0)
            }
        }
        if let homeRegion = homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let issuer = issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
        if let licenseArn = licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let licenseMetadata = licenseMetadata {
            var licenseMetadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseMetadata)
            for metadatalist0 in licenseMetadata {
                try licenseMetadataContainer.encode(metadatalist0)
            }
        }
        if let licenseName = licenseName {
            try encodeContainer.encode(licenseName, forKey: .licenseName)
        }
        if let productName = productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let productSKU = productSKU {
            try encodeContainer.encode(productSKU, forKey: .productSKU)
        }
        if let receivedMetadata = receivedMetadata {
            try encodeContainer.encode(receivedMetadata, forKey: .receivedMetadata)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let validity = validity {
            try encodeContainer.encode(validity, forKey: .validity)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let licenseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseName)
        licenseName = licenseNameDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productName)
        productName = productNameDecoded
        let productSKUDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productSKU)
        productSKU = productSKUDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(IssuerDetails.self, forKey: .issuer)
        issuer = issuerDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseStatus.self, forKey: .status)
        status = statusDecoded
        let validityDecoded = try containerValues.decodeIfPresent(DatetimeRange.self, forKey: .validity)
        validity = validityDecoded
        let beneficiaryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .beneficiary)
        beneficiary = beneficiaryDecoded
        let entitlementsContainer = try containerValues.decodeIfPresent([Entitlement?].self, forKey: .entitlements)
        var entitlementsDecoded0:[Entitlement]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [Entitlement]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let consumptionConfigurationDecoded = try containerValues.decodeIfPresent(ConsumptionConfiguration.self, forKey: .consumptionConfiguration)
        consumptionConfiguration = consumptionConfigurationDecoded
        let licenseMetadataContainer = try containerValues.decodeIfPresent([Metadata?].self, forKey: .licenseMetadata)
        var licenseMetadataDecoded0:[Metadata]? = nil
        if let licenseMetadataContainer = licenseMetadataContainer {
            licenseMetadataDecoded0 = [Metadata]()
            for structure0 in licenseMetadataContainer {
                if let structure0 = structure0 {
                    licenseMetadataDecoded0?.append(structure0)
                }
            }
        }
        licenseMetadata = licenseMetadataDecoded0
        let createTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createTime)
        createTime = createTimeDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let receivedMetadataDecoded = try containerValues.decodeIfPresent(ReceivedMetadata.self, forKey: .receivedMetadata)
        receivedMetadata = receivedMetadataDecoded
    }
}

extension GrantedLicense: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GrantedLicense(beneficiary: \(String(describing: beneficiary)), consumptionConfiguration: \(String(describing: consumptionConfiguration)), createTime: \(String(describing: createTime)), entitlements: \(String(describing: entitlements)), homeRegion: \(String(describing: homeRegion)), issuer: \(String(describing: issuer)), licenseArn: \(String(describing: licenseArn)), licenseMetadata: \(String(describing: licenseMetadata)), licenseName: \(String(describing: licenseName)), productName: \(String(describing: productName)), productSKU: \(String(describing: productSKU)), receivedMetadata: \(String(describing: receivedMetadata)), status: \(String(describing: status)), validity: \(String(describing: validity)), version: \(String(describing: version)))"}
}

/// <p>Describes a license that is granted to a grantee.</p>
public struct GrantedLicense: Equatable {
    /// <p>Granted license beneficiary.</p>
    public let beneficiary: String?
    /// <p>Configuration for consumption of the license.</p>
    public let consumptionConfiguration: ConsumptionConfiguration?
    /// <p>Creation time of the granted license.</p>
    public let createTime: String?
    /// <p>License entitlements.</p>
    public let entitlements: [Entitlement]?
    /// <p>Home Region of the granted license.</p>
    public let homeRegion: String?
    /// <p>Granted license issuer.</p>
    public let issuer: IssuerDetails?
    /// <p>Amazon Resource Name (ARN) of the license.</p>
    public let licenseArn: String?
    /// <p>Granted license metadata.</p>
    public let licenseMetadata: [Metadata]?
    /// <p>License name.</p>
    public let licenseName: String?
    /// <p>Product name.</p>
    public let productName: String?
    /// <p>Product SKU.</p>
    public let productSKU: String?
    /// <p>Granted license received metadata.</p>
    public let receivedMetadata: ReceivedMetadata?
    /// <p>Granted license status.</p>
    public let status: LicenseStatus?
    /// <p>Date and time range during which the granted license is valid, in ISO8601-UTC format.</p>
    public let validity: DatetimeRange?
    /// <p>Version of the granted license.</p>
    public let version: String?

    public init (
        beneficiary: String? = nil,
        consumptionConfiguration: ConsumptionConfiguration? = nil,
        createTime: String? = nil,
        entitlements: [Entitlement]? = nil,
        homeRegion: String? = nil,
        issuer: IssuerDetails? = nil,
        licenseArn: String? = nil,
        licenseMetadata: [Metadata]? = nil,
        licenseName: String? = nil,
        productName: String? = nil,
        productSKU: String? = nil,
        receivedMetadata: ReceivedMetadata? = nil,
        status: LicenseStatus? = nil,
        validity: DatetimeRange? = nil,
        version: String? = nil
    )
    {
        self.beneficiary = beneficiary
        self.consumptionConfiguration = consumptionConfiguration
        self.createTime = createTime
        self.entitlements = entitlements
        self.homeRegion = homeRegion
        self.issuer = issuer
        self.licenseArn = licenseArn
        self.licenseMetadata = licenseMetadata
        self.licenseName = licenseName
        self.productName = productName
        self.productSKU = productSKU
        self.receivedMetadata = receivedMetadata
        self.status = status
        self.validity = validity
        self.version = version
    }
}

extension InvalidParameterValueException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterValueException(message: \(String(describing: message)))"}
}

extension InvalidParameterValueException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more parameter values are not valid.</p>
public struct InvalidParameterValueException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterValueExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParameterValueExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceStateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidResourceStateException(message: \(String(describing: message)))"}
}

extension InvalidResourceStateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidResourceStateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>License Manager cannot allocate a license to a resource because of its state. </p>
///          <p>For example, you cannot allocate a license to an instance in the process of shutting
///          down.</p>
public struct InvalidResourceStateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResourceStateExceptionBody: Equatable {
    public let message: String?
}

extension InvalidResourceStateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InventoryFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case condition = "Condition"
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = condition {
            try encodeContainer.encode(condition.rawValue, forKey: .condition)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let conditionDecoded = try containerValues.decodeIfPresent(InventoryFilterCondition.self, forKey: .condition)
        condition = conditionDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension InventoryFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InventoryFilter(condition: \(String(describing: condition)), name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>An inventory filter.</p>
public struct InventoryFilter: Equatable {
    /// <p>Condition of the filter.</p>
    public let condition: InventoryFilterCondition?
    /// <p>Name of the filter.</p>
    public let name: String?
    /// <p>Value of the filter.</p>
    public let value: String?

    public init (
        condition: InventoryFilterCondition? = nil,
        name: String? = nil,
        value: String? = nil
    )
    {
        self.condition = condition
        self.name = name
        self.value = value
    }
}

public enum InventoryFilterCondition {
    case beginsWith
    case contains
    case equals
    case notEquals
    case sdkUnknown(String)
}

extension InventoryFilterCondition : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InventoryFilterCondition] {
        return [
            .beginsWith,
            .contains,
            .equals,
            .notEquals,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .beginsWith: return "BEGINS_WITH"
        case .contains: return "CONTAINS"
        case .equals: return "EQUALS"
        case .notEquals: return "NOT_EQUALS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InventoryFilterCondition(rawValue: rawValue) ?? InventoryFilterCondition.sdkUnknown(rawValue)
    }
}

extension Issuer: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case signKey = "SignKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let signKey = signKey {
            try encodeContainer.encode(signKey, forKey: .signKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let signKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signKey)
        signKey = signKeyDecoded
    }
}

extension Issuer: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Issuer(name: \(String(describing: name)), signKey: \(String(describing: signKey)))"}
}

/// <p>Details about the issuer of a license.</p>
public struct Issuer: Equatable {
    /// <p>Issuer name.</p>
    public let name: String?
    /// <p>Asymmetric CMK from AWS Key Management Service. The CMK must have a key usage of sign and verify,
    ///          and support the RSASSA-PSS SHA-256 signing algorithm.</p>
    public let signKey: String?

    public init (
        name: String? = nil,
        signKey: String? = nil
    )
    {
        self.name = name
        self.signKey = signKey
    }
}

extension IssuerDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyFingerprint = "KeyFingerprint"
        case name = "Name"
        case signKey = "SignKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyFingerprint = keyFingerprint {
            try encodeContainer.encode(keyFingerprint, forKey: .keyFingerprint)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let signKey = signKey {
            try encodeContainer.encode(signKey, forKey: .signKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let signKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signKey)
        signKey = signKeyDecoded
        let keyFingerprintDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyFingerprint)
        keyFingerprint = keyFingerprintDecoded
    }
}

extension IssuerDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IssuerDetails(keyFingerprint: \(String(describing: keyFingerprint)), name: \(String(describing: name)), signKey: \(String(describing: signKey)))"}
}

/// <p>Details associated with the issuer of a license.</p>
public struct IssuerDetails: Equatable {
    /// <p>Issuer key fingerprint.</p>
    public let keyFingerprint: String?
    /// <p>Issuer name.</p>
    public let name: String?
    /// <p>Asymmetric CMK from AWS Key Management Service. The CMK must have a key usage of sign and verify,
    ///          and support the RSASSA-PSS SHA-256 signing algorithm.</p>
    public let signKey: String?

    public init (
        keyFingerprint: String? = nil,
        name: String? = nil,
        signKey: String? = nil
    )
    {
        self.keyFingerprint = keyFingerprint
        self.name = name
        self.signKey = signKey
    }
}

extension License: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case beneficiary = "Beneficiary"
        case consumptionConfiguration = "ConsumptionConfiguration"
        case createTime = "CreateTime"
        case entitlements = "Entitlements"
        case homeRegion = "HomeRegion"
        case issuer = "Issuer"
        case licenseArn = "LicenseArn"
        case licenseMetadata = "LicenseMetadata"
        case licenseName = "LicenseName"
        case productName = "ProductName"
        case productSKU = "ProductSKU"
        case status = "Status"
        case validity = "Validity"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beneficiary = beneficiary {
            try encodeContainer.encode(beneficiary, forKey: .beneficiary)
        }
        if let consumptionConfiguration = consumptionConfiguration {
            try encodeContainer.encode(consumptionConfiguration, forKey: .consumptionConfiguration)
        }
        if let createTime = createTime {
            try encodeContainer.encode(createTime, forKey: .createTime)
        }
        if let entitlements = entitlements {
            var entitlementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entitlements)
            for entitlementlist0 in entitlements {
                try entitlementsContainer.encode(entitlementlist0)
            }
        }
        if let homeRegion = homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let issuer = issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
        if let licenseArn = licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let licenseMetadata = licenseMetadata {
            var licenseMetadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseMetadata)
            for metadatalist0 in licenseMetadata {
                try licenseMetadataContainer.encode(metadatalist0)
            }
        }
        if let licenseName = licenseName {
            try encodeContainer.encode(licenseName, forKey: .licenseName)
        }
        if let productName = productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let productSKU = productSKU {
            try encodeContainer.encode(productSKU, forKey: .productSKU)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let validity = validity {
            try encodeContainer.encode(validity, forKey: .validity)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let licenseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseName)
        licenseName = licenseNameDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productName)
        productName = productNameDecoded
        let productSKUDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productSKU)
        productSKU = productSKUDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(IssuerDetails.self, forKey: .issuer)
        issuer = issuerDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseStatus.self, forKey: .status)
        status = statusDecoded
        let validityDecoded = try containerValues.decodeIfPresent(DatetimeRange.self, forKey: .validity)
        validity = validityDecoded
        let beneficiaryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .beneficiary)
        beneficiary = beneficiaryDecoded
        let entitlementsContainer = try containerValues.decodeIfPresent([Entitlement?].self, forKey: .entitlements)
        var entitlementsDecoded0:[Entitlement]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [Entitlement]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let consumptionConfigurationDecoded = try containerValues.decodeIfPresent(ConsumptionConfiguration.self, forKey: .consumptionConfiguration)
        consumptionConfiguration = consumptionConfigurationDecoded
        let licenseMetadataContainer = try containerValues.decodeIfPresent([Metadata?].self, forKey: .licenseMetadata)
        var licenseMetadataDecoded0:[Metadata]? = nil
        if let licenseMetadataContainer = licenseMetadataContainer {
            licenseMetadataDecoded0 = [Metadata]()
            for structure0 in licenseMetadataContainer {
                if let structure0 = structure0 {
                    licenseMetadataDecoded0?.append(structure0)
                }
            }
        }
        licenseMetadata = licenseMetadataDecoded0
        let createTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createTime)
        createTime = createTimeDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension License: CustomDebugStringConvertible {
    public var debugDescription: String {
        "License(beneficiary: \(String(describing: beneficiary)), consumptionConfiguration: \(String(describing: consumptionConfiguration)), createTime: \(String(describing: createTime)), entitlements: \(String(describing: entitlements)), homeRegion: \(String(describing: homeRegion)), issuer: \(String(describing: issuer)), licenseArn: \(String(describing: licenseArn)), licenseMetadata: \(String(describing: licenseMetadata)), licenseName: \(String(describing: licenseName)), productName: \(String(describing: productName)), productSKU: \(String(describing: productSKU)), status: \(String(describing: status)), validity: \(String(describing: validity)), version: \(String(describing: version)))"}
}

/// <p>Software license that is managed in AWS License Manager.</p>
public struct License: Equatable {
    /// <p>License beneficiary.</p>
    public let beneficiary: String?
    /// <p>Configuration for consumption of the license.</p>
    public let consumptionConfiguration: ConsumptionConfiguration?
    /// <p>License creation time.</p>
    public let createTime: String?
    /// <p>License entitlements.</p>
    public let entitlements: [Entitlement]?
    /// <p>Home Region of the license.</p>
    public let homeRegion: String?
    /// <p>License issuer.</p>
    public let issuer: IssuerDetails?
    /// <p>Amazon Resource Name (ARN) of the license.</p>
    public let licenseArn: String?
    /// <p>License metadata.</p>
    public let licenseMetadata: [Metadata]?
    /// <p>License name.</p>
    public let licenseName: String?
    /// <p>Product name.</p>
    public let productName: String?
    /// <p>Product SKU.</p>
    public let productSKU: String?
    /// <p>License status.</p>
    public let status: LicenseStatus?
    /// <p>Date and time range during which the license is valid, in ISO8601-UTC format.</p>
    public let validity: DatetimeRange?
    /// <p>License version.</p>
    public let version: String?

    public init (
        beneficiary: String? = nil,
        consumptionConfiguration: ConsumptionConfiguration? = nil,
        createTime: String? = nil,
        entitlements: [Entitlement]? = nil,
        homeRegion: String? = nil,
        issuer: IssuerDetails? = nil,
        licenseArn: String? = nil,
        licenseMetadata: [Metadata]? = nil,
        licenseName: String? = nil,
        productName: String? = nil,
        productSKU: String? = nil,
        status: LicenseStatus? = nil,
        validity: DatetimeRange? = nil,
        version: String? = nil
    )
    {
        self.beneficiary = beneficiary
        self.consumptionConfiguration = consumptionConfiguration
        self.createTime = createTime
        self.entitlements = entitlements
        self.homeRegion = homeRegion
        self.issuer = issuer
        self.licenseArn = licenseArn
        self.licenseMetadata = licenseMetadata
        self.licenseName = licenseName
        self.productName = productName
        self.productSKU = productSKU
        self.status = status
        self.validity = validity
        self.version = version
    }
}

extension LicenseConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case automatedDiscoveryInformation = "AutomatedDiscoveryInformation"
        case consumedLicenseSummaryList = "ConsumedLicenseSummaryList"
        case consumedLicenses = "ConsumedLicenses"
        case description = "Description"
        case disassociateWhenNotFound = "DisassociateWhenNotFound"
        case licenseConfigurationArn = "LicenseConfigurationArn"
        case licenseConfigurationId = "LicenseConfigurationId"
        case licenseCount = "LicenseCount"
        case licenseCountHardLimit = "LicenseCountHardLimit"
        case licenseCountingType = "LicenseCountingType"
        case licenseRules = "LicenseRules"
        case managedResourceSummaryList = "ManagedResourceSummaryList"
        case name = "Name"
        case ownerAccountId = "OwnerAccountId"
        case productInformationList = "ProductInformationList"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automatedDiscoveryInformation = automatedDiscoveryInformation {
            try encodeContainer.encode(automatedDiscoveryInformation, forKey: .automatedDiscoveryInformation)
        }
        if let consumedLicenseSummaryList = consumedLicenseSummaryList {
            var consumedLicenseSummaryListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .consumedLicenseSummaryList)
            for consumedlicensesummarylist0 in consumedLicenseSummaryList {
                try consumedLicenseSummaryListContainer.encode(consumedlicensesummarylist0)
            }
        }
        if let consumedLicenses = consumedLicenses {
            try encodeContainer.encode(consumedLicenses, forKey: .consumedLicenses)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disassociateWhenNotFound = disassociateWhenNotFound {
            try encodeContainer.encode(disassociateWhenNotFound, forKey: .disassociateWhenNotFound)
        }
        if let licenseConfigurationArn = licenseConfigurationArn {
            try encodeContainer.encode(licenseConfigurationArn, forKey: .licenseConfigurationArn)
        }
        if let licenseConfigurationId = licenseConfigurationId {
            try encodeContainer.encode(licenseConfigurationId, forKey: .licenseConfigurationId)
        }
        if let licenseCount = licenseCount {
            try encodeContainer.encode(licenseCount, forKey: .licenseCount)
        }
        if let licenseCountHardLimit = licenseCountHardLimit {
            try encodeContainer.encode(licenseCountHardLimit, forKey: .licenseCountHardLimit)
        }
        if let licenseCountingType = licenseCountingType {
            try encodeContainer.encode(licenseCountingType.rawValue, forKey: .licenseCountingType)
        }
        if let licenseRules = licenseRules {
            var licenseRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseRules)
            for stringlist0 in licenseRules {
                try licenseRulesContainer.encode(stringlist0)
            }
        }
        if let managedResourceSummaryList = managedResourceSummaryList {
            var managedResourceSummaryListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .managedResourceSummaryList)
            for managedresourcesummarylist0 in managedResourceSummaryList {
                try managedResourceSummaryListContainer.encode(managedresourcesummarylist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerAccountId = ownerAccountId {
            try encodeContainer.encode(ownerAccountId, forKey: .ownerAccountId)
        }
        if let productInformationList = productInformationList {
            var productInformationListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productInformationList)
            for productinformationlist0 in productInformationList {
                try productInformationListContainer.encode(productinformationlist0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseConfigurationId)
        licenseConfigurationId = licenseConfigurationIdDecoded
        let licenseConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseConfigurationArn)
        licenseConfigurationArn = licenseConfigurationArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let licenseCountingTypeDecoded = try containerValues.decodeIfPresent(LicenseCountingType.self, forKey: .licenseCountingType)
        licenseCountingType = licenseCountingTypeDecoded
        let licenseRulesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .licenseRules)
        var licenseRulesDecoded0:[String]? = nil
        if let licenseRulesContainer = licenseRulesContainer {
            licenseRulesDecoded0 = [String]()
            for string0 in licenseRulesContainer {
                if let string0 = string0 {
                    licenseRulesDecoded0?.append(string0)
                }
            }
        }
        licenseRules = licenseRulesDecoded0
        let licenseCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .licenseCount)
        licenseCount = licenseCountDecoded
        let licenseCountHardLimitDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .licenseCountHardLimit)
        licenseCountHardLimit = licenseCountHardLimitDecoded
        let disassociateWhenNotFoundDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .disassociateWhenNotFound)
        disassociateWhenNotFound = disassociateWhenNotFoundDecoded
        let consumedLicensesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .consumedLicenses)
        consumedLicenses = consumedLicensesDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let consumedLicenseSummaryListContainer = try containerValues.decodeIfPresent([ConsumedLicenseSummary?].self, forKey: .consumedLicenseSummaryList)
        var consumedLicenseSummaryListDecoded0:[ConsumedLicenseSummary]? = nil
        if let consumedLicenseSummaryListContainer = consumedLicenseSummaryListContainer {
            consumedLicenseSummaryListDecoded0 = [ConsumedLicenseSummary]()
            for structure0 in consumedLicenseSummaryListContainer {
                if let structure0 = structure0 {
                    consumedLicenseSummaryListDecoded0?.append(structure0)
                }
            }
        }
        consumedLicenseSummaryList = consumedLicenseSummaryListDecoded0
        let managedResourceSummaryListContainer = try containerValues.decodeIfPresent([ManagedResourceSummary?].self, forKey: .managedResourceSummaryList)
        var managedResourceSummaryListDecoded0:[ManagedResourceSummary]? = nil
        if let managedResourceSummaryListContainer = managedResourceSummaryListContainer {
            managedResourceSummaryListDecoded0 = [ManagedResourceSummary]()
            for structure0 in managedResourceSummaryListContainer {
                if let structure0 = structure0 {
                    managedResourceSummaryListDecoded0?.append(structure0)
                }
            }
        }
        managedResourceSummaryList = managedResourceSummaryListDecoded0
        let productInformationListContainer = try containerValues.decodeIfPresent([ProductInformation?].self, forKey: .productInformationList)
        var productInformationListDecoded0:[ProductInformation]? = nil
        if let productInformationListContainer = productInformationListContainer {
            productInformationListDecoded0 = [ProductInformation]()
            for structure0 in productInformationListContainer {
                if let structure0 = structure0 {
                    productInformationListDecoded0?.append(structure0)
                }
            }
        }
        productInformationList = productInformationListDecoded0
        let automatedDiscoveryInformationDecoded = try containerValues.decodeIfPresent(AutomatedDiscoveryInformation.self, forKey: .automatedDiscoveryInformation)
        automatedDiscoveryInformation = automatedDiscoveryInformationDecoded
    }
}

extension LicenseConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LicenseConfiguration(automatedDiscoveryInformation: \(String(describing: automatedDiscoveryInformation)), consumedLicenseSummaryList: \(String(describing: consumedLicenseSummaryList)), consumedLicenses: \(String(describing: consumedLicenses)), description: \(String(describing: description)), disassociateWhenNotFound: \(String(describing: disassociateWhenNotFound)), licenseConfigurationArn: \(String(describing: licenseConfigurationArn)), licenseConfigurationId: \(String(describing: licenseConfigurationId)), licenseCount: \(String(describing: licenseCount)), licenseCountHardLimit: \(String(describing: licenseCountHardLimit)), licenseCountingType: \(String(describing: licenseCountingType)), licenseRules: \(String(describing: licenseRules)), managedResourceSummaryList: \(String(describing: managedResourceSummaryList)), name: \(String(describing: name)), ownerAccountId: \(String(describing: ownerAccountId)), productInformationList: \(String(describing: productInformationList)), status: \(String(describing: status)))"}
}

/// <p>A license configuration is an abstraction of a customer license agreement that can be
///          consumed and enforced by License Manager. Components include specifications for the license
///          type (licensing by instance, socket, CPU, or vCPU), allowed tenancy (shared tenancy,
///          Dedicated Instance, Dedicated Host, or all of these), host affinity (how long a VM
///          must be associated with a host), and the number of licenses purchased and used.</p>
public struct LicenseConfiguration: Equatable {
    /// <p>Automated discovery information.</p>
    public let automatedDiscoveryInformation: AutomatedDiscoveryInformation?
    /// <p>Summaries for licenses consumed by various resources.</p>
    public let consumedLicenseSummaryList: [ConsumedLicenseSummary]?
    /// <p>Number of licenses consumed. </p>
    public let consumedLicenses: Int?
    /// <p>Description of the license configuration.</p>
    public let description: String?
    /// <p>When true, disassociates a resource when software is uninstalled.</p>
    public let disassociateWhenNotFound: Bool?
    /// <p>Amazon Resource Name (ARN) of the license configuration.</p>
    public let licenseConfigurationArn: String?
    /// <p>Unique ID of the license configuration.</p>
    public let licenseConfigurationId: String?
    /// <p>Number of licenses managed by the license configuration.</p>
    public let licenseCount: Int?
    /// <p>Number of available licenses as a hard limit.</p>
    public let licenseCountHardLimit: Bool?
    /// <p>Dimension to use to track the license inventory.</p>
    public let licenseCountingType: LicenseCountingType?
    /// <p>License rules.</p>
    public let licenseRules: [String]?
    /// <p>Summaries for managed resources.</p>
    public let managedResourceSummaryList: [ManagedResourceSummary]?
    /// <p>Name of the license configuration.</p>
    public let name: String?
    /// <p>Account ID of the license configuration's owner.</p>
    public let ownerAccountId: String?
    /// <p>Product information.</p>
    public let productInformationList: [ProductInformation]?
    /// <p>Status of the license configuration.</p>
    public let status: String?

    public init (
        automatedDiscoveryInformation: AutomatedDiscoveryInformation? = nil,
        consumedLicenseSummaryList: [ConsumedLicenseSummary]? = nil,
        consumedLicenses: Int? = nil,
        description: String? = nil,
        disassociateWhenNotFound: Bool? = nil,
        licenseConfigurationArn: String? = nil,
        licenseConfigurationId: String? = nil,
        licenseCount: Int? = nil,
        licenseCountHardLimit: Bool? = nil,
        licenseCountingType: LicenseCountingType? = nil,
        licenseRules: [String]? = nil,
        managedResourceSummaryList: [ManagedResourceSummary]? = nil,
        name: String? = nil,
        ownerAccountId: String? = nil,
        productInformationList: [ProductInformation]? = nil,
        status: String? = nil
    )
    {
        self.automatedDiscoveryInformation = automatedDiscoveryInformation
        self.consumedLicenseSummaryList = consumedLicenseSummaryList
        self.consumedLicenses = consumedLicenses
        self.description = description
        self.disassociateWhenNotFound = disassociateWhenNotFound
        self.licenseConfigurationArn = licenseConfigurationArn
        self.licenseConfigurationId = licenseConfigurationId
        self.licenseCount = licenseCount
        self.licenseCountHardLimit = licenseCountHardLimit
        self.licenseCountingType = licenseCountingType
        self.licenseRules = licenseRules
        self.managedResourceSummaryList = managedResourceSummaryList
        self.name = name
        self.ownerAccountId = ownerAccountId
        self.productInformationList = productInformationList
        self.status = status
    }
}

extension LicenseConfigurationAssociation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amiAssociationScope = "AmiAssociationScope"
        case associationTime = "AssociationTime"
        case resourceArn = "ResourceArn"
        case resourceOwnerId = "ResourceOwnerId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amiAssociationScope = amiAssociationScope {
            try encodeContainer.encode(amiAssociationScope, forKey: .amiAssociationScope)
        }
        if let associationTime = associationTime {
            try encodeContainer.encode(associationTime.timeIntervalSince1970, forKey: .associationTime)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceOwnerId = resourceOwnerId {
            try encodeContainer.encode(resourceOwnerId, forKey: .resourceOwnerId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceOwnerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceOwnerId)
        resourceOwnerId = resourceOwnerIdDecoded
        let associationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .associationTime)
        associationTime = associationTimeDecoded
        let amiAssociationScopeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amiAssociationScope)
        amiAssociationScope = amiAssociationScopeDecoded
    }
}

extension LicenseConfigurationAssociation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LicenseConfigurationAssociation(amiAssociationScope: \(String(describing: amiAssociationScope)), associationTime: \(String(describing: associationTime)), resourceArn: \(String(describing: resourceArn)), resourceOwnerId: \(String(describing: resourceOwnerId)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>Describes an association with a license configuration.</p>
public struct LicenseConfigurationAssociation: Equatable {
    /// <p>Scope of AMI associations. The possible value is <code>cross-account</code>.</p>
    public let amiAssociationScope: String?
    /// <p>Time when the license configuration was associated with the resource.</p>
    public let associationTime: Date?
    /// <p>Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?
    /// <p>ID of the AWS account that owns the resource consuming licenses.</p>
    public let resourceOwnerId: String?
    /// <p>Type of server resource.</p>
    public let resourceType: ResourceType?

    public init (
        amiAssociationScope: String? = nil,
        associationTime: Date? = nil,
        resourceArn: String? = nil,
        resourceOwnerId: String? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.amiAssociationScope = amiAssociationScope
        self.associationTime = associationTime
        self.resourceArn = resourceArn
        self.resourceOwnerId = resourceOwnerId
        self.resourceType = resourceType
    }
}

public enum LicenseConfigurationStatus {
    case available
    case disabled
    case sdkUnknown(String)
}

extension LicenseConfigurationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LicenseConfigurationStatus] {
        return [
            .available,
            .disabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .disabled: return "DISABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LicenseConfigurationStatus(rawValue: rawValue) ?? LicenseConfigurationStatus.sdkUnknown(rawValue)
    }
}

extension LicenseConfigurationUsage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associationTime = "AssociationTime"
        case consumedLicenses = "ConsumedLicenses"
        case resourceArn = "ResourceArn"
        case resourceOwnerId = "ResourceOwnerId"
        case resourceStatus = "ResourceStatus"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationTime = associationTime {
            try encodeContainer.encode(associationTime.timeIntervalSince1970, forKey: .associationTime)
        }
        if let consumedLicenses = consumedLicenses {
            try encodeContainer.encode(consumedLicenses, forKey: .consumedLicenses)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceOwnerId = resourceOwnerId {
            try encodeContainer.encode(resourceOwnerId, forKey: .resourceOwnerId)
        }
        if let resourceStatus = resourceStatus {
            try encodeContainer.encode(resourceStatus, forKey: .resourceStatus)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceStatus)
        resourceStatus = resourceStatusDecoded
        let resourceOwnerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceOwnerId)
        resourceOwnerId = resourceOwnerIdDecoded
        let associationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .associationTime)
        associationTime = associationTimeDecoded
        let consumedLicensesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .consumedLicenses)
        consumedLicenses = consumedLicensesDecoded
    }
}

extension LicenseConfigurationUsage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LicenseConfigurationUsage(associationTime: \(String(describing: associationTime)), consumedLicenses: \(String(describing: consumedLicenses)), resourceArn: \(String(describing: resourceArn)), resourceOwnerId: \(String(describing: resourceOwnerId)), resourceStatus: \(String(describing: resourceStatus)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>Details about the usage of a resource associated with a license configuration.</p>
public struct LicenseConfigurationUsage: Equatable {
    /// <p>Time when the license configuration was initially associated with the resource.</p>
    public let associationTime: Date?
    /// <p>Number of licenses consumed by the resource.</p>
    public let consumedLicenses: Int?
    /// <p>Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?
    /// <p>ID of the account that owns the resource.</p>
    public let resourceOwnerId: String?
    /// <p>Status of the resource.</p>
    public let resourceStatus: String?
    /// <p>Type of resource.</p>
    public let resourceType: ResourceType?

    public init (
        associationTime: Date? = nil,
        consumedLicenses: Int? = nil,
        resourceArn: String? = nil,
        resourceOwnerId: String? = nil,
        resourceStatus: String? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.associationTime = associationTime
        self.consumedLicenses = consumedLicenses
        self.resourceArn = resourceArn
        self.resourceOwnerId = resourceOwnerId
        self.resourceStatus = resourceStatus
        self.resourceType = resourceType
    }
}

public enum LicenseCountingType {
    case core
    case instance
    case socket
    case vcpu
    case sdkUnknown(String)
}

extension LicenseCountingType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LicenseCountingType] {
        return [
            .core,
            .instance,
            .socket,
            .vcpu,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .core: return "Core"
        case .instance: return "Instance"
        case .socket: return "Socket"
        case .vcpu: return "vCPU"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LicenseCountingType(rawValue: rawValue) ?? LicenseCountingType.sdkUnknown(rawValue)
    }
}

public enum LicenseDeletionStatus {
    case deleted
    case pendingDelete
    case sdkUnknown(String)
}

extension LicenseDeletionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LicenseDeletionStatus] {
        return [
            .deleted,
            .pendingDelete,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deleted: return "DELETED"
        case .pendingDelete: return "PENDING_DELETE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LicenseDeletionStatus(rawValue: rawValue) ?? LicenseDeletionStatus.sdkUnknown(rawValue)
    }
}

extension LicenseOperationFailure: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorMessage = "ErrorMessage"
        case failureTime = "FailureTime"
        case metadataList = "MetadataList"
        case operationName = "OperationName"
        case operationRequestedBy = "OperationRequestedBy"
        case resourceArn = "ResourceArn"
        case resourceOwnerId = "ResourceOwnerId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let failureTime = failureTime {
            try encodeContainer.encode(failureTime.timeIntervalSince1970, forKey: .failureTime)
        }
        if let metadataList = metadataList {
            var metadataListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metadataList)
            for metadatalist0 in metadataList {
                try metadataListContainer.encode(metadatalist0)
            }
        }
        if let operationName = operationName {
            try encodeContainer.encode(operationName, forKey: .operationName)
        }
        if let operationRequestedBy = operationRequestedBy {
            try encodeContainer.encode(operationRequestedBy, forKey: .operationRequestedBy)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceOwnerId = resourceOwnerId {
            try encodeContainer.encode(resourceOwnerId, forKey: .resourceOwnerId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let failureTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .failureTime)
        failureTime = failureTimeDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let resourceOwnerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceOwnerId)
        resourceOwnerId = resourceOwnerIdDecoded
        let operationRequestedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationRequestedBy)
        operationRequestedBy = operationRequestedByDecoded
        let metadataListContainer = try containerValues.decodeIfPresent([Metadata?].self, forKey: .metadataList)
        var metadataListDecoded0:[Metadata]? = nil
        if let metadataListContainer = metadataListContainer {
            metadataListDecoded0 = [Metadata]()
            for structure0 in metadataListContainer {
                if let structure0 = structure0 {
                    metadataListDecoded0?.append(structure0)
                }
            }
        }
        metadataList = metadataListDecoded0
    }
}

extension LicenseOperationFailure: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LicenseOperationFailure(errorMessage: \(String(describing: errorMessage)), failureTime: \(String(describing: failureTime)), metadataList: \(String(describing: metadataList)), operationName: \(String(describing: operationName)), operationRequestedBy: \(String(describing: operationRequestedBy)), resourceArn: \(String(describing: resourceArn)), resourceOwnerId: \(String(describing: resourceOwnerId)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>Describes the failure of a license operation.</p>
public struct LicenseOperationFailure: Equatable {
    /// <p>Error message.</p>
    public let errorMessage: String?
    /// <p>Failure time.</p>
    public let failureTime: Date?
    /// <p>Reserved.</p>
    public let metadataList: [Metadata]?
    /// <p>Name of the operation.</p>
    public let operationName: String?
    /// <p>The requester is "License Manager Automated Discovery".</p>
    public let operationRequestedBy: String?
    /// <p>Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?
    /// <p>ID of the AWS account that owns the resource.</p>
    public let resourceOwnerId: String?
    /// <p>Resource type.</p>
    public let resourceType: ResourceType?

    public init (
        errorMessage: String? = nil,
        failureTime: Date? = nil,
        metadataList: [Metadata]? = nil,
        operationName: String? = nil,
        operationRequestedBy: String? = nil,
        resourceArn: String? = nil,
        resourceOwnerId: String? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.errorMessage = errorMessage
        self.failureTime = failureTime
        self.metadataList = metadataList
        self.operationName = operationName
        self.operationRequestedBy = operationRequestedBy
        self.resourceArn = resourceArn
        self.resourceOwnerId = resourceOwnerId
        self.resourceType = resourceType
    }
}

extension LicenseSpecification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amiAssociationScope = "AmiAssociationScope"
        case licenseConfigurationArn = "LicenseConfigurationArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amiAssociationScope = amiAssociationScope {
            try encodeContainer.encode(amiAssociationScope, forKey: .amiAssociationScope)
        }
        if let licenseConfigurationArn = licenseConfigurationArn {
            try encodeContainer.encode(licenseConfigurationArn, forKey: .licenseConfigurationArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseConfigurationArn)
        licenseConfigurationArn = licenseConfigurationArnDecoded
        let amiAssociationScopeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amiAssociationScope)
        amiAssociationScope = amiAssociationScopeDecoded
    }
}

extension LicenseSpecification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LicenseSpecification(amiAssociationScope: \(String(describing: amiAssociationScope)), licenseConfigurationArn: \(String(describing: licenseConfigurationArn)))"}
}

/// <p>Details for associating a license configuration with a resource.</p>
public struct LicenseSpecification: Equatable {
    /// <p>Scope of AMI associations. The possible value is <code>cross-account</code>.</p>
    public let amiAssociationScope: String?
    /// <p>Amazon Resource Name (ARN) of the license configuration.</p>
    public let licenseConfigurationArn: String?

    public init (
        amiAssociationScope: String? = nil,
        licenseConfigurationArn: String? = nil
    )
    {
        self.amiAssociationScope = amiAssociationScope
        self.licenseConfigurationArn = licenseConfigurationArn
    }
}

public enum LicenseStatus {
    case available
    case deactivated
    case deleted
    case expired
    case pendingAvailable
    case pendingDelete
    case suspended
    case sdkUnknown(String)
}

extension LicenseStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LicenseStatus] {
        return [
            .available,
            .deactivated,
            .deleted,
            .expired,
            .pendingAvailable,
            .pendingDelete,
            .suspended,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .deactivated: return "DEACTIVATED"
        case .deleted: return "DELETED"
        case .expired: return "EXPIRED"
        case .pendingAvailable: return "PENDING_AVAILABLE"
        case .pendingDelete: return "PENDING_DELETE"
        case .suspended: return "SUSPENDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LicenseStatus(rawValue: rawValue) ?? LicenseStatus.sdkUnknown(rawValue)
    }
}

extension LicenseUsage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entitlementUsages = "EntitlementUsages"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entitlementUsages = entitlementUsages {
            var entitlementUsagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entitlementUsages)
            for entitlementusagelist0 in entitlementUsages {
                try entitlementUsagesContainer.encode(entitlementusagelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitlementUsagesContainer = try containerValues.decodeIfPresent([EntitlementUsage?].self, forKey: .entitlementUsages)
        var entitlementUsagesDecoded0:[EntitlementUsage]? = nil
        if let entitlementUsagesContainer = entitlementUsagesContainer {
            entitlementUsagesDecoded0 = [EntitlementUsage]()
            for structure0 in entitlementUsagesContainer {
                if let structure0 = structure0 {
                    entitlementUsagesDecoded0?.append(structure0)
                }
            }
        }
        entitlementUsages = entitlementUsagesDecoded0
    }
}

extension LicenseUsage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LicenseUsage(entitlementUsages: \(String(describing: entitlementUsages)))"}
}

/// <p>Describes the entitlement usage associated with a license.</p>
public struct LicenseUsage: Equatable {
    /// <p>License entitlement usages.</p>
    public let entitlementUsages: [EntitlementUsage]?

    public init (
        entitlementUsages: [EntitlementUsage]? = nil
    )
    {
        self.entitlementUsages = entitlementUsages
    }
}

extension LicenseUsageException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LicenseUsageException(message: \(String(describing: message)))"}
}

extension LicenseUsageException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LicenseUsageExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have enough licenses available to support a new resource launch.</p>
public struct LicenseUsageException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LicenseUsageExceptionBody: Equatable {
    public let message: String?
}

extension LicenseUsageExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListAssociationsForLicenseConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "ListAssociationsForLicenseConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssociationsForLicenseConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssociationsForLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssociationsForLicenseConfigurationInput>
    public typealias MOutput = OperationOutput<ListAssociationsForLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssociationsForLicenseConfigurationOutputError>
}

extension ListAssociationsForLicenseConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssociationsForLicenseConfigurationInput(licenseConfigurationArn: \(String(describing: licenseConfigurationArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssociationsForLicenseConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseConfigurationArn = licenseConfigurationArn {
            try encodeContainer.encode(licenseConfigurationArn, forKey: .licenseConfigurationArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAssociationsForLicenseConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "ListAssociationsForLicenseConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssociationsForLicenseConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssociationsForLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssociationsForLicenseConfigurationInput>
    public typealias MOutput = OperationOutput<ListAssociationsForLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssociationsForLicenseConfigurationOutputError>
}

public struct ListAssociationsForLicenseConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAssociationsForLicenseConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssociationsForLicenseConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssociationsForLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssociationsForLicenseConfigurationInput>
    public typealias MOutput = OperationOutput<ListAssociationsForLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssociationsForLicenseConfigurationOutputError>
}

public struct ListAssociationsForLicenseConfigurationInput: Equatable {
    /// <p>Amazon Resource Name (ARN) of a license configuration.</p>
    public let licenseConfigurationArn: String?
    /// <p>Maximum number of results to return in a single call.</p>
    public let maxResults: Int?
    /// <p>Token for the next set of results.</p>
    public let nextToken: String?

    public init (
        licenseConfigurationArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.licenseConfigurationArn = licenseConfigurationArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssociationsForLicenseConfigurationInputBody: Equatable {
    public let licenseConfigurationArn: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListAssociationsForLicenseConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseConfigurationArn)
        licenseConfigurationArn = licenseConfigurationArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssociationsForLicenseConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssociationsForLicenseConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FilterLimitExceededException" : self = .filterLimitExceededException(try FilterLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssociationsForLicenseConfigurationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case filterLimitExceededException(FilterLimitExceededException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssociationsForLicenseConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssociationsForLicenseConfigurationOutputResponse(licenseConfigurationAssociations: \(String(describing: licenseConfigurationAssociations)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssociationsForLicenseConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAssociationsForLicenseConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.licenseConfigurationAssociations = output.licenseConfigurationAssociations
            self.nextToken = output.nextToken
        } else {
            self.licenseConfigurationAssociations = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssociationsForLicenseConfigurationOutputResponse: Equatable {
    /// <p>Information about the associations for the license configuration.</p>
    public let licenseConfigurationAssociations: [LicenseConfigurationAssociation]?
    /// <p>Token for the next set of results.</p>
    public let nextToken: String?

    public init (
        licenseConfigurationAssociations: [LicenseConfigurationAssociation]? = nil,
        nextToken: String? = nil
    )
    {
        self.licenseConfigurationAssociations = licenseConfigurationAssociations
        self.nextToken = nextToken
    }
}

struct ListAssociationsForLicenseConfigurationOutputResponseBody: Equatable {
    public let licenseConfigurationAssociations: [LicenseConfigurationAssociation]?
    public let nextToken: String?
}

extension ListAssociationsForLicenseConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case licenseConfigurationAssociations = "LicenseConfigurationAssociations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationAssociationsContainer = try containerValues.decodeIfPresent([LicenseConfigurationAssociation?].self, forKey: .licenseConfigurationAssociations)
        var licenseConfigurationAssociationsDecoded0:[LicenseConfigurationAssociation]? = nil
        if let licenseConfigurationAssociationsContainer = licenseConfigurationAssociationsContainer {
            licenseConfigurationAssociationsDecoded0 = [LicenseConfigurationAssociation]()
            for structure0 in licenseConfigurationAssociationsContainer {
                if let structure0 = structure0 {
                    licenseConfigurationAssociationsDecoded0?.append(structure0)
                }
            }
        }
        licenseConfigurationAssociations = licenseConfigurationAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDistributedGrantsInputBodyMiddleware: Middleware {
    public let id: String = "ListDistributedGrantsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDistributedGrantsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDistributedGrantsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDistributedGrantsInput>
    public typealias MOutput = OperationOutput<ListDistributedGrantsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDistributedGrantsOutputError>
}

extension ListDistributedGrantsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDistributedGrantsInput(filters: \(String(describing: filters)), grantArns: \(String(describing: grantArns)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDistributedGrantsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case grantArns = "GrantArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let grantArns = grantArns {
            var grantArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantArns)
            for arnlist0 in grantArns {
                try grantArnsContainer.encode(arnlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDistributedGrantsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDistributedGrantsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDistributedGrantsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDistributedGrantsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDistributedGrantsInput>
    public typealias MOutput = OperationOutput<ListDistributedGrantsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDistributedGrantsOutputError>
}

public struct ListDistributedGrantsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDistributedGrantsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDistributedGrantsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDistributedGrantsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDistributedGrantsInput>
    public typealias MOutput = OperationOutput<ListDistributedGrantsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDistributedGrantsOutputError>
}

public struct ListDistributedGrantsInput: Equatable {
    /// <p>Filters to scope the results. The following filters are supported:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>LicenseArn</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>GrantStatus</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>GranteePrincipalARN</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ProductSKU</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LicenseIssuerName</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let filters: [Filter]?
    /// <p>Amazon Resource Names (ARNs) of the grants.</p>
    public let grantArns: [String]?
    /// <p>Maximum number of results to return in a single call.</p>
    public let maxResults: Int?
    /// <p>Token for the next set of results.</p>
    public let nextToken: String?

    public init (
        filters: [Filter]? = nil,
        grantArns: [String]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.grantArns = grantArns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDistributedGrantsInputBody: Equatable {
    public let grantArns: [String]?
    public let filters: [Filter]?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListDistributedGrantsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case grantArns = "GrantArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .grantArns)
        var grantArnsDecoded0:[String]? = nil
        if let grantArnsContainer = grantArnsContainer {
            grantArnsDecoded0 = [String]()
            for string0 in grantArnsContainer {
                if let string0 = string0 {
                    grantArnsDecoded0?.append(string0)
                }
            }
        }
        grantArns = grantArnsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDistributedGrantsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDistributedGrantsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDistributedGrantsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDistributedGrantsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDistributedGrantsOutputResponse(grants: \(String(describing: grants)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDistributedGrantsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDistributedGrantsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.grants = output.grants
            self.nextToken = output.nextToken
        } else {
            self.grants = nil
            self.nextToken = nil
        }
    }
}

public struct ListDistributedGrantsOutputResponse: Equatable {
    /// <p>Distributed grant details.</p>
    public let grants: [Grant]?
    /// <p>Token for the next set of results.</p>
    public let nextToken: String?

    public init (
        grants: [Grant]? = nil,
        nextToken: String? = nil
    )
    {
        self.grants = grants
        self.nextToken = nextToken
    }
}

struct ListDistributedGrantsOutputResponseBody: Equatable {
    public let grants: [Grant]?
    public let nextToken: String?
}

extension ListDistributedGrantsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case grants = "Grants"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantsContainer = try containerValues.decodeIfPresent([Grant?].self, forKey: .grants)
        var grantsDecoded0:[Grant]? = nil
        if let grantsContainer = grantsContainer {
            grantsDecoded0 = [Grant]()
            for structure0 in grantsContainer {
                if let structure0 = structure0 {
                    grantsDecoded0?.append(structure0)
                }
            }
        }
        grants = grantsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListFailuresForLicenseConfigurationOperationsInputBodyMiddleware: Middleware {
    public let id: String = "ListFailuresForLicenseConfigurationOperationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFailuresForLicenseConfigurationOperationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFailuresForLicenseConfigurationOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFailuresForLicenseConfigurationOperationsInput>
    public typealias MOutput = OperationOutput<ListFailuresForLicenseConfigurationOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFailuresForLicenseConfigurationOperationsOutputError>
}

extension ListFailuresForLicenseConfigurationOperationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFailuresForLicenseConfigurationOperationsInput(licenseConfigurationArn: \(String(describing: licenseConfigurationArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFailuresForLicenseConfigurationOperationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseConfigurationArn = licenseConfigurationArn {
            try encodeContainer.encode(licenseConfigurationArn, forKey: .licenseConfigurationArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListFailuresForLicenseConfigurationOperationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListFailuresForLicenseConfigurationOperationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFailuresForLicenseConfigurationOperationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFailuresForLicenseConfigurationOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFailuresForLicenseConfigurationOperationsInput>
    public typealias MOutput = OperationOutput<ListFailuresForLicenseConfigurationOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFailuresForLicenseConfigurationOperationsOutputError>
}

public struct ListFailuresForLicenseConfigurationOperationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFailuresForLicenseConfigurationOperationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFailuresForLicenseConfigurationOperationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFailuresForLicenseConfigurationOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFailuresForLicenseConfigurationOperationsInput>
    public typealias MOutput = OperationOutput<ListFailuresForLicenseConfigurationOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFailuresForLicenseConfigurationOperationsOutputError>
}

public struct ListFailuresForLicenseConfigurationOperationsInput: Equatable {
    /// <p>Amazon Resource Name of the license configuration.</p>
    public let licenseConfigurationArn: String?
    /// <p>Maximum number of results to return in a single call.</p>
    public let maxResults: Int?
    /// <p>Token for the next set of results.</p>
    public let nextToken: String?

    public init (
        licenseConfigurationArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.licenseConfigurationArn = licenseConfigurationArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFailuresForLicenseConfigurationOperationsInputBody: Equatable {
    public let licenseConfigurationArn: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListFailuresForLicenseConfigurationOperationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseConfigurationArn)
        licenseConfigurationArn = licenseConfigurationArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFailuresForLicenseConfigurationOperationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFailuresForLicenseConfigurationOperationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFailuresForLicenseConfigurationOperationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFailuresForLicenseConfigurationOperationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFailuresForLicenseConfigurationOperationsOutputResponse(licenseOperationFailureList: \(String(describing: licenseOperationFailureList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFailuresForLicenseConfigurationOperationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFailuresForLicenseConfigurationOperationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.licenseOperationFailureList = output.licenseOperationFailureList
            self.nextToken = output.nextToken
        } else {
            self.licenseOperationFailureList = nil
            self.nextToken = nil
        }
    }
}

public struct ListFailuresForLicenseConfigurationOperationsOutputResponse: Equatable {
    /// <p>License configuration operations that failed.</p>
    public let licenseOperationFailureList: [LicenseOperationFailure]?
    /// <p>Token for the next set of results.</p>
    public let nextToken: String?

    public init (
        licenseOperationFailureList: [LicenseOperationFailure]? = nil,
        nextToken: String? = nil
    )
    {
        self.licenseOperationFailureList = licenseOperationFailureList
        self.nextToken = nextToken
    }
}

struct ListFailuresForLicenseConfigurationOperationsOutputResponseBody: Equatable {
    public let licenseOperationFailureList: [LicenseOperationFailure]?
    public let nextToken: String?
}

extension ListFailuresForLicenseConfigurationOperationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case licenseOperationFailureList = "LicenseOperationFailureList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseOperationFailureListContainer = try containerValues.decodeIfPresent([LicenseOperationFailure?].self, forKey: .licenseOperationFailureList)
        var licenseOperationFailureListDecoded0:[LicenseOperationFailure]? = nil
        if let licenseOperationFailureListContainer = licenseOperationFailureListContainer {
            licenseOperationFailureListDecoded0 = [LicenseOperationFailure]()
            for structure0 in licenseOperationFailureListContainer {
                if let structure0 = structure0 {
                    licenseOperationFailureListDecoded0?.append(structure0)
                }
            }
        }
        licenseOperationFailureList = licenseOperationFailureListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListLicenseConfigurationsInputBodyMiddleware: Middleware {
    public let id: String = "ListLicenseConfigurationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLicenseConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLicenseConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLicenseConfigurationsInput>
    public typealias MOutput = OperationOutput<ListLicenseConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLicenseConfigurationsOutputError>
}

extension ListLicenseConfigurationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLicenseConfigurationsInput(filters: \(String(describing: filters)), licenseConfigurationArns: \(String(describing: licenseConfigurationArns)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListLicenseConfigurationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case licenseConfigurationArns = "LicenseConfigurationArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let licenseConfigurationArns = licenseConfigurationArns {
            var licenseConfigurationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseConfigurationArns)
            for stringlist0 in licenseConfigurationArns {
                try licenseConfigurationArnsContainer.encode(stringlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListLicenseConfigurationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListLicenseConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLicenseConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLicenseConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLicenseConfigurationsInput>
    public typealias MOutput = OperationOutput<ListLicenseConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLicenseConfigurationsOutputError>
}

public struct ListLicenseConfigurationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListLicenseConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLicenseConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLicenseConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLicenseConfigurationsInput>
    public typealias MOutput = OperationOutput<ListLicenseConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLicenseConfigurationsOutputError>
}

public struct ListLicenseConfigurationsInput: Equatable {
    /// <p>Filters to scope the results. The following filters and logical operators
    ///         are supported:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>licenseCountingType</code> - The dimension on which licenses are counted.
    ///                Possible values are <code>vCPU</code> | <code>Instance</code> | <code>Core</code> | <code>Socket</code>.
    ///                Logical operators are <code>EQUALS</code> | <code>NOT_EQUALS</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>enforceLicenseCount</code> - A Boolean value that indicates whether hard license enforcement is used.
    ///                Logical operators are <code>EQUALS</code> | <code>NOT_EQUALS</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>usagelimitExceeded</code> - A Boolean value that indicates whether the available licenses have been exceeded.
    ///                Logical operators are <code>EQUALS</code> | <code>NOT_EQUALS</code>.</p>
    ///             </li>
    ///          </ul>
    public let filters: [Filter]?
    /// <p>Amazon Resource Names (ARN) of the license configurations.</p>
    public let licenseConfigurationArns: [String]?
    /// <p>Maximum number of results to return in a single call.</p>
    public let maxResults: Int?
    /// <p>Token for the next set of results.</p>
    public let nextToken: String?

    public init (
        filters: [Filter]? = nil,
        licenseConfigurationArns: [String]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.licenseConfigurationArns = licenseConfigurationArns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLicenseConfigurationsInputBody: Equatable {
    public let licenseConfigurationArns: [String]?
    public let maxResults: Int?
    public let nextToken: String?
    public let filters: [Filter]?
}

extension ListLicenseConfigurationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case licenseConfigurationArns = "LicenseConfigurationArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .licenseConfigurationArns)
        var licenseConfigurationArnsDecoded0:[String]? = nil
        if let licenseConfigurationArnsContainer = licenseConfigurationArnsContainer {
            licenseConfigurationArnsDecoded0 = [String]()
            for string0 in licenseConfigurationArnsContainer {
                if let string0 = string0 {
                    licenseConfigurationArnsDecoded0?.append(string0)
                }
            }
        }
        licenseConfigurationArns = licenseConfigurationArnsDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListLicenseConfigurationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLicenseConfigurationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FilterLimitExceededException" : self = .filterLimitExceededException(try FilterLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLicenseConfigurationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case filterLimitExceededException(FilterLimitExceededException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLicenseConfigurationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLicenseConfigurationsOutputResponse(licenseConfigurations: \(String(describing: licenseConfigurations)), nextToken: \(String(describing: nextToken)))"}
}

extension ListLicenseConfigurationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListLicenseConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.licenseConfigurations = output.licenseConfigurations
            self.nextToken = output.nextToken
        } else {
            self.licenseConfigurations = nil
            self.nextToken = nil
        }
    }
}

public struct ListLicenseConfigurationsOutputResponse: Equatable {
    /// <p>Information about the license configurations.</p>
    public let licenseConfigurations: [LicenseConfiguration]?
    /// <p>Token for the next set of results.</p>
    public let nextToken: String?

    public init (
        licenseConfigurations: [LicenseConfiguration]? = nil,
        nextToken: String? = nil
    )
    {
        self.licenseConfigurations = licenseConfigurations
        self.nextToken = nextToken
    }
}

struct ListLicenseConfigurationsOutputResponseBody: Equatable {
    public let licenseConfigurations: [LicenseConfiguration]?
    public let nextToken: String?
}

extension ListLicenseConfigurationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case licenseConfigurations = "LicenseConfigurations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationsContainer = try containerValues.decodeIfPresent([LicenseConfiguration?].self, forKey: .licenseConfigurations)
        var licenseConfigurationsDecoded0:[LicenseConfiguration]? = nil
        if let licenseConfigurationsContainer = licenseConfigurationsContainer {
            licenseConfigurationsDecoded0 = [LicenseConfiguration]()
            for structure0 in licenseConfigurationsContainer {
                if let structure0 = structure0 {
                    licenseConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        licenseConfigurations = licenseConfigurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListLicenseManagerReportGeneratorsInputBodyMiddleware: Middleware {
    public let id: String = "ListLicenseManagerReportGeneratorsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLicenseManagerReportGeneratorsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLicenseManagerReportGeneratorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLicenseManagerReportGeneratorsInput>
    public typealias MOutput = OperationOutput<ListLicenseManagerReportGeneratorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLicenseManagerReportGeneratorsOutputError>
}

extension ListLicenseManagerReportGeneratorsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLicenseManagerReportGeneratorsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListLicenseManagerReportGeneratorsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListLicenseManagerReportGeneratorsInputHeadersMiddleware: Middleware {
    public let id: String = "ListLicenseManagerReportGeneratorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLicenseManagerReportGeneratorsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLicenseManagerReportGeneratorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLicenseManagerReportGeneratorsInput>
    public typealias MOutput = OperationOutput<ListLicenseManagerReportGeneratorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLicenseManagerReportGeneratorsOutputError>
}

public struct ListLicenseManagerReportGeneratorsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListLicenseManagerReportGeneratorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLicenseManagerReportGeneratorsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLicenseManagerReportGeneratorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLicenseManagerReportGeneratorsInput>
    public typealias MOutput = OperationOutput<ListLicenseManagerReportGeneratorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLicenseManagerReportGeneratorsOutputError>
}

public struct ListLicenseManagerReportGeneratorsInput: Equatable {
    /// <p>Filters to scope the results. The following filters are supported: </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>LicenseConfigurationArn</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let filters: [Filter]?
    /// <p>Maximum number of results to return in a single call.</p>
    public let maxResults: Int?
    /// <p>Token for the next set of results.</p>
    public let nextToken: String?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLicenseManagerReportGeneratorsInputBody: Equatable {
    public let filters: [Filter]?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListLicenseManagerReportGeneratorsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListLicenseManagerReportGeneratorsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLicenseManagerReportGeneratorsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLicenseManagerReportGeneratorsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLicenseManagerReportGeneratorsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLicenseManagerReportGeneratorsOutputResponse(nextToken: \(String(describing: nextToken)), reportGenerators: \(String(describing: reportGenerators)))"}
}

extension ListLicenseManagerReportGeneratorsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListLicenseManagerReportGeneratorsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.reportGenerators = output.reportGenerators
        } else {
            self.nextToken = nil
            self.reportGenerators = nil
        }
    }
}

public struct ListLicenseManagerReportGeneratorsOutputResponse: Equatable {
    /// <p>Token for the next set of results.</p>
    public let nextToken: String?
    /// <p>A report generator that creates periodic reports on your license configurations.</p>
    public let reportGenerators: [ReportGenerator]?

    public init (
        nextToken: String? = nil,
        reportGenerators: [ReportGenerator]? = nil
    )
    {
        self.nextToken = nextToken
        self.reportGenerators = reportGenerators
    }
}

struct ListLicenseManagerReportGeneratorsOutputResponseBody: Equatable {
    public let reportGenerators: [ReportGenerator]?
    public let nextToken: String?
}

extension ListLicenseManagerReportGeneratorsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case reportGenerators = "ReportGenerators"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportGeneratorsContainer = try containerValues.decodeIfPresent([ReportGenerator?].self, forKey: .reportGenerators)
        var reportGeneratorsDecoded0:[ReportGenerator]? = nil
        if let reportGeneratorsContainer = reportGeneratorsContainer {
            reportGeneratorsDecoded0 = [ReportGenerator]()
            for structure0 in reportGeneratorsContainer {
                if let structure0 = structure0 {
                    reportGeneratorsDecoded0?.append(structure0)
                }
            }
        }
        reportGenerators = reportGeneratorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListLicenseSpecificationsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListLicenseSpecificationsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLicenseSpecificationsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLicenseSpecificationsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLicenseSpecificationsForResourceInput>
    public typealias MOutput = OperationOutput<ListLicenseSpecificationsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLicenseSpecificationsForResourceOutputError>
}

extension ListLicenseSpecificationsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLicenseSpecificationsForResourceInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceArn: \(String(describing: resourceArn)))"}
}

extension ListLicenseSpecificationsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListLicenseSpecificationsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListLicenseSpecificationsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLicenseSpecificationsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLicenseSpecificationsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLicenseSpecificationsForResourceInput>
    public typealias MOutput = OperationOutput<ListLicenseSpecificationsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLicenseSpecificationsForResourceOutputError>
}

public struct ListLicenseSpecificationsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListLicenseSpecificationsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLicenseSpecificationsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLicenseSpecificationsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLicenseSpecificationsForResourceInput>
    public typealias MOutput = OperationOutput<ListLicenseSpecificationsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLicenseSpecificationsForResourceOutputError>
}

public struct ListLicenseSpecificationsForResourceInput: Equatable {
    /// <p>Maximum number of results to return in a single call.</p>
    public let maxResults: Int?
    /// <p>Token for the next set of results.</p>
    public let nextToken: String?
    /// <p>Amazon Resource Name (ARN) of a resource that has an associated license configuration.</p>
    public let resourceArn: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListLicenseSpecificationsForResourceInputBody: Equatable {
    public let resourceArn: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListLicenseSpecificationsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLicenseSpecificationsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLicenseSpecificationsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLicenseSpecificationsForResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLicenseSpecificationsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLicenseSpecificationsForResourceOutputResponse(licenseSpecifications: \(String(describing: licenseSpecifications)), nextToken: \(String(describing: nextToken)))"}
}

extension ListLicenseSpecificationsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListLicenseSpecificationsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.licenseSpecifications = output.licenseSpecifications
            self.nextToken = output.nextToken
        } else {
            self.licenseSpecifications = nil
            self.nextToken = nil
        }
    }
}

public struct ListLicenseSpecificationsForResourceOutputResponse: Equatable {
    /// <p>License configurations associated with a resource.</p>
    public let licenseSpecifications: [LicenseSpecification]?
    /// <p>Token for the next set of results.</p>
    public let nextToken: String?

    public init (
        licenseSpecifications: [LicenseSpecification]? = nil,
        nextToken: String? = nil
    )
    {
        self.licenseSpecifications = licenseSpecifications
        self.nextToken = nextToken
    }
}

struct ListLicenseSpecificationsForResourceOutputResponseBody: Equatable {
    public let licenseSpecifications: [LicenseSpecification]?
    public let nextToken: String?
}

extension ListLicenseSpecificationsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case licenseSpecifications = "LicenseSpecifications"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseSpecificationsContainer = try containerValues.decodeIfPresent([LicenseSpecification?].self, forKey: .licenseSpecifications)
        var licenseSpecificationsDecoded0:[LicenseSpecification]? = nil
        if let licenseSpecificationsContainer = licenseSpecificationsContainer {
            licenseSpecificationsDecoded0 = [LicenseSpecification]()
            for structure0 in licenseSpecificationsContainer {
                if let structure0 = structure0 {
                    licenseSpecificationsDecoded0?.append(structure0)
                }
            }
        }
        licenseSpecifications = licenseSpecificationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListLicenseVersionsInputBodyMiddleware: Middleware {
    public let id: String = "ListLicenseVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLicenseVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLicenseVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLicenseVersionsInput>
    public typealias MOutput = OperationOutput<ListLicenseVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLicenseVersionsOutputError>
}

extension ListLicenseVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLicenseVersionsInput(licenseArn: \(String(describing: licenseArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListLicenseVersionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case licenseArn = "LicenseArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseArn = licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListLicenseVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListLicenseVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLicenseVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLicenseVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLicenseVersionsInput>
    public typealias MOutput = OperationOutput<ListLicenseVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLicenseVersionsOutputError>
}

public struct ListLicenseVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListLicenseVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLicenseVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLicenseVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLicenseVersionsInput>
    public typealias MOutput = OperationOutput<ListLicenseVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLicenseVersionsOutputError>
}

public struct ListLicenseVersionsInput: Equatable {
    /// <p>Amazon Resource Name (ARN) of the license.</p>
    public let licenseArn: String?
    /// <p>Maximum number of results to return in a single call.</p>
    public let maxResults: Int?
    /// <p>Token for the next set of results.</p>
    public let nextToken: String?

    public init (
        licenseArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.licenseArn = licenseArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLicenseVersionsInputBody: Equatable {
    public let licenseArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListLicenseVersionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case licenseArn = "LicenseArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListLicenseVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLicenseVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLicenseVersionsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLicenseVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLicenseVersionsOutputResponse(licenses: \(String(describing: licenses)), nextToken: \(String(describing: nextToken)))"}
}

extension ListLicenseVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListLicenseVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.licenses = output.licenses
            self.nextToken = output.nextToken
        } else {
            self.licenses = nil
            self.nextToken = nil
        }
    }
}

public struct ListLicenseVersionsOutputResponse: Equatable {
    /// <p>License details.</p>
    public let licenses: [License]?
    /// <p>Token for the next set of results.</p>
    public let nextToken: String?

    public init (
        licenses: [License]? = nil,
        nextToken: String? = nil
    )
    {
        self.licenses = licenses
        self.nextToken = nextToken
    }
}

struct ListLicenseVersionsOutputResponseBody: Equatable {
    public let licenses: [License]?
    public let nextToken: String?
}

extension ListLicenseVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case licenses = "Licenses"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licensesContainer = try containerValues.decodeIfPresent([License?].self, forKey: .licenses)
        var licensesDecoded0:[License]? = nil
        if let licensesContainer = licensesContainer {
            licensesDecoded0 = [License]()
            for structure0 in licensesContainer {
                if let structure0 = structure0 {
                    licensesDecoded0?.append(structure0)
                }
            }
        }
        licenses = licensesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListLicensesInputBodyMiddleware: Middleware {
    public let id: String = "ListLicensesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLicensesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLicensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLicensesInput>
    public typealias MOutput = OperationOutput<ListLicensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLicensesOutputError>
}

extension ListLicensesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLicensesInput(filters: \(String(describing: filters)), licenseArns: \(String(describing: licenseArns)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListLicensesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case licenseArns = "LicenseArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let licenseArns = licenseArns {
            var licenseArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseArns)
            for arnlist0 in licenseArns {
                try licenseArnsContainer.encode(arnlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListLicensesInputHeadersMiddleware: Middleware {
    public let id: String = "ListLicensesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLicensesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLicensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLicensesInput>
    public typealias MOutput = OperationOutput<ListLicensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLicensesOutputError>
}

public struct ListLicensesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListLicensesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLicensesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLicensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLicensesInput>
    public typealias MOutput = OperationOutput<ListLicensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLicensesOutputError>
}

public struct ListLicensesInput: Equatable {
    /// <p>Filters to scope the results. The following filters are supported:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Beneficiary</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ProductSKU</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Fingerprint</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Status</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let filters: [Filter]?
    /// <p>Amazon Resource Names (ARNs) of the licenses.</p>
    public let licenseArns: [String]?
    /// <p>Maximum number of results to return in a single call.</p>
    public let maxResults: Int?
    /// <p>Token for the next set of results.</p>
    public let nextToken: String?

    public init (
        filters: [Filter]? = nil,
        licenseArns: [String]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.licenseArns = licenseArns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLicensesInputBody: Equatable {
    public let licenseArns: [String]?
    public let filters: [Filter]?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListLicensesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case licenseArns = "LicenseArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .licenseArns)
        var licenseArnsDecoded0:[String]? = nil
        if let licenseArnsContainer = licenseArnsContainer {
            licenseArnsDecoded0 = [String]()
            for string0 in licenseArnsContainer {
                if let string0 = string0 {
                    licenseArnsDecoded0?.append(string0)
                }
            }
        }
        licenseArns = licenseArnsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListLicensesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLicensesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLicensesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLicensesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLicensesOutputResponse(licenses: \(String(describing: licenses)), nextToken: \(String(describing: nextToken)))"}
}

extension ListLicensesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListLicensesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.licenses = output.licenses
            self.nextToken = output.nextToken
        } else {
            self.licenses = nil
            self.nextToken = nil
        }
    }
}

public struct ListLicensesOutputResponse: Equatable {
    /// <p>License details.</p>
    public let licenses: [License]?
    /// <p>Token for the next set of results.</p>
    public let nextToken: String?

    public init (
        licenses: [License]? = nil,
        nextToken: String? = nil
    )
    {
        self.licenses = licenses
        self.nextToken = nextToken
    }
}

struct ListLicensesOutputResponseBody: Equatable {
    public let licenses: [License]?
    public let nextToken: String?
}

extension ListLicensesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case licenses = "Licenses"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licensesContainer = try containerValues.decodeIfPresent([License?].self, forKey: .licenses)
        var licensesDecoded0:[License]? = nil
        if let licensesContainer = licensesContainer {
            licensesDecoded0 = [License]()
            for structure0 in licensesContainer {
                if let structure0 = structure0 {
                    licensesDecoded0?.append(structure0)
                }
            }
        }
        licenses = licensesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListReceivedGrantsInputBodyMiddleware: Middleware {
    public let id: String = "ListReceivedGrantsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReceivedGrantsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReceivedGrantsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReceivedGrantsInput>
    public typealias MOutput = OperationOutput<ListReceivedGrantsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReceivedGrantsOutputError>
}

extension ListReceivedGrantsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListReceivedGrantsInput(filters: \(String(describing: filters)), grantArns: \(String(describing: grantArns)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListReceivedGrantsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case grantArns = "GrantArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let grantArns = grantArns {
            var grantArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantArns)
            for arnlist0 in grantArns {
                try grantArnsContainer.encode(arnlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListReceivedGrantsInputHeadersMiddleware: Middleware {
    public let id: String = "ListReceivedGrantsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReceivedGrantsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReceivedGrantsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReceivedGrantsInput>
    public typealias MOutput = OperationOutput<ListReceivedGrantsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReceivedGrantsOutputError>
}

public struct ListReceivedGrantsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListReceivedGrantsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReceivedGrantsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReceivedGrantsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReceivedGrantsInput>
    public typealias MOutput = OperationOutput<ListReceivedGrantsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReceivedGrantsOutputError>
}

public struct ListReceivedGrantsInput: Equatable {
    /// <p>Filters to scope the results. The following filters are supported:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ProductSKU</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LicenseIssuerName</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LicenseArn</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>GrantStatus</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>GranterAccountId</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let filters: [Filter]?
    /// <p>Amazon Resource Names (ARNs) of the grants.</p>
    public let grantArns: [String]?
    /// <p>Maximum number of results to return in a single call.</p>
    public let maxResults: Int?
    /// <p>Token for the next set of results.</p>
    public let nextToken: String?

    public init (
        filters: [Filter]? = nil,
        grantArns: [String]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.grantArns = grantArns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListReceivedGrantsInputBody: Equatable {
    public let grantArns: [String]?
    public let filters: [Filter]?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListReceivedGrantsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case grantArns = "GrantArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .grantArns)
        var grantArnsDecoded0:[String]? = nil
        if let grantArnsContainer = grantArnsContainer {
            grantArnsDecoded0 = [String]()
            for string0 in grantArnsContainer {
                if let string0 = string0 {
                    grantArnsDecoded0?.append(string0)
                }
            }
        }
        grantArns = grantArnsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListReceivedGrantsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReceivedGrantsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListReceivedGrantsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReceivedGrantsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListReceivedGrantsOutputResponse(grants: \(String(describing: grants)), nextToken: \(String(describing: nextToken)))"}
}

extension ListReceivedGrantsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListReceivedGrantsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.grants = output.grants
            self.nextToken = output.nextToken
        } else {
            self.grants = nil
            self.nextToken = nil
        }
    }
}

public struct ListReceivedGrantsOutputResponse: Equatable {
    /// <p>Received grant details.</p>
    public let grants: [Grant]?
    /// <p>Token for the next set of results.</p>
    public let nextToken: String?

    public init (
        grants: [Grant]? = nil,
        nextToken: String? = nil
    )
    {
        self.grants = grants
        self.nextToken = nextToken
    }
}

struct ListReceivedGrantsOutputResponseBody: Equatable {
    public let grants: [Grant]?
    public let nextToken: String?
}

extension ListReceivedGrantsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case grants = "Grants"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantsContainer = try containerValues.decodeIfPresent([Grant?].self, forKey: .grants)
        var grantsDecoded0:[Grant]? = nil
        if let grantsContainer = grantsContainer {
            grantsDecoded0 = [Grant]()
            for structure0 in grantsContainer {
                if let structure0 = structure0 {
                    grantsDecoded0?.append(structure0)
                }
            }
        }
        grants = grantsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListReceivedLicensesInputBodyMiddleware: Middleware {
    public let id: String = "ListReceivedLicensesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReceivedLicensesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReceivedLicensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReceivedLicensesInput>
    public typealias MOutput = OperationOutput<ListReceivedLicensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReceivedLicensesOutputError>
}

extension ListReceivedLicensesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListReceivedLicensesInput(filters: \(String(describing: filters)), licenseArns: \(String(describing: licenseArns)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListReceivedLicensesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case licenseArns = "LicenseArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let licenseArns = licenseArns {
            var licenseArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseArns)
            for arnlist0 in licenseArns {
                try licenseArnsContainer.encode(arnlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListReceivedLicensesInputHeadersMiddleware: Middleware {
    public let id: String = "ListReceivedLicensesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReceivedLicensesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReceivedLicensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReceivedLicensesInput>
    public typealias MOutput = OperationOutput<ListReceivedLicensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReceivedLicensesOutputError>
}

public struct ListReceivedLicensesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListReceivedLicensesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReceivedLicensesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReceivedLicensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReceivedLicensesInput>
    public typealias MOutput = OperationOutput<ListReceivedLicensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReceivedLicensesOutputError>
}

public struct ListReceivedLicensesInput: Equatable {
    /// <p>Filters to scope the results. The following filters are supported:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ProductSKU</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Status</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Fingerprint</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IssuerName</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Beneficiary</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let filters: [Filter]?
    /// <p>Amazon Resource Names (ARNs) of the licenses.</p>
    public let licenseArns: [String]?
    /// <p>Maximum number of results to return in a single call.</p>
    public let maxResults: Int?
    /// <p>Token for the next set of results.</p>
    public let nextToken: String?

    public init (
        filters: [Filter]? = nil,
        licenseArns: [String]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.licenseArns = licenseArns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListReceivedLicensesInputBody: Equatable {
    public let licenseArns: [String]?
    public let filters: [Filter]?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListReceivedLicensesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case licenseArns = "LicenseArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .licenseArns)
        var licenseArnsDecoded0:[String]? = nil
        if let licenseArnsContainer = licenseArnsContainer {
            licenseArnsDecoded0 = [String]()
            for string0 in licenseArnsContainer {
                if let string0 = string0 {
                    licenseArnsDecoded0?.append(string0)
                }
            }
        }
        licenseArns = licenseArnsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListReceivedLicensesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReceivedLicensesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListReceivedLicensesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReceivedLicensesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListReceivedLicensesOutputResponse(licenses: \(String(describing: licenses)), nextToken: \(String(describing: nextToken)))"}
}

extension ListReceivedLicensesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListReceivedLicensesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.licenses = output.licenses
            self.nextToken = output.nextToken
        } else {
            self.licenses = nil
            self.nextToken = nil
        }
    }
}

public struct ListReceivedLicensesOutputResponse: Equatable {
    /// <p>Received license details.</p>
    public let licenses: [GrantedLicense]?
    /// <p>Token for the next set of results.</p>
    public let nextToken: String?

    public init (
        licenses: [GrantedLicense]? = nil,
        nextToken: String? = nil
    )
    {
        self.licenses = licenses
        self.nextToken = nextToken
    }
}

struct ListReceivedLicensesOutputResponseBody: Equatable {
    public let licenses: [GrantedLicense]?
    public let nextToken: String?
}

extension ListReceivedLicensesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case licenses = "Licenses"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licensesContainer = try containerValues.decodeIfPresent([GrantedLicense?].self, forKey: .licenses)
        var licensesDecoded0:[GrantedLicense]? = nil
        if let licensesContainer = licensesContainer {
            licensesDecoded0 = [GrantedLicense]()
            for structure0 in licensesContainer {
                if let structure0 = structure0 {
                    licensesDecoded0?.append(structure0)
                }
            }
        }
        licenses = licensesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListResourceInventoryInputBodyMiddleware: Middleware {
    public let id: String = "ListResourceInventoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourceInventoryInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourceInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourceInventoryInput>
    public typealias MOutput = OperationOutput<ListResourceInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourceInventoryOutputError>
}

extension ListResourceInventoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourceInventoryInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListResourceInventoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for inventoryfilterlist0 in filters {
                try filtersContainer.encode(inventoryfilterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListResourceInventoryInputHeadersMiddleware: Middleware {
    public let id: String = "ListResourceInventoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourceInventoryInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourceInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourceInventoryInput>
    public typealias MOutput = OperationOutput<ListResourceInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourceInventoryOutputError>
}

public struct ListResourceInventoryInputQueryItemMiddleware: Middleware {
    public let id: String = "ListResourceInventoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourceInventoryInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourceInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourceInventoryInput>
    public typealias MOutput = OperationOutput<ListResourceInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourceInventoryOutputError>
}

public struct ListResourceInventoryInput: Equatable {
    /// <p>Filters to scope the results. The following filters and logical operators
    ///         are supported:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>account_id</code> - The ID of the AWS account that owns the resource.
    ///                Logical operators are <code>EQUALS</code> | <code>NOT_EQUALS</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>application_name</code> - The name of the application.
    ///                Logical operators are <code>EQUALS</code> | <code>BEGINS_WITH</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>license_included</code> - The type of license included.
    ///                Logical operators are <code>EQUALS</code> | <code>NOT_EQUALS</code>.
    ///                Possible values are <code>sql-server-enterprise</code> |
    ///                <code>sql-server-standard</code> |
    ///                <code>sql-server-web</code> |
    ///                <code>windows-server-datacenter</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>platform</code> - The platform of the resource.
    ///                Logical operators are <code>EQUALS</code> | <code>BEGINS_WITH</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>resource_id</code> - The ID of the resource.
    ///                Logical operators are <code>EQUALS</code> | <code>NOT_EQUALS</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>tag:<key></code> - The key/value combination of a tag assigned
    ///                to the resource. Logical operators are <code>EQUALS</code> (single account) or
    ///                <code>EQUALS</code> | <code>NOT_EQUALS</code> (cross account).</p>
    ///             </li>
    ///          </ul>
    public let filters: [InventoryFilter]?
    /// <p>Maximum number of results to return in a single call.</p>
    public let maxResults: Int?
    /// <p>Token for the next set of results.</p>
    public let nextToken: String?

    public init (
        filters: [InventoryFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResourceInventoryInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
    public let filters: [InventoryFilter]?
}

extension ListResourceInventoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([InventoryFilter?].self, forKey: .filters)
        var filtersDecoded0:[InventoryFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [InventoryFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListResourceInventoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourceInventoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FilterLimitExceededException" : self = .filterLimitExceededException(try FilterLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourceInventoryOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case failedDependencyException(FailedDependencyException)
    case filterLimitExceededException(FilterLimitExceededException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourceInventoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourceInventoryOutputResponse(nextToken: \(String(describing: nextToken)), resourceInventoryList: \(String(describing: resourceInventoryList)))"}
}

extension ListResourceInventoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListResourceInventoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.resourceInventoryList = output.resourceInventoryList
        } else {
            self.nextToken = nil
            self.resourceInventoryList = nil
        }
    }
}

public struct ListResourceInventoryOutputResponse: Equatable {
    /// <p>Token for the next set of results.</p>
    public let nextToken: String?
    /// <p>Information about the resources.</p>
    public let resourceInventoryList: [ResourceInventory]?

    public init (
        nextToken: String? = nil,
        resourceInventoryList: [ResourceInventory]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceInventoryList = resourceInventoryList
    }
}

struct ListResourceInventoryOutputResponseBody: Equatable {
    public let resourceInventoryList: [ResourceInventory]?
    public let nextToken: String?
}

extension ListResourceInventoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case resourceInventoryList = "ResourceInventoryList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceInventoryListContainer = try containerValues.decodeIfPresent([ResourceInventory?].self, forKey: .resourceInventoryList)
        var resourceInventoryListDecoded0:[ResourceInventory]? = nil
        if let resourceInventoryListContainer = resourceInventoryListContainer {
            resourceInventoryListDecoded0 = [ResourceInventory]()
            for structure0 in resourceInventoryListContainer {
                if let structure0 = structure0 {
                    resourceInventoryListDecoded0?.append(structure0)
                }
            }
        }
        resourceInventoryList = resourceInventoryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>Amazon Resource Name (ARN) of the license configuration.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceArn: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>Information about the tags.</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct ListTokensInputBodyMiddleware: Middleware {
    public let id: String = "ListTokensInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTokensInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTokensOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTokensInput>
    public typealias MOutput = OperationOutput<ListTokensOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTokensOutputError>
}

extension ListTokensInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTokensInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), tokenIds: \(String(describing: tokenIds)))"}
}

extension ListTokensInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case tokenIds = "TokenIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let tokenIds = tokenIds {
            var tokenIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tokenIds)
            for stringlist0 in tokenIds {
                try tokenIdsContainer.encode(stringlist0)
            }
        }
    }
}

public struct ListTokensInputHeadersMiddleware: Middleware {
    public let id: String = "ListTokensInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTokensInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTokensOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTokensInput>
    public typealias MOutput = OperationOutput<ListTokensOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTokensOutputError>
}

public struct ListTokensInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTokensInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTokensInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTokensOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTokensInput>
    public typealias MOutput = OperationOutput<ListTokensOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTokensOutputError>
}

public struct ListTokensInput: Equatable {
    /// <p>Filters to scope the results. The following filter is supported:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>LicenseArns</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let filters: [Filter]?
    /// <p>Maximum number of results to return in a single call.</p>
    public let maxResults: Int?
    /// <p>Token for the next set of results.</p>
    public let nextToken: String?
    /// <p>Token IDs.</p>
    public let tokenIds: [String]?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        tokenIds: [String]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.tokenIds = tokenIds
    }
}

struct ListTokensInputBody: Equatable {
    public let tokenIds: [String]?
    public let filters: [Filter]?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListTokensInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case tokenIds = "TokenIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tokenIds)
        var tokenIdsDecoded0:[String]? = nil
        if let tokenIdsContainer = tokenIdsContainer {
            tokenIdsDecoded0 = [String]()
            for string0 in tokenIdsContainer {
                if let string0 = string0 {
                    tokenIdsDecoded0?.append(string0)
                }
            }
        }
        tokenIds = tokenIdsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTokensOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTokensOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTokensOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTokensOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTokensOutputResponse(nextToken: \(String(describing: nextToken)), tokens: \(String(describing: tokens)))"}
}

extension ListTokensOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTokensOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tokens = output.tokens
        } else {
            self.nextToken = nil
            self.tokens = nil
        }
    }
}

public struct ListTokensOutputResponse: Equatable {
    /// <p>Token for the next set of results.</p>
    public let nextToken: String?
    /// <p>Received token details.</p>
    public let tokens: [TokenData]?

    public init (
        nextToken: String? = nil,
        tokens: [TokenData]? = nil
    )
    {
        self.nextToken = nextToken
        self.tokens = tokens
    }
}

struct ListTokensOutputResponseBody: Equatable {
    public let tokens: [TokenData]?
    public let nextToken: String?
}

extension ListTokensOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case tokens = "Tokens"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokensContainer = try containerValues.decodeIfPresent([TokenData?].self, forKey: .tokens)
        var tokensDecoded0:[TokenData]? = nil
        if let tokensContainer = tokensContainer {
            tokensDecoded0 = [TokenData]()
            for structure0 in tokensContainer {
                if let structure0 = structure0 {
                    tokensDecoded0?.append(structure0)
                }
            }
        }
        tokens = tokensDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListUsageForLicenseConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "ListUsageForLicenseConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUsageForLicenseConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUsageForLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUsageForLicenseConfigurationInput>
    public typealias MOutput = OperationOutput<ListUsageForLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUsageForLicenseConfigurationOutputError>
}

extension ListUsageForLicenseConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUsageForLicenseConfigurationInput(filters: \(String(describing: filters)), licenseConfigurationArn: \(String(describing: licenseConfigurationArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListUsageForLicenseConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case licenseConfigurationArn = "LicenseConfigurationArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let licenseConfigurationArn = licenseConfigurationArn {
            try encodeContainer.encode(licenseConfigurationArn, forKey: .licenseConfigurationArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListUsageForLicenseConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "ListUsageForLicenseConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUsageForLicenseConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUsageForLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUsageForLicenseConfigurationInput>
    public typealias MOutput = OperationOutput<ListUsageForLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUsageForLicenseConfigurationOutputError>
}

public struct ListUsageForLicenseConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "ListUsageForLicenseConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUsageForLicenseConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUsageForLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUsageForLicenseConfigurationInput>
    public typealias MOutput = OperationOutput<ListUsageForLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUsageForLicenseConfigurationOutputError>
}

public struct ListUsageForLicenseConfigurationInput: Equatable {
    /// <p>Filters to scope the results. The following filters and logical operators
    ///         are supported:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>resourceArn</code> - The ARN of the license configuration resource.
    ///                Logical operators are <code>EQUALS</code> | <code>NOT_EQUALS</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>resourceType</code> - The resource type (<code>EC2_INSTANCE</code> | <code>EC2_HOST</code> | <code>EC2_AMI</code> | <code>SYSTEMS_MANAGER_MANAGED_INSTANCE</code>).
    ///                Logical operators are <code>EQUALS</code> | <code>NOT_EQUALS</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>resourceAccount</code> - The ID of the account that owns the resource.
    ///                Logical operators are <code>EQUALS</code> | <code>NOT_EQUALS</code>.</p>
    ///             </li>
    ///          </ul>
    public let filters: [Filter]?
    /// <p>Amazon Resource Name (ARN) of the license configuration.</p>
    public let licenseConfigurationArn: String?
    /// <p>Maximum number of results to return in a single call.</p>
    public let maxResults: Int?
    /// <p>Token for the next set of results.</p>
    public let nextToken: String?

    public init (
        filters: [Filter]? = nil,
        licenseConfigurationArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.licenseConfigurationArn = licenseConfigurationArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUsageForLicenseConfigurationInputBody: Equatable {
    public let licenseConfigurationArn: String?
    public let maxResults: Int?
    public let nextToken: String?
    public let filters: [Filter]?
}

extension ListUsageForLicenseConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case licenseConfigurationArn = "LicenseConfigurationArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseConfigurationArn)
        licenseConfigurationArn = licenseConfigurationArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListUsageForLicenseConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUsageForLicenseConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FilterLimitExceededException" : self = .filterLimitExceededException(try FilterLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUsageForLicenseConfigurationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case filterLimitExceededException(FilterLimitExceededException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUsageForLicenseConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUsageForLicenseConfigurationOutputResponse(licenseConfigurationUsageList: \(String(describing: licenseConfigurationUsageList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListUsageForLicenseConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListUsageForLicenseConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.licenseConfigurationUsageList = output.licenseConfigurationUsageList
            self.nextToken = output.nextToken
        } else {
            self.licenseConfigurationUsageList = nil
            self.nextToken = nil
        }
    }
}

public struct ListUsageForLicenseConfigurationOutputResponse: Equatable {
    /// <p>Information about the license configurations.</p>
    public let licenseConfigurationUsageList: [LicenseConfigurationUsage]?
    /// <p>Token for the next set of results.</p>
    public let nextToken: String?

    public init (
        licenseConfigurationUsageList: [LicenseConfigurationUsage]? = nil,
        nextToken: String? = nil
    )
    {
        self.licenseConfigurationUsageList = licenseConfigurationUsageList
        self.nextToken = nextToken
    }
}

struct ListUsageForLicenseConfigurationOutputResponseBody: Equatable {
    public let licenseConfigurationUsageList: [LicenseConfigurationUsage]?
    public let nextToken: String?
}

extension ListUsageForLicenseConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case licenseConfigurationUsageList = "LicenseConfigurationUsageList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationUsageListContainer = try containerValues.decodeIfPresent([LicenseConfigurationUsage?].self, forKey: .licenseConfigurationUsageList)
        var licenseConfigurationUsageListDecoded0:[LicenseConfigurationUsage]? = nil
        if let licenseConfigurationUsageListContainer = licenseConfigurationUsageListContainer {
            licenseConfigurationUsageListDecoded0 = [LicenseConfigurationUsage]()
            for structure0 in licenseConfigurationUsageListContainer {
                if let structure0 = structure0 {
                    licenseConfigurationUsageListDecoded0?.append(structure0)
                }
            }
        }
        licenseConfigurationUsageList = licenseConfigurationUsageListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ManagedResourceSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associationCount = "AssociationCount"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationCount = associationCount {
            try encodeContainer.encode(associationCount, forKey: .associationCount)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let associationCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .associationCount)
        associationCount = associationCountDecoded
    }
}

extension ManagedResourceSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ManagedResourceSummary(associationCount: \(String(describing: associationCount)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>Summary information about a managed resource.</p>
public struct ManagedResourceSummary: Equatable {
    /// <p>Number of resources associated with licenses.</p>
    public let associationCount: Int?
    /// <p>Type of resource associated with a license.</p>
    public let resourceType: ResourceType?

    public init (
        associationCount: Int? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.associationCount = associationCount
        self.resourceType = resourceType
    }
}

extension Metadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Metadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Metadata(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>Describes key/value pairs.</p>
public struct Metadata: Equatable {
    /// <p>The key name.</p>
    public let name: String?
    /// <p>The value.</p>
    public let value: String?

    public init (
        name: String? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

extension NoEntitlementsAllowedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoEntitlementsAllowedException(message: \(String(describing: message)))"}
}

extension NoEntitlementsAllowedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NoEntitlementsAllowedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There are no entitlements found for this license, or the entitlement maximum count is reached.</p>
public struct NoEntitlementsAllowedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoEntitlementsAllowedExceptionBody: Equatable {
    public let message: String?
}

extension NoEntitlementsAllowedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OrganizationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enableIntegration = "EnableIntegration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enableIntegration != false {
            try encodeContainer.encode(enableIntegration, forKey: .enableIntegration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableIntegrationDecoded = try containerValues.decode(Bool.self, forKey: .enableIntegration)
        enableIntegration = enableIntegrationDecoded
    }
}

extension OrganizationConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrganizationConfiguration(enableIntegration: \(String(describing: enableIntegration)))"}
}

/// <p>Configuration information for AWS Organizations.</p>
public struct OrganizationConfiguration: Equatable {
    /// <p>Enables AWS Organization integration.</p>
    public let enableIntegration: Bool

    public init (
        enableIntegration: Bool = false
    )
    {
        self.enableIntegration = enableIntegration
    }
}

extension ProductInformation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case productInformationFilterList = "ProductInformationFilterList"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let productInformationFilterList = productInformationFilterList {
            var productInformationFilterListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productInformationFilterList)
            for productinformationfilterlist0 in productInformationFilterList {
                try productInformationFilterListContainer.encode(productinformationfilterlist0)
            }
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let productInformationFilterListContainer = try containerValues.decodeIfPresent([ProductInformationFilter?].self, forKey: .productInformationFilterList)
        var productInformationFilterListDecoded0:[ProductInformationFilter]? = nil
        if let productInformationFilterListContainer = productInformationFilterListContainer {
            productInformationFilterListDecoded0 = [ProductInformationFilter]()
            for structure0 in productInformationFilterListContainer {
                if let structure0 = structure0 {
                    productInformationFilterListDecoded0?.append(structure0)
                }
            }
        }
        productInformationFilterList = productInformationFilterListDecoded0
    }
}

extension ProductInformation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProductInformation(productInformationFilterList: \(String(describing: productInformationFilterList)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>Describes product information for a license configuration.</p>
public struct ProductInformation: Equatable {
    /// <p>A Product information filter consists of a <code>ProductInformationFilterComparator</code> which is a logical operator, a <code>ProductInformationFilterName</code> which specifies the type of filter being declared, and a <code>ProductInformationFilterValue</code> that specifies the value to filter on. </p>
    ///          <p>Accepted values for <code>ProductInformationFilterName</code> are listed here along with descriptions and valid options for <code>ProductInformationFilterComparator</code>. </p>
    ///          <p>The following filters and are supported when the resource type
    ///          is <code>SSM_MANAGED</code>:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Application Name</code> - The name of the application.
    ///                Logical operator is <code>EQUALS</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Application Publisher</code> - The publisher of the application.
    ///                Logical operator is <code>EQUALS</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Application Version</code> - The version of the application.
    ///                Logical operator is <code>EQUALS</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Platform Name</code> - The name of the platform.
    ///                Logical operator is <code>EQUALS</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Platform Type</code> - The platform type.
    ///                Logical operator is <code>EQUALS</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Tag:key</code> - The key of a tag attached to an AWS resource you wish to exclude from automated discovery. Logical operator is <code>NOT_EQUALS</code>.  The key for your tag must be appended to <code>Tag:</code> following the example: <code>Tag:name-of-your-key</code>. <code>ProductInformationFilterValue</code> is optional if you are not using values for the key.
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>AccountId</code> - The 12-digit ID of an AWS account you wish to exclude from automated discovery.
    ///                Logical operator is <code>NOT_EQUALS</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>License Included</code> - The type of license included.
    ///                Logical operators are <code>EQUALS</code> and <code>NOT_EQUALS</code>.
    ///                Possible values are: <code>sql-server-enterprise</code> |
    ///                <code>sql-server-standard</code> |
    ///                <code>sql-server-web</code> |
    ///                <code>windows-server-datacenter</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The following filters and logical operators are supported when the resource type
    ///          is <code>RDS</code>:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Engine Edition</code> - The edition of the database engine.
    ///                Logical operator is <code>EQUALS</code>.
    ///                Possible values are: <code>oracle-ee</code> | <code>oracle-se</code> | <code>oracle-se1</code> | <code>oracle-se2</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>License Pack</code> - The license pack.
    ///                Logical operator is <code>EQUALS</code>.
    ///                Possible values are: <code>data guard</code> |
    ///                <code>diagnostic pack sqlt</code> |
    ///                <code>tuning pack sqlt</code> |
    ///                <code>ols</code> |
    ///                <code>olap</code>.</p>
    ///             </li>
    ///          </ul>
    public let productInformationFilterList: [ProductInformationFilter]?
    /// <p>Resource type. The possible values are <code>SSM_MANAGED</code> | <code>RDS</code>.</p>
    public let resourceType: String?

    public init (
        productInformationFilterList: [ProductInformationFilter]? = nil,
        resourceType: String? = nil
    )
    {
        self.productInformationFilterList = productInformationFilterList
        self.resourceType = resourceType
    }
}

extension ProductInformationFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case productInformationFilterComparator = "ProductInformationFilterComparator"
        case productInformationFilterName = "ProductInformationFilterName"
        case productInformationFilterValue = "ProductInformationFilterValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let productInformationFilterComparator = productInformationFilterComparator {
            try encodeContainer.encode(productInformationFilterComparator, forKey: .productInformationFilterComparator)
        }
        if let productInformationFilterName = productInformationFilterName {
            try encodeContainer.encode(productInformationFilterName, forKey: .productInformationFilterName)
        }
        if let productInformationFilterValue = productInformationFilterValue {
            var productInformationFilterValueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productInformationFilterValue)
            for stringlist0 in productInformationFilterValue {
                try productInformationFilterValueContainer.encode(stringlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productInformationFilterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productInformationFilterName)
        productInformationFilterName = productInformationFilterNameDecoded
        let productInformationFilterValueContainer = try containerValues.decodeIfPresent([String?].self, forKey: .productInformationFilterValue)
        var productInformationFilterValueDecoded0:[String]? = nil
        if let productInformationFilterValueContainer = productInformationFilterValueContainer {
            productInformationFilterValueDecoded0 = [String]()
            for string0 in productInformationFilterValueContainer {
                if let string0 = string0 {
                    productInformationFilterValueDecoded0?.append(string0)
                }
            }
        }
        productInformationFilterValue = productInformationFilterValueDecoded0
        let productInformationFilterComparatorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productInformationFilterComparator)
        productInformationFilterComparator = productInformationFilterComparatorDecoded
    }
}

extension ProductInformationFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProductInformationFilter(productInformationFilterComparator: \(String(describing: productInformationFilterComparator)), productInformationFilterName: \(String(describing: productInformationFilterName)), productInformationFilterValue: \(String(describing: productInformationFilterValue)))"}
}

/// <p>Describes product information filters.</p>
public struct ProductInformationFilter: Equatable {
    /// <p>Logical operator.</p>
    public let productInformationFilterComparator: String?
    /// <p>Filter name.</p>
    public let productInformationFilterName: String?
    /// <p>Filter value.</p>
    public let productInformationFilterValue: [String]?

    public init (
        productInformationFilterComparator: String? = nil,
        productInformationFilterName: String? = nil,
        productInformationFilterValue: [String]? = nil
    )
    {
        self.productInformationFilterComparator = productInformationFilterComparator
        self.productInformationFilterName = productInformationFilterName
        self.productInformationFilterValue = productInformationFilterValue
    }
}

extension ProvisionalConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxTimeToLiveInMinutes = "MaxTimeToLiveInMinutes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxTimeToLiveInMinutes = maxTimeToLiveInMinutes {
            try encodeContainer.encode(maxTimeToLiveInMinutes, forKey: .maxTimeToLiveInMinutes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxTimeToLiveInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxTimeToLiveInMinutes)
        maxTimeToLiveInMinutes = maxTimeToLiveInMinutesDecoded
    }
}

extension ProvisionalConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvisionalConfiguration(maxTimeToLiveInMinutes: \(String(describing: maxTimeToLiveInMinutes)))"}
}

/// <p>Details about a provisional configuration.</p>
public struct ProvisionalConfiguration: Equatable {
    /// <p>Maximum time for the provisional configuration, in minutes.</p>
    public let maxTimeToLiveInMinutes: Int?

    public init (
        maxTimeToLiveInMinutes: Int? = nil
    )
    {
        self.maxTimeToLiveInMinutes = maxTimeToLiveInMinutes
    }
}

extension RateLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RateLimitExceededException(message: \(String(describing: message)))"}
}

extension RateLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RateLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Too many requests have been submitted. Try again after a brief wait.</p>
public struct RateLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RateLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension RateLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ReceivedMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedOperations = "AllowedOperations"
        case receivedStatus = "ReceivedStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedOperations = allowedOperations {
            var allowedOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedOperations)
            for allowedoperationlist0 in allowedOperations {
                try allowedOperationsContainer.encode(allowedoperationlist0.rawValue)
            }
        }
        if let receivedStatus = receivedStatus {
            try encodeContainer.encode(receivedStatus.rawValue, forKey: .receivedStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let receivedStatusDecoded = try containerValues.decodeIfPresent(ReceivedStatus.self, forKey: .receivedStatus)
        receivedStatus = receivedStatusDecoded
        let allowedOperationsContainer = try containerValues.decodeIfPresent([AllowedOperation?].self, forKey: .allowedOperations)
        var allowedOperationsDecoded0:[AllowedOperation]? = nil
        if let allowedOperationsContainer = allowedOperationsContainer {
            allowedOperationsDecoded0 = [AllowedOperation]()
            for string0 in allowedOperationsContainer {
                if let string0 = string0 {
                    allowedOperationsDecoded0?.append(string0)
                }
            }
        }
        allowedOperations = allowedOperationsDecoded0
    }
}

extension ReceivedMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReceivedMetadata(allowedOperations: \(String(describing: allowedOperations)), receivedStatus: \(String(describing: receivedStatus)))"}
}

/// <p>Metadata associated with received licenses and grants.</p>
public struct ReceivedMetadata: Equatable {
    /// <p>Allowed operations.</p>
    public let allowedOperations: [AllowedOperation]?
    /// <p>Received status.</p>
    public let receivedStatus: ReceivedStatus?

    public init (
        allowedOperations: [AllowedOperation]? = nil,
        receivedStatus: ReceivedStatus? = nil
    )
    {
        self.allowedOperations = allowedOperations
        self.receivedStatus = receivedStatus
    }
}

public enum ReceivedStatus {
    case active
    case deleted
    case disabled
    case failedWorkflow
    case pendingAccept
    case pendingWorkflow
    case rejected
    case sdkUnknown(String)
}

extension ReceivedStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReceivedStatus] {
        return [
            .active,
            .deleted,
            .disabled,
            .failedWorkflow,
            .pendingAccept,
            .pendingWorkflow,
            .rejected,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .deleted: return "DELETED"
        case .disabled: return "DISABLED"
        case .failedWorkflow: return "FAILED_WORKFLOW"
        case .pendingAccept: return "PENDING_ACCEPT"
        case .pendingWorkflow: return "PENDING_WORKFLOW"
        case .rejected: return "REJECTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReceivedStatus(rawValue: rawValue) ?? ReceivedStatus.sdkUnknown(rawValue)
    }
}

extension RedirectException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RedirectException(location: \(String(describing: location)), message: \(String(describing: message)))"}
}

extension RedirectException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RedirectExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This is not the correct Region for the resource. Try again.</p>
public struct RedirectException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var location: String?
    public var message: String?

    public init (
        location: String? = nil,
        message: String? = nil
    )
    {
        self.location = location
        self.message = message
    }
}

struct RedirectExceptionBody: Equatable {
    public let message: String?
}

extension RedirectExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct RejectGrantInputBodyMiddleware: Middleware {
    public let id: String = "RejectGrantInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RejectGrantInput>,
                  next: H) -> Swift.Result<OperationOutput<RejectGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RejectGrantInput>
    public typealias MOutput = OperationOutput<RejectGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RejectGrantOutputError>
}

extension RejectGrantInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RejectGrantInput(grantArn: \(String(describing: grantArn)))"}
}

extension RejectGrantInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grantArn = "GrantArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantArn = grantArn {
            try encodeContainer.encode(grantArn, forKey: .grantArn)
        }
    }
}

public struct RejectGrantInputHeadersMiddleware: Middleware {
    public let id: String = "RejectGrantInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RejectGrantInput>,
                  next: H) -> Swift.Result<OperationOutput<RejectGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RejectGrantInput>
    public typealias MOutput = OperationOutput<RejectGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RejectGrantOutputError>
}

public struct RejectGrantInputQueryItemMiddleware: Middleware {
    public let id: String = "RejectGrantInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RejectGrantInput>,
                  next: H) -> Swift.Result<OperationOutput<RejectGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RejectGrantInput>
    public typealias MOutput = OperationOutput<RejectGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RejectGrantOutputError>
}

public struct RejectGrantInput: Equatable {
    /// <p>Amazon Resource Name (ARN) of the grant.</p>
    public let grantArn: String?

    public init (
        grantArn: String? = nil
    )
    {
        self.grantArn = grantArn
    }
}

struct RejectGrantInputBody: Equatable {
    public let grantArn: String?
}

extension RejectGrantInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case grantArn = "GrantArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
    }
}

extension RejectGrantOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RejectGrantOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RejectGrantOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RejectGrantOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RejectGrantOutputResponse(grantArn: \(String(describing: grantArn)), status: \(String(describing: status)), version: \(String(describing: version)))"}
}

extension RejectGrantOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RejectGrantOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.grantArn = output.grantArn
            self.status = output.status
            self.version = output.version
        } else {
            self.grantArn = nil
            self.status = nil
            self.version = nil
        }
    }
}

public struct RejectGrantOutputResponse: Equatable {
    /// <p>Grant ARN.</p>
    public let grantArn: String?
    /// <p>Grant status.</p>
    public let status: GrantStatus?
    /// <p>Grant version.</p>
    public let version: String?

    public init (
        grantArn: String? = nil,
        status: GrantStatus? = nil,
        version: String? = nil
    )
    {
        self.grantArn = grantArn
        self.status = status
        self.version = version
    }
}

struct RejectGrantOutputResponseBody: Equatable {
    public let grantArn: String?
    public let status: GrantStatus?
    public let version: String?
}

extension RejectGrantOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case grantArn = "GrantArn"
        case status = "Status"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GrantStatus.self, forKey: .status)
        status = statusDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

public enum RenewType {
    case monthly
    case `none`
    case weekly
    case sdkUnknown(String)
}

extension RenewType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RenewType] {
        return [
            .monthly,
            .none,
            .weekly,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .monthly: return "Monthly"
        case .none: return "None"
        case .weekly: return "Weekly"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RenewType(rawValue: rawValue) ?? RenewType.sdkUnknown(rawValue)
    }
}

extension ReportContext: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case licenseConfigurationArns
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseConfigurationArns = licenseConfigurationArns {
            var licenseConfigurationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseConfigurationArns)
            for arnlist0 in licenseConfigurationArns {
                try licenseConfigurationArnsContainer.encode(arnlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .licenseConfigurationArns)
        var licenseConfigurationArnsDecoded0:[String]? = nil
        if let licenseConfigurationArnsContainer = licenseConfigurationArnsContainer {
            licenseConfigurationArnsDecoded0 = [String]()
            for string0 in licenseConfigurationArnsContainer {
                if let string0 = string0 {
                    licenseConfigurationArnsDecoded0?.append(string0)
                }
            }
        }
        licenseConfigurationArns = licenseConfigurationArnsDecoded0
    }
}

extension ReportContext: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReportContext(licenseConfigurationArns: \(String(describing: licenseConfigurationArns)))"}
}

/// <p>Details of the license configuration that this generator reports on.</p>
public struct ReportContext: Equatable {
    /// <p>Amazon Resource Number (ARN) of the license configuration that this generator reports on.</p>
    public let licenseConfigurationArns: [String]?

    public init (
        licenseConfigurationArns: [String]? = nil
    )
    {
        self.licenseConfigurationArns = licenseConfigurationArns
    }
}

extension ReportFrequency: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case period
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let period = period {
            try encodeContainer.encode(period.rawValue, forKey: .period)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .value)
        value = valueDecoded
        let periodDecoded = try containerValues.decodeIfPresent(ReportFrequencyType.self, forKey: .period)
        period = periodDecoded
    }
}

extension ReportFrequency: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReportFrequency(period: \(String(describing: period)), value: \(String(describing: value)))"}
}

/// <p>Details on how frequently reports are generated.</p>
public struct ReportFrequency: Equatable {
    /// <p>Time period between each report. The period can be daily, weekly, or monthly.</p>
    public let period: ReportFrequencyType?
    /// <p>Number of times within the frequency period that a report will be generated.  Currently only <code>1</code> is supported.</p>
    public let value: Int?

    public init (
        period: ReportFrequencyType? = nil,
        value: Int? = nil
    )
    {
        self.period = period
        self.value = value
    }
}

public enum ReportFrequencyType {
    case day
    case month
    case week
    case sdkUnknown(String)
}

extension ReportFrequencyType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReportFrequencyType] {
        return [
            .day,
            .month,
            .week,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .day: return "DAY"
        case .month: return "MONTH"
        case .week: return "WEEK"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReportFrequencyType(rawValue: rawValue) ?? ReportFrequencyType.sdkUnknown(rawValue)
    }
}

extension ReportGenerator: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createTime = "CreateTime"
        case description = "Description"
        case lastReportGenerationTime = "LastReportGenerationTime"
        case lastRunFailureReason = "LastRunFailureReason"
        case lastRunStatus = "LastRunStatus"
        case licenseManagerReportGeneratorArn = "LicenseManagerReportGeneratorArn"
        case reportContext = "ReportContext"
        case reportCreatorAccount = "ReportCreatorAccount"
        case reportFrequency = "ReportFrequency"
        case reportGeneratorName = "ReportGeneratorName"
        case reportType = "ReportType"
        case s3Location = "S3Location"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createTime = createTime {
            try encodeContainer.encode(createTime, forKey: .createTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastReportGenerationTime = lastReportGenerationTime {
            try encodeContainer.encode(lastReportGenerationTime, forKey: .lastReportGenerationTime)
        }
        if let lastRunFailureReason = lastRunFailureReason {
            try encodeContainer.encode(lastRunFailureReason, forKey: .lastRunFailureReason)
        }
        if let lastRunStatus = lastRunStatus {
            try encodeContainer.encode(lastRunStatus, forKey: .lastRunStatus)
        }
        if let licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArn {
            try encodeContainer.encode(licenseManagerReportGeneratorArn, forKey: .licenseManagerReportGeneratorArn)
        }
        if let reportContext = reportContext {
            try encodeContainer.encode(reportContext, forKey: .reportContext)
        }
        if let reportCreatorAccount = reportCreatorAccount {
            try encodeContainer.encode(reportCreatorAccount, forKey: .reportCreatorAccount)
        }
        if let reportFrequency = reportFrequency {
            try encodeContainer.encode(reportFrequency, forKey: .reportFrequency)
        }
        if let reportGeneratorName = reportGeneratorName {
            try encodeContainer.encode(reportGeneratorName, forKey: .reportGeneratorName)
        }
        if let reportType = reportType {
            var reportTypeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reportType)
            for reporttypelist0 in reportType {
                try reportTypeContainer.encode(reporttypelist0.rawValue)
            }
        }
        if let s3Location = s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportGeneratorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportGeneratorName)
        reportGeneratorName = reportGeneratorNameDecoded
        let reportTypeContainer = try containerValues.decodeIfPresent([ReportType?].self, forKey: .reportType)
        var reportTypeDecoded0:[ReportType]? = nil
        if let reportTypeContainer = reportTypeContainer {
            reportTypeDecoded0 = [ReportType]()
            for string0 in reportTypeContainer {
                if let string0 = string0 {
                    reportTypeDecoded0?.append(string0)
                }
            }
        }
        reportType = reportTypeDecoded0
        let reportContextDecoded = try containerValues.decodeIfPresent(ReportContext.self, forKey: .reportContext)
        reportContext = reportContextDecoded
        let reportFrequencyDecoded = try containerValues.decodeIfPresent(ReportFrequency.self, forKey: .reportFrequency)
        reportFrequency = reportFrequencyDecoded
        let licenseManagerReportGeneratorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseManagerReportGeneratorArn)
        licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArnDecoded
        let lastRunStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastRunStatus)
        lastRunStatus = lastRunStatusDecoded
        let lastRunFailureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastRunFailureReason)
        lastRunFailureReason = lastRunFailureReasonDecoded
        let lastReportGenerationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastReportGenerationTime)
        lastReportGenerationTime = lastReportGenerationTimeDecoded
        let reportCreatorAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportCreatorAccount)
        reportCreatorAccount = reportCreatorAccountDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let s3LocationDecoded = try containerValues.decodeIfPresent(S3Location.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createTime)
        createTime = createTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ReportGenerator: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReportGenerator(createTime: \(String(describing: createTime)), description: \(String(describing: description)), lastReportGenerationTime: \(String(describing: lastReportGenerationTime)), lastRunFailureReason: \(String(describing: lastRunFailureReason)), lastRunStatus: \(String(describing: lastRunStatus)), licenseManagerReportGeneratorArn: \(String(describing: licenseManagerReportGeneratorArn)), reportContext: \(String(describing: reportContext)), reportCreatorAccount: \(String(describing: reportCreatorAccount)), reportFrequency: \(String(describing: reportFrequency)), reportGeneratorName: \(String(describing: reportGeneratorName)), reportType: \(String(describing: reportType)), s3Location: \(String(describing: s3Location)), tags: \(String(describing: tags)))"}
}

/// <p>Describe the details of a report generator.</p>
public struct ReportGenerator: Equatable {
    /// <p>Time the report was created.</p>
    public let createTime: String?
    /// <p>Description of the report generator.</p>
    public let description: String?
    /// <p>Time the last report was generated at.</p>
    public let lastReportGenerationTime: String?
    /// <p>Failure message for the last report generation attempt.</p>
    public let lastRunFailureReason: String?
    /// <p>Status of the last report generation attempt.</p>
    public let lastRunStatus: String?
    /// <p>Amazon Resource Number (ARN) of the report generator.</p>
    public let licenseManagerReportGeneratorArn: String?
    /// <p>License configuration type this generator reports on.</p>
    public let reportContext: ReportContext?
    /// <p>The AWS account ID used to create the report generator.</p>
    public let reportCreatorAccount: String?
    /// <p>Details on how frequently reports are generated.</p>
    public let reportFrequency: ReportFrequency?
    /// <p>Name of the report generator.</p>
    public let reportGeneratorName: String?
    /// <p>Type of reports that are generated.</p>
    public let reportType: [ReportType]?
    /// <p>Details of the S3 bucket that report generator reports are published to.</p>
    public let s3Location: S3Location?
    /// <p>Tags associated with the report generator.</p>
    public let tags: [Tag]?

    public init (
        createTime: String? = nil,
        description: String? = nil,
        lastReportGenerationTime: String? = nil,
        lastRunFailureReason: String? = nil,
        lastRunStatus: String? = nil,
        licenseManagerReportGeneratorArn: String? = nil,
        reportContext: ReportContext? = nil,
        reportCreatorAccount: String? = nil,
        reportFrequency: ReportFrequency? = nil,
        reportGeneratorName: String? = nil,
        reportType: [ReportType]? = nil,
        s3Location: S3Location? = nil,
        tags: [Tag]? = nil
    )
    {
        self.createTime = createTime
        self.description = description
        self.lastReportGenerationTime = lastReportGenerationTime
        self.lastRunFailureReason = lastRunFailureReason
        self.lastRunStatus = lastRunStatus
        self.licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArn
        self.reportContext = reportContext
        self.reportCreatorAccount = reportCreatorAccount
        self.reportFrequency = reportFrequency
        self.reportGeneratorName = reportGeneratorName
        self.reportType = reportType
        self.s3Location = s3Location
        self.tags = tags
    }
}

public enum ReportType {
    case licenseConfigurationSummaryReport
    case licenseConfigurationUsageReport
    case sdkUnknown(String)
}

extension ReportType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReportType] {
        return [
            .licenseConfigurationSummaryReport,
            .licenseConfigurationUsageReport,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .licenseConfigurationSummaryReport: return "LicenseConfigurationSummaryReport"
        case .licenseConfigurationUsageReport: return "LicenseConfigurationUsageReport"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReportType(rawValue: rawValue) ?? ReportType.sdkUnknown(rawValue)
    }
}

extension ResourceInventory: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case platform = "Platform"
        case platformVersion = "PlatformVersion"
        case resourceArn = "ResourceArn"
        case resourceId = "ResourceId"
        case resourceOwningAccountId = "ResourceOwningAccountId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let platform = platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let platformVersion = platformVersion {
            try encodeContainer.encode(platformVersion, forKey: .platformVersion)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceOwningAccountId = resourceOwningAccountId {
            try encodeContainer.encode(resourceOwningAccountId, forKey: .resourceOwningAccountId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let platformDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platform)
        platform = platformDecoded
        let platformVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformVersion)
        platformVersion = platformVersionDecoded
        let resourceOwningAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceOwningAccountId)
        resourceOwningAccountId = resourceOwningAccountIdDecoded
    }
}

extension ResourceInventory: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInventory(platform: \(String(describing: platform)), platformVersion: \(String(describing: platformVersion)), resourceArn: \(String(describing: resourceArn)), resourceId: \(String(describing: resourceId)), resourceOwningAccountId: \(String(describing: resourceOwningAccountId)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>Details about a resource.</p>
public struct ResourceInventory: Equatable {
    /// <p>Platform of the resource.</p>
    public let platform: String?
    /// <p>Platform version of the resource in the inventory.</p>
    public let platformVersion: String?
    /// <p>Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?
    /// <p>ID of the resource.</p>
    public let resourceId: String?
    /// <p>ID of the account that owns the resource.</p>
    public let resourceOwningAccountId: String?
    /// <p>Type of resource.</p>
    public let resourceType: ResourceType?

    public init (
        platform: String? = nil,
        platformVersion: String? = nil,
        resourceArn: String? = nil,
        resourceId: String? = nil,
        resourceOwningAccountId: String? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.platform = platform
        self.platformVersion = platformVersion
        self.resourceArn = resourceArn
        self.resourceId = resourceId
        self.resourceOwningAccountId = resourceOwningAccountId
        self.resourceType = resourceType
    }
}

extension ResourceLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceLimitExceededException(message: \(String(describing: message)))"}
}

extension ResourceLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your resource limits have been exceeded.</p>
public struct ResourceLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension ResourceLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource cannot be found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ResourceType {
    case ec2Ami
    case ec2Host
    case ec2Instance
    case rds
    case systemsManagerManagedInstance
    case sdkUnknown(String)
}

extension ResourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceType] {
        return [
            .ec2Ami,
            .ec2Host,
            .ec2Instance,
            .rds,
            .systemsManagerManagedInstance,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ec2Ami: return "EC2_AMI"
        case .ec2Host: return "EC2_HOST"
        case .ec2Instance: return "EC2_INSTANCE"
        case .rds: return "RDS"
        case .systemsManagerManagedInstance: return "SYSTEMS_MANAGER_MANAGED_INSTANCE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
    }
}

extension S3Location: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket
        case keyPrefix
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let keyPrefix = keyPrefix {
            try encodeContainer.encode(keyPrefix, forKey: .keyPrefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyPrefix)
        keyPrefix = keyPrefixDecoded
    }
}

extension S3Location: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Location(bucket: \(String(describing: bucket)), keyPrefix: \(String(describing: keyPrefix)))"}
}

/// <p>Details of the S3 bucket that report generator reports are published to.</p>
public struct S3Location: Equatable {
    /// <p>Name of the S3 bucket reports are published to.</p>
    public let bucket: String?
    /// <p>Prefix of the S3 bucket reports are published to.</p>
    public let keyPrefix: String?

    public init (
        bucket: String? = nil,
        keyPrefix: String? = nil
    )
    {
        self.bucket = bucket
        self.keyPrefix = keyPrefix
    }
}

extension ServerInternalException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServerInternalException(message: \(String(describing: message)))"}
}

extension ServerInternalException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServerInternalExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The server experienced an internal error. Try again.</p>
public struct ServerInternalException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServerInternalExceptionBody: Equatable {
    public let message: String?
}

extension ServerInternalExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Details about a tag for a license configuration.</p>
public struct Tag: Equatable {
    /// <p>Tag key.</p>
    public let key: String?
    /// <p>Tag value.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>Amazon Resource Name (ARN) of the license configuration.</p>
    public let resourceArn: String?
    /// <p>One or more tags.</p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TokenData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case expirationTime = "ExpirationTime"
        case licenseArn = "LicenseArn"
        case roleArns = "RoleArns"
        case status = "Status"
        case tokenId = "TokenId"
        case tokenProperties = "TokenProperties"
        case tokenType = "TokenType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expirationTime = expirationTime {
            try encodeContainer.encode(expirationTime, forKey: .expirationTime)
        }
        if let licenseArn = licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let roleArns = roleArns {
            var roleArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roleArns)
            for arnlist0 in roleArns {
                try roleArnsContainer.encode(arnlist0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let tokenId = tokenId {
            try encodeContainer.encode(tokenId, forKey: .tokenId)
        }
        if let tokenProperties = tokenProperties {
            var tokenPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tokenProperties)
            for maxsize3stringlist0 in tokenProperties {
                try tokenPropertiesContainer.encode(maxsize3stringlist0)
            }
        }
        if let tokenType = tokenType {
            try encodeContainer.encode(tokenType, forKey: .tokenType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tokenId)
        tokenId = tokenIdDecoded
        let tokenTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tokenType)
        tokenType = tokenTypeDecoded
        let licenseArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let expirationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let tokenPropertiesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tokenProperties)
        var tokenPropertiesDecoded0:[String]? = nil
        if let tokenPropertiesContainer = tokenPropertiesContainer {
            tokenPropertiesDecoded0 = [String]()
            for string0 in tokenPropertiesContainer {
                if let string0 = string0 {
                    tokenPropertiesDecoded0?.append(string0)
                }
            }
        }
        tokenProperties = tokenPropertiesDecoded0
        let roleArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .roleArns)
        var roleArnsDecoded0:[String]? = nil
        if let roleArnsContainer = roleArnsContainer {
            roleArnsDecoded0 = [String]()
            for string0 in roleArnsContainer {
                if let string0 = string0 {
                    roleArnsDecoded0?.append(string0)
                }
            }
        }
        roleArns = roleArnsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension TokenData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TokenData(expirationTime: \(String(describing: expirationTime)), licenseArn: \(String(describing: licenseArn)), roleArns: \(String(describing: roleArns)), status: \(String(describing: status)), tokenId: \(String(describing: tokenId)), tokenProperties: \(String(describing: tokenProperties)), tokenType: \(String(describing: tokenType)))"}
}

/// <p>Describes a token.</p>
public struct TokenData: Equatable {
    /// <p>Token expiration time, in ISO8601-UTC format.</p>
    public let expirationTime: String?
    /// <p>Amazon Resource Name (ARN) of the license.</p>
    public let licenseArn: String?
    /// <p>Amazon Resource Names (ARN) of the roles included in the token.</p>
    public let roleArns: [String]?
    /// <p>Token status. The possible values are <code>AVAILABLE</code> and <code>DELETED</code>.</p>
    public let status: String?
    /// <p>Token ID.</p>
    public let tokenId: String?
    /// <p>Data specified by the caller.</p>
    public let tokenProperties: [String]?
    /// <p>Type of token generated. The supported value is <code>REFRESH_TOKEN</code>.</p>
    public let tokenType: String?

    public init (
        expirationTime: String? = nil,
        licenseArn: String? = nil,
        roleArns: [String]? = nil,
        status: String? = nil,
        tokenId: String? = nil,
        tokenProperties: [String]? = nil,
        tokenType: String? = nil
    )
    {
        self.expirationTime = expirationTime
        self.licenseArn = licenseArn
        self.roleArns = roleArns
        self.status = status
        self.tokenId = tokenId
        self.tokenProperties = tokenProperties
        self.tokenType = tokenType
    }
}

public enum TokenType {
    case refreshToken
    case sdkUnknown(String)
}

extension TokenType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TokenType] {
        return [
            .refreshToken,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .refreshToken: return "REFRESH_TOKEN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TokenType(rawValue: rawValue) ?? TokenType.sdkUnknown(rawValue)
    }
}

extension UnsupportedDigitalSignatureMethodException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedDigitalSignatureMethodException(message: \(String(describing: message)))"}
}

extension UnsupportedDigitalSignatureMethodException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedDigitalSignatureMethodExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The digital signature method is unsupported. Try your request again.</p>
public struct UnsupportedDigitalSignatureMethodException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedDigitalSignatureMethodExceptionBody: Equatable {
    public let message: String?
}

extension UnsupportedDigitalSignatureMethodExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>Amazon Resource Name (ARN) of the license configuration.</p>
    public let resourceArn: String?
    /// <p>Keys identifying the tags to remove.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateLicenseConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateLicenseConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLicenseConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLicenseConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLicenseConfigurationOutputError>
}

extension UpdateLicenseConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLicenseConfigurationInput(description: \(String(describing: description)), disassociateWhenNotFound: \(String(describing: disassociateWhenNotFound)), licenseConfigurationArn: \(String(describing: licenseConfigurationArn)), licenseConfigurationStatus: \(String(describing: licenseConfigurationStatus)), licenseCount: \(String(describing: licenseCount)), licenseCountHardLimit: \(String(describing: licenseCountHardLimit)), licenseRules: \(String(describing: licenseRules)), name: \(String(describing: name)), productInformationList: \(String(describing: productInformationList)))"}
}

extension UpdateLicenseConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case disassociateWhenNotFound = "DisassociateWhenNotFound"
        case licenseConfigurationArn = "LicenseConfigurationArn"
        case licenseConfigurationStatus = "LicenseConfigurationStatus"
        case licenseCount = "LicenseCount"
        case licenseCountHardLimit = "LicenseCountHardLimit"
        case licenseRules = "LicenseRules"
        case name = "Name"
        case productInformationList = "ProductInformationList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disassociateWhenNotFound = disassociateWhenNotFound {
            try encodeContainer.encode(disassociateWhenNotFound, forKey: .disassociateWhenNotFound)
        }
        if let licenseConfigurationArn = licenseConfigurationArn {
            try encodeContainer.encode(licenseConfigurationArn, forKey: .licenseConfigurationArn)
        }
        if let licenseConfigurationStatus = licenseConfigurationStatus {
            try encodeContainer.encode(licenseConfigurationStatus.rawValue, forKey: .licenseConfigurationStatus)
        }
        if let licenseCount = licenseCount {
            try encodeContainer.encode(licenseCount, forKey: .licenseCount)
        }
        if let licenseCountHardLimit = licenseCountHardLimit {
            try encodeContainer.encode(licenseCountHardLimit, forKey: .licenseCountHardLimit)
        }
        if let licenseRules = licenseRules {
            var licenseRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseRules)
            for stringlist0 in licenseRules {
                try licenseRulesContainer.encode(stringlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let productInformationList = productInformationList {
            var productInformationListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productInformationList)
            for productinformationlist0 in productInformationList {
                try productInformationListContainer.encode(productinformationlist0)
            }
        }
    }
}

public struct UpdateLicenseConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateLicenseConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLicenseConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLicenseConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLicenseConfigurationOutputError>
}

public struct UpdateLicenseConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateLicenseConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLicenseConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLicenseConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLicenseConfigurationOutputError>
}

public struct UpdateLicenseConfigurationInput: Equatable {
    /// <p>New description of the license configuration.</p>
    public let description: String?
    /// <p>When true, disassociates a resource when software is uninstalled.</p>
    public let disassociateWhenNotFound: Bool?
    /// <p>Amazon Resource Name (ARN) of the license configuration.</p>
    public let licenseConfigurationArn: String?
    /// <p>New status of the license configuration.</p>
    public let licenseConfigurationStatus: LicenseConfigurationStatus?
    /// <p>New number of licenses managed by the license configuration.</p>
    public let licenseCount: Int?
    /// <p>New hard limit of the number of available licenses.</p>
    public let licenseCountHardLimit: Bool?
    /// <p>New license rule. The only rule that you can add after you create a license
    ///           configuration is licenseAffinityToHost.</p>
    public let licenseRules: [String]?
    /// <p>New name of the license configuration.</p>
    public let name: String?
    /// <p>New product information.</p>
    public let productInformationList: [ProductInformation]?

    public init (
        description: String? = nil,
        disassociateWhenNotFound: Bool? = nil,
        licenseConfigurationArn: String? = nil,
        licenseConfigurationStatus: LicenseConfigurationStatus? = nil,
        licenseCount: Int? = nil,
        licenseCountHardLimit: Bool? = nil,
        licenseRules: [String]? = nil,
        name: String? = nil,
        productInformationList: [ProductInformation]? = nil
    )
    {
        self.description = description
        self.disassociateWhenNotFound = disassociateWhenNotFound
        self.licenseConfigurationArn = licenseConfigurationArn
        self.licenseConfigurationStatus = licenseConfigurationStatus
        self.licenseCount = licenseCount
        self.licenseCountHardLimit = licenseCountHardLimit
        self.licenseRules = licenseRules
        self.name = name
        self.productInformationList = productInformationList
    }
}

struct UpdateLicenseConfigurationInputBody: Equatable {
    public let licenseConfigurationArn: String?
    public let licenseConfigurationStatus: LicenseConfigurationStatus?
    public let licenseRules: [String]?
    public let licenseCount: Int?
    public let licenseCountHardLimit: Bool?
    public let name: String?
    public let description: String?
    public let productInformationList: [ProductInformation]?
    public let disassociateWhenNotFound: Bool?
}

extension UpdateLicenseConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case disassociateWhenNotFound = "DisassociateWhenNotFound"
        case licenseConfigurationArn = "LicenseConfigurationArn"
        case licenseConfigurationStatus = "LicenseConfigurationStatus"
        case licenseCount = "LicenseCount"
        case licenseCountHardLimit = "LicenseCountHardLimit"
        case licenseRules = "LicenseRules"
        case name = "Name"
        case productInformationList = "ProductInformationList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseConfigurationArn)
        licenseConfigurationArn = licenseConfigurationArnDecoded
        let licenseConfigurationStatusDecoded = try containerValues.decodeIfPresent(LicenseConfigurationStatus.self, forKey: .licenseConfigurationStatus)
        licenseConfigurationStatus = licenseConfigurationStatusDecoded
        let licenseRulesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .licenseRules)
        var licenseRulesDecoded0:[String]? = nil
        if let licenseRulesContainer = licenseRulesContainer {
            licenseRulesDecoded0 = [String]()
            for string0 in licenseRulesContainer {
                if let string0 = string0 {
                    licenseRulesDecoded0?.append(string0)
                }
            }
        }
        licenseRules = licenseRulesDecoded0
        let licenseCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .licenseCount)
        licenseCount = licenseCountDecoded
        let licenseCountHardLimitDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .licenseCountHardLimit)
        licenseCountHardLimit = licenseCountHardLimitDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let productInformationListContainer = try containerValues.decodeIfPresent([ProductInformation?].self, forKey: .productInformationList)
        var productInformationListDecoded0:[ProductInformation]? = nil
        if let productInformationListContainer = productInformationListContainer {
            productInformationListDecoded0 = [ProductInformation]()
            for structure0 in productInformationListContainer {
                if let structure0 = structure0 {
                    productInformationListDecoded0?.append(structure0)
                }
            }
        }
        productInformationList = productInformationListDecoded0
        let disassociateWhenNotFoundDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .disassociateWhenNotFound)
        disassociateWhenNotFound = disassociateWhenNotFoundDecoded
    }
}

extension UpdateLicenseConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLicenseConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLicenseConfigurationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLicenseConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLicenseConfigurationOutputResponse()"}
}

extension UpdateLicenseConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateLicenseConfigurationOutputResponse: Equatable {

    public init() {}
}

struct UpdateLicenseConfigurationOutputResponseBody: Equatable {
}

extension UpdateLicenseConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateLicenseManagerReportGeneratorInputBodyMiddleware: Middleware {
    public let id: String = "UpdateLicenseManagerReportGeneratorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLicenseManagerReportGeneratorInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLicenseManagerReportGeneratorInput>
    public typealias MOutput = OperationOutput<UpdateLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLicenseManagerReportGeneratorOutputError>
}

extension UpdateLicenseManagerReportGeneratorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLicenseManagerReportGeneratorInput(clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), licenseManagerReportGeneratorArn: \(String(describing: licenseManagerReportGeneratorArn)), reportContext: \(String(describing: reportContext)), reportFrequency: \(String(describing: reportFrequency)), reportGeneratorName: \(String(describing: reportGeneratorName)), type: \(String(describing: type)))"}
}

extension UpdateLicenseManagerReportGeneratorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case licenseManagerReportGeneratorArn = "LicenseManagerReportGeneratorArn"
        case reportContext = "ReportContext"
        case reportFrequency = "ReportFrequency"
        case reportGeneratorName = "ReportGeneratorName"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArn {
            try encodeContainer.encode(licenseManagerReportGeneratorArn, forKey: .licenseManagerReportGeneratorArn)
        }
        if let reportContext = reportContext {
            try encodeContainer.encode(reportContext, forKey: .reportContext)
        }
        if let reportFrequency = reportFrequency {
            try encodeContainer.encode(reportFrequency, forKey: .reportFrequency)
        }
        if let reportGeneratorName = reportGeneratorName {
            try encodeContainer.encode(reportGeneratorName, forKey: .reportGeneratorName)
        }
        if let type = type {
            var typeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .type)
            for reporttypelist0 in type {
                try typeContainer.encode(reporttypelist0.rawValue)
            }
        }
    }
}

public struct UpdateLicenseManagerReportGeneratorInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateLicenseManagerReportGeneratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLicenseManagerReportGeneratorInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLicenseManagerReportGeneratorInput>
    public typealias MOutput = OperationOutput<UpdateLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLicenseManagerReportGeneratorOutputError>
}

public struct UpdateLicenseManagerReportGeneratorInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateLicenseManagerReportGeneratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLicenseManagerReportGeneratorInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLicenseManagerReportGeneratorInput>
    public typealias MOutput = OperationOutput<UpdateLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLicenseManagerReportGeneratorOutputError>
}

public struct UpdateLicenseManagerReportGeneratorInput: Equatable {
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: String?
    /// <p>Description of the report generator.</p>
    public let description: String?
    /// <p>Amazon Resource Number (ARN) of the report generator to update.</p>
    public let licenseManagerReportGeneratorArn: String?
    /// <p>?</p>
    public let reportContext: ReportContext?
    /// <p>Frequency by which reports are generated.  The following options are avaiable:</p>
    ///          <p>??? What are the APi value options?</p>
    public let reportFrequency: ReportFrequency?
    /// <p>Name of the report generator.</p>
    public let reportGeneratorName: String?
    /// <p>Type of reports to generate. The following report types an be generated:</p>
    ///          <ul>
    ///             <li>
    ///                <p>License configuration report - Reports on the number and details of consumed licenses for a license configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>Resource report - Reports on the tracked licenses and resource consumption for a license configuration.</p>
    ///             </li>
    ///          </ul>
    public let type: [ReportType]?

    public init (
        clientToken: String? = nil,
        description: String? = nil,
        licenseManagerReportGeneratorArn: String? = nil,
        reportContext: ReportContext? = nil,
        reportFrequency: ReportFrequency? = nil,
        reportGeneratorName: String? = nil,
        type: [ReportType]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArn
        self.reportContext = reportContext
        self.reportFrequency = reportFrequency
        self.reportGeneratorName = reportGeneratorName
        self.type = type
    }
}

struct UpdateLicenseManagerReportGeneratorInputBody: Equatable {
    public let licenseManagerReportGeneratorArn: String?
    public let reportGeneratorName: String?
    public let type: [ReportType]?
    public let reportContext: ReportContext?
    public let reportFrequency: ReportFrequency?
    public let clientToken: String?
    public let description: String?
}

extension UpdateLicenseManagerReportGeneratorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case licenseManagerReportGeneratorArn = "LicenseManagerReportGeneratorArn"
        case reportContext = "ReportContext"
        case reportFrequency = "ReportFrequency"
        case reportGeneratorName = "ReportGeneratorName"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseManagerReportGeneratorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseManagerReportGeneratorArn)
        licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArnDecoded
        let reportGeneratorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportGeneratorName)
        reportGeneratorName = reportGeneratorNameDecoded
        let typeContainer = try containerValues.decodeIfPresent([ReportType?].self, forKey: .type)
        var typeDecoded0:[ReportType]? = nil
        if let typeContainer = typeContainer {
            typeDecoded0 = [ReportType]()
            for string0 in typeContainer {
                if let string0 = string0 {
                    typeDecoded0?.append(string0)
                }
            }
        }
        type = typeDecoded0
        let reportContextDecoded = try containerValues.decodeIfPresent(ReportContext.self, forKey: .reportContext)
        reportContext = reportContextDecoded
        let reportFrequencyDecoded = try containerValues.decodeIfPresent(ReportFrequency.self, forKey: .reportFrequency)
        reportFrequency = reportFrequencyDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateLicenseManagerReportGeneratorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLicenseManagerReportGeneratorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLicenseManagerReportGeneratorOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLicenseManagerReportGeneratorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLicenseManagerReportGeneratorOutputResponse()"}
}

extension UpdateLicenseManagerReportGeneratorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateLicenseManagerReportGeneratorOutputResponse: Equatable {

    public init() {}
}

struct UpdateLicenseManagerReportGeneratorOutputResponseBody: Equatable {
}

extension UpdateLicenseManagerReportGeneratorOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateLicenseSpecificationsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "UpdateLicenseSpecificationsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLicenseSpecificationsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLicenseSpecificationsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLicenseSpecificationsForResourceInput>
    public typealias MOutput = OperationOutput<UpdateLicenseSpecificationsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLicenseSpecificationsForResourceOutputError>
}

extension UpdateLicenseSpecificationsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLicenseSpecificationsForResourceInput(addLicenseSpecifications: \(String(describing: addLicenseSpecifications)), removeLicenseSpecifications: \(String(describing: removeLicenseSpecifications)), resourceArn: \(String(describing: resourceArn)))"}
}

extension UpdateLicenseSpecificationsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addLicenseSpecifications = "AddLicenseSpecifications"
        case removeLicenseSpecifications = "RemoveLicenseSpecifications"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addLicenseSpecifications = addLicenseSpecifications {
            var addLicenseSpecificationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addLicenseSpecifications)
            for licensespecifications0 in addLicenseSpecifications {
                try addLicenseSpecificationsContainer.encode(licensespecifications0)
            }
        }
        if let removeLicenseSpecifications = removeLicenseSpecifications {
            var removeLicenseSpecificationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .removeLicenseSpecifications)
            for licensespecifications0 in removeLicenseSpecifications {
                try removeLicenseSpecificationsContainer.encode(licensespecifications0)
            }
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct UpdateLicenseSpecificationsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateLicenseSpecificationsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLicenseSpecificationsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLicenseSpecificationsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLicenseSpecificationsForResourceInput>
    public typealias MOutput = OperationOutput<UpdateLicenseSpecificationsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLicenseSpecificationsForResourceOutputError>
}

public struct UpdateLicenseSpecificationsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateLicenseSpecificationsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLicenseSpecificationsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLicenseSpecificationsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLicenseSpecificationsForResourceInput>
    public typealias MOutput = OperationOutput<UpdateLicenseSpecificationsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLicenseSpecificationsForResourceOutputError>
}

public struct UpdateLicenseSpecificationsForResourceInput: Equatable {
    /// <p>ARNs of the license configurations to add.</p>
    public let addLicenseSpecifications: [LicenseSpecification]?
    /// <p>ARNs of the license configurations to remove.</p>
    public let removeLicenseSpecifications: [LicenseSpecification]?
    /// <p>Amazon Resource Name (ARN) of the AWS resource.</p>
    public let resourceArn: String?

    public init (
        addLicenseSpecifications: [LicenseSpecification]? = nil,
        removeLicenseSpecifications: [LicenseSpecification]? = nil,
        resourceArn: String? = nil
    )
    {
        self.addLicenseSpecifications = addLicenseSpecifications
        self.removeLicenseSpecifications = removeLicenseSpecifications
        self.resourceArn = resourceArn
    }
}

struct UpdateLicenseSpecificationsForResourceInputBody: Equatable {
    public let resourceArn: String?
    public let addLicenseSpecifications: [LicenseSpecification]?
    public let removeLicenseSpecifications: [LicenseSpecification]?
}

extension UpdateLicenseSpecificationsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case addLicenseSpecifications = "AddLicenseSpecifications"
        case removeLicenseSpecifications = "RemoveLicenseSpecifications"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let addLicenseSpecificationsContainer = try containerValues.decodeIfPresent([LicenseSpecification?].self, forKey: .addLicenseSpecifications)
        var addLicenseSpecificationsDecoded0:[LicenseSpecification]? = nil
        if let addLicenseSpecificationsContainer = addLicenseSpecificationsContainer {
            addLicenseSpecificationsDecoded0 = [LicenseSpecification]()
            for structure0 in addLicenseSpecificationsContainer {
                if let structure0 = structure0 {
                    addLicenseSpecificationsDecoded0?.append(structure0)
                }
            }
        }
        addLicenseSpecifications = addLicenseSpecificationsDecoded0
        let removeLicenseSpecificationsContainer = try containerValues.decodeIfPresent([LicenseSpecification?].self, forKey: .removeLicenseSpecifications)
        var removeLicenseSpecificationsDecoded0:[LicenseSpecification]? = nil
        if let removeLicenseSpecificationsContainer = removeLicenseSpecificationsContainer {
            removeLicenseSpecificationsDecoded0 = [LicenseSpecification]()
            for structure0 in removeLicenseSpecificationsContainer {
                if let structure0 = structure0 {
                    removeLicenseSpecificationsDecoded0?.append(structure0)
                }
            }
        }
        removeLicenseSpecifications = removeLicenseSpecificationsDecoded0
    }
}

extension UpdateLicenseSpecificationsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLicenseSpecificationsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LicenseUsageException" : self = .licenseUsageException(try LicenseUsageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLicenseSpecificationsForResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidResourceStateException(InvalidResourceStateException)
    case licenseUsageException(LicenseUsageException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLicenseSpecificationsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLicenseSpecificationsForResourceOutputResponse()"}
}

extension UpdateLicenseSpecificationsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateLicenseSpecificationsForResourceOutputResponse: Equatable {

    public init() {}
}

struct UpdateLicenseSpecificationsForResourceOutputResponseBody: Equatable {
}

extension UpdateLicenseSpecificationsForResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateServiceSettingsInputBodyMiddleware: Middleware {
    public let id: String = "UpdateServiceSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServiceSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServiceSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServiceSettingsInput>
    public typealias MOutput = OperationOutput<UpdateServiceSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServiceSettingsOutputError>
}

extension UpdateServiceSettingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateServiceSettingsInput(enableCrossAccountsDiscovery: \(String(describing: enableCrossAccountsDiscovery)), organizationConfiguration: \(String(describing: organizationConfiguration)), s3BucketArn: \(String(describing: s3BucketArn)), snsTopicArn: \(String(describing: snsTopicArn)))"}
}

extension UpdateServiceSettingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enableCrossAccountsDiscovery = "EnableCrossAccountsDiscovery"
        case organizationConfiguration = "OrganizationConfiguration"
        case s3BucketArn = "S3BucketArn"
        case snsTopicArn = "SnsTopicArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enableCrossAccountsDiscovery = enableCrossAccountsDiscovery {
            try encodeContainer.encode(enableCrossAccountsDiscovery, forKey: .enableCrossAccountsDiscovery)
        }
        if let organizationConfiguration = organizationConfiguration {
            try encodeContainer.encode(organizationConfiguration, forKey: .organizationConfiguration)
        }
        if let s3BucketArn = s3BucketArn {
            try encodeContainer.encode(s3BucketArn, forKey: .s3BucketArn)
        }
        if let snsTopicArn = snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
    }
}

public struct UpdateServiceSettingsInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateServiceSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServiceSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServiceSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServiceSettingsInput>
    public typealias MOutput = OperationOutput<UpdateServiceSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServiceSettingsOutputError>
}

public struct UpdateServiceSettingsInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateServiceSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServiceSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServiceSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServiceSettingsInput>
    public typealias MOutput = OperationOutput<UpdateServiceSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServiceSettingsOutputError>
}

public struct UpdateServiceSettingsInput: Equatable {
    /// <p>Activates cross-account discovery.</p>
    public let enableCrossAccountsDiscovery: Bool?
    /// <p>Enables integration with AWS Organizations for cross-account discovery.</p>
    public let organizationConfiguration: OrganizationConfiguration?
    /// <p>Amazon Resource Name (ARN) of the Amazon S3 bucket where the License Manager information is stored.</p>
    public let s3BucketArn: String?
    /// <p>Amazon Resource Name (ARN) of the Amazon SNS topic used for License Manager alerts.</p>
    public let snsTopicArn: String?

    public init (
        enableCrossAccountsDiscovery: Bool? = nil,
        organizationConfiguration: OrganizationConfiguration? = nil,
        s3BucketArn: String? = nil,
        snsTopicArn: String? = nil
    )
    {
        self.enableCrossAccountsDiscovery = enableCrossAccountsDiscovery
        self.organizationConfiguration = organizationConfiguration
        self.s3BucketArn = s3BucketArn
        self.snsTopicArn = snsTopicArn
    }
}

struct UpdateServiceSettingsInputBody: Equatable {
    public let s3BucketArn: String?
    public let snsTopicArn: String?
    public let organizationConfiguration: OrganizationConfiguration?
    public let enableCrossAccountsDiscovery: Bool?
}

extension UpdateServiceSettingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case enableCrossAccountsDiscovery = "EnableCrossAccountsDiscovery"
        case organizationConfiguration = "OrganizationConfiguration"
        case s3BucketArn = "S3BucketArn"
        case snsTopicArn = "SnsTopicArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketArn)
        s3BucketArn = s3BucketArnDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let organizationConfigurationDecoded = try containerValues.decodeIfPresent(OrganizationConfiguration.self, forKey: .organizationConfiguration)
        organizationConfiguration = organizationConfigurationDecoded
        let enableCrossAccountsDiscoveryDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableCrossAccountsDiscovery)
        enableCrossAccountsDiscovery = enableCrossAccountsDiscoveryDecoded
    }
}

extension UpdateServiceSettingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServiceSettingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationException" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceededException" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServiceSettingsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServiceSettingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateServiceSettingsOutputResponse()"}
}

extension UpdateServiceSettingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateServiceSettingsOutputResponse: Equatable {

    public init() {}
}

struct UpdateServiceSettingsOutputResponseBody: Equatable {
}

extension UpdateServiceSettingsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The provided input is not valid. Try your request again.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
