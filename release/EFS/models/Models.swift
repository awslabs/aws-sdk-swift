// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessPointAlreadyExists: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessPointAlreadyExists(accessPointId: \(String(describing: accessPointId)), errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension AccessPointAlreadyExists: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessPointAlreadyExistsBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accessPointId = output.accessPointId
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.accessPointId = nil
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if the access point you are trying to create already exists, with the
///             creation token you provided in the request.</p>
public struct AccessPointAlreadyExists: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var accessPointId: String?
    public var errorCode: String?
    public var message: String?

    public init (
        accessPointId: String? = nil,
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.accessPointId = accessPointId
        self.errorCode = errorCode
        self.message = message
    }
}

struct AccessPointAlreadyExistsBody: Equatable {
    public let errorCode: String?
    public let message: String?
    public let accessPointId: String?
}

extension AccessPointAlreadyExistsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessPointId = "AccessPointId"
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let accessPointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessPointId)
        accessPointId = accessPointIdDecoded
    }
}

extension AccessPointDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessPointArn = "AccessPointArn"
        case accessPointId = "AccessPointId"
        case clientToken = "ClientToken"
        case fileSystemId = "FileSystemId"
        case lifeCycleState = "LifeCycleState"
        case name = "Name"
        case ownerId = "OwnerId"
        case posixUser = "PosixUser"
        case rootDirectory = "RootDirectory"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessPointArn = accessPointArn {
            try encodeContainer.encode(accessPointArn, forKey: .accessPointArn)
        }
        if let accessPointId = accessPointId {
            try encodeContainer.encode(accessPointId, forKey: .accessPointId)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let lifeCycleState = lifeCycleState {
            try encodeContainer.encode(lifeCycleState.rawValue, forKey: .lifeCycleState)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let posixUser = posixUser {
            try encodeContainer.encode(posixUser, forKey: .posixUser)
        }
        if let rootDirectory = rootDirectory {
            try encodeContainer.encode(rootDirectory, forKey: .rootDirectory)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let accessPointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessPointId)
        accessPointId = accessPointIdDecoded
        let accessPointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessPointArn)
        accessPointArn = accessPointArnDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let posixUserDecoded = try containerValues.decodeIfPresent(PosixUser.self, forKey: .posixUser)
        posixUser = posixUserDecoded
        let rootDirectoryDecoded = try containerValues.decodeIfPresent(RootDirectory.self, forKey: .rootDirectory)
        rootDirectory = rootDirectoryDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let lifeCycleStateDecoded = try containerValues.decodeIfPresent(LifeCycleState.self, forKey: .lifeCycleState)
        lifeCycleState = lifeCycleStateDecoded
    }
}

extension AccessPointDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessPointDescription(accessPointArn: \(String(describing: accessPointArn)), accessPointId: \(String(describing: accessPointId)), clientToken: \(String(describing: clientToken)), fileSystemId: \(String(describing: fileSystemId)), lifeCycleState: \(String(describing: lifeCycleState)), name: \(String(describing: name)), ownerId: \(String(describing: ownerId)), posixUser: \(String(describing: posixUser)), rootDirectory: \(String(describing: rootDirectory)), tags: \(String(describing: tags)))"}
}

/// <p>Provides a description of an EFS file system access point.</p>
public struct AccessPointDescription: Equatable {
    /// <p>The  unique Amazon Resource Name (ARN) associated with the access point.</p>
    public let accessPointArn: String?
    /// <p>The ID of the access point, assigned by Amazon EFS.</p>
    public let accessPointId: String?
    /// <p>The opaque string specified in the request to ensure idempotent creation.</p>
    public let clientToken: String?
    /// <p>The ID of the EFS file system that the access point applies to.</p>
    public let fileSystemId: String?
    /// <p>Identifies the lifecycle phase of the access point.</p>
    public let lifeCycleState: LifeCycleState?
    /// <p>The name of the access point. This is the value of the <code>Name</code> tag.</p>
    public let name: String?
    /// <p>Identified the AWS account that owns the access point resource.</p>
    public let ownerId: String?
    /// <p>The full POSIX identity, including the user ID, group ID, and secondary group IDs on the access point that is used for all file operations by
    ///       NFS clients using the access point.</p>
    public let posixUser: PosixUser?
    /// <p>The directory on the Amazon EFS file system that the access point exposes as the root directory to NFS clients using the access point.</p>
    public let rootDirectory: RootDirectory?
    /// <p>The tags associated with the access point, presented as an array of Tag objects.</p>
    public let tags: [Tag]?

    public init (
        accessPointArn: String? = nil,
        accessPointId: String? = nil,
        clientToken: String? = nil,
        fileSystemId: String? = nil,
        lifeCycleState: LifeCycleState? = nil,
        name: String? = nil,
        ownerId: String? = nil,
        posixUser: PosixUser? = nil,
        rootDirectory: RootDirectory? = nil,
        tags: [Tag]? = nil
    )
    {
        self.accessPointArn = accessPointArn
        self.accessPointId = accessPointId
        self.clientToken = clientToken
        self.fileSystemId = fileSystemId
        self.lifeCycleState = lifeCycleState
        self.name = name
        self.ownerId = ownerId
        self.posixUser = posixUser
        self.rootDirectory = rootDirectory
        self.tags = tags
    }
}

extension AccessPointLimitExceeded: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessPointLimitExceeded(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension AccessPointLimitExceeded: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessPointLimitExceededBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if the AWS account has already created the maximum number of access points
///             allowed per file system.</p>
public struct AccessPointLimitExceeded: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var errorCode: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct AccessPointLimitExceededBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension AccessPointLimitExceededBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccessPointNotFound: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessPointNotFound(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension AccessPointNotFound: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessPointNotFoundBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if the specified <code>AccessPointId</code> value doesn't exist in the
///             requester's AWS account.</p>
public struct AccessPointNotFound: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var errorCode: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct AccessPointNotFoundBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension AccessPointNotFoundBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AvailabilityZonesMismatch: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AvailabilityZonesMismatch(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension AvailabilityZonesMismatch: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AvailabilityZonesMismatchBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if the Availability Zone that was specified for a mount target is different from the Availability Zone that was specified for One Zone storage classes.
///             For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/availability-durability.html">Regional and One Zone storage redundancy</a>.</p>
public struct AvailabilityZonesMismatch: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var errorCode: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct AvailabilityZonesMismatchBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension AvailabilityZonesMismatchBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BackupPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
    }
}

extension BackupPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BackupPolicy(status: \(String(describing: status)))"}
}

/// <p>The backup policy for the file system used to create automatic daily backups. If status has a value of
///       <code>ENABLED</code>, the file system is being automatically backed up. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/awsbackup.html#automatic-backups">Automatic backups</a>.</p>
public struct BackupPolicy: Equatable {
    /// <p>Describes the status of the file system's backup policy.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>
    ///                      <code>ENABLED</code>
    ///                   </b> - EFS is automatically backing up the file system.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>
    ///                      <code>ENABLING</code>
    ///                   </b> - EFS is turning on automatic backups for the file system.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>
    ///                      <code>DISABLED</code>
    ///                   </b> - automatic back ups are turned off for the file system.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>
    ///                      <code>DISABLING</code>
    ///                   </b> - EFS is turning off automatic backups for the file system.</p>
    ///             </li>
    ///          </ul>
    public let status: Status?

    public init (
        status: Status? = nil
    )
    {
        self.status = status
    }
}

extension BadRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequest(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension BadRequest: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadRequestBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if the request is malformed or contains an error such as an invalid
///             parameter value or a missing required parameter.</p>
public struct BadRequest: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var errorCode: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct BadRequestBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension BadRequestBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateAccessPointInputBodyMiddleware: Middleware {
    public let id: String = "CreateAccessPointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAccessPointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAccessPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAccessPointInput>
    public typealias MOutput = OperationOutput<CreateAccessPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAccessPointOutputError>
}

extension CreateAccessPointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAccessPointInput(clientToken: \(String(describing: clientToken)), fileSystemId: \(String(describing: fileSystemId)), posixUser: \(String(describing: posixUser)), rootDirectory: \(String(describing: rootDirectory)), tags: \(String(describing: tags)))"}
}

extension CreateAccessPointInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case fileSystemId = "FileSystemId"
        case posixUser = "PosixUser"
        case rootDirectory = "RootDirectory"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let posixUser = posixUser {
            try encodeContainer.encode(posixUser, forKey: .posixUser)
        }
        if let rootDirectory = rootDirectory {
            try encodeContainer.encode(rootDirectory, forKey: .rootDirectory)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateAccessPointInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAccessPointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAccessPointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAccessPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAccessPointInput>
    public typealias MOutput = OperationOutput<CreateAccessPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAccessPointOutputError>
}

public struct CreateAccessPointInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAccessPointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAccessPointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAccessPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAccessPointInput>
    public typealias MOutput = OperationOutput<CreateAccessPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAccessPointOutputError>
}

public struct CreateAccessPointInput: Equatable {
    /// <p>A string of up to 64 ASCII characters that Amazon EFS uses to ensure idempotent
    ///       creation.</p>
    public var clientToken: String?
    /// <p>The ID of the EFS file system that the access point provides access to.</p>
    public let fileSystemId: String?
    /// <p>The operating system user and
    ///       group applied to all file system requests made using the access point.</p>
    public let posixUser: PosixUser?
    /// <p>Specifies the directory on the Amazon EFS file system that the access point exposes as
    ///       the root directory of your file system to NFS clients using the access point.
    ///       The clients using the access point can only access the root directory and below.
    ///       If the <code>RootDirectory</code> > <code>Path</code> specified does not exist,
    ///       EFS creates it and applies the <code>CreationInfo</code> settings when a client connects to an access point.
    ///       When specifying a <code>RootDirectory</code>, you need to provide the <code>Path</code>, and the <code>CreationInfo</code>.</p>
    ///          <p>Amazon EFS creates a root directory only if you have provided the  CreationInfo: OwnUid, OwnGID, and permissions for the directory.
    ///       If  you do not provide this information, Amazon EFS does not create the root directory. If the root directory does not exist, attempts to mount
    ///       using the access point will fail.</p>
    public let rootDirectory: RootDirectory?
    /// <p>Creates tags associated with the access point. Each tag is a key-value pair.</p>
    public let tags: [Tag]?

    public init (
        clientToken: String? = nil,
        fileSystemId: String? = nil,
        posixUser: PosixUser? = nil,
        rootDirectory: RootDirectory? = nil,
        tags: [Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.fileSystemId = fileSystemId
        self.posixUser = posixUser
        self.rootDirectory = rootDirectory
        self.tags = tags
    }
}

struct CreateAccessPointInputBody: Equatable {
    public let clientToken: String?
    public let tags: [Tag]?
    public let fileSystemId: String?
    public let posixUser: PosixUser?
    public let rootDirectory: RootDirectory?
}

extension CreateAccessPointInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case fileSystemId = "FileSystemId"
        case posixUser = "PosixUser"
        case rootDirectory = "RootDirectory"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let posixUserDecoded = try containerValues.decodeIfPresent(PosixUser.self, forKey: .posixUser)
        posixUser = posixUserDecoded
        let rootDirectoryDecoded = try containerValues.decodeIfPresent(RootDirectory.self, forKey: .rootDirectory)
        rootDirectory = rootDirectoryDecoded
    }
}

extension CreateAccessPointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAccessPointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointAlreadyExists" : self = .accessPointAlreadyExists(try AccessPointAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccessPointLimitExceeded" : self = .accessPointLimitExceeded(try AccessPointLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectFileSystemLifeCycleState" : self = .incorrectFileSystemLifeCycleState(try IncorrectFileSystemLifeCycleState(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAccessPointOutputError: Equatable {
    case accessPointAlreadyExists(AccessPointAlreadyExists)
    case accessPointLimitExceeded(AccessPointLimitExceeded)
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case incorrectFileSystemLifeCycleState(IncorrectFileSystemLifeCycleState)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAccessPointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAccessPointOutputResponse(accessPointArn: \(String(describing: accessPointArn)), accessPointId: \(String(describing: accessPointId)), clientToken: \(String(describing: clientToken)), fileSystemId: \(String(describing: fileSystemId)), lifeCycleState: \(String(describing: lifeCycleState)), name: \(String(describing: name)), ownerId: \(String(describing: ownerId)), posixUser: \(String(describing: posixUser)), rootDirectory: \(String(describing: rootDirectory)), tags: \(String(describing: tags)))"}
}

extension CreateAccessPointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAccessPointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accessPointArn = output.accessPointArn
            self.accessPointId = output.accessPointId
            self.clientToken = output.clientToken
            self.fileSystemId = output.fileSystemId
            self.lifeCycleState = output.lifeCycleState
            self.name = output.name
            self.ownerId = output.ownerId
            self.posixUser = output.posixUser
            self.rootDirectory = output.rootDirectory
            self.tags = output.tags
        } else {
            self.accessPointArn = nil
            self.accessPointId = nil
            self.clientToken = nil
            self.fileSystemId = nil
            self.lifeCycleState = nil
            self.name = nil
            self.ownerId = nil
            self.posixUser = nil
            self.rootDirectory = nil
            self.tags = nil
        }
    }
}

/// <p>Provides a description of an EFS file system access point.</p>
public struct CreateAccessPointOutputResponse: Equatable {
    /// <p>The  unique Amazon Resource Name (ARN) associated with the access point.</p>
    public let accessPointArn: String?
    /// <p>The ID of the access point, assigned by Amazon EFS.</p>
    public let accessPointId: String?
    /// <p>The opaque string specified in the request to ensure idempotent creation.</p>
    public let clientToken: String?
    /// <p>The ID of the EFS file system that the access point applies to.</p>
    public let fileSystemId: String?
    /// <p>Identifies the lifecycle phase of the access point.</p>
    public let lifeCycleState: LifeCycleState?
    /// <p>The name of the access point. This is the value of the <code>Name</code> tag.</p>
    public let name: String?
    /// <p>Identified the AWS account that owns the access point resource.</p>
    public let ownerId: String?
    /// <p>The full POSIX identity, including the user ID, group ID, and secondary group IDs on the access point that is used for all file operations by
    ///       NFS clients using the access point.</p>
    public let posixUser: PosixUser?
    /// <p>The directory on the Amazon EFS file system that the access point exposes as the root directory to NFS clients using the access point.</p>
    public let rootDirectory: RootDirectory?
    /// <p>The tags associated with the access point, presented as an array of Tag objects.</p>
    public let tags: [Tag]?

    public init (
        accessPointArn: String? = nil,
        accessPointId: String? = nil,
        clientToken: String? = nil,
        fileSystemId: String? = nil,
        lifeCycleState: LifeCycleState? = nil,
        name: String? = nil,
        ownerId: String? = nil,
        posixUser: PosixUser? = nil,
        rootDirectory: RootDirectory? = nil,
        tags: [Tag]? = nil
    )
    {
        self.accessPointArn = accessPointArn
        self.accessPointId = accessPointId
        self.clientToken = clientToken
        self.fileSystemId = fileSystemId
        self.lifeCycleState = lifeCycleState
        self.name = name
        self.ownerId = ownerId
        self.posixUser = posixUser
        self.rootDirectory = rootDirectory
        self.tags = tags
    }
}

struct CreateAccessPointOutputResponseBody: Equatable {
    public let clientToken: String?
    public let name: String?
    public let tags: [Tag]?
    public let accessPointId: String?
    public let accessPointArn: String?
    public let fileSystemId: String?
    public let posixUser: PosixUser?
    public let rootDirectory: RootDirectory?
    public let ownerId: String?
    public let lifeCycleState: LifeCycleState?
}

extension CreateAccessPointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessPointArn = "AccessPointArn"
        case accessPointId = "AccessPointId"
        case clientToken = "ClientToken"
        case fileSystemId = "FileSystemId"
        case lifeCycleState = "LifeCycleState"
        case name = "Name"
        case ownerId = "OwnerId"
        case posixUser = "PosixUser"
        case rootDirectory = "RootDirectory"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let accessPointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessPointId)
        accessPointId = accessPointIdDecoded
        let accessPointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessPointArn)
        accessPointArn = accessPointArnDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let posixUserDecoded = try containerValues.decodeIfPresent(PosixUser.self, forKey: .posixUser)
        posixUser = posixUserDecoded
        let rootDirectoryDecoded = try containerValues.decodeIfPresent(RootDirectory.self, forKey: .rootDirectory)
        rootDirectory = rootDirectoryDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let lifeCycleStateDecoded = try containerValues.decodeIfPresent(LifeCycleState.self, forKey: .lifeCycleState)
        lifeCycleState = lifeCycleStateDecoded
    }
}

public struct CreateFileSystemInputBodyMiddleware: Middleware {
    public let id: String = "CreateFileSystemInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFileSystemInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFileSystemInput>
    public typealias MOutput = OperationOutput<CreateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFileSystemOutputError>
}

extension CreateFileSystemInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFileSystemInput(availabilityZoneName: \(String(describing: availabilityZoneName)), backup: \(String(describing: backup)), creationToken: \(String(describing: creationToken)), encrypted: \(String(describing: encrypted)), kmsKeyId: \(String(describing: kmsKeyId)), performanceMode: \(String(describing: performanceMode)), provisionedThroughputInMibps: \(String(describing: provisionedThroughputInMibps)), tags: \(String(describing: tags)), throughputMode: \(String(describing: throughputMode)))"}
}

extension CreateFileSystemInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZoneName = "AvailabilityZoneName"
        case backup = "Backup"
        case creationToken = "CreationToken"
        case encrypted = "Encrypted"
        case kmsKeyId = "KmsKeyId"
        case performanceMode = "PerformanceMode"
        case provisionedThroughputInMibps = "ProvisionedThroughputInMibps"
        case tags = "Tags"
        case throughputMode = "ThroughputMode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZoneName = availabilityZoneName {
            try encodeContainer.encode(availabilityZoneName, forKey: .availabilityZoneName)
        }
        if let backup = backup {
            try encodeContainer.encode(backup, forKey: .backup)
        }
        if let creationToken = creationToken {
            try encodeContainer.encode(creationToken, forKey: .creationToken)
        }
        if let encrypted = encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let performanceMode = performanceMode {
            try encodeContainer.encode(performanceMode.rawValue, forKey: .performanceMode)
        }
        if let provisionedThroughputInMibps = provisionedThroughputInMibps {
            try encodeContainer.encode(provisionedThroughputInMibps, forKey: .provisionedThroughputInMibps)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let throughputMode = throughputMode {
            try encodeContainer.encode(throughputMode.rawValue, forKey: .throughputMode)
        }
    }
}

public struct CreateFileSystemInputHeadersMiddleware: Middleware {
    public let id: String = "CreateFileSystemInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFileSystemInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFileSystemInput>
    public typealias MOutput = OperationOutput<CreateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFileSystemOutputError>
}

public struct CreateFileSystemInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateFileSystemInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFileSystemInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFileSystemInput>
    public typealias MOutput = OperationOutput<CreateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFileSystemOutputError>
}

public struct CreateFileSystemInput: Equatable {
    /// <p>Used to create a file system that uses One Zone storage classes. It specifies the AWS
    ///       Availability Zone in which to create the file system. Use the format <code>us-east-1a</code>
    ///       to specify the Availability Zone. For
    ///       more information about One Zone storage classes, see <a href="https://docs.aws.amazon.com/efs/latest/ug/storage-classes.html">Using EFS storage classes</a> in the <i>Amazon EFS User Guide</i>.</p>
    ///          <note>
    ///             <p>One Zone storage classes are not available in all Availability Zones in AWS Regions where
    ///         Amazon EFS is available.</p>
    ///          </note>
    public let availabilityZoneName: String?
    /// <p>Specifies whether automatic backups are enabled on the file system that you are creating.
    ///       Set the value to <code>true</code> to enable automatic backups. If you are creating a file
    ///       system that uses One Zone storage classes, automatic backups are enabled by default. For more
    ///       information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/awsbackup.html#automatic-backups">Automatic backups</a> in the
    ///         <i>Amazon EFS User Guide</i>.</p>
    ///          <p>Default is <code>false</code>. However, if you specify an <code>AvailabilityZoneName</code>,
    ///       the default is <code>true</code>.</p>
    ///          <note>
    ///             <p>AWS Backup is not available in all AWS Regions where Amazon EFS is available.</p>
    ///          </note>
    public let backup: Bool?
    /// <p>A string of up to 64 ASCII characters. Amazon EFS uses this to ensure idempotent
    ///       creation.</p>
    public var creationToken: String?
    /// <p>A Boolean value that, if true, creates an encrypted file system. When creating an
    ///       encrypted file system, you have the option of specifying <a>CreateFileSystemRequest$KmsKeyId</a> for an existing AWS Key Management Service (AWS
    ///       KMS) customer master key (CMK). If you don't specify a CMK, then the default CMK for
    ///       Amazon EFS, <code>/aws/elasticfilesystem</code>, is used to protect the encrypted file system.
    ///     </p>
    public let encrypted: Bool?
    /// <p>The ID of the AWS KMS CMK that you want to use to protect the encrypted file system. This
    ///       parameter is only required if you want to use a non-default KMS key. If this parameter is not
    ///       specified, the default CMK for Amazon EFS is used. This ID can be in one of the following
    ///       formats:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID - A unique identifier of the key, for example
    ///             <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>ARN - An Amazon Resource Name (ARN) for the key, for example
    ///             <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>Key alias - A previously created display name for a key, for example
    ///             <code>alias/projectKey1</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>Key alias ARN - An ARN for a key alias, for example
    ///             <code>arn:aws:kms:us-west-2:444455556666:alias/projectKey1</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If <code>KmsKeyId</code> is specified, the <a>CreateFileSystemRequest$Encrypted</a> parameter must be set to true.</p>
    ///          <important>
    ///             <p>EFS accepts only symmetric KMS keys. You cannot use asymmetric KMS keys with EFS file systems.</p>
    ///          </important>
    public let kmsKeyId: String?
    /// <p>The performance mode of the file system. We recommend <code>generalPurpose</code>
    ///       performance mode for most file systems. File systems using the <code>maxIO</code> performance
    ///       mode can scale to higher levels of aggregate throughput and operations per second with a
    ///       tradeoff of slightly higher latencies for most file operations. The performance mode
    ///       can't be changed after the file system has been created.</p>
    ///          <note>
    ///             <p>The <code>maxIO</code> mode is not supported on file systems using One Zone storage classes.</p>
    ///          </note>
    public let performanceMode: PerformanceMode?
    /// <p>The throughput, measured in MiB/s, that you want to provision for a file system that
    ///       you're creating. Valid values are 1-1024. Required if <code>ThroughputMode</code> is set
    ///       to <code>provisioned</code>. The upper limit for throughput is 1024 MiB/s. To increase this
    ///       limit, contact AWS Support. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/limits.html#soft-limits">Amazon EFS quotas that you can increase</a>
    ///       in the <i>Amazon EFS User Guide</i>.</p>
    public let provisionedThroughputInMibps: Double?
    /// <p>A value that specifies to create one or more tags associated with the file system. Each
    ///         tag is a user-defined key-value pair. Name your file system on creation by including a
    ///           <code>"Key":"Name","Value":"{value}"</code> key-value pair.</p>
    public let tags: [Tag]?
    /// <p>Specifies the throughput mode for the file system, either <code>bursting</code> or
    ///         <code>provisioned</code>. If you set <code>ThroughputMode</code> to
    ///       <code>provisioned</code>, you must also set a value for
    ///         <code>ProvisionedThroughputInMibps</code>. After you create the file system, you can
    ///       decrease your file system's throughput in Provisioned Throughput mode or change between
    ///       the throughput modes, as long as it’s been more than 24 hours since the last decrease or
    ///       throughput mode change. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/performance.html#provisioned-throughput">Specifying throughput with
    ///         provisioned mode</a> in the <i>Amazon EFS User Guide</i>. </p>
    ///          <p>Default is <code>bursting</code>.</p>
    public let throughputMode: ThroughputMode?

    public init (
        availabilityZoneName: String? = nil,
        backup: Bool? = nil,
        creationToken: String? = nil,
        encrypted: Bool? = nil,
        kmsKeyId: String? = nil,
        performanceMode: PerformanceMode? = nil,
        provisionedThroughputInMibps: Double? = nil,
        tags: [Tag]? = nil,
        throughputMode: ThroughputMode? = nil
    )
    {
        self.availabilityZoneName = availabilityZoneName
        self.backup = backup
        self.creationToken = creationToken
        self.encrypted = encrypted
        self.kmsKeyId = kmsKeyId
        self.performanceMode = performanceMode
        self.provisionedThroughputInMibps = provisionedThroughputInMibps
        self.tags = tags
        self.throughputMode = throughputMode
    }
}

struct CreateFileSystemInputBody: Equatable {
    public let creationToken: String?
    public let performanceMode: PerformanceMode?
    public let encrypted: Bool?
    public let kmsKeyId: String?
    public let throughputMode: ThroughputMode?
    public let provisionedThroughputInMibps: Double?
    public let availabilityZoneName: String?
    public let backup: Bool?
    public let tags: [Tag]?
}

extension CreateFileSystemInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case availabilityZoneName = "AvailabilityZoneName"
        case backup = "Backup"
        case creationToken = "CreationToken"
        case encrypted = "Encrypted"
        case kmsKeyId = "KmsKeyId"
        case performanceMode = "PerformanceMode"
        case provisionedThroughputInMibps = "ProvisionedThroughputInMibps"
        case tags = "Tags"
        case throughputMode = "ThroughputMode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationToken)
        creationToken = creationTokenDecoded
        let performanceModeDecoded = try containerValues.decodeIfPresent(PerformanceMode.self, forKey: .performanceMode)
        performanceMode = performanceModeDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let throughputModeDecoded = try containerValues.decodeIfPresent(ThroughputMode.self, forKey: .throughputMode)
        throughputMode = throughputModeDecoded
        let provisionedThroughputInMibpsDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .provisionedThroughputInMibps)
        provisionedThroughputInMibps = provisionedThroughputInMibpsDecoded
        let availabilityZoneNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZoneName)
        availabilityZoneName = availabilityZoneNameDecoded
        let backupDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .backup)
        backup = backupDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFileSystemOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFileSystemOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemAlreadyExists" : self = .fileSystemAlreadyExists(try FileSystemAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemLimitExceeded" : self = .fileSystemLimitExceeded(try FileSystemLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientThroughputCapacity" : self = .insufficientThroughputCapacity(try InsufficientThroughputCapacity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThroughputLimitExceeded" : self = .throughputLimitExceeded(try ThroughputLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedAvailabilityZone" : self = .unsupportedAvailabilityZone(try UnsupportedAvailabilityZone(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFileSystemOutputError: Equatable {
    case badRequest(BadRequest)
    case fileSystemAlreadyExists(FileSystemAlreadyExists)
    case fileSystemLimitExceeded(FileSystemLimitExceeded)
    case insufficientThroughputCapacity(InsufficientThroughputCapacity)
    case internalServerError(InternalServerError)
    case throughputLimitExceeded(ThroughputLimitExceeded)
    case unsupportedAvailabilityZone(UnsupportedAvailabilityZone)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFileSystemOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFileSystemOutputResponse(availabilityZoneId: \(String(describing: availabilityZoneId)), availabilityZoneName: \(String(describing: availabilityZoneName)), creationTime: \(String(describing: creationTime)), creationToken: \(String(describing: creationToken)), encrypted: \(String(describing: encrypted)), fileSystemArn: \(String(describing: fileSystemArn)), fileSystemId: \(String(describing: fileSystemId)), kmsKeyId: \(String(describing: kmsKeyId)), lifeCycleState: \(String(describing: lifeCycleState)), name: \(String(describing: name)), numberOfMountTargets: \(String(describing: numberOfMountTargets)), ownerId: \(String(describing: ownerId)), performanceMode: \(String(describing: performanceMode)), provisionedThroughputInMibps: \(String(describing: provisionedThroughputInMibps)), sizeInBytes: \(String(describing: sizeInBytes)), tags: \(String(describing: tags)), throughputMode: \(String(describing: throughputMode)))"}
}

extension CreateFileSystemOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateFileSystemOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.availabilityZoneId = output.availabilityZoneId
            self.availabilityZoneName = output.availabilityZoneName
            self.creationTime = output.creationTime
            self.creationToken = output.creationToken
            self.encrypted = output.encrypted
            self.fileSystemArn = output.fileSystemArn
            self.fileSystemId = output.fileSystemId
            self.kmsKeyId = output.kmsKeyId
            self.lifeCycleState = output.lifeCycleState
            self.name = output.name
            self.numberOfMountTargets = output.numberOfMountTargets
            self.ownerId = output.ownerId
            self.performanceMode = output.performanceMode
            self.provisionedThroughputInMibps = output.provisionedThroughputInMibps
            self.sizeInBytes = output.sizeInBytes
            self.tags = output.tags
            self.throughputMode = output.throughputMode
        } else {
            self.availabilityZoneId = nil
            self.availabilityZoneName = nil
            self.creationTime = nil
            self.creationToken = nil
            self.encrypted = nil
            self.fileSystemArn = nil
            self.fileSystemId = nil
            self.kmsKeyId = nil
            self.lifeCycleState = nil
            self.name = nil
            self.numberOfMountTargets = 0
            self.ownerId = nil
            self.performanceMode = nil
            self.provisionedThroughputInMibps = nil
            self.sizeInBytes = nil
            self.tags = nil
            self.throughputMode = nil
        }
    }
}

/// <p>A description of the file system.</p>
public struct CreateFileSystemOutputResponse: Equatable {
    /// <p>The unique and consistent identifier of the Availability Zone in which the file system's
    ///       One Zone storage classes exist. For example, <code>use1-az1</code> is an Availability Zone ID
    ///       for the us-east-1 AWS Region, and it has the same location in every AWS account.</p>
    public let availabilityZoneId: String?
    /// <p>Describes the AWS Availability Zone in which the file system is located, and is valid only
    ///       for file systems using One Zone storage classes. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/storage-classes.html">Using EFS storage classes</a>
    ///       in the <i>Amazon EFS User Guide</i>.</p>
    public let availabilityZoneName: String?
    /// <p>The time that the file system was created, in seconds (since
    ///       1970-01-01T00:00:00Z).</p>
    public let creationTime: Date?
    /// <p>The opaque string specified in the request.</p>
    public let creationToken: String?
    /// <p>A Boolean value that, if true, indicates that the file system is encrypted.</p>
    public let encrypted: Bool?
    /// <p>The Amazon Resource Name (ARN) for the EFS file system, in the format
    ///       <code>arn:aws:elasticfilesystem:<i>region</i>:<i>account-id</i>:file-system/<i>file-system-id</i>
    ///             </code>.
    ///       Example with sample data: <code>arn:aws:elasticfilesystem:us-west-2:1111333322228888:file-system/fs-01234567</code>
    ///          </p>
    public let fileSystemArn: String?
    /// <p>The ID of the file system, assigned by Amazon EFS.</p>
    public let fileSystemId: String?
    /// <p>The ID of an AWS Key Management Service (AWS KMS) customer master key (CMK) that was
    ///       used to protect the encrypted file system.</p>
    public let kmsKeyId: String?
    /// <p>The lifecycle phase of the file system.</p>
    public let lifeCycleState: LifeCycleState?
    /// <p>You can add tags to a file system, including a <code>Name</code> tag. For more
    ///       information, see <a>CreateFileSystem</a>. If the file system has a <code>Name</code> tag, Amazon EFS returns
    ///       the value in this field. </p>
    public let name: String?
    /// <p>The current number of mount targets that the file system has. For more information, see <a>CreateMountTarget</a>.</p>
    public let numberOfMountTargets: Int
    /// <p>The AWS account that created the file system. If the file system was created by an IAM
    ///       user, the parent account to which the user belongs is the owner.</p>
    public let ownerId: String?
    /// <p>The performance mode of the file system.</p>
    public let performanceMode: PerformanceMode?
    /// <p>The amount of provisioned throughput, measured in MiB/s, for the file system. Valid for
    ///       file systems using <code>ThroughputMode</code> set to <code>provisioned</code>.</p>
    public let provisionedThroughputInMibps: Double?
    /// <p>The latest known metered size (in bytes) of data stored in the file system, in its
    ///         <code>Value</code> field, and the time at which that size was determined in its
    ///         <code>Timestamp</code> field. The <code>Timestamp</code> value is the integer number of
    ///       seconds since 1970-01-01T00:00:00Z. The <code>SizeInBytes</code> value doesn't represent
    ///       the size of a consistent snapshot of the file system, but it is eventually consistent when
    ///       there are no writes to the file system. That is, <code>SizeInBytes</code> represents actual
    ///       size only if the file system is not modified for a period longer than a couple of hours.
    ///       Otherwise, the value is not the exact size that the file system was at any point in time.
    ///     </p>
    public let sizeInBytes: FileSystemSize?
    /// <p>The tags associated with the file system, presented as an array of <code>Tag</code>
    ///       objects.</p>
    public let tags: [Tag]?
    /// <p>Displays the file system's throughput mode. For more information, see
    ///       <a href="https://docs.aws.amazon.com/efs/latest/ug/performance.html#throughput-modes">Throughput modes</a>
    ///       in the <i>Amazon EFS User Guide</i>.
    ///     </p>
    public let throughputMode: ThroughputMode?

    public init (
        availabilityZoneId: String? = nil,
        availabilityZoneName: String? = nil,
        creationTime: Date? = nil,
        creationToken: String? = nil,
        encrypted: Bool? = nil,
        fileSystemArn: String? = nil,
        fileSystemId: String? = nil,
        kmsKeyId: String? = nil,
        lifeCycleState: LifeCycleState? = nil,
        name: String? = nil,
        numberOfMountTargets: Int = 0,
        ownerId: String? = nil,
        performanceMode: PerformanceMode? = nil,
        provisionedThroughputInMibps: Double? = nil,
        sizeInBytes: FileSystemSize? = nil,
        tags: [Tag]? = nil,
        throughputMode: ThroughputMode? = nil
    )
    {
        self.availabilityZoneId = availabilityZoneId
        self.availabilityZoneName = availabilityZoneName
        self.creationTime = creationTime
        self.creationToken = creationToken
        self.encrypted = encrypted
        self.fileSystemArn = fileSystemArn
        self.fileSystemId = fileSystemId
        self.kmsKeyId = kmsKeyId
        self.lifeCycleState = lifeCycleState
        self.name = name
        self.numberOfMountTargets = numberOfMountTargets
        self.ownerId = ownerId
        self.performanceMode = performanceMode
        self.provisionedThroughputInMibps = provisionedThroughputInMibps
        self.sizeInBytes = sizeInBytes
        self.tags = tags
        self.throughputMode = throughputMode
    }
}

struct CreateFileSystemOutputResponseBody: Equatable {
    public let ownerId: String?
    public let creationToken: String?
    public let fileSystemId: String?
    public let fileSystemArn: String?
    public let creationTime: Date?
    public let lifeCycleState: LifeCycleState?
    public let name: String?
    public let numberOfMountTargets: Int
    public let sizeInBytes: FileSystemSize?
    public let performanceMode: PerformanceMode?
    public let encrypted: Bool?
    public let kmsKeyId: String?
    public let throughputMode: ThroughputMode?
    public let provisionedThroughputInMibps: Double?
    public let availabilityZoneName: String?
    public let availabilityZoneId: String?
    public let tags: [Tag]?
}

extension CreateFileSystemOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case availabilityZoneId = "AvailabilityZoneId"
        case availabilityZoneName = "AvailabilityZoneName"
        case creationTime = "CreationTime"
        case creationToken = "CreationToken"
        case encrypted = "Encrypted"
        case fileSystemArn = "FileSystemArn"
        case fileSystemId = "FileSystemId"
        case kmsKeyId = "KmsKeyId"
        case lifeCycleState = "LifeCycleState"
        case name = "Name"
        case numberOfMountTargets = "NumberOfMountTargets"
        case ownerId = "OwnerId"
        case performanceMode = "PerformanceMode"
        case provisionedThroughputInMibps = "ProvisionedThroughputInMibps"
        case sizeInBytes = "SizeInBytes"
        case tags = "Tags"
        case throughputMode = "ThroughputMode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let creationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationToken)
        creationToken = creationTokenDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let fileSystemArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemArn)
        fileSystemArn = fileSystemArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lifeCycleStateDecoded = try containerValues.decodeIfPresent(LifeCycleState.self, forKey: .lifeCycleState)
        lifeCycleState = lifeCycleStateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let numberOfMountTargetsDecoded = try containerValues.decode(Int.self, forKey: .numberOfMountTargets)
        numberOfMountTargets = numberOfMountTargetsDecoded
        let sizeInBytesDecoded = try containerValues.decodeIfPresent(FileSystemSize.self, forKey: .sizeInBytes)
        sizeInBytes = sizeInBytesDecoded
        let performanceModeDecoded = try containerValues.decodeIfPresent(PerformanceMode.self, forKey: .performanceMode)
        performanceMode = performanceModeDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let throughputModeDecoded = try containerValues.decodeIfPresent(ThroughputMode.self, forKey: .throughputMode)
        throughputMode = throughputModeDecoded
        let provisionedThroughputInMibpsDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .provisionedThroughputInMibps)
        provisionedThroughputInMibps = provisionedThroughputInMibpsDecoded
        let availabilityZoneNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZoneName)
        availabilityZoneName = availabilityZoneNameDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateMountTargetInputBodyMiddleware: Middleware {
    public let id: String = "CreateMountTargetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMountTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMountTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMountTargetInput>
    public typealias MOutput = OperationOutput<CreateMountTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMountTargetOutputError>
}

extension CreateMountTargetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMountTargetInput(fileSystemId: \(String(describing: fileSystemId)), ipAddress: \(String(describing: ipAddress)), securityGroups: \(String(describing: securityGroups)), subnetId: \(String(describing: subnetId)))"}
}

extension CreateMountTargetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fileSystemId = "FileSystemId"
        case ipAddress = "IpAddress"
        case securityGroups = "SecurityGroups"
        case subnetId = "SubnetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let ipAddress = ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygroups0 in securityGroups {
                try securityGroupsContainer.encode(securitygroups0)
            }
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }
}

public struct CreateMountTargetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateMountTargetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMountTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMountTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMountTargetInput>
    public typealias MOutput = OperationOutput<CreateMountTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMountTargetOutputError>
}

public struct CreateMountTargetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateMountTargetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMountTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMountTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMountTargetInput>
    public typealias MOutput = OperationOutput<CreateMountTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMountTargetOutputError>
}

/// <p></p>
public struct CreateMountTargetInput: Equatable {
    /// <p>The ID of the file system for which to create the mount target.</p>
    public let fileSystemId: String?
    /// <p>Valid IPv4 address within the address range of the specified subnet.</p>
    public let ipAddress: String?
    /// <p>Up to five VPC security group IDs, of the form <code>sg-xxxxxxxx</code>. These must be
    ///       for the same VPC as subnet specified.</p>
    public let securityGroups: [String]?
    /// <p>The ID of the subnet to add the mount target in. For file systems that use One Zone storage classes, use the subnet
    ///     that is associated with the file system's Availability Zone.</p>
    public let subnetId: String?

    public init (
        fileSystemId: String? = nil,
        ipAddress: String? = nil,
        securityGroups: [String]? = nil,
        subnetId: String? = nil
    )
    {
        self.fileSystemId = fileSystemId
        self.ipAddress = ipAddress
        self.securityGroups = securityGroups
        self.subnetId = subnetId
    }
}

struct CreateMountTargetInputBody: Equatable {
    public let fileSystemId: String?
    public let subnetId: String?
    public let ipAddress: String?
    public let securityGroups: [String]?
}

extension CreateMountTargetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileSystemId = "FileSystemId"
        case ipAddress = "IpAddress"
        case securityGroups = "SecurityGroups"
        case subnetId = "SubnetId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
    }
}

extension CreateMountTargetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMountTargetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AvailabilityZonesMismatch" : self = .availabilityZonesMismatch(try AvailabilityZonesMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectFileSystemLifeCycleState" : self = .incorrectFileSystemLifeCycleState(try IncorrectFileSystemLifeCycleState(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IpAddressInUse" : self = .ipAddressInUse(try IpAddressInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MountTargetConflict" : self = .mountTargetConflict(try MountTargetConflict(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NetworkInterfaceLimitExceeded" : self = .networkInterfaceLimitExceeded(try NetworkInterfaceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoFreeAddressesInSubnet" : self = .noFreeAddressesInSubnet(try NoFreeAddressesInSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SecurityGroupLimitExceeded" : self = .securityGroupLimitExceeded(try SecurityGroupLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SecurityGroupNotFound" : self = .securityGroupNotFound(try SecurityGroupNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetNotFound" : self = .subnetNotFound(try SubnetNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedAvailabilityZone" : self = .unsupportedAvailabilityZone(try UnsupportedAvailabilityZone(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMountTargetOutputError: Equatable {
    case availabilityZonesMismatch(AvailabilityZonesMismatch)
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case incorrectFileSystemLifeCycleState(IncorrectFileSystemLifeCycleState)
    case internalServerError(InternalServerError)
    case ipAddressInUse(IpAddressInUse)
    case mountTargetConflict(MountTargetConflict)
    case networkInterfaceLimitExceeded(NetworkInterfaceLimitExceeded)
    case noFreeAddressesInSubnet(NoFreeAddressesInSubnet)
    case securityGroupLimitExceeded(SecurityGroupLimitExceeded)
    case securityGroupNotFound(SecurityGroupNotFound)
    case subnetNotFound(SubnetNotFound)
    case unsupportedAvailabilityZone(UnsupportedAvailabilityZone)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMountTargetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMountTargetOutputResponse(availabilityZoneId: \(String(describing: availabilityZoneId)), availabilityZoneName: \(String(describing: availabilityZoneName)), fileSystemId: \(String(describing: fileSystemId)), ipAddress: \(String(describing: ipAddress)), lifeCycleState: \(String(describing: lifeCycleState)), mountTargetId: \(String(describing: mountTargetId)), networkInterfaceId: \(String(describing: networkInterfaceId)), ownerId: \(String(describing: ownerId)), subnetId: \(String(describing: subnetId)), vpcId: \(String(describing: vpcId)))"}
}

extension CreateMountTargetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateMountTargetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.availabilityZoneId = output.availabilityZoneId
            self.availabilityZoneName = output.availabilityZoneName
            self.fileSystemId = output.fileSystemId
            self.ipAddress = output.ipAddress
            self.lifeCycleState = output.lifeCycleState
            self.mountTargetId = output.mountTargetId
            self.networkInterfaceId = output.networkInterfaceId
            self.ownerId = output.ownerId
            self.subnetId = output.subnetId
            self.vpcId = output.vpcId
        } else {
            self.availabilityZoneId = nil
            self.availabilityZoneName = nil
            self.fileSystemId = nil
            self.ipAddress = nil
            self.lifeCycleState = nil
            self.mountTargetId = nil
            self.networkInterfaceId = nil
            self.ownerId = nil
            self.subnetId = nil
            self.vpcId = nil
        }
    }
}

/// <p>Provides a description of a mount target.</p>
public struct CreateMountTargetOutputResponse: Equatable {
    /// <p>The unique and consistent identifier of the Availability Zone that the mount target resides in.
    ///       For example, <code>use1-az1</code> is an AZ ID for the us-east-1 Region and it has the same location in every AWS account.</p>
    public let availabilityZoneId: String?
    /// <p>The name of the Availability Zone in which the mount target is located. Availability Zones are
    ///       independently mapped to names for each AWS account. For example, the Availability Zone
    ///       <code>us-east-1a</code> for your AWS account might not be the same location as <code>us-east-1a</code> for another AWS account.</p>
    public let availabilityZoneName: String?
    /// <p>The ID of the file system for which the mount target is intended.</p>
    public let fileSystemId: String?
    /// <p>Address at which the file system can be mounted by using the mount target.</p>
    public let ipAddress: String?
    /// <p>Lifecycle state of the mount target.</p>
    public let lifeCycleState: LifeCycleState?
    /// <p>System-assigned mount target ID.</p>
    public let mountTargetId: String?
    /// <p>The ID of the network interface that Amazon EFS created when it created the mount
    ///       target.</p>
    public let networkInterfaceId: String?
    /// <p>AWS account ID that owns the resource.</p>
    public let ownerId: String?
    /// <p>The ID of the mount target's subnet.</p>
    public let subnetId: String?
    /// <p>The virtual private cloud (VPC) ID that the mount target is configured in.</p>
    public let vpcId: String?

    public init (
        availabilityZoneId: String? = nil,
        availabilityZoneName: String? = nil,
        fileSystemId: String? = nil,
        ipAddress: String? = nil,
        lifeCycleState: LifeCycleState? = nil,
        mountTargetId: String? = nil,
        networkInterfaceId: String? = nil,
        ownerId: String? = nil,
        subnetId: String? = nil,
        vpcId: String? = nil
    )
    {
        self.availabilityZoneId = availabilityZoneId
        self.availabilityZoneName = availabilityZoneName
        self.fileSystemId = fileSystemId
        self.ipAddress = ipAddress
        self.lifeCycleState = lifeCycleState
        self.mountTargetId = mountTargetId
        self.networkInterfaceId = networkInterfaceId
        self.ownerId = ownerId
        self.subnetId = subnetId
        self.vpcId = vpcId
    }
}

struct CreateMountTargetOutputResponseBody: Equatable {
    public let ownerId: String?
    public let mountTargetId: String?
    public let fileSystemId: String?
    public let subnetId: String?
    public let lifeCycleState: LifeCycleState?
    public let ipAddress: String?
    public let networkInterfaceId: String?
    public let availabilityZoneId: String?
    public let availabilityZoneName: String?
    public let vpcId: String?
}

extension CreateMountTargetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case availabilityZoneId = "AvailabilityZoneId"
        case availabilityZoneName = "AvailabilityZoneName"
        case fileSystemId = "FileSystemId"
        case ipAddress = "IpAddress"
        case lifeCycleState = "LifeCycleState"
        case mountTargetId = "MountTargetId"
        case networkInterfaceId = "NetworkInterfaceId"
        case ownerId = "OwnerId"
        case subnetId = "SubnetId"
        case vpcId = "VpcId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let mountTargetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mountTargetId)
        mountTargetId = mountTargetIdDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let lifeCycleStateDecoded = try containerValues.decodeIfPresent(LifeCycleState.self, forKey: .lifeCycleState)
        lifeCycleState = lifeCycleStateDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let availabilityZoneNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZoneName)
        availabilityZoneName = availabilityZoneNameDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

public struct CreateTagsInputBodyMiddleware: Middleware {
    public let id: String = "CreateTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTagsInput>
    public typealias MOutput = OperationOutput<CreateTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTagsOutputError>
}

extension CreateTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTagsInput(fileSystemId: \(String(describing: fileSystemId)), tags: \(String(describing: tags)))"}
}

extension CreateTagsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateTagsInputHeadersMiddleware: Middleware {
    public let id: String = "CreateTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTagsInput>
    public typealias MOutput = OperationOutput<CreateTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTagsOutputError>
}

public struct CreateTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTagsInput>
    public typealias MOutput = OperationOutput<CreateTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTagsOutputError>
}

/// <p></p>
public struct CreateTagsInput: Equatable {
    /// <p>The ID of the file system whose tags you want to modify (String). This operation modifies
    ///       the tags only, not the file system.</p>
    public let fileSystemId: String?
    /// <p>An array of <code>Tag</code> objects to add. Each <code>Tag</code> object is a key-value
    ///       pair. </p>
    public let tags: [Tag]?

    public init (
        fileSystemId: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.fileSystemId = fileSystemId
        self.tags = tags
    }
}

struct CreateTagsInputBody: Equatable {
    public let tags: [Tag]?
}

extension CreateTagsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTagsOutputError: Equatable {
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTagsOutputResponse()"}
}

extension CreateTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateTagsOutputResponse: Equatable {

    public init() {}
}

struct CreateTagsOutputResponseBody: Equatable {
}

extension CreateTagsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CreationInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ownerGid = "OwnerGid"
        case ownerUid = "OwnerUid"
        case permissions = "Permissions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ownerGid = ownerGid {
            try encodeContainer.encode(ownerGid, forKey: .ownerGid)
        }
        if let ownerUid = ownerUid {
            try encodeContainer.encode(ownerUid, forKey: .ownerUid)
        }
        if let permissions = permissions {
            try encodeContainer.encode(permissions, forKey: .permissions)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerUidDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .ownerUid)
        ownerUid = ownerUidDecoded
        let ownerGidDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .ownerGid)
        ownerGid = ownerGidDecoded
        let permissionsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .permissions)
        permissions = permissionsDecoded
    }
}

extension CreationInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreationInfo(ownerGid: \(String(describing: ownerGid)), ownerUid: \(String(describing: ownerUid)), permissions: \(String(describing: permissions)))"}
}

/// <p>Required if the <code>RootDirectory</code> > <code>Path</code> specified does not exist.
///       Specifies the POSIX IDs and permissions to apply to the access point's <code>RootDirectory</code> > <code>Path</code>.
///       If the access point root directory does not exist, EFS creates it with these settings when a client connects to the access point.
///       When specifying <code>CreationInfo</code>, you must include values for all properties.
///    </p>
///          <p>Amazon EFS creates a root directory only if you have provided the  CreationInfo: OwnUid, OwnGID, and permissions for the directory.
///       If  you do not provide this information, Amazon EFS does not create the root directory. If the root directory does not exist, attempts to mount
///       using the access point will fail.</p>
///          <important>
///             <p>If you do not provide <code>CreationInfo</code> and the specified <code>RootDirectory</code> does not exist,
///       attempts to mount the file system using the access point will fail.</p>
///          </important>
public struct CreationInfo: Equatable {
    /// <p>Specifies the POSIX group ID to apply to the <code>RootDirectory</code>. Accepts values from 0 to 2^32 (4294967295).</p>
    public let ownerGid: Int?
    /// <p>Specifies the POSIX user ID to apply to the <code>RootDirectory</code>. Accepts values from 0 to 2^32 (4294967295).</p>
    public let ownerUid: Int?
    /// <p>Specifies the POSIX permissions to apply to the <code>RootDirectory</code>, in the format of an octal number representing the file's mode bits.</p>
    public let permissions: String?

    public init (
        ownerGid: Int? = nil,
        ownerUid: Int? = nil,
        permissions: String? = nil
    )
    {
        self.ownerGid = ownerGid
        self.ownerUid = ownerUid
        self.permissions = permissions
    }
}

extension DeleteAccessPointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAccessPointInput(accessPointId: \(String(describing: accessPointId)))"}
}

extension DeleteAccessPointInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteAccessPointInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAccessPointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccessPointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccessPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccessPointInput>
    public typealias MOutput = OperationOutput<DeleteAccessPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccessPointOutputError>
}

public struct DeleteAccessPointInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAccessPointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccessPointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccessPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccessPointInput>
    public typealias MOutput = OperationOutput<DeleteAccessPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccessPointOutputError>
}

public struct DeleteAccessPointInput: Equatable {
    /// <p>The ID of the access point that you want to delete.</p>
    public let accessPointId: String?

    public init (
        accessPointId: String? = nil
    )
    {
        self.accessPointId = accessPointId
    }
}

struct DeleteAccessPointInputBody: Equatable {
}

extension DeleteAccessPointInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAccessPointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAccessPointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointNotFound" : self = .accessPointNotFound(try AccessPointNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAccessPointOutputError: Equatable {
    case accessPointNotFound(AccessPointNotFound)
    case badRequest(BadRequest)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccessPointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAccessPointOutputResponse()"}
}

extension DeleteAccessPointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAccessPointOutputResponse: Equatable {

    public init() {}
}

struct DeleteAccessPointOutputResponseBody: Equatable {
}

extension DeleteAccessPointOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteFileSystemInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFileSystemInput(fileSystemId: \(String(describing: fileSystemId)))"}
}

extension DeleteFileSystemInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteFileSystemInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFileSystemInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFileSystemInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFileSystemInput>
    public typealias MOutput = OperationOutput<DeleteFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFileSystemOutputError>
}

public struct DeleteFileSystemInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFileSystemInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFileSystemInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFileSystemInput>
    public typealias MOutput = OperationOutput<DeleteFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFileSystemOutputError>
}

/// <p></p>
public struct DeleteFileSystemInput: Equatable {
    /// <p>The ID of the file system you want to delete.</p>
    public let fileSystemId: String?

    public init (
        fileSystemId: String? = nil
    )
    {
        self.fileSystemId = fileSystemId
    }
}

struct DeleteFileSystemInputBody: Equatable {
}

extension DeleteFileSystemInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteFileSystemOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFileSystemOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemInUse" : self = .fileSystemInUse(try FileSystemInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFileSystemOutputError: Equatable {
    case badRequest(BadRequest)
    case fileSystemInUse(FileSystemInUse)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFileSystemOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFileSystemOutputResponse()"}
}

extension DeleteFileSystemOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFileSystemOutputResponse: Equatable {

    public init() {}
}

struct DeleteFileSystemOutputResponseBody: Equatable {
}

extension DeleteFileSystemOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteFileSystemPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFileSystemPolicyInput(fileSystemId: \(String(describing: fileSystemId)))"}
}

extension DeleteFileSystemPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteFileSystemPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFileSystemPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFileSystemPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFileSystemPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFileSystemPolicyInput>
    public typealias MOutput = OperationOutput<DeleteFileSystemPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFileSystemPolicyOutputError>
}

public struct DeleteFileSystemPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFileSystemPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFileSystemPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFileSystemPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFileSystemPolicyInput>
    public typealias MOutput = OperationOutput<DeleteFileSystemPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFileSystemPolicyOutputError>
}

public struct DeleteFileSystemPolicyInput: Equatable {
    /// <p>Specifies the EFS file system for which to delete the <code>FileSystemPolicy</code>.</p>
    public let fileSystemId: String?

    public init (
        fileSystemId: String? = nil
    )
    {
        self.fileSystemId = fileSystemId
    }
}

struct DeleteFileSystemPolicyInputBody: Equatable {
}

extension DeleteFileSystemPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteFileSystemPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFileSystemPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectFileSystemLifeCycleState" : self = .incorrectFileSystemLifeCycleState(try IncorrectFileSystemLifeCycleState(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFileSystemPolicyOutputError: Equatable {
    case fileSystemNotFound(FileSystemNotFound)
    case incorrectFileSystemLifeCycleState(IncorrectFileSystemLifeCycleState)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFileSystemPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFileSystemPolicyOutputResponse()"}
}

extension DeleteFileSystemPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFileSystemPolicyOutputResponse: Equatable {

    public init() {}
}

struct DeleteFileSystemPolicyOutputResponseBody: Equatable {
}

extension DeleteFileSystemPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteMountTargetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMountTargetInput(mountTargetId: \(String(describing: mountTargetId)))"}
}

extension DeleteMountTargetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteMountTargetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteMountTargetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMountTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMountTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMountTargetInput>
    public typealias MOutput = OperationOutput<DeleteMountTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMountTargetOutputError>
}

public struct DeleteMountTargetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteMountTargetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMountTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMountTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMountTargetInput>
    public typealias MOutput = OperationOutput<DeleteMountTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMountTargetOutputError>
}

/// <p></p>
public struct DeleteMountTargetInput: Equatable {
    /// <p>The ID of the mount target to delete (String).</p>
    public let mountTargetId: String?

    public init (
        mountTargetId: String? = nil
    )
    {
        self.mountTargetId = mountTargetId
    }
}

struct DeleteMountTargetInputBody: Equatable {
}

extension DeleteMountTargetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteMountTargetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMountTargetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyTimeout" : self = .dependencyTimeout(try DependencyTimeout(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MountTargetNotFound" : self = .mountTargetNotFound(try MountTargetNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMountTargetOutputError: Equatable {
    case badRequest(BadRequest)
    case dependencyTimeout(DependencyTimeout)
    case internalServerError(InternalServerError)
    case mountTargetNotFound(MountTargetNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMountTargetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMountTargetOutputResponse()"}
}

extension DeleteMountTargetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMountTargetOutputResponse: Equatable {

    public init() {}
}

struct DeleteMountTargetOutputResponseBody: Equatable {
}

extension DeleteMountTargetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteTagsInputBodyMiddleware: Middleware {
    public let id: String = "DeleteTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTagsInput>
    public typealias MOutput = OperationOutput<DeleteTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTagsOutputError>
}

extension DeleteTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTagsInput(fileSystemId: \(String(describing: fileSystemId)), tagKeys: \(String(describing: tagKeys)))"}
}

extension DeleteTagsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeys0 in tagKeys {
                try tagKeysContainer.encode(tagkeys0)
            }
        }
    }
}

public struct DeleteTagsInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTagsInput>
    public typealias MOutput = OperationOutput<DeleteTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTagsOutputError>
}

public struct DeleteTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTagsInput>
    public typealias MOutput = OperationOutput<DeleteTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTagsOutputError>
}

/// <p></p>
public struct DeleteTagsInput: Equatable {
    /// <p>The ID of the file system whose tags you want to delete (String).</p>
    public let fileSystemId: String?
    /// <p>A list of tag keys to delete.</p>
    public let tagKeys: [String]?

    public init (
        fileSystemId: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.fileSystemId = fileSystemId
        self.tagKeys = tagKeys
    }
}

struct DeleteTagsInputBody: Equatable {
    public let tagKeys: [String]?
}

extension DeleteTagsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension DeleteTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTagsOutputError: Equatable {
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTagsOutputResponse()"}
}

extension DeleteTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTagsOutputResponse: Equatable {

    public init() {}
}

struct DeleteTagsOutputResponseBody: Equatable {
}

extension DeleteTagsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DependencyTimeout: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DependencyTimeout(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension DependencyTimeout: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DependencyTimeoutBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service timed out trying to fulfill the request, and the client should try the
///             call again.</p>
public struct DependencyTimeout: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var errorCode: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct DependencyTimeoutBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension DependencyTimeoutBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DescribeAccessPointsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccessPointsInput(accessPointId: \(String(describing: accessPointId)), fileSystemId: \(String(describing: fileSystemId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAccessPointsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeAccessPointsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAccessPointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccessPointsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccessPointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccessPointsInput>
    public typealias MOutput = OperationOutput<DescribeAccessPointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccessPointsOutputError>
}

public struct DescribeAccessPointsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAccessPointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccessPointsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccessPointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let accessPointId = input.operationInput.accessPointId {
            let accessPointIdQueryItem = URLQueryItem(name: "AccessPointId".urlPercentEncoding(), value: String(accessPointId).urlPercentEncoding())
            input.builder.withQueryItem(accessPointIdQueryItem)
        }
        if let fileSystemId = input.operationInput.fileSystemId {
            let fileSystemIdQueryItem = URLQueryItem(name: "FileSystemId".urlPercentEncoding(), value: String(fileSystemId).urlPercentEncoding())
            input.builder.withQueryItem(fileSystemIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccessPointsInput>
    public typealias MOutput = OperationOutput<DescribeAccessPointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccessPointsOutputError>
}

public struct DescribeAccessPointsInput: Equatable {
    /// <p>(Optional) Specifies an EFS access point to describe in the response; mutually exclusive with <code>FileSystemId</code>.</p>
    public let accessPointId: String?
    /// <p>(Optional) If you provide a <code>FileSystemId</code>, EFS returns all access points for that file system; mutually exclusive with <code>AccessPointId</code>.</p>
    public let fileSystemId: String?
    /// <p>(Optional) When retrieving all access points for a file system,
    ///       you can optionally specify the <code>MaxItems</code> parameter to limit the number of objects returned in a response.
    ///       The default value is 100. </p>
    public let maxResults: Int?
    /// <p>
    ///             <code>NextToken</code> is present if the response is paginated. You can use <code>NextMarker</code> in the subsequent request to fetch the next page of access point descriptions.</p>
    public let nextToken: String?

    public init (
        accessPointId: String? = nil,
        fileSystemId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.accessPointId = accessPointId
        self.fileSystemId = fileSystemId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAccessPointsInputBody: Equatable {
}

extension DescribeAccessPointsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeAccessPointsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccessPointsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointNotFound" : self = .accessPointNotFound(try AccessPointNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccessPointsOutputError: Equatable {
    case accessPointNotFound(AccessPointNotFound)
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccessPointsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccessPointsOutputResponse(accessPoints: \(String(describing: accessPoints)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAccessPointsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAccessPointsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accessPoints = output.accessPoints
            self.nextToken = output.nextToken
        } else {
            self.accessPoints = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAccessPointsOutputResponse: Equatable {
    /// <p>An array of access point descriptions.</p>
    public let accessPoints: [AccessPointDescription]?
    /// <p>Present if there are more access points than returned in the response.
    ///       You can use the NextMarker in the subsequent request to fetch the additional descriptions.</p>
    public let nextToken: String?

    public init (
        accessPoints: [AccessPointDescription]? = nil,
        nextToken: String? = nil
    )
    {
        self.accessPoints = accessPoints
        self.nextToken = nextToken
    }
}

struct DescribeAccessPointsOutputResponseBody: Equatable {
    public let accessPoints: [AccessPointDescription]?
    public let nextToken: String?
}

extension DescribeAccessPointsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessPoints = "AccessPoints"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPointsContainer = try containerValues.decodeIfPresent([AccessPointDescription?].self, forKey: .accessPoints)
        var accessPointsDecoded0:[AccessPointDescription]? = nil
        if let accessPointsContainer = accessPointsContainer {
            accessPointsDecoded0 = [AccessPointDescription]()
            for structure0 in accessPointsContainer {
                if let structure0 = structure0 {
                    accessPointsDecoded0?.append(structure0)
                }
            }
        }
        accessPoints = accessPointsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeAccountPreferencesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAccountPreferencesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountPreferencesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountPreferencesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountPreferencesInput>
    public typealias MOutput = OperationOutput<DescribeAccountPreferencesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountPreferencesOutputError>
}

extension DescribeAccountPreferencesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountPreferencesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAccountPreferencesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeAccountPreferencesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAccountPreferencesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountPreferencesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountPreferencesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountPreferencesInput>
    public typealias MOutput = OperationOutput<DescribeAccountPreferencesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountPreferencesOutputError>
}

public struct DescribeAccountPreferencesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAccountPreferencesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountPreferencesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountPreferencesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountPreferencesInput>
    public typealias MOutput = OperationOutput<DescribeAccountPreferencesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountPreferencesOutputError>
}

public struct DescribeAccountPreferencesInput: Equatable {
    /// Max results used for pagination.
    public let maxResults: Int?
    /// Token used for pagination.
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAccountPreferencesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribeAccountPreferencesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeAccountPreferencesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccountPreferencesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountPreferencesOutputError: Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountPreferencesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountPreferencesOutputResponse(nextToken: \(String(describing: nextToken)), resourceIdPreference: \(String(describing: resourceIdPreference)))"}
}

extension DescribeAccountPreferencesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAccountPreferencesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.resourceIdPreference = output.resourceIdPreference
        } else {
            self.nextToken = nil
            self.resourceIdPreference = nil
        }
    }
}

public struct DescribeAccountPreferencesOutputResponse: Equatable {
    /// Token used for pagination.
    public let nextToken: String?
    public let resourceIdPreference: ResourceIdPreference?

    public init (
        nextToken: String? = nil,
        resourceIdPreference: ResourceIdPreference? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceIdPreference = resourceIdPreference
    }
}

struct DescribeAccountPreferencesOutputResponseBody: Equatable {
    public let resourceIdPreference: ResourceIdPreference?
    public let nextToken: String?
}

extension DescribeAccountPreferencesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case resourceIdPreference = "ResourceIdPreference"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdPreferenceDecoded = try containerValues.decodeIfPresent(ResourceIdPreference.self, forKey: .resourceIdPreference)
        resourceIdPreference = resourceIdPreferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBackupPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBackupPolicyInput(fileSystemId: \(String(describing: fileSystemId)))"}
}

extension DescribeBackupPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeBackupPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeBackupPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBackupPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBackupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBackupPolicyInput>
    public typealias MOutput = OperationOutput<DescribeBackupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBackupPolicyOutputError>
}

public struct DescribeBackupPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeBackupPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBackupPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBackupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBackupPolicyInput>
    public typealias MOutput = OperationOutput<DescribeBackupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBackupPolicyOutputError>
}

public struct DescribeBackupPolicyInput: Equatable {
    /// <p>Specifies which EFS file system to retrieve the <code>BackupPolicy</code> for.</p>
    public let fileSystemId: String?

    public init (
        fileSystemId: String? = nil
    )
    {
        self.fileSystemId = fileSystemId
    }
}

struct DescribeBackupPolicyInputBody: Equatable {
}

extension DescribeBackupPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeBackupPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBackupPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotFound" : self = .policyNotFound(try PolicyNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBackupPolicyOutputError: Equatable {
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case policyNotFound(PolicyNotFound)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBackupPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBackupPolicyOutputResponse(backupPolicy: \(String(describing: backupPolicy)))"}
}

extension DescribeBackupPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeBackupPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backupPolicy = output.backupPolicy
        } else {
            self.backupPolicy = nil
        }
    }
}

public struct DescribeBackupPolicyOutputResponse: Equatable {
    /// <p>Describes the file system's backup policy, indicating whether automatic backups are turned on or off..</p>
    public let backupPolicy: BackupPolicy?

    public init (
        backupPolicy: BackupPolicy? = nil
    )
    {
        self.backupPolicy = backupPolicy
    }
}

struct DescribeBackupPolicyOutputResponseBody: Equatable {
    public let backupPolicy: BackupPolicy?
}

extension DescribeBackupPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupPolicy = "BackupPolicy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPolicyDecoded = try containerValues.decodeIfPresent(BackupPolicy.self, forKey: .backupPolicy)
        backupPolicy = backupPolicyDecoded
    }
}

extension DescribeFileSystemPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFileSystemPolicyInput(fileSystemId: \(String(describing: fileSystemId)))"}
}

extension DescribeFileSystemPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeFileSystemPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeFileSystemPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFileSystemPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFileSystemPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFileSystemPolicyInput>
    public typealias MOutput = OperationOutput<DescribeFileSystemPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFileSystemPolicyOutputError>
}

public struct DescribeFileSystemPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeFileSystemPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFileSystemPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFileSystemPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFileSystemPolicyInput>
    public typealias MOutput = OperationOutput<DescribeFileSystemPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFileSystemPolicyOutputError>
}

public struct DescribeFileSystemPolicyInput: Equatable {
    /// <p>Specifies which EFS file system to retrieve the <code>FileSystemPolicy</code> for.</p>
    public let fileSystemId: String?

    public init (
        fileSystemId: String? = nil
    )
    {
        self.fileSystemId = fileSystemId
    }
}

struct DescribeFileSystemPolicyInputBody: Equatable {
}

extension DescribeFileSystemPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeFileSystemPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFileSystemPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotFound" : self = .policyNotFound(try PolicyNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFileSystemPolicyOutputError: Equatable {
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case policyNotFound(PolicyNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFileSystemPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFileSystemPolicyOutputResponse(fileSystemId: \(String(describing: fileSystemId)), policy: \(String(describing: policy)))"}
}

extension DescribeFileSystemPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeFileSystemPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fileSystemId = output.fileSystemId
            self.policy = output.policy
        } else {
            self.fileSystemId = nil
            self.policy = nil
        }
    }
}

public struct DescribeFileSystemPolicyOutputResponse: Equatable {
    /// <p>Specifies the EFS file system to which the <code>FileSystemPolicy</code> applies.</p>
    public let fileSystemId: String?
    /// <p>The JSON formatted <code>FileSystemPolicy</code> for the EFS file system.</p>
    public let policy: String?

    public init (
        fileSystemId: String? = nil,
        policy: String? = nil
    )
    {
        self.fileSystemId = fileSystemId
        self.policy = policy
    }
}

struct DescribeFileSystemPolicyOutputResponseBody: Equatable {
    public let fileSystemId: String?
    public let policy: String?
}

extension DescribeFileSystemPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileSystemId = "FileSystemId"
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension DescribeFileSystemsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFileSystemsInput(creationToken: \(String(describing: creationToken)), fileSystemId: \(String(describing: fileSystemId)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)))"}
}

extension DescribeFileSystemsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeFileSystemsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeFileSystemsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFileSystemsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFileSystemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFileSystemsInput>
    public typealias MOutput = OperationOutput<DescribeFileSystemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFileSystemsOutputError>
}

public struct DescribeFileSystemsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeFileSystemsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFileSystemsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFileSystemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let creationToken = input.operationInput.creationToken {
            let creationTokenQueryItem = URLQueryItem(name: "CreationToken".urlPercentEncoding(), value: String(creationToken).urlPercentEncoding())
            input.builder.withQueryItem(creationTokenQueryItem)
        }
        if let fileSystemId = input.operationInput.fileSystemId {
            let fileSystemIdQueryItem = URLQueryItem(name: "FileSystemId".urlPercentEncoding(), value: String(fileSystemId).urlPercentEncoding())
            input.builder.withQueryItem(fileSystemIdQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "Marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFileSystemsInput>
    public typealias MOutput = OperationOutput<DescribeFileSystemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFileSystemsOutputError>
}

/// <p></p>
public struct DescribeFileSystemsInput: Equatable {
    /// <p>(Optional) Restricts the list to the file system with this creation token (String). You
    ///       specify a creation token when you create an Amazon EFS file system.</p>
    public let creationToken: String?
    /// <p>(Optional) ID of the file system whose description you want to retrieve
    ///       (String).</p>
    public let fileSystemId: String?
    /// <p>(Optional) Opaque pagination token returned from a previous
    ///         <code>DescribeFileSystems</code> operation (String). If present, specifies to continue the
    ///       list from where the returning call had left off. </p>
    public let marker: String?
    /// <p>(Optional) Specifies the maximum number of file systems to return in the response
    ///       (integer). This number is automatically set to 100. The response is paginated at 100 per page if you have more than 100 file systems.
    ///       </p>
    public let maxItems: Int?

    public init (
        creationToken: String? = nil,
        fileSystemId: String? = nil,
        marker: String? = nil,
        maxItems: Int? = nil
    )
    {
        self.creationToken = creationToken
        self.fileSystemId = fileSystemId
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct DescribeFileSystemsInputBody: Equatable {
}

extension DescribeFileSystemsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeFileSystemsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFileSystemsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFileSystemsOutputError: Equatable {
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFileSystemsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFileSystemsOutputResponse(fileSystems: \(String(describing: fileSystems)), marker: \(String(describing: marker)), nextMarker: \(String(describing: nextMarker)))"}
}

extension DescribeFileSystemsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeFileSystemsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fileSystems = output.fileSystems
            self.marker = output.marker
            self.nextMarker = output.nextMarker
        } else {
            self.fileSystems = nil
            self.marker = nil
            self.nextMarker = nil
        }
    }
}

public struct DescribeFileSystemsOutputResponse: Equatable {
    /// <p>An array of file system descriptions.</p>
    public let fileSystems: [FileSystemDescription]?
    /// <p>Present if provided by caller in the request (String).</p>
    public let marker: String?
    /// <p>Present if there are more file systems than returned in the response (String). You can
    ///       use the <code>NextMarker</code> in the subsequent request to fetch the descriptions.</p>
    public let nextMarker: String?

    public init (
        fileSystems: [FileSystemDescription]? = nil,
        marker: String? = nil,
        nextMarker: String? = nil
    )
    {
        self.fileSystems = fileSystems
        self.marker = marker
        self.nextMarker = nextMarker
    }
}

struct DescribeFileSystemsOutputResponseBody: Equatable {
    public let marker: String?
    public let fileSystems: [FileSystemDescription]?
    public let nextMarker: String?
}

extension DescribeFileSystemsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileSystems = "FileSystems"
        case marker = "Marker"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let fileSystemsContainer = try containerValues.decodeIfPresent([FileSystemDescription?].self, forKey: .fileSystems)
        var fileSystemsDecoded0:[FileSystemDescription]? = nil
        if let fileSystemsContainer = fileSystemsContainer {
            fileSystemsDecoded0 = [FileSystemDescription]()
            for structure0 in fileSystemsContainer {
                if let structure0 = structure0 {
                    fileSystemsDecoded0?.append(structure0)
                }
            }
        }
        fileSystems = fileSystemsDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension DescribeLifecycleConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLifecycleConfigurationInput(fileSystemId: \(String(describing: fileSystemId)))"}
}

extension DescribeLifecycleConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeLifecycleConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeLifecycleConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLifecycleConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLifecycleConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLifecycleConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeLifecycleConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLifecycleConfigurationOutputError>
}

public struct DescribeLifecycleConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeLifecycleConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLifecycleConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLifecycleConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLifecycleConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeLifecycleConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLifecycleConfigurationOutputError>
}

public struct DescribeLifecycleConfigurationInput: Equatable {
    /// <p>The ID of the file system whose <code>LifecycleConfiguration</code> object you want to
    ///       retrieve (String).</p>
    public let fileSystemId: String?

    public init (
        fileSystemId: String? = nil
    )
    {
        self.fileSystemId = fileSystemId
    }
}

struct DescribeLifecycleConfigurationInputBody: Equatable {
}

extension DescribeLifecycleConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeLifecycleConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLifecycleConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLifecycleConfigurationOutputError: Equatable {
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLifecycleConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLifecycleConfigurationOutputResponse(lifecyclePolicies: \(String(describing: lifecyclePolicies)))"}
}

extension DescribeLifecycleConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeLifecycleConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lifecyclePolicies = output.lifecyclePolicies
        } else {
            self.lifecyclePolicies = nil
        }
    }
}

public struct DescribeLifecycleConfigurationOutputResponse: Equatable {
    /// <p>An array of lifecycle management policies. Currently, EFS supports a maximum of one
    ///       policy per file system.</p>
    public let lifecyclePolicies: [LifecyclePolicy]?

    public init (
        lifecyclePolicies: [LifecyclePolicy]? = nil
    )
    {
        self.lifecyclePolicies = lifecyclePolicies
    }
}

struct DescribeLifecycleConfigurationOutputResponseBody: Equatable {
    public let lifecyclePolicies: [LifecyclePolicy]?
}

extension DescribeLifecycleConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lifecyclePolicies = "LifecyclePolicies"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecyclePoliciesContainer = try containerValues.decodeIfPresent([LifecyclePolicy?].self, forKey: .lifecyclePolicies)
        var lifecyclePoliciesDecoded0:[LifecyclePolicy]? = nil
        if let lifecyclePoliciesContainer = lifecyclePoliciesContainer {
            lifecyclePoliciesDecoded0 = [LifecyclePolicy]()
            for structure0 in lifecyclePoliciesContainer {
                if let structure0 = structure0 {
                    lifecyclePoliciesDecoded0?.append(structure0)
                }
            }
        }
        lifecyclePolicies = lifecyclePoliciesDecoded0
    }
}

extension DescribeMountTargetSecurityGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMountTargetSecurityGroupsInput(mountTargetId: \(String(describing: mountTargetId)))"}
}

extension DescribeMountTargetSecurityGroupsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeMountTargetSecurityGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeMountTargetSecurityGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMountTargetSecurityGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMountTargetSecurityGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMountTargetSecurityGroupsInput>
    public typealias MOutput = OperationOutput<DescribeMountTargetSecurityGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMountTargetSecurityGroupsOutputError>
}

public struct DescribeMountTargetSecurityGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeMountTargetSecurityGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMountTargetSecurityGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMountTargetSecurityGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMountTargetSecurityGroupsInput>
    public typealias MOutput = OperationOutput<DescribeMountTargetSecurityGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMountTargetSecurityGroupsOutputError>
}

/// <p></p>
public struct DescribeMountTargetSecurityGroupsInput: Equatable {
    /// <p>The ID of the mount target whose security groups you want to retrieve.</p>
    public let mountTargetId: String?

    public init (
        mountTargetId: String? = nil
    )
    {
        self.mountTargetId = mountTargetId
    }
}

struct DescribeMountTargetSecurityGroupsInputBody: Equatable {
}

extension DescribeMountTargetSecurityGroupsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeMountTargetSecurityGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMountTargetSecurityGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectMountTargetState" : self = .incorrectMountTargetState(try IncorrectMountTargetState(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MountTargetNotFound" : self = .mountTargetNotFound(try MountTargetNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMountTargetSecurityGroupsOutputError: Equatable {
    case badRequest(BadRequest)
    case incorrectMountTargetState(IncorrectMountTargetState)
    case internalServerError(InternalServerError)
    case mountTargetNotFound(MountTargetNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMountTargetSecurityGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMountTargetSecurityGroupsOutputResponse(securityGroups: \(String(describing: securityGroups)))"}
}

extension DescribeMountTargetSecurityGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeMountTargetSecurityGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.securityGroups = output.securityGroups
        } else {
            self.securityGroups = nil
        }
    }
}

public struct DescribeMountTargetSecurityGroupsOutputResponse: Equatable {
    /// <p>An array of security groups.</p>
    public let securityGroups: [String]?

    public init (
        securityGroups: [String]? = nil
    )
    {
        self.securityGroups = securityGroups
    }
}

struct DescribeMountTargetSecurityGroupsOutputResponseBody: Equatable {
    public let securityGroups: [String]?
}

extension DescribeMountTargetSecurityGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case securityGroups = "SecurityGroups"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityGroupsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
    }
}

extension DescribeMountTargetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMountTargetsInput(accessPointId: \(String(describing: accessPointId)), fileSystemId: \(String(describing: fileSystemId)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), mountTargetId: \(String(describing: mountTargetId)))"}
}

extension DescribeMountTargetsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeMountTargetsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeMountTargetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMountTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMountTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMountTargetsInput>
    public typealias MOutput = OperationOutput<DescribeMountTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMountTargetsOutputError>
}

public struct DescribeMountTargetsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeMountTargetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMountTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMountTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accessPointId = input.operationInput.accessPointId {
            let accessPointIdQueryItem = URLQueryItem(name: "AccessPointId".urlPercentEncoding(), value: String(accessPointId).urlPercentEncoding())
            input.builder.withQueryItem(accessPointIdQueryItem)
        }
        if let fileSystemId = input.operationInput.fileSystemId {
            let fileSystemIdQueryItem = URLQueryItem(name: "FileSystemId".urlPercentEncoding(), value: String(fileSystemId).urlPercentEncoding())
            input.builder.withQueryItem(fileSystemIdQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "Marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let mountTargetId = input.operationInput.mountTargetId {
            let mountTargetIdQueryItem = URLQueryItem(name: "MountTargetId".urlPercentEncoding(), value: String(mountTargetId).urlPercentEncoding())
            input.builder.withQueryItem(mountTargetIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMountTargetsInput>
    public typealias MOutput = OperationOutput<DescribeMountTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMountTargetsOutputError>
}

/// <p></p>
public struct DescribeMountTargetsInput: Equatable {
    /// <p>(Optional) The ID of the access point whose mount targets that you want to list. It must be included in your request if a
    ///       <code>FileSystemId</code> or <code>MountTargetId</code> is not included in your request. Accepts either an access point ID or ARN as input.</p>
    public let accessPointId: String?
    /// <p>(Optional) ID of the file system whose mount targets you want to list (String). It must
    ///       be included in your request if an <code>AccessPointId</code> or <code>MountTargetId</code> is not included. Accepts either a file system ID or ARN as input.</p>
    public let fileSystemId: String?
    /// <p>(Optional) Opaque pagination token returned from a previous
    ///         <code>DescribeMountTargets</code> operation (String). If present, it specifies to continue
    ///       the list from where the previous returning call left off.</p>
    public let marker: String?
    /// <p>(Optional) Maximum number of mount targets to return in the response. Currently, this
    ///       number is automatically set to
    ///       10, and other values are ignored. The response is paginated at 100 per page if you have more than 100 mount targets.</p>
    public let maxItems: Int?
    /// <p>(Optional) ID of the mount target that you want to have described (String). It must be
    ///       included in your request if <code>FileSystemId</code> is not included. Accepts either a mount target ID or ARN as input.</p>
    public let mountTargetId: String?

    public init (
        accessPointId: String? = nil,
        fileSystemId: String? = nil,
        marker: String? = nil,
        maxItems: Int? = nil,
        mountTargetId: String? = nil
    )
    {
        self.accessPointId = accessPointId
        self.fileSystemId = fileSystemId
        self.marker = marker
        self.maxItems = maxItems
        self.mountTargetId = mountTargetId
    }
}

struct DescribeMountTargetsInputBody: Equatable {
}

extension DescribeMountTargetsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeMountTargetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMountTargetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointNotFound" : self = .accessPointNotFound(try AccessPointNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MountTargetNotFound" : self = .mountTargetNotFound(try MountTargetNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMountTargetsOutputError: Equatable {
    case accessPointNotFound(AccessPointNotFound)
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case mountTargetNotFound(MountTargetNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMountTargetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMountTargetsOutputResponse(marker: \(String(describing: marker)), mountTargets: \(String(describing: mountTargets)), nextMarker: \(String(describing: nextMarker)))"}
}

extension DescribeMountTargetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeMountTargetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.mountTargets = output.mountTargets
            self.nextMarker = output.nextMarker
        } else {
            self.marker = nil
            self.mountTargets = nil
            self.nextMarker = nil
        }
    }
}

/// <p></p>
public struct DescribeMountTargetsOutputResponse: Equatable {
    /// <p>If the request included the <code>Marker</code>, the response returns that value in
    ///       this field.</p>
    public let marker: String?
    /// <p>Returns the file system's mount targets as an array of
    ///         <code>MountTargetDescription</code> objects.</p>
    public let mountTargets: [MountTargetDescription]?
    /// <p>If a value is present, there are more mount targets to return. In a subsequent request,
    ///       you can provide <code>Marker</code> in your request with this value to retrieve the next set
    ///       of mount targets.</p>
    public let nextMarker: String?

    public init (
        marker: String? = nil,
        mountTargets: [MountTargetDescription]? = nil,
        nextMarker: String? = nil
    )
    {
        self.marker = marker
        self.mountTargets = mountTargets
        self.nextMarker = nextMarker
    }
}

struct DescribeMountTargetsOutputResponseBody: Equatable {
    public let marker: String?
    public let mountTargets: [MountTargetDescription]?
    public let nextMarker: String?
}

extension DescribeMountTargetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case mountTargets = "MountTargets"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let mountTargetsContainer = try containerValues.decodeIfPresent([MountTargetDescription?].self, forKey: .mountTargets)
        var mountTargetsDecoded0:[MountTargetDescription]? = nil
        if let mountTargetsContainer = mountTargetsContainer {
            mountTargetsDecoded0 = [MountTargetDescription]()
            for structure0 in mountTargetsContainer {
                if let structure0 = structure0 {
                    mountTargetsDecoded0?.append(structure0)
                }
            }
        }
        mountTargets = mountTargetsDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension DescribeTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTagsInput(fileSystemId: \(String(describing: fileSystemId)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)))"}
}

extension DescribeTagsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeTagsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTagsInput>
    public typealias MOutput = OperationOutput<DescribeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTagsOutputError>
}

public struct DescribeTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "Marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTagsInput>
    public typealias MOutput = OperationOutput<DescribeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTagsOutputError>
}

/// <p></p>
public struct DescribeTagsInput: Equatable {
    /// <p>The ID of the file system whose tag set you want to retrieve.</p>
    public let fileSystemId: String?
    /// <p>(Optional) An opaque pagination token returned from a previous
    ///         <code>DescribeTags</code> operation (String). If present, it specifies to continue the list
    ///       from where the previous call left off.</p>
    public let marker: String?
    /// <p>(Optional) The maximum number of file system tags to return in the response. Currently,
    ///       this number is automatically set to
    ///       100, and other values are ignored. The response is paginated at 100 per page if you have more than 100 tags.</p>
    public let maxItems: Int?

    public init (
        fileSystemId: String? = nil,
        marker: String? = nil,
        maxItems: Int? = nil
    )
    {
        self.fileSystemId = fileSystemId
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct DescribeTagsInputBody: Equatable {
}

extension DescribeTagsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTagsOutputError: Equatable {
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTagsOutputResponse(marker: \(String(describing: marker)), nextMarker: \(String(describing: nextMarker)), tags: \(String(describing: tags)))"}
}

extension DescribeTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeTagsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.nextMarker = output.nextMarker
            self.tags = output.tags
        } else {
            self.marker = nil
            self.nextMarker = nil
            self.tags = nil
        }
    }
}

/// <p></p>
public struct DescribeTagsOutputResponse: Equatable {
    /// <p>If the request included a <code>Marker</code>, the response returns that value in this
    ///       field.</p>
    public let marker: String?
    /// <p>If a value is present, there are more tags to return. In a subsequent request, you can
    ///       provide the value of <code>NextMarker</code> as the value of the <code>Marker</code> parameter
    ///       in your next request to retrieve the next set of tags.</p>
    public let nextMarker: String?
    /// <p>Returns tags associated with the file system as an array of <code>Tag</code> objects.
    ///     </p>
    public let tags: [Tag]?

    public init (
        marker: String? = nil,
        nextMarker: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.marker = marker
        self.nextMarker = nextMarker
        self.tags = tags
    }
}

struct DescribeTagsOutputResponseBody: Equatable {
    public let marker: String?
    public let tags: [Tag]?
    public let nextMarker: String?
}

extension DescribeTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case nextMarker = "NextMarker"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension FileSystemAlreadyExists: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FileSystemAlreadyExists(errorCode: \(String(describing: errorCode)), fileSystemId: \(String(describing: fileSystemId)), message: \(String(describing: message)))"}
}

extension FileSystemAlreadyExists: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: FileSystemAlreadyExistsBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.fileSystemId = output.fileSystemId
            self.message = output.message
        } else {
            self.errorCode = nil
            self.fileSystemId = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if the file system you are trying to create already exists, with the
///             creation token you provided.</p>
public struct FileSystemAlreadyExists: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var errorCode: String?
    public var fileSystemId: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        fileSystemId: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.fileSystemId = fileSystemId
        self.message = message
    }
}

struct FileSystemAlreadyExistsBody: Equatable {
    public let errorCode: String?
    public let message: String?
    public let fileSystemId: String?
}

extension FileSystemAlreadyExistsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case fileSystemId = "FileSystemId"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
    }
}

extension FileSystemDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZoneId = "AvailabilityZoneId"
        case availabilityZoneName = "AvailabilityZoneName"
        case creationTime = "CreationTime"
        case creationToken = "CreationToken"
        case encrypted = "Encrypted"
        case fileSystemArn = "FileSystemArn"
        case fileSystemId = "FileSystemId"
        case kmsKeyId = "KmsKeyId"
        case lifeCycleState = "LifeCycleState"
        case name = "Name"
        case numberOfMountTargets = "NumberOfMountTargets"
        case ownerId = "OwnerId"
        case performanceMode = "PerformanceMode"
        case provisionedThroughputInMibps = "ProvisionedThroughputInMibps"
        case sizeInBytes = "SizeInBytes"
        case tags = "Tags"
        case throughputMode = "ThroughputMode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZoneId = availabilityZoneId {
            try encodeContainer.encode(availabilityZoneId, forKey: .availabilityZoneId)
        }
        if let availabilityZoneName = availabilityZoneName {
            try encodeContainer.encode(availabilityZoneName, forKey: .availabilityZoneName)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let creationToken = creationToken {
            try encodeContainer.encode(creationToken, forKey: .creationToken)
        }
        if let encrypted = encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let fileSystemArn = fileSystemArn {
            try encodeContainer.encode(fileSystemArn, forKey: .fileSystemArn)
        }
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let lifeCycleState = lifeCycleState {
            try encodeContainer.encode(lifeCycleState.rawValue, forKey: .lifeCycleState)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if numberOfMountTargets != 0 {
            try encodeContainer.encode(numberOfMountTargets, forKey: .numberOfMountTargets)
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let performanceMode = performanceMode {
            try encodeContainer.encode(performanceMode.rawValue, forKey: .performanceMode)
        }
        if let provisionedThroughputInMibps = provisionedThroughputInMibps {
            try encodeContainer.encode(provisionedThroughputInMibps, forKey: .provisionedThroughputInMibps)
        }
        if let sizeInBytes = sizeInBytes {
            try encodeContainer.encode(sizeInBytes, forKey: .sizeInBytes)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let throughputMode = throughputMode {
            try encodeContainer.encode(throughputMode.rawValue, forKey: .throughputMode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let creationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationToken)
        creationToken = creationTokenDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let fileSystemArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemArn)
        fileSystemArn = fileSystemArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lifeCycleStateDecoded = try containerValues.decodeIfPresent(LifeCycleState.self, forKey: .lifeCycleState)
        lifeCycleState = lifeCycleStateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let numberOfMountTargetsDecoded = try containerValues.decode(Int.self, forKey: .numberOfMountTargets)
        numberOfMountTargets = numberOfMountTargetsDecoded
        let sizeInBytesDecoded = try containerValues.decodeIfPresent(FileSystemSize.self, forKey: .sizeInBytes)
        sizeInBytes = sizeInBytesDecoded
        let performanceModeDecoded = try containerValues.decodeIfPresent(PerformanceMode.self, forKey: .performanceMode)
        performanceMode = performanceModeDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let throughputModeDecoded = try containerValues.decodeIfPresent(ThroughputMode.self, forKey: .throughputMode)
        throughputMode = throughputModeDecoded
        let provisionedThroughputInMibpsDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .provisionedThroughputInMibps)
        provisionedThroughputInMibps = provisionedThroughputInMibpsDecoded
        let availabilityZoneNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZoneName)
        availabilityZoneName = availabilityZoneNameDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension FileSystemDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FileSystemDescription(availabilityZoneId: \(String(describing: availabilityZoneId)), availabilityZoneName: \(String(describing: availabilityZoneName)), creationTime: \(String(describing: creationTime)), creationToken: \(String(describing: creationToken)), encrypted: \(String(describing: encrypted)), fileSystemArn: \(String(describing: fileSystemArn)), fileSystemId: \(String(describing: fileSystemId)), kmsKeyId: \(String(describing: kmsKeyId)), lifeCycleState: \(String(describing: lifeCycleState)), name: \(String(describing: name)), numberOfMountTargets: \(String(describing: numberOfMountTargets)), ownerId: \(String(describing: ownerId)), performanceMode: \(String(describing: performanceMode)), provisionedThroughputInMibps: \(String(describing: provisionedThroughputInMibps)), sizeInBytes: \(String(describing: sizeInBytes)), tags: \(String(describing: tags)), throughputMode: \(String(describing: throughputMode)))"}
}

/// <p>A description of the file system.</p>
public struct FileSystemDescription: Equatable {
    /// <p>The unique and consistent identifier of the Availability Zone in which the file system's
    ///       One Zone storage classes exist. For example, <code>use1-az1</code> is an Availability Zone ID
    ///       for the us-east-1 AWS Region, and it has the same location in every AWS account.</p>
    public let availabilityZoneId: String?
    /// <p>Describes the AWS Availability Zone in which the file system is located, and is valid only
    ///       for file systems using One Zone storage classes. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/storage-classes.html">Using EFS storage classes</a>
    ///       in the <i>Amazon EFS User Guide</i>.</p>
    public let availabilityZoneName: String?
    /// <p>The time that the file system was created, in seconds (since
    ///       1970-01-01T00:00:00Z).</p>
    public let creationTime: Date?
    /// <p>The opaque string specified in the request.</p>
    public let creationToken: String?
    /// <p>A Boolean value that, if true, indicates that the file system is encrypted.</p>
    public let encrypted: Bool?
    /// <p>The Amazon Resource Name (ARN) for the EFS file system, in the format
    ///       <code>arn:aws:elasticfilesystem:<i>region</i>:<i>account-id</i>:file-system/<i>file-system-id</i>
    ///             </code>.
    ///       Example with sample data: <code>arn:aws:elasticfilesystem:us-west-2:1111333322228888:file-system/fs-01234567</code>
    ///          </p>
    public let fileSystemArn: String?
    /// <p>The ID of the file system, assigned by Amazon EFS.</p>
    public let fileSystemId: String?
    /// <p>The ID of an AWS Key Management Service (AWS KMS) customer master key (CMK) that was
    ///       used to protect the encrypted file system.</p>
    public let kmsKeyId: String?
    /// <p>The lifecycle phase of the file system.</p>
    public let lifeCycleState: LifeCycleState?
    /// <p>You can add tags to a file system, including a <code>Name</code> tag. For more
    ///       information, see <a>CreateFileSystem</a>. If the file system has a <code>Name</code> tag, Amazon EFS returns
    ///       the value in this field. </p>
    public let name: String?
    /// <p>The current number of mount targets that the file system has. For more information, see <a>CreateMountTarget</a>.</p>
    public let numberOfMountTargets: Int
    /// <p>The AWS account that created the file system. If the file system was created by an IAM
    ///       user, the parent account to which the user belongs is the owner.</p>
    public let ownerId: String?
    /// <p>The performance mode of the file system.</p>
    public let performanceMode: PerformanceMode?
    /// <p>The amount of provisioned throughput, measured in MiB/s, for the file system. Valid for
    ///       file systems using <code>ThroughputMode</code> set to <code>provisioned</code>.</p>
    public let provisionedThroughputInMibps: Double?
    /// <p>The latest known metered size (in bytes) of data stored in the file system, in its
    ///         <code>Value</code> field, and the time at which that size was determined in its
    ///         <code>Timestamp</code> field. The <code>Timestamp</code> value is the integer number of
    ///       seconds since 1970-01-01T00:00:00Z. The <code>SizeInBytes</code> value doesn't represent
    ///       the size of a consistent snapshot of the file system, but it is eventually consistent when
    ///       there are no writes to the file system. That is, <code>SizeInBytes</code> represents actual
    ///       size only if the file system is not modified for a period longer than a couple of hours.
    ///       Otherwise, the value is not the exact size that the file system was at any point in time.
    ///     </p>
    public let sizeInBytes: FileSystemSize?
    /// <p>The tags associated with the file system, presented as an array of <code>Tag</code>
    ///       objects.</p>
    public let tags: [Tag]?
    /// <p>Displays the file system's throughput mode. For more information, see
    ///       <a href="https://docs.aws.amazon.com/efs/latest/ug/performance.html#throughput-modes">Throughput modes</a>
    ///       in the <i>Amazon EFS User Guide</i>.
    ///     </p>
    public let throughputMode: ThroughputMode?

    public init (
        availabilityZoneId: String? = nil,
        availabilityZoneName: String? = nil,
        creationTime: Date? = nil,
        creationToken: String? = nil,
        encrypted: Bool? = nil,
        fileSystemArn: String? = nil,
        fileSystemId: String? = nil,
        kmsKeyId: String? = nil,
        lifeCycleState: LifeCycleState? = nil,
        name: String? = nil,
        numberOfMountTargets: Int = 0,
        ownerId: String? = nil,
        performanceMode: PerformanceMode? = nil,
        provisionedThroughputInMibps: Double? = nil,
        sizeInBytes: FileSystemSize? = nil,
        tags: [Tag]? = nil,
        throughputMode: ThroughputMode? = nil
    )
    {
        self.availabilityZoneId = availabilityZoneId
        self.availabilityZoneName = availabilityZoneName
        self.creationTime = creationTime
        self.creationToken = creationToken
        self.encrypted = encrypted
        self.fileSystemArn = fileSystemArn
        self.fileSystemId = fileSystemId
        self.kmsKeyId = kmsKeyId
        self.lifeCycleState = lifeCycleState
        self.name = name
        self.numberOfMountTargets = numberOfMountTargets
        self.ownerId = ownerId
        self.performanceMode = performanceMode
        self.provisionedThroughputInMibps = provisionedThroughputInMibps
        self.sizeInBytes = sizeInBytes
        self.tags = tags
        self.throughputMode = throughputMode
    }
}

extension FileSystemInUse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FileSystemInUse(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension FileSystemInUse: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: FileSystemInUseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if a file system has mount targets.</p>
public struct FileSystemInUse: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var errorCode: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct FileSystemInUseBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension FileSystemInUseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FileSystemLimitExceeded: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FileSystemLimitExceeded(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension FileSystemLimitExceeded: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: FileSystemLimitExceededBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if the AWS account has already created the maximum number of file systems
///             allowed per account.</p>
public struct FileSystemLimitExceeded: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var errorCode: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct FileSystemLimitExceededBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension FileSystemLimitExceededBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FileSystemNotFound: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FileSystemNotFound(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension FileSystemNotFound: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: FileSystemNotFoundBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if the specified <code>FileSystemId</code> value doesn't exist in the
///             requester's AWS account.</p>
public struct FileSystemNotFound: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var errorCode: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct FileSystemNotFoundBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension FileSystemNotFoundBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FileSystemSize: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case timestamp = "Timestamp"
        case value = "Value"
        case valueInIA = "ValueInIA"
        case valueInStandard = "ValueInStandard"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
        if value != 0 {
            try encodeContainer.encode(value, forKey: .value)
        }
        if let valueInIA = valueInIA {
            try encodeContainer.encode(valueInIA, forKey: .valueInIA)
        }
        if let valueInStandard = valueInStandard {
            try encodeContainer.encode(valueInStandard, forKey: .valueInStandard)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decode(Int.self, forKey: .value)
        value = valueDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let valueInIADecoded = try containerValues.decodeIfPresent(Int.self, forKey: .valueInIA)
        valueInIA = valueInIADecoded
        let valueInStandardDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .valueInStandard)
        valueInStandard = valueInStandardDecoded
    }
}

extension FileSystemSize: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FileSystemSize(timestamp: \(String(describing: timestamp)), value: \(String(describing: value)), valueInIA: \(String(describing: valueInIA)), valueInStandard: \(String(describing: valueInStandard)))"}
}

/// <p>The latest known metered size (in bytes) of data stored in the file system, in its
///         <code>Value</code> field, and the time at which that size was determined in its
///         <code>Timestamp</code> field. The value doesn't represent the size of a consistent
///       snapshot of the file system, but it is eventually consistent when there are no writes to the
///       file system. That is, the value represents the actual size only if the file system is not
///       modified for a period longer than a couple of hours. Otherwise, the value is not necessarily
///       the exact size the file system was at any instant in time.</p>
public struct FileSystemSize: Equatable {
    /// <p>The time at which the size of data, returned in the <code>Value</code> field, was
    ///       determined. The value is the integer number of seconds since 1970-01-01T00:00:00Z.</p>
    public let timestamp: Date?
    /// <p>The latest known metered size (in bytes) of data stored in the file system.</p>
    public let value: Int
    /// <p>The latest known metered size (in bytes) of data stored in the Infrequent Access
    ///       storage class.</p>
    public let valueInIA: Int?
    /// <p>The latest known metered size (in bytes) of data stored in the Standard storage
    ///       class.</p>
    public let valueInStandard: Int?

    public init (
        timestamp: Date? = nil,
        value: Int = 0,
        valueInIA: Int? = nil,
        valueInStandard: Int? = nil
    )
    {
        self.timestamp = timestamp
        self.value = value
        self.valueInIA = valueInIA
        self.valueInStandard = valueInStandard
    }
}

extension IncorrectFileSystemLifeCycleState: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IncorrectFileSystemLifeCycleState(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension IncorrectFileSystemLifeCycleState: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IncorrectFileSystemLifeCycleStateBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if the file system's lifecycle state is not "available".</p>
public struct IncorrectFileSystemLifeCycleState: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var errorCode: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct IncorrectFileSystemLifeCycleStateBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension IncorrectFileSystemLifeCycleStateBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IncorrectMountTargetState: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IncorrectMountTargetState(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension IncorrectMountTargetState: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IncorrectMountTargetStateBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if the mount target is not in the correct state for the
///             operation.</p>
public struct IncorrectMountTargetState: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var errorCode: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct IncorrectMountTargetStateBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension IncorrectMountTargetStateBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientThroughputCapacity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsufficientThroughputCapacity(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension InsufficientThroughputCapacity: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InsufficientThroughputCapacityBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if there's not enough capacity to provision additional throughput. This value
///             might be returned when you try to create a file system in provisioned throughput mode,
///             when you attempt to increase the provisioned throughput of an existing file system, or
///             when you attempt to change an existing file system from bursting to provisioned
///             throughput mode. Try again later.</p>
public struct InsufficientThroughputCapacity: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var errorCode: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct InsufficientThroughputCapacityBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension InsufficientThroughputCapacityBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServerError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerError(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension InternalServerError: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerErrorBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if an error occurred on the server side.</p>
public struct InternalServerError: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var errorCode: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct InternalServerErrorBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension InternalServerErrorBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPolicyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidPolicyException(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension InvalidPolicyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidPolicyExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if the <code>FileSystemPolicy</code> is is malformed or contains an error such as an invalid
///             parameter value or a missing required parameter. Returned in the case of a policy lockout safety check error.</p>
public struct InvalidPolicyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var errorCode: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct InvalidPolicyExceptionBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension InvalidPolicyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IpAddressInUse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IpAddressInUse(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension IpAddressInUse: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IpAddressInUseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if the request specified an <code>IpAddress</code> that is already in use
///             in the subnet.</p>
public struct IpAddressInUse: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var errorCode: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct IpAddressInUseBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension IpAddressInUseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum LifeCycleState {
    case available
    case creating
    case deleted
    case deleting
    case error
    case updating
    case sdkUnknown(String)
}

extension LifeCycleState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LifeCycleState] {
        return [
            .available,
            .creating,
            .deleted,
            .deleting,
            .error,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "available"
        case .creating: return "creating"
        case .deleted: return "deleted"
        case .deleting: return "deleting"
        case .error: return "error"
        case .updating: return "updating"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LifeCycleState(rawValue: rawValue) ?? LifeCycleState.sdkUnknown(rawValue)
    }
}

extension LifecyclePolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case transitionToIA = "TransitionToIA"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transitionToIA = transitionToIA {
            try encodeContainer.encode(transitionToIA.rawValue, forKey: .transitionToIA)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitionToIADecoded = try containerValues.decodeIfPresent(TransitionToIARules.self, forKey: .transitionToIA)
        transitionToIA = transitionToIADecoded
    }
}

extension LifecyclePolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LifecyclePolicy(transitionToIA: \(String(describing: transitionToIA)))"}
}

/// <p>Describes a policy used by EFS lifecycle management to transition files to the Infrequent
///       Access (IA) storage class.</p>
public struct LifecyclePolicy: Equatable {
    /// <p>
    ///       A value that describes the period of time that a file is not accessed, after which it transitions to the IA storage class. Metadata
    ///       operations such as listing the contents of a directory don't count as file access
    ///       events.</p>
    public let transitionToIA: TransitionToIARules?

    public init (
        transitionToIA: TransitionToIARules? = nil
    )
    {
        self.transitionToIA = transitionToIA
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceId: \(String(describing: resourceId)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>(Optional) Specifies the maximum number of tag objects to return in the response. The default value is 100.</p>
    public let maxResults: Int?
    /// <p>(Optional) You can use <code>NextToken</code> in a subsequent request to fetch the next page of access point descriptions if the response payload was paginated.</p>
    public let nextToken: String?
    /// <p>Specifies the EFS resource you want to retrieve tags for. You can retrieve tags for EFS file systems and access points using this API endpoint.</p>
    public let resourceId: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceId = resourceId
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointNotFound" : self = .accessPointNotFound(try AccessPointNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case accessPointNotFound(AccessPointNotFound)
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>
    ///             <code>NextToken</code> is present if the response payload is paginated. You can use <code>NextToken</code> in a subsequent request to fetch the next page of access point descriptions.</p>
    public let nextToken: String?
    /// <p>An array of the tags for the specified EFS resource.</p>
    public let tags: [Tag]?

    public init (
        nextToken: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
    public let nextToken: String?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ModifyMountTargetSecurityGroupsInputBodyMiddleware: Middleware {
    public let id: String = "ModifyMountTargetSecurityGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyMountTargetSecurityGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyMountTargetSecurityGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyMountTargetSecurityGroupsInput>
    public typealias MOutput = OperationOutput<ModifyMountTargetSecurityGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyMountTargetSecurityGroupsOutputError>
}

extension ModifyMountTargetSecurityGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyMountTargetSecurityGroupsInput(mountTargetId: \(String(describing: mountTargetId)), securityGroups: \(String(describing: securityGroups)))"}
}

extension ModifyMountTargetSecurityGroupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case securityGroups = "SecurityGroups"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygroups0 in securityGroups {
                try securityGroupsContainer.encode(securitygroups0)
            }
        }
    }
}

public struct ModifyMountTargetSecurityGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyMountTargetSecurityGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyMountTargetSecurityGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyMountTargetSecurityGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyMountTargetSecurityGroupsInput>
    public typealias MOutput = OperationOutput<ModifyMountTargetSecurityGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyMountTargetSecurityGroupsOutputError>
}

public struct ModifyMountTargetSecurityGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyMountTargetSecurityGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyMountTargetSecurityGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyMountTargetSecurityGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyMountTargetSecurityGroupsInput>
    public typealias MOutput = OperationOutput<ModifyMountTargetSecurityGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyMountTargetSecurityGroupsOutputError>
}

/// <p></p>
public struct ModifyMountTargetSecurityGroupsInput: Equatable {
    /// <p>The ID of the mount target whose security groups you want to modify.</p>
    public let mountTargetId: String?
    /// <p>An array of up to five VPC security group IDs.</p>
    public let securityGroups: [String]?

    public init (
        mountTargetId: String? = nil,
        securityGroups: [String]? = nil
    )
    {
        self.mountTargetId = mountTargetId
        self.securityGroups = securityGroups
    }
}

struct ModifyMountTargetSecurityGroupsInputBody: Equatable {
    public let securityGroups: [String]?
}

extension ModifyMountTargetSecurityGroupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case securityGroups = "SecurityGroups"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityGroupsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
    }
}

extension ModifyMountTargetSecurityGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyMountTargetSecurityGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectMountTargetState" : self = .incorrectMountTargetState(try IncorrectMountTargetState(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MountTargetNotFound" : self = .mountTargetNotFound(try MountTargetNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SecurityGroupLimitExceeded" : self = .securityGroupLimitExceeded(try SecurityGroupLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SecurityGroupNotFound" : self = .securityGroupNotFound(try SecurityGroupNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyMountTargetSecurityGroupsOutputError: Equatable {
    case badRequest(BadRequest)
    case incorrectMountTargetState(IncorrectMountTargetState)
    case internalServerError(InternalServerError)
    case mountTargetNotFound(MountTargetNotFound)
    case securityGroupLimitExceeded(SecurityGroupLimitExceeded)
    case securityGroupNotFound(SecurityGroupNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyMountTargetSecurityGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyMountTargetSecurityGroupsOutputResponse()"}
}

extension ModifyMountTargetSecurityGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ModifyMountTargetSecurityGroupsOutputResponse: Equatable {

    public init() {}
}

struct ModifyMountTargetSecurityGroupsOutputResponseBody: Equatable {
}

extension ModifyMountTargetSecurityGroupsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension MountTargetConflict: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MountTargetConflict(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension MountTargetConflict: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MountTargetConflictBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if the mount target would violate one of the specified restrictions based
///             on the file system's existing mount targets.</p>
public struct MountTargetConflict: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var errorCode: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct MountTargetConflictBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension MountTargetConflictBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MountTargetDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZoneId = "AvailabilityZoneId"
        case availabilityZoneName = "AvailabilityZoneName"
        case fileSystemId = "FileSystemId"
        case ipAddress = "IpAddress"
        case lifeCycleState = "LifeCycleState"
        case mountTargetId = "MountTargetId"
        case networkInterfaceId = "NetworkInterfaceId"
        case ownerId = "OwnerId"
        case subnetId = "SubnetId"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZoneId = availabilityZoneId {
            try encodeContainer.encode(availabilityZoneId, forKey: .availabilityZoneId)
        }
        if let availabilityZoneName = availabilityZoneName {
            try encodeContainer.encode(availabilityZoneName, forKey: .availabilityZoneName)
        }
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let ipAddress = ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let lifeCycleState = lifeCycleState {
            try encodeContainer.encode(lifeCycleState.rawValue, forKey: .lifeCycleState)
        }
        if let mountTargetId = mountTargetId {
            try encodeContainer.encode(mountTargetId, forKey: .mountTargetId)
        }
        if let networkInterfaceId = networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let mountTargetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mountTargetId)
        mountTargetId = mountTargetIdDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let lifeCycleStateDecoded = try containerValues.decodeIfPresent(LifeCycleState.self, forKey: .lifeCycleState)
        lifeCycleState = lifeCycleStateDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let availabilityZoneNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZoneName)
        availabilityZoneName = availabilityZoneNameDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension MountTargetDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MountTargetDescription(availabilityZoneId: \(String(describing: availabilityZoneId)), availabilityZoneName: \(String(describing: availabilityZoneName)), fileSystemId: \(String(describing: fileSystemId)), ipAddress: \(String(describing: ipAddress)), lifeCycleState: \(String(describing: lifeCycleState)), mountTargetId: \(String(describing: mountTargetId)), networkInterfaceId: \(String(describing: networkInterfaceId)), ownerId: \(String(describing: ownerId)), subnetId: \(String(describing: subnetId)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Provides a description of a mount target.</p>
public struct MountTargetDescription: Equatable {
    /// <p>The unique and consistent identifier of the Availability Zone that the mount target resides in.
    ///       For example, <code>use1-az1</code> is an AZ ID for the us-east-1 Region and it has the same location in every AWS account.</p>
    public let availabilityZoneId: String?
    /// <p>The name of the Availability Zone in which the mount target is located. Availability Zones are
    ///       independently mapped to names for each AWS account. For example, the Availability Zone
    ///       <code>us-east-1a</code> for your AWS account might not be the same location as <code>us-east-1a</code> for another AWS account.</p>
    public let availabilityZoneName: String?
    /// <p>The ID of the file system for which the mount target is intended.</p>
    public let fileSystemId: String?
    /// <p>Address at which the file system can be mounted by using the mount target.</p>
    public let ipAddress: String?
    /// <p>Lifecycle state of the mount target.</p>
    public let lifeCycleState: LifeCycleState?
    /// <p>System-assigned mount target ID.</p>
    public let mountTargetId: String?
    /// <p>The ID of the network interface that Amazon EFS created when it created the mount
    ///       target.</p>
    public let networkInterfaceId: String?
    /// <p>AWS account ID that owns the resource.</p>
    public let ownerId: String?
    /// <p>The ID of the mount target's subnet.</p>
    public let subnetId: String?
    /// <p>The virtual private cloud (VPC) ID that the mount target is configured in.</p>
    public let vpcId: String?

    public init (
        availabilityZoneId: String? = nil,
        availabilityZoneName: String? = nil,
        fileSystemId: String? = nil,
        ipAddress: String? = nil,
        lifeCycleState: LifeCycleState? = nil,
        mountTargetId: String? = nil,
        networkInterfaceId: String? = nil,
        ownerId: String? = nil,
        subnetId: String? = nil,
        vpcId: String? = nil
    )
    {
        self.availabilityZoneId = availabilityZoneId
        self.availabilityZoneName = availabilityZoneName
        self.fileSystemId = fileSystemId
        self.ipAddress = ipAddress
        self.lifeCycleState = lifeCycleState
        self.mountTargetId = mountTargetId
        self.networkInterfaceId = networkInterfaceId
        self.ownerId = ownerId
        self.subnetId = subnetId
        self.vpcId = vpcId
    }
}

extension MountTargetNotFound: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MountTargetNotFound(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension MountTargetNotFound: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MountTargetNotFoundBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if there is no mount target with the specified ID found in the
///             caller's account.</p>
public struct MountTargetNotFound: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var errorCode: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct MountTargetNotFoundBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension MountTargetNotFoundBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NetworkInterfaceLimitExceeded: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NetworkInterfaceLimitExceeded(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension NetworkInterfaceLimitExceeded: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NetworkInterfaceLimitExceededBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The calling account has reached the limit for elastic network interfaces for the
///             specific AWS Region. The client should try to delete some elastic network interfaces or
///             get the account limit raised. For more information, see <a href="https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Appendix_Limits.html">Amazon VPC Limits</a>
///             in the <i>Amazon VPC User Guide </i> (see the Network interfaces per VPC
///             entry in the table). </p>
public struct NetworkInterfaceLimitExceeded: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var errorCode: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct NetworkInterfaceLimitExceededBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension NetworkInterfaceLimitExceededBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoFreeAddressesInSubnet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoFreeAddressesInSubnet(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension NoFreeAddressesInSubnet: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NoFreeAddressesInSubnetBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if <code>IpAddress</code> was not specified in the request and there are
///             no free IP addresses in the subnet.</p>
public struct NoFreeAddressesInSubnet: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var errorCode: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct NoFreeAddressesInSubnetBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension NoFreeAddressesInSubnetBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum PerformanceMode {
    case generalPurpose
    case maxIo
    case sdkUnknown(String)
}

extension PerformanceMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PerformanceMode] {
        return [
            .generalPurpose,
            .maxIo,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .generalPurpose: return "generalPurpose"
        case .maxIo: return "maxIO"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PerformanceMode(rawValue: rawValue) ?? PerformanceMode.sdkUnknown(rawValue)
    }
}

extension PolicyNotFound: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyNotFound(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension PolicyNotFound: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PolicyNotFoundBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if the default file system policy is in effect for the EFS file system specified.</p>
public struct PolicyNotFound: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var errorCode: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct PolicyNotFoundBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension PolicyNotFoundBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PosixUser: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gid = "Gid"
        case secondaryGids = "SecondaryGids"
        case uid = "Uid"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gid = gid {
            try encodeContainer.encode(gid, forKey: .gid)
        }
        if let secondaryGids = secondaryGids {
            var secondaryGidsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondaryGids)
            for secondarygids0 in secondaryGids {
                try secondaryGidsContainer.encode(secondarygids0)
            }
        }
        if let uid = uid {
            try encodeContainer.encode(uid, forKey: .uid)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uidDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .uid)
        uid = uidDecoded
        let gidDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .gid)
        gid = gidDecoded
        let secondaryGidsContainer = try containerValues.decodeIfPresent([Int?].self, forKey: .secondaryGids)
        var secondaryGidsDecoded0:[Int]? = nil
        if let secondaryGidsContainer = secondaryGidsContainer {
            secondaryGidsDecoded0 = [Int]()
            for long0 in secondaryGidsContainer {
                if let long0 = long0 {
                    secondaryGidsDecoded0?.append(long0)
                }
            }
        }
        secondaryGids = secondaryGidsDecoded0
    }
}

extension PosixUser: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PosixUser(gid: \(String(describing: gid)), secondaryGids: \(String(describing: secondaryGids)), uid: \(String(describing: uid)))"}
}

/// <p>The full POSIX identity, including the user ID, group ID, and any secondary group IDs, on the access point that is used for all file system operations performed by
///       NFS clients using the access point.</p>
public struct PosixUser: Equatable {
    /// <p>The POSIX group ID used for all file system operations using this access point.</p>
    public let gid: Int?
    /// <p>Secondary POSIX group IDs used for all file system operations using this access point.</p>
    public let secondaryGids: [Int]?
    /// <p>The POSIX user ID used for all file system operations using this access point.</p>
    public let uid: Int?

    public init (
        gid: Int? = nil,
        secondaryGids: [Int]? = nil,
        uid: Int? = nil
    )
    {
        self.gid = gid
        self.secondaryGids = secondaryGids
        self.uid = uid
    }
}

public struct PutAccountPreferencesInputBodyMiddleware: Middleware {
    public let id: String = "PutAccountPreferencesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccountPreferencesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccountPreferencesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccountPreferencesInput>
    public typealias MOutput = OperationOutput<PutAccountPreferencesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccountPreferencesOutputError>
}

extension PutAccountPreferencesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAccountPreferencesInput(resourceIdType: \(String(describing: resourceIdType)))"}
}

extension PutAccountPreferencesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceIdType = "ResourceIdType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceIdType = resourceIdType {
            try encodeContainer.encode(resourceIdType.rawValue, forKey: .resourceIdType)
        }
    }
}

public struct PutAccountPreferencesInputHeadersMiddleware: Middleware {
    public let id: String = "PutAccountPreferencesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccountPreferencesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccountPreferencesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccountPreferencesInput>
    public typealias MOutput = OperationOutput<PutAccountPreferencesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccountPreferencesOutputError>
}

public struct PutAccountPreferencesInputQueryItemMiddleware: Middleware {
    public let id: String = "PutAccountPreferencesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccountPreferencesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccountPreferencesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccountPreferencesInput>
    public typealias MOutput = OperationOutput<PutAccountPreferencesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccountPreferencesOutputError>
}

public struct PutAccountPreferencesInput: Equatable {
    /// A preference indicating a choice to use 63bit/32bit IDs for all applicable resources.
    public let resourceIdType: ResourceIdType?

    public init (
        resourceIdType: ResourceIdType? = nil
    )
    {
        self.resourceIdType = resourceIdType
    }
}

struct PutAccountPreferencesInputBody: Equatable {
    public let resourceIdType: ResourceIdType?
}

extension PutAccountPreferencesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceIdType = "ResourceIdType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdTypeDecoded = try containerValues.decodeIfPresent(ResourceIdType.self, forKey: .resourceIdType)
        resourceIdType = resourceIdTypeDecoded
    }
}

extension PutAccountPreferencesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutAccountPreferencesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutAccountPreferencesOutputError: Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAccountPreferencesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAccountPreferencesOutputResponse(resourceIdPreference: \(String(describing: resourceIdPreference)))"}
}

extension PutAccountPreferencesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutAccountPreferencesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resourceIdPreference = output.resourceIdPreference
        } else {
            self.resourceIdPreference = nil
        }
    }
}

public struct PutAccountPreferencesOutputResponse: Equatable {
    public let resourceIdPreference: ResourceIdPreference?

    public init (
        resourceIdPreference: ResourceIdPreference? = nil
    )
    {
        self.resourceIdPreference = resourceIdPreference
    }
}

struct PutAccountPreferencesOutputResponseBody: Equatable {
    public let resourceIdPreference: ResourceIdPreference?
}

extension PutAccountPreferencesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceIdPreference = "ResourceIdPreference"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdPreferenceDecoded = try containerValues.decodeIfPresent(ResourceIdPreference.self, forKey: .resourceIdPreference)
        resourceIdPreference = resourceIdPreferenceDecoded
    }
}

public struct PutBackupPolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutBackupPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBackupPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBackupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBackupPolicyInput>
    public typealias MOutput = OperationOutput<PutBackupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBackupPolicyOutputError>
}

extension PutBackupPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBackupPolicyInput(backupPolicy: \(String(describing: backupPolicy)), fileSystemId: \(String(describing: fileSystemId)))"}
}

extension PutBackupPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupPolicy = "BackupPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupPolicy = backupPolicy {
            try encodeContainer.encode(backupPolicy, forKey: .backupPolicy)
        }
    }
}

public struct PutBackupPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutBackupPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBackupPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBackupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBackupPolicyInput>
    public typealias MOutput = OperationOutput<PutBackupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBackupPolicyOutputError>
}

public struct PutBackupPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutBackupPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBackupPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBackupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBackupPolicyInput>
    public typealias MOutput = OperationOutput<PutBackupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBackupPolicyOutputError>
}

public struct PutBackupPolicyInput: Equatable {
    /// <p>The backup policy included in the <code>PutBackupPolicy</code> request.</p>
    public let backupPolicy: BackupPolicy?
    /// <p>Specifies which EFS file system to update the backup policy for.</p>
    public let fileSystemId: String?

    public init (
        backupPolicy: BackupPolicy? = nil,
        fileSystemId: String? = nil
    )
    {
        self.backupPolicy = backupPolicy
        self.fileSystemId = fileSystemId
    }
}

struct PutBackupPolicyInputBody: Equatable {
    public let backupPolicy: BackupPolicy?
}

extension PutBackupPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupPolicy = "BackupPolicy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPolicyDecoded = try containerValues.decodeIfPresent(BackupPolicy.self, forKey: .backupPolicy)
        backupPolicy = backupPolicyDecoded
    }
}

extension PutBackupPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutBackupPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectFileSystemLifeCycleState" : self = .incorrectFileSystemLifeCycleState(try IncorrectFileSystemLifeCycleState(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutBackupPolicyOutputError: Equatable {
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case incorrectFileSystemLifeCycleState(IncorrectFileSystemLifeCycleState)
    case internalServerError(InternalServerError)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBackupPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBackupPolicyOutputResponse(backupPolicy: \(String(describing: backupPolicy)))"}
}

extension PutBackupPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutBackupPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backupPolicy = output.backupPolicy
        } else {
            self.backupPolicy = nil
        }
    }
}

public struct PutBackupPolicyOutputResponse: Equatable {
    /// <p>Describes the file system's backup policy, indicating whether automatic backups are turned on or off..</p>
    public let backupPolicy: BackupPolicy?

    public init (
        backupPolicy: BackupPolicy? = nil
    )
    {
        self.backupPolicy = backupPolicy
    }
}

struct PutBackupPolicyOutputResponseBody: Equatable {
    public let backupPolicy: BackupPolicy?
}

extension PutBackupPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupPolicy = "BackupPolicy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPolicyDecoded = try containerValues.decodeIfPresent(BackupPolicy.self, forKey: .backupPolicy)
        backupPolicy = backupPolicyDecoded
    }
}

public struct PutFileSystemPolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutFileSystemPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutFileSystemPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutFileSystemPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutFileSystemPolicyInput>
    public typealias MOutput = OperationOutput<PutFileSystemPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutFileSystemPolicyOutputError>
}

extension PutFileSystemPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutFileSystemPolicyInput(bypassPolicyLockoutSafetyCheck: \(String(describing: bypassPolicyLockoutSafetyCheck)), fileSystemId: \(String(describing: fileSystemId)), policy: \(String(describing: policy)))"}
}

extension PutFileSystemPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bypassPolicyLockoutSafetyCheck = "BypassPolicyLockoutSafetyCheck"
        case policy = "Policy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if bypassPolicyLockoutSafetyCheck != false {
            try encodeContainer.encode(bypassPolicyLockoutSafetyCheck, forKey: .bypassPolicyLockoutSafetyCheck)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

public struct PutFileSystemPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutFileSystemPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutFileSystemPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutFileSystemPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutFileSystemPolicyInput>
    public typealias MOutput = OperationOutput<PutFileSystemPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutFileSystemPolicyOutputError>
}

public struct PutFileSystemPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutFileSystemPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutFileSystemPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutFileSystemPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutFileSystemPolicyInput>
    public typealias MOutput = OperationOutput<PutFileSystemPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutFileSystemPolicyOutputError>
}

public struct PutFileSystemPolicyInput: Equatable {
    /// <p>(Optional) A flag to indicate whether to bypass the <code>FileSystemPolicy</code> lockout safety check. The policy lockout safety check
    ///       determines whether the policy in the request will prevent the principal making the request will be locked out from making future <code>PutFileSystemPolicy</code> requests on the file system.
    ///       Set <code>BypassPolicyLockoutSafetyCheck</code> to <code>True</code> only when you intend to prevent
    ///       the principal that is making the request from making a subsequent <code>PutFileSystemPolicy</code> request on the file system.
    ///       The default value is False.
    ///     </p>
    public let bypassPolicyLockoutSafetyCheck: Bool
    /// <p>The ID of the EFS file system that you want to create or update the <code>FileSystemPolicy</code> for.</p>
    public let fileSystemId: String?
    /// <p>The <code>FileSystemPolicy</code> that you're creating. Accepts a JSON formatted policy definition.
    ///      EFS file system policies have a 20,000 character limit.
    ///       To find out more about the elements that make up a file system policy, see
    ///       <a href="https://docs.aws.amazon.com/efs/latest/ug/access-control-overview.html#access-control-manage-access-intro-resource-policies">EFS Resource-based Policies</a>.
    ///     </p>
    public let policy: String?

    public init (
        bypassPolicyLockoutSafetyCheck: Bool = false,
        fileSystemId: String? = nil,
        policy: String? = nil
    )
    {
        self.bypassPolicyLockoutSafetyCheck = bypassPolicyLockoutSafetyCheck
        self.fileSystemId = fileSystemId
        self.policy = policy
    }
}

struct PutFileSystemPolicyInputBody: Equatable {
    public let policy: String?
    public let bypassPolicyLockoutSafetyCheck: Bool
}

extension PutFileSystemPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bypassPolicyLockoutSafetyCheck = "BypassPolicyLockoutSafetyCheck"
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
        let bypassPolicyLockoutSafetyCheckDecoded = try containerValues.decode(Bool.self, forKey: .bypassPolicyLockoutSafetyCheck)
        bypassPolicyLockoutSafetyCheck = bypassPolicyLockoutSafetyCheckDecoded
    }
}

extension PutFileSystemPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutFileSystemPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectFileSystemLifeCycleState" : self = .incorrectFileSystemLifeCycleState(try IncorrectFileSystemLifeCycleState(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPolicyException" : self = .invalidPolicyException(try InvalidPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutFileSystemPolicyOutputError: Equatable {
    case fileSystemNotFound(FileSystemNotFound)
    case incorrectFileSystemLifeCycleState(IncorrectFileSystemLifeCycleState)
    case internalServerError(InternalServerError)
    case invalidPolicyException(InvalidPolicyException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutFileSystemPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutFileSystemPolicyOutputResponse(fileSystemId: \(String(describing: fileSystemId)), policy: \(String(describing: policy)))"}
}

extension PutFileSystemPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutFileSystemPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fileSystemId = output.fileSystemId
            self.policy = output.policy
        } else {
            self.fileSystemId = nil
            self.policy = nil
        }
    }
}

public struct PutFileSystemPolicyOutputResponse: Equatable {
    /// <p>Specifies the EFS file system to which the <code>FileSystemPolicy</code> applies.</p>
    public let fileSystemId: String?
    /// <p>The JSON formatted <code>FileSystemPolicy</code> for the EFS file system.</p>
    public let policy: String?

    public init (
        fileSystemId: String? = nil,
        policy: String? = nil
    )
    {
        self.fileSystemId = fileSystemId
        self.policy = policy
    }
}

struct PutFileSystemPolicyOutputResponseBody: Equatable {
    public let fileSystemId: String?
    public let policy: String?
}

extension PutFileSystemPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileSystemId = "FileSystemId"
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

public struct PutLifecycleConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "PutLifecycleConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLifecycleConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLifecycleConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLifecycleConfigurationInput>
    public typealias MOutput = OperationOutput<PutLifecycleConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLifecycleConfigurationOutputError>
}

extension PutLifecycleConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutLifecycleConfigurationInput(fileSystemId: \(String(describing: fileSystemId)), lifecyclePolicies: \(String(describing: lifecyclePolicies)))"}
}

extension PutLifecycleConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lifecyclePolicies = "LifecyclePolicies"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lifecyclePolicies = lifecyclePolicies {
            var lifecyclePoliciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lifecyclePolicies)
            for lifecyclepolicies0 in lifecyclePolicies {
                try lifecyclePoliciesContainer.encode(lifecyclepolicies0)
            }
        }
    }
}

public struct PutLifecycleConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "PutLifecycleConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLifecycleConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLifecycleConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLifecycleConfigurationInput>
    public typealias MOutput = OperationOutput<PutLifecycleConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLifecycleConfigurationOutputError>
}

public struct PutLifecycleConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutLifecycleConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLifecycleConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLifecycleConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLifecycleConfigurationInput>
    public typealias MOutput = OperationOutput<PutLifecycleConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLifecycleConfigurationOutputError>
}

public struct PutLifecycleConfigurationInput: Equatable {
    /// <p>The ID of the file system for which you are creating the
    ///         <code>LifecycleConfiguration</code> object (String).</p>
    public let fileSystemId: String?
    /// <p>An array of <code>LifecyclePolicy</code> objects that define the file system's
    ///         <code>LifecycleConfiguration</code> object. A <code>LifecycleConfiguration</code> object
    ///       tells lifecycle management when to transition files from the Standard storage class to the
    ///       Infrequent Access storage class.</p>
    public let lifecyclePolicies: [LifecyclePolicy]?

    public init (
        fileSystemId: String? = nil,
        lifecyclePolicies: [LifecyclePolicy]? = nil
    )
    {
        self.fileSystemId = fileSystemId
        self.lifecyclePolicies = lifecyclePolicies
    }
}

struct PutLifecycleConfigurationInputBody: Equatable {
    public let lifecyclePolicies: [LifecyclePolicy]?
}

extension PutLifecycleConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lifecyclePolicies = "LifecyclePolicies"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecyclePoliciesContainer = try containerValues.decodeIfPresent([LifecyclePolicy?].self, forKey: .lifecyclePolicies)
        var lifecyclePoliciesDecoded0:[LifecyclePolicy]? = nil
        if let lifecyclePoliciesContainer = lifecyclePoliciesContainer {
            lifecyclePoliciesDecoded0 = [LifecyclePolicy]()
            for structure0 in lifecyclePoliciesContainer {
                if let structure0 = structure0 {
                    lifecyclePoliciesDecoded0?.append(structure0)
                }
            }
        }
        lifecyclePolicies = lifecyclePoliciesDecoded0
    }
}

extension PutLifecycleConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutLifecycleConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectFileSystemLifeCycleState" : self = .incorrectFileSystemLifeCycleState(try IncorrectFileSystemLifeCycleState(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutLifecycleConfigurationOutputError: Equatable {
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case incorrectFileSystemLifeCycleState(IncorrectFileSystemLifeCycleState)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutLifecycleConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutLifecycleConfigurationOutputResponse(lifecyclePolicies: \(String(describing: lifecyclePolicies)))"}
}

extension PutLifecycleConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutLifecycleConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lifecyclePolicies = output.lifecyclePolicies
        } else {
            self.lifecyclePolicies = nil
        }
    }
}

public struct PutLifecycleConfigurationOutputResponse: Equatable {
    /// <p>An array of lifecycle management policies. Currently, EFS supports a maximum of one
    ///       policy per file system.</p>
    public let lifecyclePolicies: [LifecyclePolicy]?

    public init (
        lifecyclePolicies: [LifecyclePolicy]? = nil
    )
    {
        self.lifecyclePolicies = lifecyclePolicies
    }
}

struct PutLifecycleConfigurationOutputResponseBody: Equatable {
    public let lifecyclePolicies: [LifecyclePolicy]?
}

extension PutLifecycleConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lifecyclePolicies = "LifecyclePolicies"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecyclePoliciesContainer = try containerValues.decodeIfPresent([LifecyclePolicy?].self, forKey: .lifecyclePolicies)
        var lifecyclePoliciesDecoded0:[LifecyclePolicy]? = nil
        if let lifecyclePoliciesContainer = lifecyclePoliciesContainer {
            lifecyclePoliciesDecoded0 = [LifecyclePolicy]()
            for structure0 in lifecyclePoliciesContainer {
                if let structure0 = structure0 {
                    lifecyclePoliciesDecoded0?.append(structure0)
                }
            }
        }
        lifecyclePolicies = lifecyclePoliciesDecoded0
    }
}

/// An EFS resource, for example a file system or a mount target.
public enum Resource {
    case filesystem
    case mounttarget
    case sdkUnknown(String)
}

extension Resource : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Resource] {
        return [
            .filesystem,
            .mounttarget,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .filesystem: return "FILE_SYSTEM"
        case .mounttarget: return "MOUNT_TARGET"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Resource(rawValue: rawValue) ?? Resource.sdkUnknown(rawValue)
    }
}

extension ResourceIdPreference: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceIdType = "ResourceIdType"
        case resources = "Resources"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceIdType = resourceIdType {
            try encodeContainer.encode(resourceIdType.rawValue, forKey: .resourceIdType)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resources0 in resources {
                try resourcesContainer.encode(resources0.rawValue)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdTypeDecoded = try containerValues.decodeIfPresent(ResourceIdType.self, forKey: .resourceIdType)
        resourceIdType = resourceIdTypeDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Resource?].self, forKey: .resources)
        var resourcesDecoded0:[Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Resource]()
            for string0 in resourcesContainer {
                if let string0 = string0 {
                    resourcesDecoded0?.append(string0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension ResourceIdPreference: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceIdPreference(resourceIdType: \(String(describing: resourceIdType)), resources: \(String(describing: resources)))"}
}

public struct ResourceIdPreference: Equatable {
    /// A preference indicating a choice to use 63bit/32bit IDs for all applicable resources.
    public let resourceIdType: ResourceIdType?
    /// EFS resources to which a preference applies to.
    public let resources: [Resource]?

    public init (
        resourceIdType: ResourceIdType? = nil,
        resources: [Resource]? = nil
    )
    {
        self.resourceIdType = resourceIdType
        self.resources = resources
    }
}

/// A preference indicating a choice to use 63bit/32bit IDs for all applicable resources.
public enum ResourceIdType {
    case longid
    case shortid
    case sdkUnknown(String)
}

extension ResourceIdType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceIdType] {
        return [
            .longid,
            .shortid,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .longid: return "LONG_ID"
        case .shortid: return "SHORT_ID"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceIdType(rawValue: rawValue) ?? ResourceIdType.sdkUnknown(rawValue)
    }
}

extension RootDirectory: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationInfo = "CreationInfo"
        case path = "Path"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationInfo = creationInfo {
            try encodeContainer.encode(creationInfo, forKey: .creationInfo)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let creationInfoDecoded = try containerValues.decodeIfPresent(CreationInfo.self, forKey: .creationInfo)
        creationInfo = creationInfoDecoded
    }
}

extension RootDirectory: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RootDirectory(creationInfo: \(String(describing: creationInfo)), path: \(String(describing: path)))"}
}

/// <p>Specifies the directory on the Amazon EFS file system that the access point provides access to.
///       The access point exposes the specified file system path as
///       the root directory of your file system to applications using the access point.
///       NFS clients using the access point can only access data in the access point's <code>RootDirectory</code> and it's subdirectories.</p>
public struct RootDirectory: Equatable {
    /// <p>(Optional) Specifies the POSIX IDs and permissions to apply to the access point's <code>RootDirectory</code>.
    ///       If the <code>RootDirectory</code> > <code>Path</code> specified does not exist,
    ///       EFS creates the root directory using the <code>CreationInfo</code> settings when a client connects to an access point.
    ///       When specifying the <code>CreationInfo</code>, you must provide values for all properties.
    ///     </p>
    ///          <important>
    ///             <p>If you do not provide <code>CreationInfo</code> and the specified <code>RootDirectory</code> > <code>Path</code> does not exist,
    ///       attempts to mount the file system using the access point will fail.</p>
    ///          </important>
    public let creationInfo: CreationInfo?
    /// <p>Specifies the path on the EFS file system to expose as the root directory to NFS clients using the access point to access the EFS file system.
    ///        A path can have up to four subdirectories.
    ///     If the specified path does not exist, you are required to provide the <code>CreationInfo</code>.</p>
    public let path: String?

    public init (
        creationInfo: CreationInfo? = nil,
        path: String? = nil
    )
    {
        self.creationInfo = creationInfo
        self.path = path
    }
}

extension SecurityGroupLimitExceeded: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SecurityGroupLimitExceeded(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension SecurityGroupLimitExceeded: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SecurityGroupLimitExceededBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if the size of <code>SecurityGroups</code> specified in the request is
///             greater than five.</p>
public struct SecurityGroupLimitExceeded: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var errorCode: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct SecurityGroupLimitExceededBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension SecurityGroupLimitExceededBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SecurityGroupNotFound: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SecurityGroupNotFound(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension SecurityGroupNotFound: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SecurityGroupNotFoundBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if one of the specified security groups doesn't exist in the subnet's
///             VPC.</p>
public struct SecurityGroupNotFound: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var errorCode: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct SecurityGroupNotFoundBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension SecurityGroupNotFoundBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum Status {
    case disabled
    case disabling
    case enabled
    case enabling
    case sdkUnknown(String)
}

extension Status : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Status] {
        return [
            .disabled,
            .disabling,
            .enabled,
            .enabling,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .disabling: return "DISABLING"
        case .enabled: return "ENABLED"
        case .enabling: return "ENABLING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
    }
}

extension SubnetNotFound: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubnetNotFound(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension SubnetNotFound: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SubnetNotFoundBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if there is no subnet with ID <code>SubnetId</code> provided in the
///             request.</p>
public struct SubnetNotFound: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var errorCode: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct SubnetNotFoundBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension SubnetNotFoundBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A tag is a key-value pair. Allowed characters are letters, white space, and numbers that
///       can be represented in UTF-8, and the following characters:<code> + - = . _ : /</code>.</p>
public struct Tag: Equatable {
    /// <p>The tag key (String). The key can't start with <code>aws:</code>.</p>
    public let key: String?
    /// <p>The value of the tag key.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceId: \(String(describing: resourceId)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The ID specifying the EFS resource that you want to create a tag for.</p>
    public let resourceId: String?
    /// <p>An array of <code>Tag</code> objects to add. Each <code>Tag</code> object is a key-value
    ///       pair.</p>
    public let tags: [Tag]?

    public init (
        resourceId: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceId = resourceId
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointNotFound" : self = .accessPointNotFound(try AccessPointNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case accessPointNotFound(AccessPointNotFound)
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ThroughputLimitExceeded: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThroughputLimitExceeded(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension ThroughputLimitExceeded: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThroughputLimitExceededBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if the throughput mode or amount of provisioned throughput can't be changed
///             because the throughput limit of 1024 MiB/s has been reached.</p>
public struct ThroughputLimitExceeded: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var errorCode: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct ThroughputLimitExceededBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension ThroughputLimitExceededBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ThroughputMode {
    case bursting
    case provisioned
    case sdkUnknown(String)
}

extension ThroughputMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ThroughputMode] {
        return [
            .bursting,
            .provisioned,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bursting: return "bursting"
        case .provisioned: return "provisioned"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ThroughputMode(rawValue: rawValue) ?? ThroughputMode.sdkUnknown(rawValue)
    }
}

extension TooManyRequests: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequests(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension TooManyRequests: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyRequestsBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if you don’t wait at least 24 hours before changing the throughput mode, or
///             decreasing the Provisioned Throughput value.</p>
public struct TooManyRequests: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var errorCode: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct TooManyRequestsBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension TooManyRequestsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum TransitionToIARules {
    case after14Days
    case after30Days
    case after60Days
    case after7Days
    case after90Days
    case sdkUnknown(String)
}

extension TransitionToIARules : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TransitionToIARules] {
        return [
            .after14Days,
            .after30Days,
            .after60Days,
            .after7Days,
            .after90Days,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .after14Days: return "AFTER_14_DAYS"
        case .after30Days: return "AFTER_30_DAYS"
        case .after60Days: return "AFTER_60_DAYS"
        case .after7Days: return "AFTER_7_DAYS"
        case .after90Days: return "AFTER_90_DAYS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TransitionToIARules(rawValue: rawValue) ?? TransitionToIARules.sdkUnknown(rawValue)
    }
}

extension UnsupportedAvailabilityZone: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedAvailabilityZone(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension UnsupportedAvailabilityZone: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedAvailabilityZoneBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if the requested Amazon EFS functionality is not available in the specified Availability Zone.</p>
public struct UnsupportedAvailabilityZone: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var errorCode: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct UnsupportedAvailabilityZoneBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension UnsupportedAvailabilityZoneBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceId: \(String(describing: resourceId)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>Specifies the EFS resource that you want to remove tags from.</p>
    public let resourceId: String?
    /// <p>The keys of the key-value tag pairs that you want to remove from the specified EFS
    ///       resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceId: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceId = resourceId
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessPointNotFound" : self = .accessPointNotFound(try AccessPointNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case accessPointNotFound(AccessPointNotFound)
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateFileSystemInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFileSystemInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFileSystemInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFileSystemInput>
    public typealias MOutput = OperationOutput<UpdateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFileSystemOutputError>
}

extension UpdateFileSystemInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFileSystemInput(fileSystemId: \(String(describing: fileSystemId)), provisionedThroughputInMibps: \(String(describing: provisionedThroughputInMibps)), throughputMode: \(String(describing: throughputMode)))"}
}

extension UpdateFileSystemInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case provisionedThroughputInMibps = "ProvisionedThroughputInMibps"
        case throughputMode = "ThroughputMode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let provisionedThroughputInMibps = provisionedThroughputInMibps {
            try encodeContainer.encode(provisionedThroughputInMibps, forKey: .provisionedThroughputInMibps)
        }
        if let throughputMode = throughputMode {
            try encodeContainer.encode(throughputMode.rawValue, forKey: .throughputMode)
        }
    }
}

public struct UpdateFileSystemInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFileSystemInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFileSystemInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFileSystemInput>
    public typealias MOutput = OperationOutput<UpdateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFileSystemOutputError>
}

public struct UpdateFileSystemInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFileSystemInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFileSystemInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFileSystemInput>
    public typealias MOutput = OperationOutput<UpdateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFileSystemOutputError>
}

public struct UpdateFileSystemInput: Equatable {
    /// <p>The ID of the file system that you want to update.</p>
    public let fileSystemId: String?
    /// <p>(Optional) Sets the amount of provisioned throughput, in MiB/s, for the file
    ///       system. Valid values are 1-1024. If you are changing the throughput mode to provisioned, you must also
    ///       provide the amount of provisioned throughput. Required if <code>ThroughputMode</code> is changed
    ///       to <code>provisioned</code> on update.</p>
    public let provisionedThroughputInMibps: Double?
    /// <p>(Optional) Updates the file system's throughput mode. If you're not
    ///       updating your throughput mode, you don't need to provide this value in your
    ///       request. If you are changing the <code>ThroughputMode</code> to <code>provisioned</code>,
    ///       you must also set a value for <code>ProvisionedThroughputInMibps</code>.</p>
    public let throughputMode: ThroughputMode?

    public init (
        fileSystemId: String? = nil,
        provisionedThroughputInMibps: Double? = nil,
        throughputMode: ThroughputMode? = nil
    )
    {
        self.fileSystemId = fileSystemId
        self.provisionedThroughputInMibps = provisionedThroughputInMibps
        self.throughputMode = throughputMode
    }
}

struct UpdateFileSystemInputBody: Equatable {
    public let throughputMode: ThroughputMode?
    public let provisionedThroughputInMibps: Double?
}

extension UpdateFileSystemInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case provisionedThroughputInMibps = "ProvisionedThroughputInMibps"
        case throughputMode = "ThroughputMode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let throughputModeDecoded = try containerValues.decodeIfPresent(ThroughputMode.self, forKey: .throughputMode)
        throughputMode = throughputModeDecoded
        let provisionedThroughputInMibpsDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .provisionedThroughputInMibps)
        provisionedThroughputInMibps = provisionedThroughputInMibpsDecoded
    }
}

extension UpdateFileSystemOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFileSystemOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectFileSystemLifeCycleState" : self = .incorrectFileSystemLifeCycleState(try IncorrectFileSystemLifeCycleState(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientThroughputCapacity" : self = .insufficientThroughputCapacity(try InsufficientThroughputCapacity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThroughputLimitExceeded" : self = .throughputLimitExceeded(try ThroughputLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequests" : self = .tooManyRequests(try TooManyRequests(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFileSystemOutputError: Equatable {
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case incorrectFileSystemLifeCycleState(IncorrectFileSystemLifeCycleState)
    case insufficientThroughputCapacity(InsufficientThroughputCapacity)
    case internalServerError(InternalServerError)
    case throughputLimitExceeded(ThroughputLimitExceeded)
    case tooManyRequests(TooManyRequests)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFileSystemOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFileSystemOutputResponse(availabilityZoneId: \(String(describing: availabilityZoneId)), availabilityZoneName: \(String(describing: availabilityZoneName)), creationTime: \(String(describing: creationTime)), creationToken: \(String(describing: creationToken)), encrypted: \(String(describing: encrypted)), fileSystemArn: \(String(describing: fileSystemArn)), fileSystemId: \(String(describing: fileSystemId)), kmsKeyId: \(String(describing: kmsKeyId)), lifeCycleState: \(String(describing: lifeCycleState)), name: \(String(describing: name)), numberOfMountTargets: \(String(describing: numberOfMountTargets)), ownerId: \(String(describing: ownerId)), performanceMode: \(String(describing: performanceMode)), provisionedThroughputInMibps: \(String(describing: provisionedThroughputInMibps)), sizeInBytes: \(String(describing: sizeInBytes)), tags: \(String(describing: tags)), throughputMode: \(String(describing: throughputMode)))"}
}

extension UpdateFileSystemOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateFileSystemOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.availabilityZoneId = output.availabilityZoneId
            self.availabilityZoneName = output.availabilityZoneName
            self.creationTime = output.creationTime
            self.creationToken = output.creationToken
            self.encrypted = output.encrypted
            self.fileSystemArn = output.fileSystemArn
            self.fileSystemId = output.fileSystemId
            self.kmsKeyId = output.kmsKeyId
            self.lifeCycleState = output.lifeCycleState
            self.name = output.name
            self.numberOfMountTargets = output.numberOfMountTargets
            self.ownerId = output.ownerId
            self.performanceMode = output.performanceMode
            self.provisionedThroughputInMibps = output.provisionedThroughputInMibps
            self.sizeInBytes = output.sizeInBytes
            self.tags = output.tags
            self.throughputMode = output.throughputMode
        } else {
            self.availabilityZoneId = nil
            self.availabilityZoneName = nil
            self.creationTime = nil
            self.creationToken = nil
            self.encrypted = nil
            self.fileSystemArn = nil
            self.fileSystemId = nil
            self.kmsKeyId = nil
            self.lifeCycleState = nil
            self.name = nil
            self.numberOfMountTargets = 0
            self.ownerId = nil
            self.performanceMode = nil
            self.provisionedThroughputInMibps = nil
            self.sizeInBytes = nil
            self.tags = nil
            self.throughputMode = nil
        }
    }
}

/// <p>A description of the file system.</p>
public struct UpdateFileSystemOutputResponse: Equatable {
    /// <p>The unique and consistent identifier of the Availability Zone in which the file system's
    ///       One Zone storage classes exist. For example, <code>use1-az1</code> is an Availability Zone ID
    ///       for the us-east-1 AWS Region, and it has the same location in every AWS account.</p>
    public let availabilityZoneId: String?
    /// <p>Describes the AWS Availability Zone in which the file system is located, and is valid only
    ///       for file systems using One Zone storage classes. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/storage-classes.html">Using EFS storage classes</a>
    ///       in the <i>Amazon EFS User Guide</i>.</p>
    public let availabilityZoneName: String?
    /// <p>The time that the file system was created, in seconds (since
    ///       1970-01-01T00:00:00Z).</p>
    public let creationTime: Date?
    /// <p>The opaque string specified in the request.</p>
    public let creationToken: String?
    /// <p>A Boolean value that, if true, indicates that the file system is encrypted.</p>
    public let encrypted: Bool?
    /// <p>The Amazon Resource Name (ARN) for the EFS file system, in the format
    ///       <code>arn:aws:elasticfilesystem:<i>region</i>:<i>account-id</i>:file-system/<i>file-system-id</i>
    ///             </code>.
    ///       Example with sample data: <code>arn:aws:elasticfilesystem:us-west-2:1111333322228888:file-system/fs-01234567</code>
    ///          </p>
    public let fileSystemArn: String?
    /// <p>The ID of the file system, assigned by Amazon EFS.</p>
    public let fileSystemId: String?
    /// <p>The ID of an AWS Key Management Service (AWS KMS) customer master key (CMK) that was
    ///       used to protect the encrypted file system.</p>
    public let kmsKeyId: String?
    /// <p>The lifecycle phase of the file system.</p>
    public let lifeCycleState: LifeCycleState?
    /// <p>You can add tags to a file system, including a <code>Name</code> tag. For more
    ///       information, see <a>CreateFileSystem</a>. If the file system has a <code>Name</code> tag, Amazon EFS returns
    ///       the value in this field. </p>
    public let name: String?
    /// <p>The current number of mount targets that the file system has. For more information, see <a>CreateMountTarget</a>.</p>
    public let numberOfMountTargets: Int
    /// <p>The AWS account that created the file system. If the file system was created by an IAM
    ///       user, the parent account to which the user belongs is the owner.</p>
    public let ownerId: String?
    /// <p>The performance mode of the file system.</p>
    public let performanceMode: PerformanceMode?
    /// <p>The amount of provisioned throughput, measured in MiB/s, for the file system. Valid for
    ///       file systems using <code>ThroughputMode</code> set to <code>provisioned</code>.</p>
    public let provisionedThroughputInMibps: Double?
    /// <p>The latest known metered size (in bytes) of data stored in the file system, in its
    ///         <code>Value</code> field, and the time at which that size was determined in its
    ///         <code>Timestamp</code> field. The <code>Timestamp</code> value is the integer number of
    ///       seconds since 1970-01-01T00:00:00Z. The <code>SizeInBytes</code> value doesn't represent
    ///       the size of a consistent snapshot of the file system, but it is eventually consistent when
    ///       there are no writes to the file system. That is, <code>SizeInBytes</code> represents actual
    ///       size only if the file system is not modified for a period longer than a couple of hours.
    ///       Otherwise, the value is not the exact size that the file system was at any point in time.
    ///     </p>
    public let sizeInBytes: FileSystemSize?
    /// <p>The tags associated with the file system, presented as an array of <code>Tag</code>
    ///       objects.</p>
    public let tags: [Tag]?
    /// <p>Displays the file system's throughput mode. For more information, see
    ///       <a href="https://docs.aws.amazon.com/efs/latest/ug/performance.html#throughput-modes">Throughput modes</a>
    ///       in the <i>Amazon EFS User Guide</i>.
    ///     </p>
    public let throughputMode: ThroughputMode?

    public init (
        availabilityZoneId: String? = nil,
        availabilityZoneName: String? = nil,
        creationTime: Date? = nil,
        creationToken: String? = nil,
        encrypted: Bool? = nil,
        fileSystemArn: String? = nil,
        fileSystemId: String? = nil,
        kmsKeyId: String? = nil,
        lifeCycleState: LifeCycleState? = nil,
        name: String? = nil,
        numberOfMountTargets: Int = 0,
        ownerId: String? = nil,
        performanceMode: PerformanceMode? = nil,
        provisionedThroughputInMibps: Double? = nil,
        sizeInBytes: FileSystemSize? = nil,
        tags: [Tag]? = nil,
        throughputMode: ThroughputMode? = nil
    )
    {
        self.availabilityZoneId = availabilityZoneId
        self.availabilityZoneName = availabilityZoneName
        self.creationTime = creationTime
        self.creationToken = creationToken
        self.encrypted = encrypted
        self.fileSystemArn = fileSystemArn
        self.fileSystemId = fileSystemId
        self.kmsKeyId = kmsKeyId
        self.lifeCycleState = lifeCycleState
        self.name = name
        self.numberOfMountTargets = numberOfMountTargets
        self.ownerId = ownerId
        self.performanceMode = performanceMode
        self.provisionedThroughputInMibps = provisionedThroughputInMibps
        self.sizeInBytes = sizeInBytes
        self.tags = tags
        self.throughputMode = throughputMode
    }
}

struct UpdateFileSystemOutputResponseBody: Equatable {
    public let ownerId: String?
    public let creationToken: String?
    public let fileSystemId: String?
    public let fileSystemArn: String?
    public let creationTime: Date?
    public let lifeCycleState: LifeCycleState?
    public let name: String?
    public let numberOfMountTargets: Int
    public let sizeInBytes: FileSystemSize?
    public let performanceMode: PerformanceMode?
    public let encrypted: Bool?
    public let kmsKeyId: String?
    public let throughputMode: ThroughputMode?
    public let provisionedThroughputInMibps: Double?
    public let availabilityZoneName: String?
    public let availabilityZoneId: String?
    public let tags: [Tag]?
}

extension UpdateFileSystemOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case availabilityZoneId = "AvailabilityZoneId"
        case availabilityZoneName = "AvailabilityZoneName"
        case creationTime = "CreationTime"
        case creationToken = "CreationToken"
        case encrypted = "Encrypted"
        case fileSystemArn = "FileSystemArn"
        case fileSystemId = "FileSystemId"
        case kmsKeyId = "KmsKeyId"
        case lifeCycleState = "LifeCycleState"
        case name = "Name"
        case numberOfMountTargets = "NumberOfMountTargets"
        case ownerId = "OwnerId"
        case performanceMode = "PerformanceMode"
        case provisionedThroughputInMibps = "ProvisionedThroughputInMibps"
        case sizeInBytes = "SizeInBytes"
        case tags = "Tags"
        case throughputMode = "ThroughputMode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let creationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationToken)
        creationToken = creationTokenDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let fileSystemArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemArn)
        fileSystemArn = fileSystemArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lifeCycleStateDecoded = try containerValues.decodeIfPresent(LifeCycleState.self, forKey: .lifeCycleState)
        lifeCycleState = lifeCycleStateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let numberOfMountTargetsDecoded = try containerValues.decode(Int.self, forKey: .numberOfMountTargets)
        numberOfMountTargets = numberOfMountTargetsDecoded
        let sizeInBytesDecoded = try containerValues.decodeIfPresent(FileSystemSize.self, forKey: .sizeInBytes)
        sizeInBytes = sizeInBytesDecoded
        let performanceModeDecoded = try containerValues.decodeIfPresent(PerformanceMode.self, forKey: .performanceMode)
        performanceMode = performanceModeDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let throughputModeDecoded = try containerValues.decodeIfPresent(ThroughputMode.self, forKey: .throughputMode)
        throughputMode = throughputModeDecoded
        let provisionedThroughputInMibpsDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .provisionedThroughputInMibps)
        provisionedThroughputInMibps = provisionedThroughputInMibpsDecoded
        let availabilityZoneNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZoneName)
        availabilityZoneName = availabilityZoneNameDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if the AWS Backup service is not available in the Region in which the request was made.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var errorCode: String?
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
