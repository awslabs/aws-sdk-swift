// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation

public class EfsClient {
    let client: SdkHttpClient
    let config: EfsClientConfiguration
    let serviceName = "EFS"
    let encoder: RequestEncoder
    let decoder: ResponseDecoder

    public init(config: EfsClientConfiguration) {
        client = SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        self.encoder = config.encoder ?? encoder
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public class EfsClientConfiguration: ClientRuntime.Configuration, AWSClientConfiguration {

        public var region: String
        public var credentialsProvider: AWSCredentialsProvider
        public var signingRegion: String
        public var endpointResolver: EndpointResolver

        public init (
            credentialsProvider: AWSCredentialsProvider,
            endpointResolver: EndpointResolver,
            region: String,
            signingRegion: String
        ) throws
        {
            self.credentialsProvider = credentialsProvider
            self.endpointResolver = endpointResolver
            self.region = region
            self.signingRegion = signingRegion
        }

        public convenience init(credentialsProvider: AWSCredentialsProvider) throws {
            let region = "us-east-1"
            let signingRegion = "us-east-1"
            let endpointResolver = DefaultEndpointResolver()
            try self.init(
                credentialsProvider: credentialsProvider,
                endpointResolver: endpointResolver,
                region: region,
                signingRegion: signingRegion
            )
        }

        public static func `default`() throws -> EfsClientConfiguration {
            let awsCredsProvider = try AWSCredentialsProvider.fromEnv()
            return try EfsClientConfiguration(credentialsProvider: awsCredsProvider)
        }
    }
}

extension EfsClient: EfsClientProtocol {
    /// <p>Creates an EFS access point. An access point is an application-specific view into an EFS
    ///       file system that applies an operating system user and group, and a file system path, to any
    ///       file system request made through the access point. The operating system user and group
    ///       override any identity information provided by the NFS client. The file system path is exposed
    ///       as the access point's root directory. Applications using the access point can only access data
    ///       in its own directory and below. To learn more, see <a href="https://docs.aws.amazon.com/efs/latest/ug/efs-access-points.html">Mounting a file system using EFS access
    ///         points</a>.</p>
    ///          <p>This operation requires permissions for the <code>elasticfilesystem:CreateAccessPoint</code> action.</p>
    public func createAccessPoint(input: CreateAccessPointInput, completion: @escaping (SdkResult<CreateAccessPointOutput, CreateAccessPointOutputError>) -> Void)
    {
        let urlPath = "/2015-02-01/access-points"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createAccessPoint")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elasticfilesystem.\(config.region).amazonaws.com")
                      .withSigningName(value: "elasticfilesystem")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateAccessPointInput, CreateAccessPointOutput, CreateAccessPointOutputError>(id: "createAccessPoint")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreateAccessPointOutput>, SdkError<CreateAccessPointOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateAccessPointInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateAccessPointInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateAccessPointInput, CreateAccessPointOutput, CreateAccessPointOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateAccessPointInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new, empty file system. The operation requires a creation token in the
    ///       request that Amazon EFS uses to ensure idempotent creation (calling the operation with same
    ///       creation token has no effect). If a file system does not currently exist that is owned by the
    ///       caller's AWS account with the specified creation token, this operation does the
    ///       following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Creates a new, empty file system. The file system will have an Amazon EFS assigned
    ///           ID, and an initial lifecycle state <code>creating</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>Returns with the description of the created file system.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Otherwise, this operation returns a <code>FileSystemAlreadyExists</code> error with the
    ///       ID of the existing file system.</p>
    ///          <note>
    ///             <p>For basic use cases, you can use a randomly generated UUID for the creation
    ///         token.</p>
    ///          </note>
    ///          <p> The idempotent operation allows you to retry a <code>CreateFileSystem</code> call without
    ///       risk of creating an extra file system. This can happen when an initial call fails in a way
    ///       that leaves it uncertain whether or not a file system was actually created. An example might
    ///       be that a transport level timeout occurred or your connection was reset. As long as you use
    ///       the same creation token, if the initial call had succeeded in creating a file system, the
    ///       client can learn of its existence from the <code>FileSystemAlreadyExists</code> error.</p>
    ///          <p>For more information, see
    ///       <a href="https://docs.aws.amazon.com/efs/latest/ug/creating-using-create-fs.html#creating-using-create-fs-part1">Creating a file system</a>
    ///      in the <i>Amazon EFS User Guide</i>.</p>
    ///
    ///          <note>
    ///             <p>The <code>CreateFileSystem</code> call returns while the file system's lifecycle
    ///         state is still <code>creating</code>. You can check the file system creation status by
    ///         calling the <a>DescribeFileSystems</a> operation, which among other things returns the file
    ///         system state.</p>
    ///          </note>
    ///
    ///          <p>This operation accepts an optional <code>PerformanceMode</code> parameter that you
    ///       choose for your file system. We recommend <code>generalPurpose</code> performance mode for
    ///       most file systems. File systems using the <code>maxIO</code> performance mode can scale to
    ///       higher levels of aggregate throughput and operations per second with a tradeoff of slightly
    ///       higher latencies for most file operations. The performance mode can't be changed after
    ///       the file system has been created. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/performance.html#performancemodes.html">Amazon EFS performance
    ///         modes</a>.</p>
    ///
    ///          <p>You can set the throughput mode for the file system using the <code>ThroughputMode</code> parameter.</p>
    ///
    ///          <p>After the file system is fully created, Amazon EFS sets its lifecycle state to
    ///         <code>available</code>, at which point you can create one or more mount targets for the file
    ///       system in your VPC. For more information, see <a>CreateMountTarget</a>. You mount your Amazon EFS file system on an EC2 instances in
    ///       your VPC by using the mount target. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/how-it-works.html">Amazon EFS: How it Works</a>. </p>
    ///
    ///          <p> This operation requires permissions for the
    ///         <code>elasticfilesystem:CreateFileSystem</code> action. </p>
    public func createFileSystem(input: CreateFileSystemInput, completion: @escaping (SdkResult<CreateFileSystemOutput, CreateFileSystemOutputError>) -> Void)
    {
        let urlPath = "/2015-02-01/file-systems"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createFileSystem")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elasticfilesystem.\(config.region).amazonaws.com")
                      .withSigningName(value: "elasticfilesystem")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateFileSystemInput, CreateFileSystemOutput, CreateFileSystemOutputError>(id: "createFileSystem")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreateFileSystemOutput>, SdkError<CreateFileSystemOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.creationToken == nil {
                copiedInput.creationToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateFileSystemInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateFileSystemInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateFileSystemInput, CreateFileSystemOutput, CreateFileSystemOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateFileSystemInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a mount target for a file system. You can then mount the file system on EC2
    ///       instances by using the mount target.</p>
    ///          <p>You can create one mount target in each Availability Zone in your VPC. All EC2
    ///       instances in a VPC within a given Availability Zone share a single mount target for a given
    ///       file system. If you have multiple subnets in an Availability Zone, you create a mount target
    ///       in one of the subnets. EC2 instances do not need to be in the same subnet as the mount target
    ///       in order to access their file system.</p>
    ///          <p>You can create only one mount target for an EFS file system using One Zone storage
    ///       classes. You must create that mount target in the same Availability Zone in which the file
    ///       system is located. Use the <code>AvailabilityZoneName</code> and
    ///         <code>AvailabiltyZoneId</code> properties in the <a>DescribeFileSystems</a>
    ///       response object to get this information. Use the <code>subnetId</code> associated with the
    ///       file system's Availability Zone when creating the mount target.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/how-it-works.html">Amazon EFS: How it Works</a>. </p>
    ///          <p>To create a mount target for a file system, the file system's lifecycle state must be
    ///         <code>available</code>. For more information, see <a>DescribeFileSystems</a>.</p>
    ///          <p>In the request, provide the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>The file system ID for which you are creating the mount
    ///         target.</p>
    ///             </li>
    ///             <li>
    ///                <p>A subnet ID, which determines the following:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>The VPC in which Amazon EFS creates the mount target</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>The Availability Zone in which Amazon EFS creates the mount target</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>The IP address range from which Amazon EFS selects the IP address of the mount target
    ///               (if you don't specify an IP address in the request)</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>After creating the mount target, Amazon EFS returns a response that includes, a
    ///         <code>MountTargetId</code> and an <code>IpAddress</code>. You use this IP address when
    ///       mounting the file system in an EC2 instance. You can also use the mount target's DNS name
    ///       when mounting the file system. The EC2 instance on which you mount the file system by using
    ///       the mount target can resolve the mount target's DNS name to its IP address. For more
    ///       information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/how-it-works.html#how-it-works-implementation">How it Works:
    ///         Implementation Overview</a>. </p>
    ///          <p>Note that you can create mount targets for a file system in only one VPC, and there can
    ///       be only one mount target per Availability Zone. That is, if the file system already has one or
    ///       more mount targets created for it, the subnet specified in the request to add another mount
    ///       target must meet the following requirements:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must belong to the same VPC as the subnets of the existing mount targets</p>
    ///             </li>
    ///             <li>
    ///                <p>Must not be in the same Availability Zone as any of the subnets of the existing
    ///           mount targets</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>If the request satisfies the requirements, Amazon EFS does the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Creates a new mount target in the specified subnet.</p>
    ///             </li>
    ///             <li>
    ///                <p>Also creates a new network interface in the subnet as follows:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>If the request provides an <code>IpAddress</code>, Amazon EFS assigns that IP
    ///               address to the network interface. Otherwise, Amazon EFS assigns a free address in the
    ///               subnet (in the same way that the Amazon EC2 <code>CreateNetworkInterface</code> call
    ///               does when a request does not specify a primary private IP address).</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>If the request provides <code>SecurityGroups</code>, this network interface is
    ///               associated with those security groups. Otherwise, it belongs to the default security
    ///               group for the subnet's VPC.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Assigns the description <code>Mount target <i>fsmt-id</i> for
    ///                 file system <i>fs-id</i>
    ///                         </code> where <code>
    ///                            <i>fsmt-id</i>
    ///                         </code> is the mount target ID, and <code>
    ///                            <i>fs-id</i>
    ///                         </code> is the <code>FileSystemId</code>.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Sets the <code>requesterManaged</code> property of the network interface to
    ///                 <code>true</code>, and the <code>requesterId</code> value to
    ///               <code>EFS</code>.</p>
    ///                   </li>
    ///                </ul>
    ///                <p>Each Amazon EFS mount target has one corresponding requester-managed EC2 network
    ///           interface. After the network interface is created, Amazon EFS sets the
    ///             <code>NetworkInterfaceId</code> field in the mount target's description to the
    ///           network interface ID, and the <code>IpAddress</code> field to its address. If network
    ///           interface creation fails, the entire <code>CreateMountTarget</code> operation
    ///           fails.</p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>The <code>CreateMountTarget</code> call returns only after creating the network
    ///         interface, but while the mount target state is still <code>creating</code>, you can check
    ///         the mount target creation status by calling the <a>DescribeMountTargets</a> operation, which among other things returns the mount
    ///         target state.</p>
    ///          </note>
    ///          <p>We recommend that you create a mount target in each of the Availability Zones. There
    ///       are cost considerations for using a file system in an Availability Zone through a mount target
    ///       created in another Availability Zone. For more information, see <a href="http://aws.amazon.com/efs/">Amazon EFS</a>. In addition, by always using a mount target local to the
    ///       instance's Availability Zone, you eliminate a partial failure scenario. If the
    ///       Availability Zone in which your mount target is created goes down, then you can't access
    ///       your file system through that mount target. </p>
    ///          <p>This operation requires permissions for the following action on the file
    ///       system:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>elasticfilesystem:CreateMountTarget</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>This operation also requires permissions for the following Amazon EC2
    ///       actions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ec2:DescribeSubnets</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ec2:DescribeNetworkInterfaces</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ec2:CreateNetworkInterface</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public func createMountTarget(input: CreateMountTargetInput, completion: @escaping (SdkResult<CreateMountTargetOutput, CreateMountTargetOutputError>) -> Void)
    {
        let urlPath = "/2015-02-01/mount-targets"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createMountTarget")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elasticfilesystem.\(config.region).amazonaws.com")
                      .withSigningName(value: "elasticfilesystem")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateMountTargetInput, CreateMountTargetOutput, CreateMountTargetOutputError>(id: "createMountTarget")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateMountTargetInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateMountTargetInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateMountTargetInput, CreateMountTargetOutput, CreateMountTargetOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateMountTargetInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <note>
    ///             <p>DEPRECATED - CreateTags is deprecated and not maintained. Please use the
    ///        API action to create tags for EFS resources.</p>
    ///          </note>
    ///          <p>Creates or overwrites tags associated with a file system. Each tag is a key-value pair. If
    ///       a tag key specified in the request already exists on the file system, this operation
    ///       overwrites its value with the value provided in the request. If you add the <code>Name</code>
    ///       tag to your file system, Amazon EFS returns it in the response to the <a>DescribeFileSystems</a> operation. </p>
    ///          <p>This operation requires permission for the <code>elasticfilesystem:CreateTags</code>
    ///       action.</p>
    @available(*, deprecated, message: "Use TagResource.")
    public func createTags(input: CreateTagsInput, completion: @escaping (SdkResult<CreateTagsOutput, CreateTagsOutputError>) -> Void)
    {
        guard let fileSystemId = input.fileSystemId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component fileSystemId unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-02-01/create-tags/\(fileSystemId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createTags")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elasticfilesystem.\(config.region).amazonaws.com")
                      .withSigningName(value: "elasticfilesystem")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateTagsInput, CreateTagsOutput, CreateTagsOutputError>(id: "createTags")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateTagsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateTagsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateTagsInput, CreateTagsOutput, CreateTagsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateTagsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified access point. After deletion is complete, new clients can no
    ///       longer connect to the access points. Clients connected to the access point at the time of
    ///       deletion will continue to function until they terminate their connection.</p>
    ///          <p>This operation requires permissions for the <code>elasticfilesystem:DeleteAccessPoint</code> action.</p>
    public func deleteAccessPoint(input: DeleteAccessPointInput, completion: @escaping (SdkResult<DeleteAccessPointOutput, DeleteAccessPointOutputError>) -> Void)
    {
        guard let accessPointId = input.accessPointId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component accessPointId unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-02-01/access-points/\(accessPointId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteAccessPoint")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elasticfilesystem.\(config.region).amazonaws.com")
                      .withSigningName(value: "elasticfilesystem")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteAccessPointInput, DeleteAccessPointOutput, DeleteAccessPointOutputError>(id: "deleteAccessPoint")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteAccessPointInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteAccessPointInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteAccessPointInput, DeleteAccessPointOutput, DeleteAccessPointOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a file system, permanently severing access to its contents. Upon return, the
    ///       file system no longer exists and you can't access any contents of the deleted file
    ///       system.</p>
    ///          <p> You can't delete a file system that is in use. That is, if the file system has
    ///       any mount targets, you must first delete them. For more information, see <a>DescribeMountTargets</a> and <a>DeleteMountTarget</a>. </p>
    ///
    ///          <note>
    ///             <p>The <code>DeleteFileSystem</code> call returns while the file system state is still
    ///           <code>deleting</code>. You can check the file system deletion status by calling the <a>DescribeFileSystems</a> operation, which returns a list of file systems in your
    ///         account. If you pass file system ID or creation token for the deleted file system, the <a>DescribeFileSystems</a> returns a <code>404 FileSystemNotFound</code>
    ///         error.</p>
    ///          </note>
    ///
    ///          <p>This operation requires permissions for the
    ///         <code>elasticfilesystem:DeleteFileSystem</code> action.</p>
    public func deleteFileSystem(input: DeleteFileSystemInput, completion: @escaping (SdkResult<DeleteFileSystemOutput, DeleteFileSystemOutputError>) -> Void)
    {
        guard let fileSystemId = input.fileSystemId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component fileSystemId unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-02-01/file-systems/\(fileSystemId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteFileSystem")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elasticfilesystem.\(config.region).amazonaws.com")
                      .withSigningName(value: "elasticfilesystem")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteFileSystemInput, DeleteFileSystemOutput, DeleteFileSystemOutputError>(id: "deleteFileSystem")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteFileSystemInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteFileSystemInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteFileSystemInput, DeleteFileSystemOutput, DeleteFileSystemOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the <code>FileSystemPolicy</code> for the specified file system.
    ///       The default <code>FileSystemPolicy</code> goes into effect once the existing policy is deleted.
    ///       For more information about the default file system policy, see <a href="https://docs.aws.amazon.com/efs/latest/ug/res-based-policies-efs.html">Using Resource-based Policies with EFS</a>.</p>
    ///          <p>This operation requires permissions for the <code>elasticfilesystem:DeleteFileSystemPolicy</code> action.</p>
    public func deleteFileSystemPolicy(input: DeleteFileSystemPolicyInput, completion: @escaping (SdkResult<DeleteFileSystemPolicyOutput, DeleteFileSystemPolicyOutputError>) -> Void)
    {
        guard let fileSystemId = input.fileSystemId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component fileSystemId unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-02-01/file-systems/\(fileSystemId)/policy"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteFileSystemPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elasticfilesystem.\(config.region).amazonaws.com")
                      .withSigningName(value: "elasticfilesystem")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteFileSystemPolicyInput, DeleteFileSystemPolicyOutput, DeleteFileSystemPolicyOutputError>(id: "deleteFileSystemPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteFileSystemPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteFileSystemPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteFileSystemPolicyInput, DeleteFileSystemPolicyOutput, DeleteFileSystemPolicyOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified mount target.</p>
    ///
    ///          <p>This operation forcibly breaks any mounts of the file system by using the mount target
    ///       that is being deleted, which might disrupt instances or applications using those mounts. To
    ///       avoid applications getting cut off abruptly, you might consider unmounting any mounts of the
    ///       mount target, if feasible. The operation also deletes the associated network interface.
    ///       Uncommitted writes might be lost, but breaking a mount target using this operation does not
    ///       corrupt the file system itself. The file system you created remains. You can mount an EC2
    ///       instance in your VPC by using another mount target.</p>
    ///          <p>This operation requires permissions for the following action on the file
    ///       system:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>elasticfilesystem:DeleteMountTarget</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///
    ///          <note>
    ///             <p>The <code>DeleteMountTarget</code> call returns while the mount target state is still
    ///           <code>deleting</code>. You can check the mount target deletion by calling the <a>DescribeMountTargets</a> operation, which returns a list of mount target
    ///         descriptions for the given file system. </p>
    ///          </note>
    ///
    ///          <p>The operation also requires permissions for the following Amazon EC2 action on the
    ///       mount target's network interface:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ec2:DeleteNetworkInterface</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public func deleteMountTarget(input: DeleteMountTargetInput, completion: @escaping (SdkResult<DeleteMountTargetOutput, DeleteMountTargetOutputError>) -> Void)
    {
        guard let mountTargetId = input.mountTargetId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component mountTargetId unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-02-01/mount-targets/\(mountTargetId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteMountTarget")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elasticfilesystem.\(config.region).amazonaws.com")
                      .withSigningName(value: "elasticfilesystem")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteMountTargetInput, DeleteMountTargetOutput, DeleteMountTargetOutputError>(id: "deleteMountTarget")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteMountTargetInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteMountTargetInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteMountTargetInput, DeleteMountTargetOutput, DeleteMountTargetOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <note>
    ///             <p>DEPRECATED - DeleteTags is deprecated and not maintained. Please use the
    ///        API action to remove tags from EFS resources.</p>
    ///          </note>
    ///          <p>Deletes the specified tags from a file system. If the <code>DeleteTags</code> request
    ///       includes a tag key that doesn't exist, Amazon EFS ignores it and doesn't cause an
    ///       error. For more information about tags and related restrictions, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html">Tag Restrictions</a> in the
    ///         <i>AWS Billing and Cost Management User Guide</i>.</p>
    ///
    ///          <p>This operation requires permissions for the <code>elasticfilesystem:DeleteTags</code>
    ///       action.</p>
    @available(*, deprecated, message: "Use UntagResource.")
    public func deleteTags(input: DeleteTagsInput, completion: @escaping (SdkResult<DeleteTagsOutput, DeleteTagsOutputError>) -> Void)
    {
        guard let fileSystemId = input.fileSystemId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component fileSystemId unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-02-01/delete-tags/\(fileSystemId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteTags")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elasticfilesystem.\(config.region).amazonaws.com")
                      .withSigningName(value: "elasticfilesystem")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteTagsInput, DeleteTagsOutput, DeleteTagsOutputError>(id: "deleteTags")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteTagsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteTagsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteTagsInput, DeleteTagsOutput, DeleteTagsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteTagsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the description of a specific Amazon EFS access point if the <code>AccessPointId</code> is provided.
    ///       If you provide an EFS <code>FileSystemId</code>, it returns descriptions of all access points for that file system.
    ///       You can provide either an <code>AccessPointId</code> or a <code>FileSystemId</code> in the request, but not both. </p>
    ///          <p>This operation requires permissions for the <code>elasticfilesystem:DescribeAccessPoints</code> action.</p>
    public func describeAccessPoints(input: DescribeAccessPointsInput, completion: @escaping (SdkResult<DescribeAccessPointsOutput, DescribeAccessPointsOutputError>) -> Void)
    {
        let urlPath = "/2015-02-01/access-points"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeAccessPoints")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elasticfilesystem.\(config.region).amazonaws.com")
                      .withSigningName(value: "elasticfilesystem")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeAccessPointsInput, DescribeAccessPointsOutput, DescribeAccessPointsOutputError>(id: "describeAccessPoints")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeAccessPointsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeAccessPointsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeAccessPointsInput, DescribeAccessPointsOutput, DescribeAccessPointsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    public func describeAccountPreferences(input: DescribeAccountPreferencesInput, completion: @escaping (SdkResult<DescribeAccountPreferencesOutput, DescribeAccountPreferencesOutputError>) -> Void)
    {
        let urlPath = "/2015-02-01/account-preferences"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeAccountPreferences")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elasticfilesystem.\(config.region).amazonaws.com")
                      .withSigningName(value: "elasticfilesystem")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeAccountPreferencesInput, DescribeAccountPreferencesOutput, DescribeAccountPreferencesOutputError>(id: "describeAccountPreferences")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeAccountPreferencesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeAccountPreferencesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeAccountPreferencesInput, DescribeAccountPreferencesOutput, DescribeAccountPreferencesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeAccountPreferencesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the backup policy for the specified EFS file system.</p>
    public func describeBackupPolicy(input: DescribeBackupPolicyInput, completion: @escaping (SdkResult<DescribeBackupPolicyOutput, DescribeBackupPolicyOutputError>) -> Void)
    {
        guard let fileSystemId = input.fileSystemId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component fileSystemId unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-02-01/file-systems/\(fileSystemId)/backup-policy"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeBackupPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elasticfilesystem.\(config.region).amazonaws.com")
                      .withSigningName(value: "elasticfilesystem")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeBackupPolicyInput, DescribeBackupPolicyOutput, DescribeBackupPolicyOutputError>(id: "describeBackupPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeBackupPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeBackupPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeBackupPolicyInput, DescribeBackupPolicyOutput, DescribeBackupPolicyOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the <code>FileSystemPolicy</code> for the specified EFS file system.</p>
    ///          <p>This operation requires permissions for the <code>elasticfilesystem:DescribeFileSystemPolicy</code> action.</p>
    public func describeFileSystemPolicy(input: DescribeFileSystemPolicyInput, completion: @escaping (SdkResult<DescribeFileSystemPolicyOutput, DescribeFileSystemPolicyOutputError>) -> Void)
    {
        guard let fileSystemId = input.fileSystemId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component fileSystemId unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-02-01/file-systems/\(fileSystemId)/policy"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeFileSystemPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elasticfilesystem.\(config.region).amazonaws.com")
                      .withSigningName(value: "elasticfilesystem")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeFileSystemPolicyInput, DescribeFileSystemPolicyOutput, DescribeFileSystemPolicyOutputError>(id: "describeFileSystemPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeFileSystemPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeFileSystemPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeFileSystemPolicyInput, DescribeFileSystemPolicyOutput, DescribeFileSystemPolicyOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the description of a specific Amazon EFS file system if either the file system
    ///         <code>CreationToken</code> or the <code>FileSystemId</code> is provided. Otherwise, it
    ///       returns descriptions of all file systems owned by the caller's AWS account in the AWS
    ///       Region of the endpoint that you're calling.</p>
    ///
    ///          <p>When retrieving all file system descriptions, you can optionally specify the
    ///         <code>MaxItems</code> parameter to limit the number of descriptions in a response.
    ///       Currently, this number is automatically set to 10. If more file system descriptions remain,
    ///       Amazon EFS returns a <code>NextMarker</code>, an opaque token, in the response. In this case,
    ///       you should send a subsequent request with the <code>Marker</code> request parameter set to the
    ///       value of <code>NextMarker</code>. </p>
    ///
    ///          <p>To retrieve a list of your file system descriptions, this operation is used in an
    ///       iterative process, where <code>DescribeFileSystems</code> is called first without the
    ///         <code>Marker</code> and then the operation continues to call it with the <code>Marker</code>
    ///       parameter set to the value of the <code>NextMarker</code> from the previous response until the
    ///       response has no <code>NextMarker</code>. </p>
    ///
    ///          <p> The order of file systems returned in the response of one
    ///         <code>DescribeFileSystems</code> call and the order of file systems returned across the
    ///       responses of a multi-call iteration is unspecified. </p>
    ///          <p> This operation requires permissions for the
    ///         <code>elasticfilesystem:DescribeFileSystems</code> action. </p>
    public func describeFileSystems(input: DescribeFileSystemsInput, completion: @escaping (SdkResult<DescribeFileSystemsOutput, DescribeFileSystemsOutputError>) -> Void)
    {
        let urlPath = "/2015-02-01/file-systems"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeFileSystems")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elasticfilesystem.\(config.region).amazonaws.com")
                      .withSigningName(value: "elasticfilesystem")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeFileSystemsInput, DescribeFileSystemsOutput, DescribeFileSystemsOutputError>(id: "describeFileSystems")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeFileSystemsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeFileSystemsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeFileSystemsInput, DescribeFileSystemsOutput, DescribeFileSystemsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the current <code>LifecycleConfiguration</code> object for the specified Amazon
    ///       EFS file system. EFS lifecycle management uses the <code>LifecycleConfiguration</code> object
    ///       to identify which files to move to the EFS Infrequent Access (IA) storage class. For a file system
    ///       without a <code>LifecycleConfiguration</code> object, the call returns an empty array in the
    ///       response.</p>
    ///          <p>This operation requires permissions for the
    ///         <code>elasticfilesystem:DescribeLifecycleConfiguration</code> operation.</p>
    public func describeLifecycleConfiguration(input: DescribeLifecycleConfigurationInput, completion: @escaping (SdkResult<DescribeLifecycleConfigurationOutput, DescribeLifecycleConfigurationOutputError>) -> Void)
    {
        guard let fileSystemId = input.fileSystemId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component fileSystemId unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-02-01/file-systems/\(fileSystemId)/lifecycle-configuration"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeLifecycleConfiguration")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elasticfilesystem.\(config.region).amazonaws.com")
                      .withSigningName(value: "elasticfilesystem")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeLifecycleConfigurationInput, DescribeLifecycleConfigurationOutput, DescribeLifecycleConfigurationOutputError>(id: "describeLifecycleConfiguration")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeLifecycleConfigurationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeLifecycleConfigurationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeLifecycleConfigurationInput, DescribeLifecycleConfigurationOutput, DescribeLifecycleConfigurationOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the security groups currently in effect for a mount target. This operation
    ///       requires that the network interface of the mount target has been created and the lifecycle
    ///       state of the mount target is not <code>deleted</code>.</p>
    ///          <p>This operation requires permissions for the following actions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>elasticfilesystem:DescribeMountTargetSecurityGroups</code> action on the mount
    ///           target's file system. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ec2:DescribeNetworkInterfaceAttribute</code> action on the mount target's
    ///           network interface. </p>
    ///             </li>
    ///          </ul>
    public func describeMountTargetSecurityGroups(input: DescribeMountTargetSecurityGroupsInput, completion: @escaping (SdkResult<DescribeMountTargetSecurityGroupsOutput, DescribeMountTargetSecurityGroupsOutputError>) -> Void)
    {
        guard let mountTargetId = input.mountTargetId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component mountTargetId unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-02-01/mount-targets/\(mountTargetId)/security-groups"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeMountTargetSecurityGroups")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elasticfilesystem.\(config.region).amazonaws.com")
                      .withSigningName(value: "elasticfilesystem")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeMountTargetSecurityGroupsInput, DescribeMountTargetSecurityGroupsOutput, DescribeMountTargetSecurityGroupsOutputError>(id: "describeMountTargetSecurityGroups")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeMountTargetSecurityGroupsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeMountTargetSecurityGroupsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeMountTargetSecurityGroupsInput, DescribeMountTargetSecurityGroupsOutput, DescribeMountTargetSecurityGroupsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the descriptions of all the current mount targets, or a specific mount target,
    ///       for a file system. When requesting all of the current mount targets, the order of mount
    ///       targets returned in the response is unspecified.</p>
    ///
    ///          <p>This operation requires permissions for the
    ///         <code>elasticfilesystem:DescribeMountTargets</code> action, on either the file system ID
    ///       that you specify in <code>FileSystemId</code>, or on the file system of the mount target that
    ///       you specify in <code>MountTargetId</code>.</p>
    public func describeMountTargets(input: DescribeMountTargetsInput, completion: @escaping (SdkResult<DescribeMountTargetsOutput, DescribeMountTargetsOutputError>) -> Void)
    {
        let urlPath = "/2015-02-01/mount-targets"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeMountTargets")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elasticfilesystem.\(config.region).amazonaws.com")
                      .withSigningName(value: "elasticfilesystem")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeMountTargetsInput, DescribeMountTargetsOutput, DescribeMountTargetsOutputError>(id: "describeMountTargets")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeMountTargetsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeMountTargetsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeMountTargetsInput, DescribeMountTargetsOutput, DescribeMountTargetsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <note>
    ///             <p>DEPRECATED - The DeleteTags action is deprecated and not maintained. Please use the
    ///          API action to remove tags from EFS resources.</p>
    ///          </note>
    ///          <p>Returns the tags associated with a file system. The order of tags returned in the
    ///       response of one <code>DescribeTags</code> call and the order of tags returned across the
    ///       responses of a multiple-call iteration (when using pagination) is unspecified. </p>
    ///          <p> This operation requires permissions for the
    ///         <code>elasticfilesystem:DescribeTags</code> action. </p>
    @available(*, deprecated, message: "Use ListTagsForResource.")
    public func describeTags(input: DescribeTagsInput, completion: @escaping (SdkResult<DescribeTagsOutput, DescribeTagsOutputError>) -> Void)
    {
        guard let fileSystemId = input.fileSystemId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component fileSystemId unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-02-01/tags/\(fileSystemId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeTags")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elasticfilesystem.\(config.region).amazonaws.com")
                      .withSigningName(value: "elasticfilesystem")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeTagsInput, DescribeTagsOutput, DescribeTagsOutputError>(id: "describeTags")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeTagsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeTagsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeTagsInput, DescribeTagsOutput, DescribeTagsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists all tags for a top-level EFS resource. You must provide the ID of the resource that you want to retrieve the tags for.</p>
    ///          <p>This operation requires permissions for the <code>elasticfilesystem:DescribeAccessPoints</code> action.</p>
    public func listTagsForResource(input: ListTagsForResourceInput, completion: @escaping (SdkResult<ListTagsForResourceOutput, ListTagsForResourceOutputError>) -> Void)
    {
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-02-01/resource-tags/\(resourceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTagsForResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elasticfilesystem.\(config.region).amazonaws.com")
                      .withSigningName(value: "elasticfilesystem")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTagsForResourceInput, ListTagsForResourceOutput, ListTagsForResourceOutputError>(id: "listTagsForResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTagsForResourceInput, ListTagsForResourceOutput, ListTagsForResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Modifies the set of security groups in effect for a mount target.</p>
    ///          <p>When you create a mount target, Amazon EFS also creates a new network interface. For
    ///       more information, see <a>CreateMountTarget</a>. This operation replaces the security groups in effect for the
    ///       network interface associated with a mount target, with the <code>SecurityGroups</code>
    ///       provided in the request. This operation requires that the network interface of the mount
    ///       target has been created and the lifecycle state of the mount target is not
    ///         <code>deleted</code>. </p>
    ///          <p>The operation requires permissions for the following actions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>elasticfilesystem:ModifyMountTargetSecurityGroups</code> action on the mount
    ///           target's file system. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ec2:ModifyNetworkInterfaceAttribute</code> action on the mount target's network
    ///           interface. </p>
    ///             </li>
    ///          </ul>
    public func modifyMountTargetSecurityGroups(input: ModifyMountTargetSecurityGroupsInput, completion: @escaping (SdkResult<ModifyMountTargetSecurityGroupsOutput, ModifyMountTargetSecurityGroupsOutputError>) -> Void)
    {
        guard let mountTargetId = input.mountTargetId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component mountTargetId unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-02-01/mount-targets/\(mountTargetId)/security-groups"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "modifyMountTargetSecurityGroups")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elasticfilesystem.\(config.region).amazonaws.com")
                      .withSigningName(value: "elasticfilesystem")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ModifyMountTargetSecurityGroupsInput, ModifyMountTargetSecurityGroupsOutput, ModifyMountTargetSecurityGroupsOutputError>(id: "modifyMountTargetSecurityGroups")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ModifyMountTargetSecurityGroupsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ModifyMountTargetSecurityGroupsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ModifyMountTargetSecurityGroupsInput, ModifyMountTargetSecurityGroupsOutput, ModifyMountTargetSecurityGroupsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ModifyMountTargetSecurityGroupsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    public func putAccountPreferences(input: PutAccountPreferencesInput, completion: @escaping (SdkResult<PutAccountPreferencesOutput, PutAccountPreferencesOutputError>) -> Void)
    {
        let urlPath = "/2015-02-01/account-preferences"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putAccountPreferences")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elasticfilesystem.\(config.region).amazonaws.com")
                      .withSigningName(value: "elasticfilesystem")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutAccountPreferencesInput, PutAccountPreferencesOutput, PutAccountPreferencesOutputError>(id: "putAccountPreferences")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutAccountPreferencesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutAccountPreferencesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutAccountPreferencesInput, PutAccountPreferencesOutput, PutAccountPreferencesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutAccountPreferencesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the file system's backup policy. Use this action to start or stop automatic backups of the file system. </p>
    public func putBackupPolicy(input: PutBackupPolicyInput, completion: @escaping (SdkResult<PutBackupPolicyOutput, PutBackupPolicyOutputError>) -> Void)
    {
        guard let fileSystemId = input.fileSystemId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component fileSystemId unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-02-01/file-systems/\(fileSystemId)/backup-policy"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putBackupPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elasticfilesystem.\(config.region).amazonaws.com")
                      .withSigningName(value: "elasticfilesystem")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutBackupPolicyInput, PutBackupPolicyOutput, PutBackupPolicyOutputError>(id: "putBackupPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutBackupPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutBackupPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutBackupPolicyInput, PutBackupPolicyOutput, PutBackupPolicyOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutBackupPolicyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Applies an Amazon EFS <code>FileSystemPolicy</code> to an Amazon EFS file system.
    ///       A file system policy is an IAM resource-based policy and can contain multiple policy statements.
    ///       A file system always has exactly one file system policy, which can be the default policy or
    ///       an explicit policy set or updated using this API operation.
    ///       EFS file system policies have a 20,000 character limit.
    ///       When an explicit policy is set, it overrides the default policy. For more information about the default file system policy, see
    ///       <a href="https://docs.aws.amazon.com/efs/latest/ug/iam-access-control-nfs-efs.html#default-filesystempolicy">Default EFS File System Policy</a>.
    ///     </p>
    ///          <p>EFS file system policies have a 20,000 character limit.</p>
    ///          <p>This operation requires permissions for the <code>elasticfilesystem:PutFileSystemPolicy</code> action.</p>
    public func putFileSystemPolicy(input: PutFileSystemPolicyInput, completion: @escaping (SdkResult<PutFileSystemPolicyOutput, PutFileSystemPolicyOutputError>) -> Void)
    {
        guard let fileSystemId = input.fileSystemId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component fileSystemId unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-02-01/file-systems/\(fileSystemId)/policy"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putFileSystemPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elasticfilesystem.\(config.region).amazonaws.com")
                      .withSigningName(value: "elasticfilesystem")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutFileSystemPolicyInput, PutFileSystemPolicyOutput, PutFileSystemPolicyOutputError>(id: "putFileSystemPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutFileSystemPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutFileSystemPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutFileSystemPolicyInput, PutFileSystemPolicyOutput, PutFileSystemPolicyOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutFileSystemPolicyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Enables lifecycle management by creating a new <code>LifecycleConfiguration</code>
    ///       object. A <code>LifecycleConfiguration</code> object defines when files in an Amazon EFS file
    ///       system are automatically transitioned to the lower-cost EFS Infrequent Access (IA) storage class.
    ///       A <code>LifecycleConfiguration</code> applies to all files in a file system.</p>
    ///          <p>Each Amazon EFS file system supports one lifecycle configuration, which applies to all files in the file system. If a
    ///         <code>LifecycleConfiguration</code> object already exists for the specified file system, a
    ///         <code>PutLifecycleConfiguration</code> call modifies the existing configuration. A
    ///         <code>PutLifecycleConfiguration</code> call with an empty <code>LifecyclePolicies</code>
    ///       array in the request body deletes any existing <code>LifecycleConfiguration</code> and
    ///       disables lifecycle management.</p>
    ///
    ///
    ///          <p>In the request, specify the following: </p>
    ///          <ul>
    ///             <li>
    ///                <p>The ID for the file system for which you are enabling, disabling, or modifying lifecycle management.</p>
    ///             </li>
    ///             <li>
    ///                <p>A <code>LifecyclePolicies</code> array of <code>LifecyclePolicy</code> objects that
    ///           define when files are moved to the IA storage class. The array can contain only one
    ///             <code>LifecyclePolicy</code> item.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>This operation requires permissions for the
    ///         <code>elasticfilesystem:PutLifecycleConfiguration</code> operation.</p>
    ///          <p>To apply a <code>LifecycleConfiguration</code> object to an encrypted file system, you
    ///       need the same AWS Key Management Service (AWS KMS) permissions as when you created the encrypted
    ///       file system. </p>
    public func putLifecycleConfiguration(input: PutLifecycleConfigurationInput, completion: @escaping (SdkResult<PutLifecycleConfigurationOutput, PutLifecycleConfigurationOutputError>) -> Void)
    {
        guard let fileSystemId = input.fileSystemId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component fileSystemId unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-02-01/file-systems/\(fileSystemId)/lifecycle-configuration"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putLifecycleConfiguration")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elasticfilesystem.\(config.region).amazonaws.com")
                      .withSigningName(value: "elasticfilesystem")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutLifecycleConfigurationInput, PutLifecycleConfigurationOutput, PutLifecycleConfigurationOutputError>(id: "putLifecycleConfiguration")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutLifecycleConfigurationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutLifecycleConfigurationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutLifecycleConfigurationInput, PutLifecycleConfigurationOutput, PutLifecycleConfigurationOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutLifecycleConfigurationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a tag for an EFS resource. You can create tags for EFS file systems and access points using this API operation.</p>
    ///          <p>This operation requires permissions for the <code>elasticfilesystem:TagResource</code> action.</p>
    public func tagResource(input: TagResourceInput, completion: @escaping (SdkResult<TagResourceOutput, TagResourceOutputError>) -> Void)
    {
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-02-01/resource-tags/\(resourceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "tagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elasticfilesystem.\(config.region).amazonaws.com")
                      .withSigningName(value: "elasticfilesystem")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TagResourceInput, TagResourceOutput, TagResourceOutputError>(id: "tagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TagResourceInput, TagResourceOutput, TagResourceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes tags from an EFS resource. You can remove tags from EFS file systems and access points using this API operation.</p>
    ///          <p>This operation requires permissions for the <code>elasticfilesystem:UntagResource</code> action.</p>
    public func untagResource(input: UntagResourceInput, completion: @escaping (SdkResult<UntagResourceOutput, UntagResourceOutputError>) -> Void)
    {
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-02-01/resource-tags/\(resourceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "untagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elasticfilesystem.\(config.region).amazonaws.com")
                      .withSigningName(value: "elasticfilesystem")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UntagResourceInput, UntagResourceOutput, UntagResourceOutputError>(id: "untagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UntagResourceInput, UntagResourceOutput, UntagResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the throughput mode or the amount of provisioned throughput of an existing file
    ///       system.</p>
    public func updateFileSystem(input: UpdateFileSystemInput, completion: @escaping (SdkResult<UpdateFileSystemOutput, UpdateFileSystemOutputError>) -> Void)
    {
        guard let fileSystemId = input.fileSystemId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component fileSystemId unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-02-01/file-systems/\(fileSystemId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateFileSystem")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elasticfilesystem.\(config.region).amazonaws.com")
                      .withSigningName(value: "elasticfilesystem")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateFileSystemInput, UpdateFileSystemOutput, UpdateFileSystemOutputError>(id: "updateFileSystem")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateFileSystemInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateFileSystemInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateFileSystemInput, UpdateFileSystemOutput, UpdateFileSystemOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateFileSystemInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
