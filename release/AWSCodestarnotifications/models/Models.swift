// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// AWS CodeStar Notifications can't create the notification rule because you do not have sufficient permissions.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConcurrentModificationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// AWS CodeStar Notifications can't complete the request because the resource is being modified by another process. Wait a few minutes and try again.
public struct ConcurrentModificationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConfigurationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Some or all of the configuration is incomplete, missing, or not valid.
public struct ConfigurationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConfigurationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateNotificationRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case detailType = "DetailType"
        case eventTypeIds = "EventTypeIds"
        case name = "Name"
        case resource = "Resource"
        case status = "Status"
        case tags = "Tags"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let detailType = detailType {
            try encodeContainer.encode(detailType.rawValue, forKey: .detailType)
        }
        if let eventTypeIds = eventTypeIds {
            var eventTypeIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventTypeIds)
            for eventtypeids0 in eventTypeIds {
                try eventTypeIdsContainer.encode(eventtypeids0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }
}

extension CreateNotificationRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createNotificationRule"
    }
}

public struct CreateNotificationRuleInput: Swift.Equatable {
    /// A unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request with the same parameters is received and a token is included, the request returns information about the initial request that used that token. The AWS SDKs prepopulate client request tokens. If you are using an AWS SDK, an idempotency token is created for you.
    public var clientRequestToken: Swift.String?
    /// The level of detail to include in the notifications for this resource. BASIC will include only the contents of the event as it would appear in AWS CloudWatch. FULL will include any supplemental information provided by AWS CodeStar Notifications and/or the service for the resource for which the notification is created.
    /// This member is required.
    public var detailType: CodestarNotificationsClientTypes.DetailType?
    /// A list of event types associated with this notification rule. For a list of allowed events, see [EventTypeSummary].
    /// This member is required.
    public var eventTypeIds: [Swift.String]?
    /// The name for the notification rule. Notifictaion rule names must be unique in your AWS account.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource to associate with the notification rule. Supported resources include pipelines in AWS CodePipeline, repositories in AWS CodeCommit, and build projects in AWS CodeBuild.
    /// This member is required.
    public var resource: Swift.String?
    /// The status of the notification rule. The default value is ENABLED. If the status is set to DISABLED, notifications aren't sent for the notification rule.
    public var status: CodestarNotificationsClientTypes.NotificationRuleStatus?
    /// A list of tags to apply to this notification rule. Key names cannot start with "aws".
    public var tags: [Swift.String:Swift.String]?
    /// A list of Amazon Resource Names (ARNs) of SNS topics to associate with the notification rule.
    /// This member is required.
    public var targets: [CodestarNotificationsClientTypes.Target]?

    public init (
        clientRequestToken: Swift.String? = nil,
        detailType: CodestarNotificationsClientTypes.DetailType? = nil,
        eventTypeIds: [Swift.String]? = nil,
        name: Swift.String? = nil,
        resource: Swift.String? = nil,
        status: CodestarNotificationsClientTypes.NotificationRuleStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targets: [CodestarNotificationsClientTypes.Target]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.detailType = detailType
        self.eventTypeIds = eventTypeIds
        self.name = name
        self.resource = resource
        self.status = status
        self.tags = tags
        self.targets = targets
    }
}

struct CreateNotificationRuleInputBody: Swift.Equatable {
    let name: Swift.String?
    let eventTypeIds: [Swift.String]?
    let resource: Swift.String?
    let targets: [CodestarNotificationsClientTypes.Target]?
    let detailType: CodestarNotificationsClientTypes.DetailType?
    let clientRequestToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let status: CodestarNotificationsClientTypes.NotificationRuleStatus?
}

extension CreateNotificationRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case detailType = "DetailType"
        case eventTypeIds = "EventTypeIds"
        case name = "Name"
        case resource = "Resource"
        case status = "Status"
        case tags = "Tags"
        case targets = "Targets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let eventTypeIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventTypeIds)
        var eventTypeIdsDecoded0:[Swift.String]? = nil
        if let eventTypeIdsContainer = eventTypeIdsContainer {
            eventTypeIdsDecoded0 = [Swift.String]()
            for string0 in eventTypeIdsContainer {
                if let string0 = string0 {
                    eventTypeIdsDecoded0?.append(string0)
                }
            }
        }
        eventTypeIds = eventTypeIdsDecoded0
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let targetsContainer = try containerValues.decodeIfPresent([CodestarNotificationsClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[CodestarNotificationsClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [CodestarNotificationsClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let detailTypeDecoded = try containerValues.decodeIfPresent(CodestarNotificationsClientTypes.DetailType.self, forKey: .detailType)
        detailType = detailTypeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(CodestarNotificationsClientTypes.NotificationRuleStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CreateNotificationRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateNotificationRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConfigurationException" : self = .configurationException(try ConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateNotificationRuleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case concurrentModificationException(ConcurrentModificationException)
    case configurationException(ConfigurationException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateNotificationRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateNotificationRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct CreateNotificationRuleOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the notification rule.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct CreateNotificationRuleOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
}

extension CreateNotificationRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteNotificationRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeleteNotificationRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteNotificationRule"
    }
}

public struct DeleteNotificationRuleInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the notification rule you want to delete.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteNotificationRuleInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteNotificationRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteNotificationRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNotificationRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteNotificationRuleOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case limitExceededException(LimitExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNotificationRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteNotificationRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct DeleteNotificationRuleOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deleted notification rule.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteNotificationRuleOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteNotificationRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteTargetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forceUnsubscribeAll = "ForceUnsubscribeAll"
        case targetAddress = "TargetAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if forceUnsubscribeAll != false {
            try encodeContainer.encode(forceUnsubscribeAll, forKey: .forceUnsubscribeAll)
        }
        if let targetAddress = targetAddress {
            try encodeContainer.encode(targetAddress, forKey: .targetAddress)
        }
    }
}

extension DeleteTargetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteTarget"
    }
}

public struct DeleteTargetInput: Swift.Equatable {
    /// A Boolean value that can be used to delete all associations with this SNS topic. The default value is FALSE. If set to TRUE, all associations between that target and every notification rule in your AWS account are deleted.
    public var forceUnsubscribeAll: Swift.Bool
    /// The Amazon Resource Name (ARN) of the SNS topic to delete.
    /// This member is required.
    public var targetAddress: Swift.String?

    public init (
        forceUnsubscribeAll: Swift.Bool = false,
        targetAddress: Swift.String? = nil
    )
    {
        self.forceUnsubscribeAll = forceUnsubscribeAll
        self.targetAddress = targetAddress
    }
}

struct DeleteTargetInputBody: Swift.Equatable {
    let targetAddress: Swift.String?
    let forceUnsubscribeAll: Swift.Bool
}

extension DeleteTargetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forceUnsubscribeAll = "ForceUnsubscribeAll"
        case targetAddress = "TargetAddress"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetAddress)
        targetAddress = targetAddressDecoded
        let forceUnsubscribeAllDecoded = try containerValues.decode(Swift.Bool.self, forKey: .forceUnsubscribeAll)
        forceUnsubscribeAll = forceUnsubscribeAllDecoded
    }
}

extension DeleteTargetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTargetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTargetOutputError: Swift.Error, Swift.Equatable {
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTargetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTargetOutputResponse: Swift.Equatable {

}

extension DescribeNotificationRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DescribeNotificationRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeNotificationRule"
    }
}

public struct DescribeNotificationRuleInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the notification rule.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DescribeNotificationRuleInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DescribeNotificationRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DescribeNotificationRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeNotificationRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeNotificationRuleOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeNotificationRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeNotificationRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdBy = output.createdBy
            self.createdTimestamp = output.createdTimestamp
            self.detailType = output.detailType
            self.eventTypes = output.eventTypes
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
            self.name = output.name
            self.resource = output.resource
            self.status = output.status
            self.tags = output.tags
            self.targets = output.targets
        } else {
            self.arn = nil
            self.createdBy = nil
            self.createdTimestamp = nil
            self.detailType = nil
            self.eventTypes = nil
            self.lastModifiedTimestamp = nil
            self.name = nil
            self.resource = nil
            self.status = nil
            self.tags = nil
            self.targets = nil
        }
    }
}

public struct DescribeNotificationRuleOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the notification rule.
    /// This member is required.
    public var arn: Swift.String?
    /// The name or email alias of the person who created the notification rule.
    public var createdBy: Swift.String?
    /// The date and time the notification rule was created, in timestamp format.
    public var createdTimestamp: ClientRuntime.Date?
    /// The level of detail included in the notifications for this resource. BASIC will include only the contents of the event as it would appear in AWS CloudWatch. FULL will include any supplemental information provided by AWS CodeStar Notifications and/or the service for the resource for which the notification is created.
    public var detailType: CodestarNotificationsClientTypes.DetailType?
    /// A list of the event types associated with the notification rule.
    public var eventTypes: [CodestarNotificationsClientTypes.EventTypeSummary]?
    /// The date and time the notification rule was most recently updated, in timestamp format.
    public var lastModifiedTimestamp: ClientRuntime.Date?
    /// The name of the notification rule.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource associated with the notification rule.
    public var resource: Swift.String?
    /// The status of the notification rule. Valid statuses are on (sending notifications) or off (not sending notifications).
    public var status: CodestarNotificationsClientTypes.NotificationRuleStatus?
    /// The tags associated with the notification rule.
    public var tags: [Swift.String:Swift.String]?
    /// A list of the SNS topics associated with the notification rule.
    public var targets: [CodestarNotificationsClientTypes.TargetSummary]?

    public init (
        arn: Swift.String? = nil,
        createdBy: Swift.String? = nil,
        createdTimestamp: ClientRuntime.Date? = nil,
        detailType: CodestarNotificationsClientTypes.DetailType? = nil,
        eventTypes: [CodestarNotificationsClientTypes.EventTypeSummary]? = nil,
        lastModifiedTimestamp: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        resource: Swift.String? = nil,
        status: CodestarNotificationsClientTypes.NotificationRuleStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targets: [CodestarNotificationsClientTypes.TargetSummary]? = nil
    )
    {
        self.arn = arn
        self.createdBy = createdBy
        self.createdTimestamp = createdTimestamp
        self.detailType = detailType
        self.eventTypes = eventTypes
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.name = name
        self.resource = resource
        self.status = status
        self.tags = tags
        self.targets = targets
    }
}

struct DescribeNotificationRuleOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let eventTypes: [CodestarNotificationsClientTypes.EventTypeSummary]?
    let resource: Swift.String?
    let targets: [CodestarNotificationsClientTypes.TargetSummary]?
    let detailType: CodestarNotificationsClientTypes.DetailType?
    let createdBy: Swift.String?
    let status: CodestarNotificationsClientTypes.NotificationRuleStatus?
    let createdTimestamp: ClientRuntime.Date?
    let lastModifiedTimestamp: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeNotificationRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdBy = "CreatedBy"
        case createdTimestamp = "CreatedTimestamp"
        case detailType = "DetailType"
        case eventTypes = "EventTypes"
        case lastModifiedTimestamp = "LastModifiedTimestamp"
        case name = "Name"
        case resource = "Resource"
        case status = "Status"
        case tags = "Tags"
        case targets = "Targets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let eventTypesContainer = try containerValues.decodeIfPresent([CodestarNotificationsClientTypes.EventTypeSummary?].self, forKey: .eventTypes)
        var eventTypesDecoded0:[CodestarNotificationsClientTypes.EventTypeSummary]? = nil
        if let eventTypesContainer = eventTypesContainer {
            eventTypesDecoded0 = [CodestarNotificationsClientTypes.EventTypeSummary]()
            for structure0 in eventTypesContainer {
                if let structure0 = structure0 {
                    eventTypesDecoded0?.append(structure0)
                }
            }
        }
        eventTypes = eventTypesDecoded0
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let targetsContainer = try containerValues.decodeIfPresent([CodestarNotificationsClientTypes.TargetSummary?].self, forKey: .targets)
        var targetsDecoded0:[CodestarNotificationsClientTypes.TargetSummary]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [CodestarNotificationsClientTypes.TargetSummary]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let detailTypeDecoded = try containerValues.decodeIfPresent(CodestarNotificationsClientTypes.DetailType.self, forKey: .detailType)
        detailType = detailTypeDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodestarNotificationsClientTypes.NotificationRuleStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CodestarNotificationsClientTypes {
    public enum DetailType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case basic
        case full
        case sdkUnknown(Swift.String)

        public static var allCases: [DetailType] {
            return [
                .basic,
                .full,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .basic: return "BASIC"
            case .full: return "FULL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DetailType(rawValue: rawValue) ?? DetailType.sdkUnknown(rawValue)
        }
    }
}

extension CodestarNotificationsClientTypes.EventTypeSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTypeId = "EventTypeId"
        case eventTypeName = "EventTypeName"
        case resourceType = "ResourceType"
        case serviceName = "ServiceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventTypeId = eventTypeId {
            try encodeContainer.encode(eventTypeId, forKey: .eventTypeId)
        }
        if let eventTypeName = eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeId)
        eventTypeId = eventTypeIdDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CodestarNotificationsClientTypes {
    /// Returns information about an event that has triggered a notification rule.
    public struct EventTypeSummary: Swift.Equatable {
        /// The system-generated ID of the event.
        public var eventTypeId: Swift.String?
        /// The name of the event.
        public var eventTypeName: Swift.String?
        /// The resource type of the event.
        public var resourceType: Swift.String?
        /// The name of the service for which the event applies.
        public var serviceName: Swift.String?

        public init (
            eventTypeId: Swift.String? = nil,
            eventTypeName: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            serviceName: Swift.String? = nil
        )
        {
            self.eventTypeId = eventTypeId
            self.eventTypeName = eventTypeName
            self.resourceType = resourceType
            self.serviceName = serviceName
        }
    }

}

extension InvalidNextTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The value for the enumeration token used in the request to return the next batch of the results is not valid.
public struct InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One of the AWS CodeStar Notifications limits has been exceeded. Limits apply to accounts, notification rules, notifications, resources, and targets. For more information, see Limits.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodestarNotificationsClientTypes.ListEventTypesFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(CodestarNotificationsClientTypes.ListEventTypesFilterName.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CodestarNotificationsClientTypes {
    /// Information about a filter to apply to the list of returned event types. You can filter by resource type or service name.
    public struct ListEventTypesFilter: Swift.Equatable {
        /// The system-generated name of the filter type you want to filter by.
        /// This member is required.
        public var name: CodestarNotificationsClientTypes.ListEventTypesFilterName?
        /// The name of the resource type (for example, pipeline) or service name (for example, CodePipeline) that you want to filter by.
        /// This member is required.
        public var value: Swift.String?

        public init (
            name: CodestarNotificationsClientTypes.ListEventTypesFilterName? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension CodestarNotificationsClientTypes {
    public enum ListEventTypesFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case resourceType
        case serviceName
        case sdkUnknown(Swift.String)

        public static var allCases: [ListEventTypesFilterName] {
            return [
                .resourceType,
                .serviceName,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .resourceType: return "RESOURCE_TYPE"
            case .serviceName: return "SERVICE_NAME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ListEventTypesFilterName(rawValue: rawValue) ?? ListEventTypesFilterName.sdkUnknown(rawValue)
        }
    }
}

extension ListEventTypesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for listeventtypesfilters0 in filters {
                try filtersContainer.encode(listeventtypesfilters0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListEventTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listEventTypes"
    }
}

public struct ListEventTypesInput: Swift.Equatable {
    /// The filters to use to return information by service or resource type.
    public var filters: [CodestarNotificationsClientTypes.ListEventTypesFilter]?
    /// A non-negative integer used to limit the number of returned results. The default number is 50. The maximum number of results that can be returned is 100.
    public var maxResults: Swift.Int
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?

    public init (
        filters: [CodestarNotificationsClientTypes.ListEventTypesFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEventTypesInputBody: Swift.Equatable {
    let filters: [CodestarNotificationsClientTypes.ListEventTypesFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension ListEventTypesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([CodestarNotificationsClientTypes.ListEventTypesFilter?].self, forKey: .filters)
        var filtersDecoded0:[CodestarNotificationsClientTypes.ListEventTypesFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [CodestarNotificationsClientTypes.ListEventTypesFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEventTypesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEventTypesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEventTypesOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEventTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEventTypesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventTypes = output.eventTypes
            self.nextToken = output.nextToken
        } else {
            self.eventTypes = nil
            self.nextToken = nil
        }
    }
}

public struct ListEventTypesOutputResponse: Swift.Equatable {
    /// Information about each event, including service name, resource type, event ID, and event name.
    public var eventTypes: [CodestarNotificationsClientTypes.EventTypeSummary]?
    /// An enumeration token that can be used in a request to return the next batch of the results.
    public var nextToken: Swift.String?

    public init (
        eventTypes: [CodestarNotificationsClientTypes.EventTypeSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventTypes = eventTypes
        self.nextToken = nextToken
    }
}

struct ListEventTypesOutputResponseBody: Swift.Equatable {
    let eventTypes: [CodestarNotificationsClientTypes.EventTypeSummary]?
    let nextToken: Swift.String?
}

extension ListEventTypesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTypes = "EventTypes"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypesContainer = try containerValues.decodeIfPresent([CodestarNotificationsClientTypes.EventTypeSummary?].self, forKey: .eventTypes)
        var eventTypesDecoded0:[CodestarNotificationsClientTypes.EventTypeSummary]? = nil
        if let eventTypesContainer = eventTypesContainer {
            eventTypesDecoded0 = [CodestarNotificationsClientTypes.EventTypeSummary]()
            for structure0 in eventTypesContainer {
                if let structure0 = structure0 {
                    eventTypesDecoded0?.append(structure0)
                }
            }
        }
        eventTypes = eventTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CodestarNotificationsClientTypes.ListNotificationRulesFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(CodestarNotificationsClientTypes.ListNotificationRulesFilterName.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CodestarNotificationsClientTypes {
    /// Information about a filter to apply to the list of returned notification rules. You can filter by event type, owner, resource, or target.
    public struct ListNotificationRulesFilter: Swift.Equatable {
        /// The name of the attribute you want to use to filter the returned notification rules.
        /// This member is required.
        public var name: CodestarNotificationsClientTypes.ListNotificationRulesFilterName?
        /// The value of the attribute you want to use to filter the returned notification rules. For example, if you specify filtering by RESOURCE in Name, you might specify the ARN of a pipeline in AWS CodePipeline for the value.
        /// This member is required.
        public var value: Swift.String?

        public init (
            name: CodestarNotificationsClientTypes.ListNotificationRulesFilterName? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension CodestarNotificationsClientTypes {
    public enum ListNotificationRulesFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createdBy
        case eventTypeId
        case resource
        case targetAddress
        case sdkUnknown(Swift.String)

        public static var allCases: [ListNotificationRulesFilterName] {
            return [
                .createdBy,
                .eventTypeId,
                .resource,
                .targetAddress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createdBy: return "CREATED_BY"
            case .eventTypeId: return "EVENT_TYPE_ID"
            case .resource: return "RESOURCE"
            case .targetAddress: return "TARGET_ADDRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ListNotificationRulesFilterName(rawValue: rawValue) ?? ListNotificationRulesFilterName.sdkUnknown(rawValue)
        }
    }
}

extension ListNotificationRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for listnotificationrulesfilters0 in filters {
                try filtersContainer.encode(listnotificationrulesfilters0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListNotificationRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listNotificationRules"
    }
}

public struct ListNotificationRulesInput: Swift.Equatable {
    /// The filters to use to return information by service or resource type. For valid values, see [ListNotificationRulesFilter]. A filter with the same name can appear more than once when used with OR statements. Filters with different names should be applied with AND statements.
    public var filters: [CodestarNotificationsClientTypes.ListNotificationRulesFilter]?
    /// A non-negative integer used to limit the number of returned results. The maximum number of results that can be returned is 100.
    public var maxResults: Swift.Int
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?

    public init (
        filters: [CodestarNotificationsClientTypes.ListNotificationRulesFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListNotificationRulesInputBody: Swift.Equatable {
    let filters: [CodestarNotificationsClientTypes.ListNotificationRulesFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension ListNotificationRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([CodestarNotificationsClientTypes.ListNotificationRulesFilter?].self, forKey: .filters)
        var filtersDecoded0:[CodestarNotificationsClientTypes.ListNotificationRulesFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [CodestarNotificationsClientTypes.ListNotificationRulesFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListNotificationRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNotificationRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListNotificationRulesOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNotificationRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListNotificationRulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.notificationRules = output.notificationRules
        } else {
            self.nextToken = nil
            self.notificationRules = nil
        }
    }
}

public struct ListNotificationRulesOutputResponse: Swift.Equatable {
    /// An enumeration token that can be used in a request to return the next batch of the results.
    public var nextToken: Swift.String?
    /// The list of notification rules for the AWS account, by Amazon Resource Name (ARN) and ID.
    public var notificationRules: [CodestarNotificationsClientTypes.NotificationRuleSummary]?

    public init (
        nextToken: Swift.String? = nil,
        notificationRules: [CodestarNotificationsClientTypes.NotificationRuleSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.notificationRules = notificationRules
    }
}

struct ListNotificationRulesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let notificationRules: [CodestarNotificationsClientTypes.NotificationRuleSummary]?
}

extension ListNotificationRulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case notificationRules = "NotificationRules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let notificationRulesContainer = try containerValues.decodeIfPresent([CodestarNotificationsClientTypes.NotificationRuleSummary?].self, forKey: .notificationRules)
        var notificationRulesDecoded0:[CodestarNotificationsClientTypes.NotificationRuleSummary]? = nil
        if let notificationRulesContainer = notificationRulesContainer {
            notificationRulesDecoded0 = [CodestarNotificationsClientTypes.NotificationRuleSummary]()
            for structure0 in notificationRulesContainer {
                if let structure0 = structure0 {
                    notificationRulesDecoded0?.append(structure0)
                }
            }
        }
        notificationRules = notificationRulesDecoded0
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listTagsForResource"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the notification rule.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags associated with the notification rule.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CodestarNotificationsClientTypes.ListTargetsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(CodestarNotificationsClientTypes.ListTargetsFilterName.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CodestarNotificationsClientTypes {
    /// Information about a filter to apply to the list of returned targets. You can filter by target type, address, or status. For example, to filter results to notification rules that have active Amazon SNS topics as targets, you could specify a ListTargetsFilter Name as TargetType and a Value of SNS, and a Name of TARGET_STATUS and a Value of ACTIVE.
    public struct ListTargetsFilter: Swift.Equatable {
        /// The name of the attribute you want to use to filter the returned targets.
        /// This member is required.
        public var name: CodestarNotificationsClientTypes.ListTargetsFilterName?
        /// The value of the attribute you want to use to filter the returned targets. For example, if you specify SNS for the Target type, you could specify an Amazon Resource Name (ARN) for a topic as the value.
        /// This member is required.
        public var value: Swift.String?

        public init (
            name: CodestarNotificationsClientTypes.ListTargetsFilterName? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension CodestarNotificationsClientTypes {
    public enum ListTargetsFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case targetAddress
        case targetStatus
        case targetType
        case sdkUnknown(Swift.String)

        public static var allCases: [ListTargetsFilterName] {
            return [
                .targetAddress,
                .targetStatus,
                .targetType,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .targetAddress: return "TARGET_ADDRESS"
            case .targetStatus: return "TARGET_STATUS"
            case .targetType: return "TARGET_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ListTargetsFilterName(rawValue: rawValue) ?? ListTargetsFilterName.sdkUnknown(rawValue)
        }
    }
}

extension ListTargetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for listtargetsfilters0 in filters {
                try filtersContainer.encode(listtargetsfilters0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTargetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listTargets"
    }
}

public struct ListTargetsInput: Swift.Equatable {
    /// The filters to use to return information by service or resource type. Valid filters include target type, target address, and target status. A filter with the same name can appear more than once when used with OR statements. Filters with different names should be applied with AND statements.
    public var filters: [CodestarNotificationsClientTypes.ListTargetsFilter]?
    /// A non-negative integer used to limit the number of returned results. The maximum number of results that can be returned is 100.
    public var maxResults: Swift.Int
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?

    public init (
        filters: [CodestarNotificationsClientTypes.ListTargetsFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTargetsInputBody: Swift.Equatable {
    let filters: [CodestarNotificationsClientTypes.ListTargetsFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension ListTargetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([CodestarNotificationsClientTypes.ListTargetsFilter?].self, forKey: .filters)
        var filtersDecoded0:[CodestarNotificationsClientTypes.ListTargetsFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [CodestarNotificationsClientTypes.ListTargetsFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTargetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTargetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTargetsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTargetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTargetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.targets = output.targets
        } else {
            self.nextToken = nil
            self.targets = nil
        }
    }
}

public struct ListTargetsOutputResponse: Swift.Equatable {
    /// An enumeration token that can be used in a request to return the next batch of results.
    public var nextToken: Swift.String?
    /// The list of notification rule targets.
    public var targets: [CodestarNotificationsClientTypes.TargetSummary]?

    public init (
        nextToken: Swift.String? = nil,
        targets: [CodestarNotificationsClientTypes.TargetSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.targets = targets
    }
}

struct ListTargetsOutputResponseBody: Swift.Equatable {
    let targets: [CodestarNotificationsClientTypes.TargetSummary]?
    let nextToken: Swift.String?
}

extension ListTargetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case targets = "Targets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetsContainer = try containerValues.decodeIfPresent([CodestarNotificationsClientTypes.TargetSummary?].self, forKey: .targets)
        var targetsDecoded0:[CodestarNotificationsClientTypes.TargetSummary]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [CodestarNotificationsClientTypes.TargetSummary]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CodestarNotificationsClientTypes {
    public enum NotificationRuleStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationRuleStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationRuleStatus(rawValue: rawValue) ?? NotificationRuleStatus.sdkUnknown(rawValue)
        }
    }
}

extension CodestarNotificationsClientTypes.NotificationRuleSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension CodestarNotificationsClientTypes {
    /// Information about a specified notification rule.
    public struct NotificationRuleSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the notification rule.
        public var arn: Swift.String?
        /// The unique ID of the notification rule.
        public var id: Swift.String?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
        }
    }

}

extension ResourceAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A resource with the same name or ID already exists. Notification rule names must be unique in your AWS account.
public struct ResourceAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// AWS CodeStar Notifications can't find a resource that matches the provided ARN.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubscribeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case clientRequestToken = "ClientRequestToken"
        case target = "Target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }
}

extension SubscribeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/subscribe"
    }
}

public struct SubscribeInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the notification rule for which you want to create the association.
    /// This member is required.
    public var arn: Swift.String?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var clientRequestToken: Swift.String?
    /// Information about the SNS topics associated with a notification rule.
    /// This member is required.
    public var target: CodestarNotificationsClientTypes.Target?

    public init (
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        target: CodestarNotificationsClientTypes.Target? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.target = target
    }
}

struct SubscribeInputBody: Swift.Equatable {
    let arn: Swift.String?
    let target: CodestarNotificationsClientTypes.Target?
    let clientRequestToken: Swift.String?
}

extension SubscribeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case clientRequestToken = "ClientRequestToken"
        case target = "Target"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let targetDecoded = try containerValues.decodeIfPresent(CodestarNotificationsClientTypes.Target.self, forKey: .target)
        target = targetDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension SubscribeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SubscribeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SubscribeOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SubscribeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SubscribeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct SubscribeOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the notification rule for which you have created assocations.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct SubscribeOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
}

extension SubscribeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tagResource"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the notification rule to tag.
    /// This member is required.
    public var arn: Swift.String?
    /// The list of tags to associate with the resource. Tag key names cannot start with "aws".
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let arn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TagResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {
    /// The list of tags associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct TagResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CodestarNotificationsClientTypes.Target: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetAddress = "TargetAddress"
        case targetType = "TargetType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetAddress = targetAddress {
            try encodeContainer.encode(targetAddress, forKey: .targetAddress)
        }
        if let targetType = targetType {
            try encodeContainer.encode(targetType, forKey: .targetType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let targetAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetAddress)
        targetAddress = targetAddressDecoded
    }
}

extension CodestarNotificationsClientTypes {
    /// Information about the SNS topics associated with a notification rule.
    public struct Target: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the SNS topic.
        public var targetAddress: Swift.String?
        /// The target type. Can be an Amazon SNS topic.
        public var targetType: Swift.String?

        public init (
            targetAddress: Swift.String? = nil,
            targetType: Swift.String? = nil
        )
        {
            self.targetAddress = targetAddress
            self.targetType = targetType
        }
    }

}

extension CodestarNotificationsClientTypes {
    public enum TargetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deactivated
        case inactive
        case pending
        case unreachable
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetStatus] {
            return [
                .active,
                .deactivated,
                .inactive,
                .pending,
                .unreachable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deactivated: return "DEACTIVATED"
            case .inactive: return "INACTIVE"
            case .pending: return "PENDING"
            case .unreachable: return "UNREACHABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetStatus(rawValue: rawValue) ?? TargetStatus.sdkUnknown(rawValue)
        }
    }
}

extension CodestarNotificationsClientTypes.TargetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetAddress = "TargetAddress"
        case targetStatus = "TargetStatus"
        case targetType = "TargetType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetAddress = targetAddress {
            try encodeContainer.encode(targetAddress, forKey: .targetAddress)
        }
        if let targetStatus = targetStatus {
            try encodeContainer.encode(targetStatus.rawValue, forKey: .targetStatus)
        }
        if let targetType = targetType {
            try encodeContainer.encode(targetType, forKey: .targetType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetAddress)
        targetAddress = targetAddressDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let targetStatusDecoded = try containerValues.decodeIfPresent(CodestarNotificationsClientTypes.TargetStatus.self, forKey: .targetStatus)
        targetStatus = targetStatusDecoded
    }
}

extension CodestarNotificationsClientTypes {
    /// Information about the targets specified for a notification rule.
    public struct TargetSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the SNS topic.
        public var targetAddress: Swift.String?
        /// The status of the target.
        public var targetStatus: CodestarNotificationsClientTypes.TargetStatus?
        /// The type of the target (for example, SNS).
        public var targetType: Swift.String?

        public init (
            targetAddress: Swift.String? = nil,
            targetStatus: CodestarNotificationsClientTypes.TargetStatus? = nil,
            targetType: Swift.String? = nil
        )
        {
            self.targetAddress = targetAddress
            self.targetStatus = targetStatus
            self.targetType = targetType
        }
    }

}

extension UnsubscribeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case targetAddress = "TargetAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let targetAddress = targetAddress {
            try encodeContainer.encode(targetAddress, forKey: .targetAddress)
        }
    }
}

extension UnsubscribeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/unsubscribe"
    }
}

public struct UnsubscribeInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the notification rule.
    /// This member is required.
    public var arn: Swift.String?
    /// The ARN of the SNS topic to unsubscribe from the notification rule.
    /// This member is required.
    public var targetAddress: Swift.String?

    public init (
        arn: Swift.String? = nil,
        targetAddress: Swift.String? = nil
    )
    {
        self.arn = arn
        self.targetAddress = targetAddress
    }
}

struct UnsubscribeInputBody: Swift.Equatable {
    let arn: Swift.String?
    let targetAddress: Swift.String?
}

extension UnsubscribeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case targetAddress = "TargetAddress"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let targetAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetAddress)
        targetAddress = targetAddressDecoded
    }
}

extension UnsubscribeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UnsubscribeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UnsubscribeOutputError: Swift.Error, Swift.Equatable {
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnsubscribeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsubscribeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct UnsubscribeOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the the notification rule from which you have removed a subscription.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct UnsubscribeOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
}

extension UnsubscribeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeys0 in tagKeys {
                try tagKeysContainer.encode(tagkeys0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/untagResource"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the notification rule from which to remove the tags.
    /// This member is required.
    public var arn: Swift.String?
    /// The key names of the tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        arn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let arn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateNotificationRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case detailType = "DetailType"
        case eventTypeIds = "EventTypeIds"
        case name = "Name"
        case status = "Status"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let detailType = detailType {
            try encodeContainer.encode(detailType.rawValue, forKey: .detailType)
        }
        if let eventTypeIds = eventTypeIds {
            var eventTypeIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventTypeIds)
            for eventtypeids0 in eventTypeIds {
                try eventTypeIdsContainer.encode(eventtypeids0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }
}

extension UpdateNotificationRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateNotificationRule"
    }
}

public struct UpdateNotificationRuleInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the notification rule.
    /// This member is required.
    public var arn: Swift.String?
    /// The level of detail to include in the notifications for this resource. BASIC will include only the contents of the event as it would appear in AWS CloudWatch. FULL will include any supplemental information provided by AWS CodeStar Notifications and/or the service for the resource for which the notification is created.
    public var detailType: CodestarNotificationsClientTypes.DetailType?
    /// A list of event types associated with this notification rule.
    public var eventTypeIds: [Swift.String]?
    /// The name of the notification rule.
    public var name: Swift.String?
    /// The status of the notification rule. Valid statuses include enabled (sending notifications) or disabled (not sending notifications).
    public var status: CodestarNotificationsClientTypes.NotificationRuleStatus?
    /// The address and type of the targets to receive notifications from this notification rule.
    public var targets: [CodestarNotificationsClientTypes.Target]?

    public init (
        arn: Swift.String? = nil,
        detailType: CodestarNotificationsClientTypes.DetailType? = nil,
        eventTypeIds: [Swift.String]? = nil,
        name: Swift.String? = nil,
        status: CodestarNotificationsClientTypes.NotificationRuleStatus? = nil,
        targets: [CodestarNotificationsClientTypes.Target]? = nil
    )
    {
        self.arn = arn
        self.detailType = detailType
        self.eventTypeIds = eventTypeIds
        self.name = name
        self.status = status
        self.targets = targets
    }
}

struct UpdateNotificationRuleInputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let status: CodestarNotificationsClientTypes.NotificationRuleStatus?
    let eventTypeIds: [Swift.String]?
    let targets: [CodestarNotificationsClientTypes.Target]?
    let detailType: CodestarNotificationsClientTypes.DetailType?
}

extension UpdateNotificationRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case detailType = "DetailType"
        case eventTypeIds = "EventTypeIds"
        case name = "Name"
        case status = "Status"
        case targets = "Targets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodestarNotificationsClientTypes.NotificationRuleStatus.self, forKey: .status)
        status = statusDecoded
        let eventTypeIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventTypeIds)
        var eventTypeIdsDecoded0:[Swift.String]? = nil
        if let eventTypeIdsContainer = eventTypeIdsContainer {
            eventTypeIdsDecoded0 = [Swift.String]()
            for string0 in eventTypeIdsContainer {
                if let string0 = string0 {
                    eventTypeIdsDecoded0?.append(string0)
                }
            }
        }
        eventTypeIds = eventTypeIdsDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([CodestarNotificationsClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[CodestarNotificationsClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [CodestarNotificationsClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let detailTypeDecoded = try containerValues.decodeIfPresent(CodestarNotificationsClientTypes.DetailType.self, forKey: .detailType)
        detailType = detailTypeDecoded
    }
}

extension UpdateNotificationRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateNotificationRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateNotificationRuleOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateNotificationRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateNotificationRuleOutputResponse: Swift.Equatable {

}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more parameter values are not valid.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
