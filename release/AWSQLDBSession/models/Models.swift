// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension QldbSessionClientTypes.AbortTransactionRequest: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension QldbSessionClientTypes {
    /// Contains the details of the transaction to abort.
    public struct AbortTransactionRequest: Swift.Equatable {

        public init () { }
    }

}

extension QldbSessionClientTypes.AbortTransactionResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timingInformation = "TimingInformation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timingInformation = self.timingInformation {
            try encodeContainer.encode(timingInformation, forKey: .timingInformation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timingInformationDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.TimingInformation.self, forKey: .timingInformation)
        timingInformation = timingInformationDecoded
    }
}

extension QldbSessionClientTypes {
    /// Contains the details of the aborted transaction.
    public struct AbortTransactionResult: Swift.Equatable {
        /// Contains server-side performance information for the command.
        public var timingInformation: QldbSessionClientTypes.TimingInformation?

        public init (
            timingInformation: QldbSessionClientTypes.TimingInformation? = nil
        )
        {
            self.timingInformation = timingInformation
        }
    }

}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if the request is malformed or contains an error such as an invalid parameter value or a missing required parameter.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension CapacityExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CapacityExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned when the request exceeds the processing capacity of the ledger.
public struct CapacityExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CapacityExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CapacityExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension QldbSessionClientTypes.CommitTransactionRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitDigest = "CommitDigest"
        case transactionId = "TransactionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitDigest = self.commitDigest {
            try encodeContainer.encode(commitDigest.base64EncodedString(), forKey: .commitDigest)
        }
        if let transactionId = self.transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let commitDigestDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .commitDigest)
        commitDigest = commitDigestDecoded
    }
}

extension QldbSessionClientTypes {
    /// Contains the details of the transaction to commit.
    public struct CommitTransactionRequest: Swift.Equatable {
        /// Specifies the commit digest for the transaction to commit. For every active transaction, the commit digest must be passed. QLDB validates CommitDigest and rejects the commit with an error if the digest computed on the client does not match the digest computed by QLDB. The purpose of the CommitDigest parameter is to ensure that QLDB commits a transaction if and only if the server has processed the exact set of statements sent by the client, in the same order that client sent them, and with no duplicates.
        /// This member is required.
        public var commitDigest: ClientRuntime.Data?
        /// Specifies the transaction ID of the transaction to commit.
        /// This member is required.
        public var transactionId: Swift.String?

        public init (
            commitDigest: ClientRuntime.Data? = nil,
            transactionId: Swift.String? = nil
        )
        {
            self.commitDigest = commitDigest
            self.transactionId = transactionId
        }
    }

}

extension QldbSessionClientTypes.CommitTransactionResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitDigest = "CommitDigest"
        case consumedIOs = "ConsumedIOs"
        case timingInformation = "TimingInformation"
        case transactionId = "TransactionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitDigest = self.commitDigest {
            try encodeContainer.encode(commitDigest.base64EncodedString(), forKey: .commitDigest)
        }
        if let consumedIOs = self.consumedIOs {
            try encodeContainer.encode(consumedIOs, forKey: .consumedIOs)
        }
        if let timingInformation = self.timingInformation {
            try encodeContainer.encode(timingInformation, forKey: .timingInformation)
        }
        if let transactionId = self.transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let commitDigestDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .commitDigest)
        commitDigest = commitDigestDecoded
        let timingInformationDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.TimingInformation.self, forKey: .timingInformation)
        timingInformation = timingInformationDecoded
        let consumedIOsDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.IOUsage.self, forKey: .consumedIOs)
        consumedIOs = consumedIOsDecoded
    }
}

extension QldbSessionClientTypes {
    /// Contains the details of the committed transaction.
    public struct CommitTransactionResult: Swift.Equatable {
        /// The commit digest of the committed transaction.
        public var commitDigest: ClientRuntime.Data?
        /// Contains metrics about the number of I/O requests that were consumed.
        public var consumedIOs: QldbSessionClientTypes.IOUsage?
        /// Contains server-side performance information for the command.
        public var timingInformation: QldbSessionClientTypes.TimingInformation?
        /// The transaction ID of the committed transaction.
        public var transactionId: Swift.String?

        public init (
            commitDigest: ClientRuntime.Data? = nil,
            consumedIOs: QldbSessionClientTypes.IOUsage? = nil,
            timingInformation: QldbSessionClientTypes.TimingInformation? = nil,
            transactionId: Swift.String? = nil
        )
        {
            self.commitDigest = commitDigest
            self.consumedIOs = consumedIOs
            self.timingInformation = timingInformation
            self.transactionId = transactionId
        }
    }

}

extension QldbSessionClientTypes.EndSessionRequest: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension QldbSessionClientTypes {
    /// Specifies a request to end the session.
    public struct EndSessionRequest: Swift.Equatable {

        public init () { }
    }

}

extension QldbSessionClientTypes.EndSessionResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timingInformation = "TimingInformation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timingInformation = self.timingInformation {
            try encodeContainer.encode(timingInformation, forKey: .timingInformation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timingInformationDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.TimingInformation.self, forKey: .timingInformation)
        timingInformation = timingInformationDecoded
    }
}

extension QldbSessionClientTypes {
    /// Contains the details of the ended session.
    public struct EndSessionResult: Swift.Equatable {
        /// Contains server-side performance information for the command.
        public var timingInformation: QldbSessionClientTypes.TimingInformation?

        public init (
            timingInformation: QldbSessionClientTypes.TimingInformation? = nil
        )
        {
            self.timingInformation = timingInformation
        }
    }

}

extension QldbSessionClientTypes.ExecuteStatementRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameters = "Parameters"
        case statement = "Statement"
        case transactionId = "TransactionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for statementparameters0 in parameters {
                try parametersContainer.encode(statementparameters0)
            }
        }
        if let statement = self.statement {
            try encodeContainer.encode(statement, forKey: .statement)
        }
        if let transactionId = self.transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let statementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statement)
        statement = statementDecoded
        let parametersContainer = try containerValues.decodeIfPresent([QldbSessionClientTypes.ValueHolder?].self, forKey: .parameters)
        var parametersDecoded0:[QldbSessionClientTypes.ValueHolder]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [QldbSessionClientTypes.ValueHolder]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension QldbSessionClientTypes {
    /// Specifies a request to execute a statement.
    public struct ExecuteStatementRequest: Swift.Equatable {
        /// Specifies the parameters for the parameterized statement in the request.
        public var parameters: [QldbSessionClientTypes.ValueHolder]?
        /// Specifies the statement of the request.
        /// This member is required.
        public var statement: Swift.String?
        /// Specifies the transaction ID of the request.
        /// This member is required.
        public var transactionId: Swift.String?

        public init (
            parameters: [QldbSessionClientTypes.ValueHolder]? = nil,
            statement: Swift.String? = nil,
            transactionId: Swift.String? = nil
        )
        {
            self.parameters = parameters
            self.statement = statement
            self.transactionId = transactionId
        }
    }

}

extension QldbSessionClientTypes.ExecuteStatementResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumedIOs = "ConsumedIOs"
        case firstPage = "FirstPage"
        case timingInformation = "TimingInformation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumedIOs = self.consumedIOs {
            try encodeContainer.encode(consumedIOs, forKey: .consumedIOs)
        }
        if let firstPage = self.firstPage {
            try encodeContainer.encode(firstPage, forKey: .firstPage)
        }
        if let timingInformation = self.timingInformation {
            try encodeContainer.encode(timingInformation, forKey: .timingInformation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firstPageDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.Page.self, forKey: .firstPage)
        firstPage = firstPageDecoded
        let timingInformationDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.TimingInformation.self, forKey: .timingInformation)
        timingInformation = timingInformationDecoded
        let consumedIOsDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.IOUsage.self, forKey: .consumedIOs)
        consumedIOs = consumedIOsDecoded
    }
}

extension QldbSessionClientTypes {
    /// Contains the details of the executed statement.
    public struct ExecuteStatementResult: Swift.Equatable {
        /// Contains metrics about the number of I/O requests that were consumed.
        public var consumedIOs: QldbSessionClientTypes.IOUsage?
        /// Contains the details of the first fetched page.
        public var firstPage: QldbSessionClientTypes.Page?
        /// Contains server-side performance information for the command.
        public var timingInformation: QldbSessionClientTypes.TimingInformation?

        public init (
            consumedIOs: QldbSessionClientTypes.IOUsage? = nil,
            firstPage: QldbSessionClientTypes.Page? = nil,
            timingInformation: QldbSessionClientTypes.TimingInformation? = nil
        )
        {
            self.consumedIOs = consumedIOs
            self.firstPage = firstPage
            self.timingInformation = timingInformation
        }
    }

}

extension QldbSessionClientTypes.FetchPageRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case transactionId = "TransactionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextPageToken = self.nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let transactionId = self.transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension QldbSessionClientTypes {
    /// Specifies the details of the page to be fetched.
    public struct FetchPageRequest: Swift.Equatable {
        /// Specifies the next page token of the page to be fetched.
        /// This member is required.
        public var nextPageToken: Swift.String?
        /// Specifies the transaction ID of the page to be fetched.
        /// This member is required.
        public var transactionId: Swift.String?

        public init (
            nextPageToken: Swift.String? = nil,
            transactionId: Swift.String? = nil
        )
        {
            self.nextPageToken = nextPageToken
            self.transactionId = transactionId
        }
    }

}

extension QldbSessionClientTypes.FetchPageResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumedIOs = "ConsumedIOs"
        case page = "Page"
        case timingInformation = "TimingInformation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumedIOs = self.consumedIOs {
            try encodeContainer.encode(consumedIOs, forKey: .consumedIOs)
        }
        if let page = self.page {
            try encodeContainer.encode(page, forKey: .page)
        }
        if let timingInformation = self.timingInformation {
            try encodeContainer.encode(timingInformation, forKey: .timingInformation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pageDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.Page.self, forKey: .page)
        page = pageDecoded
        let timingInformationDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.TimingInformation.self, forKey: .timingInformation)
        timingInformation = timingInformationDecoded
        let consumedIOsDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.IOUsage.self, forKey: .consumedIOs)
        consumedIOs = consumedIOsDecoded
    }
}

extension QldbSessionClientTypes {
    /// Contains the page that was fetched.
    public struct FetchPageResult: Swift.Equatable {
        /// Contains metrics about the number of I/O requests that were consumed.
        public var consumedIOs: QldbSessionClientTypes.IOUsage?
        /// Contains details of the fetched page.
        public var page: QldbSessionClientTypes.Page?
        /// Contains server-side performance information for the command.
        public var timingInformation: QldbSessionClientTypes.TimingInformation?

        public init (
            consumedIOs: QldbSessionClientTypes.IOUsage? = nil,
            page: QldbSessionClientTypes.Page? = nil,
            timingInformation: QldbSessionClientTypes.TimingInformation? = nil
        )
        {
            self.consumedIOs = consumedIOs
            self.page = page
            self.timingInformation = timingInformation
        }
    }

}

extension QldbSessionClientTypes.IOUsage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readIOs = "ReadIOs"
        case writeIOs = "WriteIOs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if readIOs != 0 {
            try encodeContainer.encode(readIOs, forKey: .readIOs)
        }
        if writeIOs != 0 {
            try encodeContainer.encode(writeIOs, forKey: .writeIOs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readIOsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .readIOs) ?? 0
        readIOs = readIOsDecoded
        let writeIOsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .writeIOs) ?? 0
        writeIOs = writeIOsDecoded
    }
}

extension QldbSessionClientTypes {
    /// Contains I/O usage metrics for a command that was invoked.
    public struct IOUsage: Swift.Equatable {
        /// The number of read I/O requests that the command made.
        public var readIOs: Swift.Int
        /// The number of write I/O requests that the command made.
        public var writeIOs: Swift.Int

        public init (
            readIOs: Swift.Int = 0,
            writeIOs: Swift.Int = 0
        )
        {
            self.readIOs = readIOs
            self.writeIOs = writeIOs
        }
    }

}

extension InvalidSessionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidSessionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if the session doesn't exist anymore because it timed out or expired.
public struct InvalidSessionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InvalidSessionExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension InvalidSessionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if a resource limit such as number of active sessions is exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OccConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OccConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned when a transaction cannot be written to the journal due to a failure in the verification phase of optimistic concurrency control (OCC).
public struct OccConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OccConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OccConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension QldbSessionClientTypes.Page: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextPageToken = self.nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for valueholders0 in values {
                try valuesContainer.encode(valueholders0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valuesContainer = try containerValues.decodeIfPresent([QldbSessionClientTypes.ValueHolder?].self, forKey: .values)
        var valuesDecoded0:[QldbSessionClientTypes.ValueHolder]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [QldbSessionClientTypes.ValueHolder]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension QldbSessionClientTypes {
    /// Contains details of the fetched page.
    public struct Page: Swift.Equatable {
        /// The token of the next page.
        public var nextPageToken: Swift.String?
        /// A structure that contains values in multiple encoding formats.
        public var values: [QldbSessionClientTypes.ValueHolder]?

        public init (
            nextPageToken: Swift.String? = nil,
            values: [QldbSessionClientTypes.ValueHolder]? = nil
        )
        {
            self.nextPageToken = nextPageToken
            self.values = values
        }
    }

}

extension RateExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RateExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned when the rate of requests exceeds the allowed throughput.
public struct RateExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RateExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RateExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SendCommandInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abortTransaction = "AbortTransaction"
        case commitTransaction = "CommitTransaction"
        case endSession = "EndSession"
        case executeStatement = "ExecuteStatement"
        case fetchPage = "FetchPage"
        case sessionToken = "SessionToken"
        case startSession = "StartSession"
        case startTransaction = "StartTransaction"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let abortTransaction = self.abortTransaction {
            try encodeContainer.encode(abortTransaction, forKey: .abortTransaction)
        }
        if let commitTransaction = self.commitTransaction {
            try encodeContainer.encode(commitTransaction, forKey: .commitTransaction)
        }
        if let endSession = self.endSession {
            try encodeContainer.encode(endSession, forKey: .endSession)
        }
        if let executeStatement = self.executeStatement {
            try encodeContainer.encode(executeStatement, forKey: .executeStatement)
        }
        if let fetchPage = self.fetchPage {
            try encodeContainer.encode(fetchPage, forKey: .fetchPage)
        }
        if let sessionToken = self.sessionToken {
            try encodeContainer.encode(sessionToken, forKey: .sessionToken)
        }
        if let startSession = self.startSession {
            try encodeContainer.encode(startSession, forKey: .startSession)
        }
        if let startTransaction = self.startTransaction {
            try encodeContainer.encode(startTransaction, forKey: .startTransaction)
        }
    }
}

extension SendCommandInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SendCommandInput: Swift.Equatable {
    /// Command to abort the current transaction.
    public var abortTransaction: QldbSessionClientTypes.AbortTransactionRequest?
    /// Command to commit the specified transaction.
    public var commitTransaction: QldbSessionClientTypes.CommitTransactionRequest?
    /// Command to end the current session.
    public var endSession: QldbSessionClientTypes.EndSessionRequest?
    /// Command to execute a statement in the specified transaction.
    public var executeStatement: QldbSessionClientTypes.ExecuteStatementRequest?
    /// Command to fetch a page.
    public var fetchPage: QldbSessionClientTypes.FetchPageRequest?
    /// Specifies the session token for the current command. A session token is constant throughout the life of the session. To obtain a session token, run the StartSession command. This SessionToken is required for every subsequent command that is issued during the current session.
    public var sessionToken: Swift.String?
    /// Command to start a new session. A session token is obtained as part of the response.
    public var startSession: QldbSessionClientTypes.StartSessionRequest?
    /// Command to start a new transaction.
    public var startTransaction: QldbSessionClientTypes.StartTransactionRequest?

    public init (
        abortTransaction: QldbSessionClientTypes.AbortTransactionRequest? = nil,
        commitTransaction: QldbSessionClientTypes.CommitTransactionRequest? = nil,
        endSession: QldbSessionClientTypes.EndSessionRequest? = nil,
        executeStatement: QldbSessionClientTypes.ExecuteStatementRequest? = nil,
        fetchPage: QldbSessionClientTypes.FetchPageRequest? = nil,
        sessionToken: Swift.String? = nil,
        startSession: QldbSessionClientTypes.StartSessionRequest? = nil,
        startTransaction: QldbSessionClientTypes.StartTransactionRequest? = nil
    )
    {
        self.abortTransaction = abortTransaction
        self.commitTransaction = commitTransaction
        self.endSession = endSession
        self.executeStatement = executeStatement
        self.fetchPage = fetchPage
        self.sessionToken = sessionToken
        self.startSession = startSession
        self.startTransaction = startTransaction
    }
}

struct SendCommandInputBody: Swift.Equatable {
    let sessionToken: Swift.String?
    let startSession: QldbSessionClientTypes.StartSessionRequest?
    let startTransaction: QldbSessionClientTypes.StartTransactionRequest?
    let endSession: QldbSessionClientTypes.EndSessionRequest?
    let commitTransaction: QldbSessionClientTypes.CommitTransactionRequest?
    let abortTransaction: QldbSessionClientTypes.AbortTransactionRequest?
    let executeStatement: QldbSessionClientTypes.ExecuteStatementRequest?
    let fetchPage: QldbSessionClientTypes.FetchPageRequest?
}

extension SendCommandInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abortTransaction = "AbortTransaction"
        case commitTransaction = "CommitTransaction"
        case endSession = "EndSession"
        case executeStatement = "ExecuteStatement"
        case fetchPage = "FetchPage"
        case sessionToken = "SessionToken"
        case startSession = "StartSession"
        case startTransaction = "StartTransaction"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionToken)
        sessionToken = sessionTokenDecoded
        let startSessionDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.StartSessionRequest.self, forKey: .startSession)
        startSession = startSessionDecoded
        let startTransactionDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.StartTransactionRequest.self, forKey: .startTransaction)
        startTransaction = startTransactionDecoded
        let endSessionDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.EndSessionRequest.self, forKey: .endSession)
        endSession = endSessionDecoded
        let commitTransactionDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.CommitTransactionRequest.self, forKey: .commitTransaction)
        commitTransaction = commitTransactionDecoded
        let abortTransactionDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.AbortTransactionRequest.self, forKey: .abortTransaction)
        abortTransaction = abortTransactionDecoded
        let executeStatementDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.ExecuteStatementRequest.self, forKey: .executeStatement)
        executeStatement = executeStatementDecoded
        let fetchPageDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.FetchPageRequest.self, forKey: .fetchPage)
        fetchPage = fetchPageDecoded
    }
}

extension SendCommandOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendCommandOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CapacityExceededException" : self = .capacityExceededException(try CapacityExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSessionException" : self = .invalidSessionException(try InvalidSessionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OccConflictException" : self = .occConflictException(try OccConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateExceededException" : self = .rateExceededException(try RateExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendCommandOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case capacityExceededException(CapacityExceededException)
    case invalidSessionException(InvalidSessionException)
    case limitExceededException(LimitExceededException)
    case occConflictException(OccConflictException)
    case rateExceededException(RateExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendCommandOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SendCommandOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.abortTransaction = output.abortTransaction
            self.commitTransaction = output.commitTransaction
            self.endSession = output.endSession
            self.executeStatement = output.executeStatement
            self.fetchPage = output.fetchPage
            self.startSession = output.startSession
            self.startTransaction = output.startTransaction
        } else {
            self.abortTransaction = nil
            self.commitTransaction = nil
            self.endSession = nil
            self.executeStatement = nil
            self.fetchPage = nil
            self.startSession = nil
            self.startTransaction = nil
        }
    }
}

public struct SendCommandOutputResponse: Swift.Equatable {
    /// Contains the details of the aborted transaction.
    public var abortTransaction: QldbSessionClientTypes.AbortTransactionResult?
    /// Contains the details of the committed transaction.
    public var commitTransaction: QldbSessionClientTypes.CommitTransactionResult?
    /// Contains the details of the ended session.
    public var endSession: QldbSessionClientTypes.EndSessionResult?
    /// Contains the details of the executed statement.
    public var executeStatement: QldbSessionClientTypes.ExecuteStatementResult?
    /// Contains the details of the fetched page.
    public var fetchPage: QldbSessionClientTypes.FetchPageResult?
    /// Contains the details of the started session that includes a session token. This SessionToken is required for every subsequent command that is issued during the current session.
    public var startSession: QldbSessionClientTypes.StartSessionResult?
    /// Contains the details of the started transaction.
    public var startTransaction: QldbSessionClientTypes.StartTransactionResult?

    public init (
        abortTransaction: QldbSessionClientTypes.AbortTransactionResult? = nil,
        commitTransaction: QldbSessionClientTypes.CommitTransactionResult? = nil,
        endSession: QldbSessionClientTypes.EndSessionResult? = nil,
        executeStatement: QldbSessionClientTypes.ExecuteStatementResult? = nil,
        fetchPage: QldbSessionClientTypes.FetchPageResult? = nil,
        startSession: QldbSessionClientTypes.StartSessionResult? = nil,
        startTransaction: QldbSessionClientTypes.StartTransactionResult? = nil
    )
    {
        self.abortTransaction = abortTransaction
        self.commitTransaction = commitTransaction
        self.endSession = endSession
        self.executeStatement = executeStatement
        self.fetchPage = fetchPage
        self.startSession = startSession
        self.startTransaction = startTransaction
    }
}

struct SendCommandOutputResponseBody: Swift.Equatable {
    let startSession: QldbSessionClientTypes.StartSessionResult?
    let startTransaction: QldbSessionClientTypes.StartTransactionResult?
    let endSession: QldbSessionClientTypes.EndSessionResult?
    let commitTransaction: QldbSessionClientTypes.CommitTransactionResult?
    let abortTransaction: QldbSessionClientTypes.AbortTransactionResult?
    let executeStatement: QldbSessionClientTypes.ExecuteStatementResult?
    let fetchPage: QldbSessionClientTypes.FetchPageResult?
}

extension SendCommandOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abortTransaction = "AbortTransaction"
        case commitTransaction = "CommitTransaction"
        case endSession = "EndSession"
        case executeStatement = "ExecuteStatement"
        case fetchPage = "FetchPage"
        case startSession = "StartSession"
        case startTransaction = "StartTransaction"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startSessionDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.StartSessionResult.self, forKey: .startSession)
        startSession = startSessionDecoded
        let startTransactionDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.StartTransactionResult.self, forKey: .startTransaction)
        startTransaction = startTransactionDecoded
        let endSessionDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.EndSessionResult.self, forKey: .endSession)
        endSession = endSessionDecoded
        let commitTransactionDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.CommitTransactionResult.self, forKey: .commitTransaction)
        commitTransaction = commitTransactionDecoded
        let abortTransactionDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.AbortTransactionResult.self, forKey: .abortTransaction)
        abortTransaction = abortTransactionDecoded
        let executeStatementDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.ExecuteStatementResult.self, forKey: .executeStatement)
        executeStatement = executeStatementDecoded
        let fetchPageDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.FetchPageResult.self, forKey: .fetchPage)
        fetchPage = fetchPageDecoded
    }
}

extension QldbSessionClientTypes.StartSessionRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ledgerName = "LedgerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ledgerName = self.ledgerName {
            try encodeContainer.encode(ledgerName, forKey: .ledgerName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ledgerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ledgerName)
        ledgerName = ledgerNameDecoded
    }
}

extension QldbSessionClientTypes {
    /// Specifies a request to start a new session.
    public struct StartSessionRequest: Swift.Equatable {
        /// The name of the ledger to start a new session against.
        /// This member is required.
        public var ledgerName: Swift.String?

        public init (
            ledgerName: Swift.String? = nil
        )
        {
            self.ledgerName = ledgerName
        }
    }

}

extension QldbSessionClientTypes.StartSessionResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionToken = "SessionToken"
        case timingInformation = "TimingInformation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sessionToken = self.sessionToken {
            try encodeContainer.encode(sessionToken, forKey: .sessionToken)
        }
        if let timingInformation = self.timingInformation {
            try encodeContainer.encode(timingInformation, forKey: .timingInformation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionToken)
        sessionToken = sessionTokenDecoded
        let timingInformationDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.TimingInformation.self, forKey: .timingInformation)
        timingInformation = timingInformationDecoded
    }
}

extension QldbSessionClientTypes {
    /// Contains the details of the started session.
    public struct StartSessionResult: Swift.Equatable {
        /// Session token of the started session. This SessionToken is required for every subsequent command that is issued during the current session.
        public var sessionToken: Swift.String?
        /// Contains server-side performance information for the command.
        public var timingInformation: QldbSessionClientTypes.TimingInformation?

        public init (
            sessionToken: Swift.String? = nil,
            timingInformation: QldbSessionClientTypes.TimingInformation? = nil
        )
        {
            self.sessionToken = sessionToken
            self.timingInformation = timingInformation
        }
    }

}

extension QldbSessionClientTypes.StartTransactionRequest: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension QldbSessionClientTypes {
    /// Specifies a request to start a transaction.
    public struct StartTransactionRequest: Swift.Equatable {

        public init () { }
    }

}

extension QldbSessionClientTypes.StartTransactionResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timingInformation = "TimingInformation"
        case transactionId = "TransactionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timingInformation = self.timingInformation {
            try encodeContainer.encode(timingInformation, forKey: .timingInformation)
        }
        if let transactionId = self.transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let timingInformationDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.TimingInformation.self, forKey: .timingInformation)
        timingInformation = timingInformationDecoded
    }
}

extension QldbSessionClientTypes {
    /// Contains the details of the started transaction.
    public struct StartTransactionResult: Swift.Equatable {
        /// Contains server-side performance information for the command.
        public var timingInformation: QldbSessionClientTypes.TimingInformation?
        /// The transaction ID of the started transaction.
        public var transactionId: Swift.String?

        public init (
            timingInformation: QldbSessionClientTypes.TimingInformation? = nil,
            transactionId: Swift.String? = nil
        )
        {
            self.timingInformation = timingInformation
            self.transactionId = transactionId
        }
    }

}

extension QldbSessionClientTypes.TimingInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case processingTimeMilliseconds = "ProcessingTimeMilliseconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if processingTimeMilliseconds != 0 {
            try encodeContainer.encode(processingTimeMilliseconds, forKey: .processingTimeMilliseconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let processingTimeMillisecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .processingTimeMilliseconds) ?? 0
        processingTimeMilliseconds = processingTimeMillisecondsDecoded
    }
}

extension QldbSessionClientTypes {
    /// Contains server-side performance information for a command. Amazon QLDB captures timing information between the times when it receives the request and when it sends the corresponding response.
    public struct TimingInformation: Swift.Equatable {
        /// The amount of time that QLDB spent on processing the command, measured in milliseconds.
        public var processingTimeMilliseconds: Swift.Int

        public init (
            processingTimeMilliseconds: Swift.Int = 0
        )
        {
            self.processingTimeMilliseconds = processingTimeMilliseconds
        }
    }

}

extension QldbSessionClientTypes.ValueHolder: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ionBinary = "IonBinary"
        case ionText = "IonText"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ionBinary = self.ionBinary {
            try encodeContainer.encode(ionBinary.base64EncodedString(), forKey: .ionBinary)
        }
        if let ionText = self.ionText {
            try encodeContainer.encode(ionText, forKey: .ionText)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ionBinaryDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .ionBinary)
        ionBinary = ionBinaryDecoded
        let ionTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ionText)
        ionText = ionTextDecoded
    }
}

extension QldbSessionClientTypes {
    /// A structure that can contain a value in multiple encoding formats.
    public struct ValueHolder: Swift.Equatable {
        /// An Amazon Ion binary value contained in a ValueHolder structure.
        public var ionBinary: ClientRuntime.Data?
        /// An Amazon Ion plaintext value contained in a ValueHolder structure.
        public var ionText: Swift.String?

        public init (
            ionBinary: ClientRuntime.Data? = nil,
            ionText: Swift.String? = nil
        )
        {
            self.ionBinary = ionBinary
            self.ionText = ionText
        }
    }

}
